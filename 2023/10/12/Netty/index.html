<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.js"></script>

<script src="tipuesearch/tipuesearch_content.js"></script>
<link rel="stylesheet" href="tipuesearch/tipuesearch.css">
<script src="tipuesearch/tipuesearch_set.js"></script>
<script src="tipuesearch/tipuesearch.min.js"></script>

  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://tobetou.cn">
  <title>Netty | 小林子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="# Netty  一、Netty介绍和应用场景1、Netty的介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。   Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可 靠性的网络 IO 程序。    Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下 的大量数据持续">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://tobetou.cn/2023/10/12/Netty/index.html">
<meta property="og:site_name" content="小林子">
<meta property="og:description" content="# Netty  一、Netty介绍和应用场景1、Netty的介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。   Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可 靠性的网络 IO 程序。    Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下 的大量数据持续">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161526548.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161545599.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161547234.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161549166.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161550263.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161551347.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161554843.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161555877.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161710015.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162115019.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162228829.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162228756.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162229839.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162229882.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162117010.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162338300.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162342416.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162120068.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162121591.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162122172.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162124674.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302171121672.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302172358207.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302180003626.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302180004835.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181030385.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181033860.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181035136.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181036674.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190017180.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190017000.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190018153.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190020007.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182335806.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190025063.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182336781.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190029611.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182338480.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190041641.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182338999.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190031824.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302191432593.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302191457030.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138827.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138828.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138829.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138830.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138831.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138832.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201137936.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201138072.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201138078.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511744.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302212121961.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302212122748.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222121907.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222124337.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222127524.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222129613.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280854160.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280911560.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280913781.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511747.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511746.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511748.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303011514102.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281513405.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517146.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517527.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517959.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012005169.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281520613.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281524162.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012202253.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012205652.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012206340.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012208931.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041358021.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041359814.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041400840.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041400443.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041401141.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041402715.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041402224.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041403864.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041403348.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041404095.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041404584.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050932443.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012215841.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012215207.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050950234.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050951476.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051110412.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051111021.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051549646.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012218070.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012219117.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012219257.png">
<meta property="og:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202303052240143.png">
<meta property="article:published_time" content="2023-10-12T12:40:48.311Z">
<meta property="article:modified_time" content="2023-10-12T18:39:35.591Z">
<meta property="article:author" content="小林子">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161526548.png">
  
    <link rel="alternative" href="/atom.xml" title="小林子" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>

  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	
	<header id="header" class="inner">
		
		<a href="/" class="profilepic">
			<img src="/img/avatar.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		
		
		
		
		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
				<li><a href="/categories/index.html">分类</a></li>
	        
				<li><a href="/archives/index.html">归档</a></li>
	        
				<li><a href="/search/index.html">搜索</a></li>
	        
			</ul>
		</nav>
		<nav>
			总文章数 46
		</nav>
		<nav>
			总字数 <span class="post-count">636.7k</span>
		</nav>
		
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/xiaolin-zi" title="github"><i class="icon-github"></i></a>
		        
					<a class="qq" target="_blank" href="/img/qq.jpg" title="qq"><i class="icon-qq"></i></a>
		        
					<a class="weixin" target="_blank" href="/img/wx.jpg" title="weixin"><i class="icon-weixin"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:1849569695@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>	

	
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xiaolin-zi" title="github"><i class="icon-github"></i></a>
			        
						<a class="qq" target="_blank" href="/img/qq.jpg" title="qq"><i class="icon-qq"></i></a>
			        
						<a class="weixin" target="_blank" href="/img/wx.jpg" title="weixin"><i class="icon-weixin"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:1849569695@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 20%"><a href="/">主页</a></li>
		        
					<li style="width: 20%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
					<li style="width: 20%"><a href="/categories/index.html">分类</a></li>
		        
					<li style="width: 20%"><a href="/archives/index.html">归档</a></li>
		        
					<li style="width: 20%"><a href="/search/index.html">搜索</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-Netty" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Netty
    </h1>
  

		<!--显示阅读次数-->
		
		  <br/>
		  <a class="cloud-tie-join-count" href="javascript:void(0);" style="color:gray;font-size:14px;">
		  <span class="icon-smile"></span>
		  <span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;">
					阅读数: <span id="busuanzi_value_page_pv"></span>次 &nbsp;&nbsp;
		  </span>
		  </a>
		
		<!--显示阅读次数完毕-->
        
        <a href="/2023/10/12/Netty/" class="archive-article-date">
  	<time datetime="2023-10-12T12:40:48.311Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2023-10-12</time>
</a>
        
      </header>
	  <div align="center" class="post-count">
		字数：50.3k字 | 预计阅读时长：221分钟
	  </div>
    
    <div class="article-entry" itemprop="articleBody">
		

      
        <meta name="referrer" content="no-referrer" />
# Netty

<h2 id="一、Netty介绍和应用场景"><a href="#一、Netty介绍和应用场景" class="headerlink" title="一、Netty介绍和应用场景"></a>一、Netty介绍和应用场景</h2><h3 id="1、Netty的介绍"><a href="#1、Netty的介绍" class="headerlink" title="1、Netty的介绍"></a>1、Netty的介绍</h3><ol>
<li><p>Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。 </p>
</li>
<li><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可 靠性的网络 IO 程序。 </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161526548.png" alt="image-20230216152017797"></p>
</li>
<li><p>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下 的大量数据持续传输的应用。 </p>
</li>
<li><p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景 </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161545599.png" alt="image-20230216154514478"></p>
</li>
<li><p>要透彻理解Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码</p>
</li>
</ol>
<span id="more"></span>

<h3 id="2、Netty的应用场景"><a href="#2、Netty的应用场景" class="headerlink" title="2、Netty的应用场景"></a>2、Netty的应用场景</h3><ol>
<li><p>互联网行业</p>
<p>1）互联网行业：在分布式系统中，各个 节点之间需要远程服务调用，高性能 的 RPC 框架必不可少，Netty 作为异步 高性能的通信框架，往往作为基础通 信组件被这些 RPC 框架使用。 </p>
<p>2）典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进 行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各 进程节点之间的内部通信</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161547234.png" alt="image-20230216154715015"></p>
</li>
<li><p>游戏行业</p>
<ul>
<li>无论是手游服务端还是大型的网络游戏， Java 语言得到了越来越广泛的应用</li>
<li>Netty 作为高性能的基础通信组件，提 供了 TCP&#x2F;UDP 和 HTTP 协议栈，方便定 制和开发私有协议栈，账号登录服务器</li>
<li>地图服务器之间可以方便的通过 Netty 进行高性能的通信</li>
</ul>
</li>
<li><p>大数据领域</p>
<ul>
<li>经典的 Hadoop 的高性能通信和 序列化组件 （Avro 实现数据文件共享）的 RPC 框架， 默认采用 Netty 进行跨界点通信</li>
<li>它的 Netty Service 基于 Netty 框 架二次封装实现。</li>
</ul>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161549166.png" alt="image-20230216154918847"></p>
</li>
<li><p>其它开源项目使用到Netty</p>
<p>网址：<a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">Netty.docs: Related projects</a></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161550263.png" alt="image-20230216155048171"></p>
</li>
</ol>
<h3 id="3、Netty的学习参考资料"><a href="#3、Netty的学习参考资料" class="headerlink" title="3、Netty的学习参考资料"></a>3、Netty的学习参考资料</h3><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161551347.png" alt="image-20230216155128261"></p>
<h2 id="二、Java-BIO编程"><a href="#二、Java-BIO编程" class="headerlink" title="二、Java BIO编程"></a>二、Java BIO编程</h2><h3 id="1、I-O模型"><a href="#1、I-O模型" class="headerlink" title="1、I&#x2F;O模型"></a>1、I&#x2F;O模型</h3><ol>
<li><p>I&#x2F;O模型基本说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</span><br><span class="line">2) Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</span><br><span class="line">3) Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图1】</span><br><span class="line">4) Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理【简单示意图2】</span><br><span class="line">5) Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理。一般适用于连接数较多且连接时间较长的应用。</span><br></pre></td></tr></table></figure>

<p>示意图1：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161554843.png" alt="image-20230216155450758"></p>
<p>示意图2：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161555877.png" alt="image-20230216155515802"></p>
</li>
</ol>
<h3 id="2、BIO、NIO、AIO适用场景分析"><a href="#2、BIO、NIO、AIO适用场景分析" class="headerlink" title="2、BIO、NIO、AIO适用场景分析"></a>2、BIO、NIO、AIO适用场景分析</h3><ol>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕 系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分 调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ol>
<h3 id="3、Java-BIO基本介绍"><a href="#3、Java-BIO基本介绍" class="headerlink" title="3、Java BIO基本介绍"></a>3、Java BIO基本介绍</h3><ol>
<li>Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io</li>
<li>BIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连 接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 【后有 应用实例】</li>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解。</li>
</ol>
<h3 id="4、Java-BIO工作机制"><a href="#4、Java-BIO工作机制" class="headerlink" title="4、Java BIO工作机制"></a>4、Java BIO工作机制</h3><p>工作原理图：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302161710015.png" alt="image-20230216171006949"></p>
<p>BIO编程简单流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 服务器端启动一个ServerSocket</span><br><span class="line">2) 客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</span><br><span class="line">3) 客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等</span><br><span class="line">待，或者被拒绝</span><br><span class="line">4) 如果有响应，客户端线程会等待请求结束后，再继续执行</span><br></pre></td></tr></table></figure>

<h3 id="5、Java-BIO应用实例"><a href="#5、Java-BIO应用实例" class="headerlink" title="5、Java BIO应用实例"></a>5、Java BIO应用实例</h3><p>实例说明： </p>
<ol>
<li>使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启 动一个线程与之通讯。 </li>
<li>要求使用线程池机制改善，可以连接多个客户端. </li>
<li>服务器端可以接收客户端发送的数据(telnet 方式即可)</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162115019.png" alt="image-20230216211503976"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用线程池机制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 思路</span></span><br><span class="line"><span class="comment">        * 1、创建一个线程池</span></span><br><span class="line"><span class="comment">        * 2、如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已经启动了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待客户端&quot;</span>+i+<span class="string">&quot;号连接中...&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到&quot;</span>+i+<span class="string">&quot;号客户端&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//创建一个线程与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写run方法</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//System.out.println(&quot;线程信息 id =&quot;+Thread.currentThread().getId()+</span></span><br><span class="line">                        <span class="comment">//&quot;名字=&quot;+Thread.currentThread().getName());</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;等待客户端发送数据中...&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span>(read!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程id为&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;的客户端发送数据:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和线程id为&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;的client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162228829.png" alt="image-20230216222819693"></p>
<p>cmd：telnet 127.0.0.1 666</p>
<p>输入ctrl+]</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162228756.png" alt="image-20230216222853279"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162229839.png" alt="image-20230216222920364"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162229882.png" alt="image-20230216222943391"></p>
<h3 id="6、Java-BIO问题分析"><a href="#6、Java-BIO问题分析" class="headerlink" title="6、Java BIO问题分析"></a>6、Java BIO问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。 </li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占 用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞 在 Read 操作上，造成线程资源浪费</li>
</ol>
<h2 id="三、Java-NIO编程"><a href="#三、Java-NIO编程" class="headerlink" title="三、Java NIO编程"></a>三、Java NIO编程</h2><h3 id="1、Java-NIO基本介绍"><a href="#1、Java-NIO基本介绍" class="headerlink" title="1、Java NIO基本介绍"></a>1、Java NIO基本介绍</h3><ol>
<li><p>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的 </p>
</li>
<li><p>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。【基本案例】</p>
</li>
<li><p>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) </p>
</li>
<li><p>NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个 它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就 增加了处理过程中的灵活性，使用它可以提供非阻塞式的高 伸缩性网络</p>
</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162117010.png" alt="image-20230216211714957"></p>
<ol start="5">
<li><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得 到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而<strong>不是保持线 程阻塞</strong>，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞 写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。【后面有案例说明】 </p>
</li>
<li><p>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分 配10000个。 </p>
</li>
<li><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求 的数量比HTTP1.1大了好几个数量级。</p>
</li>
<li><p>案例说明NIO的Buffer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.lxg.nio;</span><br><span class="line"></span><br><span class="line">import java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line">public class BasicBuffer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //举例说明Buffer的使用（简单说明）</span><br><span class="line"></span><br><span class="line">        //创建一个Buffer,大小为5，即可以存放5个int</span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(5);</span><br><span class="line"></span><br><span class="line">        //向buffer存放数据</span><br><span class="line">        for (int i = 0; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i*2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如何从buffer读取数据</span><br><span class="line">        //将buffer转换，读写切换</span><br><span class="line">        intBuffer.flip();</span><br><span class="line"></span><br><span class="line">        while (intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162338300.png" alt="image-20230216233848023"></p>
</li>
</ol>
<h3 id="2、NIO和BIO的比较"><a href="#2、NIO和BIO的比较" class="headerlink" title="2、NIO和BIO的比较"></a>2、NIO和BIO的比较</h3><ol>
<li><p>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很 多 </p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的 </p>
</li>
<li><p>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进 行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因 此使用单个线程就可以监听多个客户端通道</p>
</li>
</ol>
<h3 id="3、NIO三大核心原理示意图"><a href="#3、NIO三大核心原理示意图" class="headerlink" title="3、NIO三大核心原理示意图"></a>3、NIO三大核心原理示意图</h3><p>一张图描述NIO 的 Selector 、 Channel 和 Buffer 的关系</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162342416.png" alt="image-20230216234202233"></p>
<p>Selector 、 Channel 和 Buffer 的关系图(简单版) 关系图的说明: </p>
<ol>
<li>每个channel 都会 对应一个Buffer </li>
<li>Selector 对应一个线程， 一个线程对应多个channel(连接) </li>
<li>该图反应了有三个channel 注册到 该selector &#x2F;&#x2F;程序 </li>
<li>程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念 </li>
<li>Selector 会根据不同的事件，在各个通道上切换 </li>
<li>Buffer 就是一个内存块 ， 底层是有一个数组  </li>
<li>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是 输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换 </li>
<li>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统 通道就是双向的</li>
</ol>
<h3 id="4、缓冲区（Buffer）"><a href="#4、缓冲区（Buffer）" class="headerlink" title="4、缓冲区（Buffer）"></a>4、缓冲区（Buffer）</h3><p><strong>基本介绍</strong></p>
<p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个 容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对 象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图: 【后面举例说 明】</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162120068.png" alt="image-20230216212034024"></p>
<p><strong>Buffer类及其子类</strong></p>
<ol>
<li><p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图:</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162121591.png" alt="image-20230216212142531"></p>
</li>
<li><p>Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素 的信息:</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162122172.png" alt="image-20230216212228110"></p>
</li>
<li><p>Buffer类相关方法一览</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="comment">//JDK1.4时，引入的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">( )</span><span class="comment">//返回此缓冲区的容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">position</span><span class="params">( )</span><span class="comment">//返回此缓冲区的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">position</span> <span class="params">(<span class="type">int</span> newPositio)</span><span class="comment">//设置此缓冲区的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">( )</span><span class="comment">//返回此缓冲区的限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">limit</span> <span class="params">(<span class="type">int</span> newLimit)</span><span class="comment">//设置此缓冲区的限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">( )</span><span class="comment">//在此缓冲区的位置设置标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">( )</span><span class="comment">//将此缓冲区的位置重置为以前标记的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">( )</span><span class="comment">//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">( )</span><span class="comment">//反转此缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">( )</span><span class="comment">//重绕此缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">( )</span><span class="comment">//返回当前位置与限制之间的元素数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">( )</span><span class="comment">//告知在当前位置和限制之间是否有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">( )</span>;<span class="comment">//告知此缓冲区是否为只读缓冲区</span></span><br><span class="line"><span class="comment">//JDK1.6时引入的api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasArray</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否具有可访问的底层实现数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">array</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">arrayOffset</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDirect</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否为直接缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>ByteBuffer</strong></p>
<p>从前面可以看出对于 Java 中的基本数据类型(boolean除外)，都有一个 Buffer 类型与之 相对应，最常用的自然是ByteBuffer 类（二进制数据），该类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> &#123;</span><br><span class="line"><span class="comment">//缓冲区创建相关api</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span><span class="comment">//创建直接缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span><span class="comment">//设置缓冲区的初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span><span class="comment">//把一个数组放到缓冲区中使用</span></span><br><span class="line"><span class="comment">//构造初始化位置offset和上界length的缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array,<span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">//缓存区存取相关API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">( )</span>;<span class="comment">//从当前位置position上get，get之后，position会自动+1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span> <span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//从绝对位置get</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">byte</span> b)</span>;<span class="comment">//从当前位置上添加，put之后，position会自动+1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span> <span class="params">(<span class="type">int</span> index, <span class="type">byte</span> b)</span>;<span class="comment">//从绝对位置上put</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302162124674.png" alt="image-20230216212406614"></p>
<h3 id="5、通道（channel）"><a href="#5、通道（channel）" class="headerlink" title="5、通道（channel）"></a>5、通道（channel）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><ol>
<li><p>NIO的通道类似于流，但有些区别如下： </p>
<p>• 通道可以同时进行读写，而流只能读或者只能写</p>
<p>• 通道可以实现异步读写数据 </p>
<p>• 通道可以从缓冲读数据，也可以写数据到缓冲:</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302171121672.png" alt="image-20230217112124541"></p>
</li>
<li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对 象只能进行读取数据的操作，而 NIO 中的通道 (Channel)是双向的，可以读操作，也可以写操作。 </p>
</li>
<li><p>Channel在NIO中是一个接口 public interface Channel extends Closeable{} </p>
</li>
<li><p>常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p>
</li>
<li><p>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</p>
</li>
</ol>
<h4 id="FileChannel类"><a href="#FileChannel类" class="headerlink" title="FileChannel类"></a><strong>FileChannel类</strong></h4><p>FileChannel主要用来对本地文件进行 IO 操作，常见的方法有 </p>
<ol>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中 </li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中 </li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道 中复制数据到当前通道 </li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当 前通道复制给目标通道</li>
</ol>
<h4 id="应用实例1-本地文件写数据"><a href="#应用实例1-本地文件写数据" class="headerlink" title="应用实例1-本地文件写数据"></a><strong>应用实例1-本地文件写数据</strong></h4><p>实例要求: </p>
<ol>
<li>使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,尚硅谷” 写入 到file01.txt 中 </li>
<li>文件不存在就创建 </li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过fileOutputStream 获取对应的FileChannel</span></span><br><span class="line">        <span class="comment">//这个真实类型是FileChannelImpl</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将str放入byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反正byteBuffer进行反正</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer数据写入到fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用实例2-本地文件读数据"><a href="#应用实例2-本地文件读数据" class="headerlink" title="应用实例2-本地文件读数据"></a><strong>应用实例2-本地文件读数据</strong></h4><p>实例要求: </p>
<ol>
<li>使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读 入到程序，并显示在控制台屏幕 </li>
<li>假定文件已经存在 </li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个文件输入流FileInputStrem</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过输入流对象获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将通道数据读入到缓冲区</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer的字节数据转成字符串</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用实例3-使用一个Buffer完成文件读取"><a href="#应用实例3-使用一个Buffer完成文件读取" class="headerlink" title="应用实例3-使用一个Buffer完成文件读取"></a><strong>应用实例3-使用一个Buffer完成文件读取</strong></h4><p>实例要求: </p>
<ol>
<li>使用 FileChannel(通道) 和 方法 read , write，完成文件的拷贝 </li>
<li>拷贝一个文本文件 1.txt , 放在项目下即可 </li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件输入流和文件输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file02.txt&quot;</span>);</span><br><span class="line">       <span class="comment">/* File  file = new File(&quot;file01.txt&quot;);</span></span><br><span class="line"><span class="comment">        FileInputStream fileInputStream = new FileInputStream(file);*/</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span>  fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length());</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重置各种标记</span></span><br><span class="line">            byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStreamChannel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将buffer中的数据写到outputStreamChannel</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            outputStreamChannel.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302172358207.png" alt="image-20230217235838954"></p>
<h4 id="应用实例4-拷贝文件transferFrom方法"><a href="#应用实例4-拷贝文件transferFrom方法" class="headerlink" title="应用实例4-拷贝文件transferFrom方法"></a><strong>应用实例4-拷贝文件transferFrom方法</strong></h4><p>实例要求: </p>
<ol>
<li>使用 FileChannel(通道) 和 方法 transferFrom ，完成文件的拷贝 </li>
<li>拷贝一张图片 </li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a2.jpg&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取流对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于Buffer和Channel的注意事项和细节"><a href="#关于Buffer和Channel的注意事项和细节" class="headerlink" title="关于Buffer和Channel的注意事项和细节"></a><strong>关于Buffer和Channel的注意事项和细节</strong></h4><ol>
<li><p>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。[举例说明] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOByteBufferPutGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>);</span><br><span class="line">        buffer.putLong(<span class="number">9L</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        buffer.putShort((<span class="type">short</span>) <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将一个普通Buffer 转成只读Buffer [举例说明] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            byteBuffer.put((<span class="type">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个只读的Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> byteBuffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        readOnlyBuffer.put((byte) 100);//ReadOnlyBufferException</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成. [举例说明] </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.RandomAccess;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *说明</span></span><br><span class="line"><span class="comment"> * 1、MappedByteBuffer可让文件直接在内存（堆外内存）修改，操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedByteBufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;file01.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：使用读写模式</span></span><br><span class="line"><span class="comment">         * 参数2: 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3: 是映射到内存的大小，即将file01.txt的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是0-5 5个字节，不是索引到5</span></span><br><span class="line"><span class="comment">         * 实际类型是DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">4</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 分散和 聚集Gathering【举例说明】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入【分散】</span></span><br><span class="line"><span class="comment"> * Gathering： 从buffer读取数据时，可以采用buffer数组，依次读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScatteringAndGatheringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用ServerSocketChannel和SocketChannel 网络</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到socket并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待客户端连接（telnet）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在等待客户端连接...&quot;</span>);</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//假定从客户端接收8个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取，每次读满8个字节就重新进行读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (byteRead&lt;messageLength)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead+=read;<span class="comment">//累计读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead=&quot;</span>+byteRead);</span><br><span class="line">                <span class="comment">//使用流打印，看看当前这个buffer的position和limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt;</span><br><span class="line">                        <span class="string">&quot;position=&quot;</span>+buffer.position() +<span class="string">&quot;,limit=&quot;</span>+</span><br><span class="line">                                buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的buffer进行flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据读取出显示到客户端</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">byteWrite</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(byteWrite&lt;messageLength)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">write</span> <span class="operator">=</span> socketChannel.write(byteBuffers);</span><br><span class="line">                byteWrite+=write;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的buffer进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer-&gt;&#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead=&quot;</span>+byteRead+<span class="string">&quot;byteWrite=&quot;</span>+byteWrite</span><br><span class="line">            +<span class="string">&quot;messageLength=&quot;</span>+messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6、Selector（选择器）"><a href="#6、Selector（选择器）" class="headerlink" title="6、Selector（选择器）"></a>6、Selector（选择器）</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器) </li>
<li>**Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以 事件的方式可以注册到同一个Selector)**，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。【示意图】 </li>
<li>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少 了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 </li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ol>
<h4 id="Selector示意图和特点说明"><a href="#Selector示意图和特点说明" class="headerlink" title="Selector示意图和特点说明"></a>Selector示意图和特点说明</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302180003626.png" alt="image-20230218000334442"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">特点再说明:</span><br><span class="line">1) Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</span><br><span class="line">2) 当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</span><br><span class="line">3) 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</span><br><span class="line">4) 由于读写操作都是非阻塞的，这就可以充分提升 IO线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。</span><br><span class="line">5) 一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升</span><br></pre></td></tr></table></figure>

<h4 id="Selector类相关方法"><a href="#Selector类相关方法" class="headerlink" title="Selector类相关方法"></a>Selector类相关方法</h4><p>Selector 类是一个抽象类, 常用方法和说明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Selector</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//得到一个选择器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span>;<span class="comment">//监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的SelectionKey 加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title function_">selectedKeys</span><span class="params">()</span>;<span class="comment">//从内部集合中得</span></span><br><span class="line">到所有的 SelectionKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302180004835.png" alt="image-20230218000437637"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket</p>
</li>
<li><p>selector 相关方法说明 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selector.select()<span class="comment">//阻塞 selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回 </span></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒selector selector.selectNow();//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7、NIO非阻塞-网络编程原理分析图"><a href="#7、NIO非阻塞-网络编程原理分析图" class="headerlink" title="7、NIO非阻塞 网络编程原理分析图"></a>7、NIO非阻塞 网络编程原理分析图</h3><p>NIO 非阻塞 网络编程相关的(Selector、SelectionKey、 ServerScoketChannel和SocketChannel) 关系梳理图：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181030385.png" alt="image-20230218103010210"></p>
<p>对上图的说明: </p>
<ol>
<li>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel </li>
<li>Selector 进行监听 select 方法, 返回有事 件发生的通道的个数. </li>
<li>将socketChannel注册到Selector上, register(Selector sel, int ops), 一个 selector上可以注册多个SocketChannel </li>
<li>注册后返回一个 SelectionKey, 会和该 Selector 关联(集合) </li>
<li>进一步得到各个 SelectionKey (有事件发 生) </li>
<li>在通过 SelectionKey 反向获取 SocketChannel , 方法 channel() </li>
<li>可以通过 得到的 channel , 完成业务处 理 </li>
<li>代码撑腰</li>
</ol>
<h3 id="8、NIO非阻塞-网络编程快速入门"><a href="#8、NIO非阻塞-网络编程快速入门" class="headerlink" title="8、NIO非阻塞 网络编程快速入门"></a>8、NIO非阻塞 网络编程快速入门</h3><p>案例要求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</span><br><span class="line">2) 目的：理解NIO非阻塞网络编程机制</span><br><span class="line">3) 看代码演示</span><br></pre></td></tr></table></figure>

<p>Server:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个Selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个监听端口6666,在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        <span class="comment">/**可以通过ServerSocketChannel的configureBlocking(false)方法将获得连接设置为非阻塞的。此时若没有连接，accept会返回null</span></span><br><span class="line"><span class="comment">        可以通过SocketChannel的configureBlocking(false)方法将从通道中读取数据设置为非阻塞的。若此时通道中没有数据可读，read会返回-1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把serverSocketChannel 注册到 selector 关心事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//等待了一秒钟没有事件发生，就继续</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒，无连接...&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果返回的&gt;0,就获取到相关的selectionKey集合</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1、如果返回的&gt;0，表示已经获取到关注的事件</span></span><br><span class="line"><span class="comment">             * 2、此方法返回关注事件的集合</span></span><br><span class="line"><span class="comment">             * 3、通过selectionKeys反向获取通道</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历selectionKeys，使用迭代器进行遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应的通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//给该客户端生成一个SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功！生成了一个SocketChannel：&quot;</span>+socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将SocketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//将当前的SocketChannel注册到selector</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//发生了读取事件</span></span><br><span class="line">                    <span class="comment">//通过key反向获取到对应的channel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;from 客户端：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Client:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip和端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其他工作...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果连接成功，就发送数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,小林你好！&quot;</span>;</span><br><span class="line">        <span class="comment">//wraps a byte array into a buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据(将buffer的数据写入到channel中）</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9、SelectionKey"><a href="#9、SelectionKey" class="headerlink" title="9、SelectionKey"></a>9、SelectionKey</h3><ol>
<li><p>SelectionKey，表示 Selector 和网络通道的注册关系, 共四种: </p>
<p>int OP_ACCEPT：有新的网络连接可以accept，值为 16 </p>
<p>int OP_CONNECT：代表连接已经建立，值为 8 int OP_READ：代表读操作， 值为 1 </p>
<p>int OP_WRITE：代表写操作，值为 4<br>源码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SelectionKey相关方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title function_">selector</span><span class="params">()</span>;<span class="comment">//得到与之关联的Selector 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title function_">channel</span><span class="params">()</span>;<span class="comment">//得到与之关联的通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span>;<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span>;<span class="comment">//设置或改变监听事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAcceptable</span><span class="params">()</span>;<span class="comment">//是否可以 accept</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;<span class="comment">//是否可以读</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;<span class="comment">//是否可以写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181033860.png" alt="image-20230218103347778"></p>
</li>
</ol>
<h3 id="10、ServerSocketChannel"><a href="#10、ServerSocketChannel" class="headerlink" title="10、ServerSocketChannel"></a>10、ServerSocketChannel</h3><ol>
<li><p><strong>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</strong></p>
</li>
<li><p>相关方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannel</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">NetworkChannel</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">open</span><span class="params">()</span>，得到一个 ServerSocketChannel 通道</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local)</span>，设置服务器端端口号</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span>，设置阻塞或非阻塞模式，取值 <span class="literal">false</span> 表示采用非阻塞模式</span><br><span class="line"><span class="keyword">public</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span>，接受一个连接，返回代表这个连接的通道对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span>，注册一个选择器并设置监听事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181035136.png" alt="image-20230218103501072"></p>
</li>
</ol>
<h3 id="11、SocketChannel"><a href="#11、SocketChannel" class="headerlink" title="11、SocketChannel"></a>11、SocketChannel</h3><ol>
<li><p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通 道，或者把通道里的数据读到缓冲区。 </p>
</li>
<li><p>相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketChannel</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ByteChannel</span>, ScatteringByteChannel, GatheringByteChannel, NetworkChannel&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span>;<span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(SocketAddress remote)</span>;<span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span>;<span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span>;<span class="comment">//往通道里写数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span>;<span class="comment">//从通道里读数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span>;<span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302181036674.png" alt="image-20230218103608604"></p>
</li>
</ol>
<h3 id="12、NIO-网络编程应用实例-群聊系统"><a href="#12、NIO-网络编程应用实例-群聊系统" class="headerlink" title="12、NIO 网络编程应用实例-群聊系统"></a>12、NIO 网络编程应用实例-群聊系统</h3><p>实例要求: </p>
<ol>
<li>编写一个 NIO 群聊系统，实现服务器 端和客户端之间的数据简单通讯（非 阻塞）</li>
<li>实现多人群聊 </li>
<li>服务器端：可以监测用户上线，离线， 并实现消息转发功能 </li>
<li>客户端：通过channel 可以无阻塞发送 消息给其它所有用户，同时可以接受 其它用户发送的消息(有服务器转发得 到) </li>
<li>目的：进一步理解NIO非阻塞网络编程 机制</li>
<li>代码演示</li>
</ol>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明相关属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POST</span> <span class="operator">=</span> <span class="number">9999</span>;<span class="comment">//服务器的端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, POST));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将channel注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username+<span class="string">&quot;is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot;说：&quot;</span>+info;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端转发其他客户端过来的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels&gt;<span class="number">0</span>)&#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//得到相关通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转换成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                System.out.println(&quot;没有可用的通道...&quot;);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程,每隔3秒，从服务器端读取转发过来的信息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">//构造器,进行初始化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将listenChannel注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//有事件要处理</span></span><br><span class="line">                    <span class="comment">//遍历得到的selectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        <span class="comment">//取出selectionKey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//监听到了accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            <span class="comment">//设置非阻塞</span></span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该sc注册到selector上</span></span><br><span class="line">                            sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示用户上线</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;用户&quot;</span>+sc.getRemoteAddress()+<span class="string">&quot;已上线了&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">//通道发生read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读取事件（调用自定义方法）</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//处理结束将当前的key删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待......&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectionKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey selectionKey)</span>&#123;</span><br><span class="line">        <span class="comment">//取到关联的channel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把缓冲区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;from 客户端消息：&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其他客户端(排除自己）转发消息，调用自定义方法处理</span></span><br><span class="line">                sendInfoToOtherClients(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户&quot;</span>+channel.getRemoteAddress()+<span class="string">&quot;离线了&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中......&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到selector上的SocketChannel，并排除self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key : selector.keys())&#123;</span><br><span class="line">            <span class="comment">//通过key取出对应的SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己,也排除服务器端的ServerSocketChannel</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel!=self)&#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将msg储存到buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13、NIO与零拷贝"><a href="#13、NIO与零拷贝" class="headerlink" title="13、NIO与零拷贝"></a>13、NIO与零拷贝</h3><h4 id="零拷贝基本介绍"><a href="#零拷贝基本介绍" class="headerlink" title="零拷贝基本介绍"></a>零拷贝基本介绍</h4><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。 </li>
<li>在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝 </li>
<li>另外我们看下NIO 中如何使用零拷贝</li>
</ol>
<h4 id="传统IO数据读写"><a href="#传统IO数据读写" class="headerlink" title="传统IO数据读写"></a>传统IO数据读写</h4><ol>
<li><p>Java 传统 IO 和 网络编程的一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="传统IO"><a href="#传统IO" class="headerlink" title="传统IO"></a>传统IO</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">早期的数据IO，由用户进程向CPU发起，应用程序与磁盘之间的 I/O 操作都是通过 CPU 的中断完成的。</span><br><span class="line"></span><br><span class="line">CPU还要负责将磁盘缓冲区拷贝到内核缓冲区(pageCache)，再从内核缓冲区拷贝到用户缓冲区。</span><br><span class="line"></span><br><span class="line">为了减少CPU占用，产生了DMA技术，大大解放了CPU.</span><br><span class="line"></span><br><span class="line">DMA 的全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。</span><br><span class="line"></span><br><span class="line">目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。</span><br></pre></td></tr></table></figure>

<p>传统用户通过cpu读取磁盘数据过程:</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190017180.png" alt="image-20230219001714945"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190017000.png" alt="image-20230219001729801"></p>
<p>由于cpu要参与从磁盘读数据到寄存器，又存入内存。这中间cpu都是阻塞状态不能干别的工作,由此产生DMA技术:</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190018153.png" alt="image-20230219001837964"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</span><br><span class="line"></span><br><span class="line">操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</span><br><span class="line"></span><br><span class="line">DMA 进一步将 I/O 请求发送给磁盘；</span><br><span class="line"></span><br><span class="line">磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</span><br><span class="line"></span><br><span class="line">DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</span><br><span class="line"></span><br><span class="line">当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</span><br><span class="line"></span><br><span class="line">CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</span><br></pre></td></tr></table></figure>

<h4 id="DMA技术存在的问题："><a href="#DMA技术存在的问题：" class="headerlink" title="DMA技术存在的问题："></a><strong>DMA技术存在的问题：</strong></h4><p>举个例子，从本地文件中发一张图片给你的好盆友。</p>
<p>传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取图片到到缓存区中，然后通过 write() 方法把缓存中的图片输出到网络端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read操作：</span><br><span class="line">当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。</span><br><span class="line">如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。</span><br><span class="line"></span><br><span class="line">write操作：</span><br><span class="line">当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（socket buffer）中，</span><br><span class="line">然后再将写缓存中的数据拷贝到网卡设备完成数据发送</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190020007.png" alt="image-20230219002009824"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182335806.png" alt="image-20230218233554522"></p>
<p> 需要进行两次DMA拷贝，两次CPU拷贝，四次上下文切换</p>
<p>总共四次拷贝，四次切换，代价属实有点点大。</p>
<ul>
<li><strong>上下文切换：</strong>当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。</li>
<li><strong>CPU 拷贝：</strong>由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li>
<li><strong>DMA 拷贝：</strong>由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</li>
</ul>
<h4 id="零拷贝的想法"><a href="#零拷贝的想法" class="headerlink" title="零拷贝的想法"></a><strong>零拷贝的想法</strong></h4><p>1.用户态可以直接操作读写，不需要切换用户态内核态</p>
<p>2.尽量减少拷贝次数，尽量减少上下文切换次数</p>
<p>3.写时复制，需要写操作的时候再拷贝，只是读操作没必要拷贝</p>
<h4 id="用户态直接IO"><a href="#用户态直接IO" class="headerlink" title="用户态直接IO"></a><strong>用户态直接IO</strong></h4><p>用户态直接 I&#x2F;O 使得应用进程或运行在用户态（user space）下的库函数直接访问硬件设备。</p>
<p>用户态直接 I&#x2F;O 只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统 就是一个代表。</p>
<p>其次，这种零拷贝机制会直接操作磁盘 I&#x2F;O，由于 CPU 和磁盘 I&#x2F;O 之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步 I&#x2F;O 使用。</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a><strong>写时复制</strong></h4><p>写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中。</p>
<p>这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。</p>
<h4 id="mmap优化"><a href="#mmap优化" class="headerlink" title="mmap优化"></a>mmap优化</h4><ol>
<li><p>mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核 空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝 次数。如下图</p>
</li>
<li><p>以mmap+write的方式替代传统的read+write的方式，减少了一次拷贝</p>
<p>mmap 是 Linux 提供的一种内存映射文件方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址</p>
<p>使用 mmap 的目的是将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射。</p>
<p>从而实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程。</p>
</li>
<li><p>mmap示意图</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190025063.png" alt="image-20230219002529908"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182336781.png" alt="image-20230218233657543"></p>
<p>整个拷贝过程会发生 4 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<p>mmap 主要的用处是提高 I&#x2F;O 性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费。</p>
</li>
</ol>
<h4 id="sendFile优化"><a href="#sendFile优化" class="headerlink" title="sendFile优化"></a>sendFile优化</h4><ol>
<li><p>Linux 2.1 版本 提供了 sendFile 函数，其基本 原理如下：数据根本不 经过用户态，直接从内 核缓冲区进入到 Socket Buffer，同时，由于和用 户态完全无关，就减少 了一次上下文切换</p>
</li>
<li><p>通过 Sendfile 系统调用，数据可以直接在内核空间内部进行 I&#x2F;O 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝</p>
</li>
<li><p>示意图和小结</p>
<p>将要读取的文件缓冲区的文件 fd 和要发送的Socket缓冲区的Socket fd 传给sendfile函数，</p>
<p> Sendfile 调用中 I&#x2F;O 数据对用户空间是完全不可见的。也就是说，这是一次完全意义上的数据传输过程。</p>
<p>也就是说用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程。</p>
<p>整个拷贝过程会发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<p>提示：零拷贝从操作系统角度，是没有cpu 拷贝</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190029611.png" alt="image-20230219002913434"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182338480.png" alt="image-20230218233806310"></p>
</li>
<li><p>Linux 在 2.4 版本中，做了 一些修改，避免了从内核 缓冲区拷贝到 Socket buffer 的操作，直接拷贝到 协议栈，从而再一次减少 了数据拷贝。具体如下图 和小结：</p>
<p><strong>Sendfile+DMA gather copy</strong></p>
<p>它只适用于将数据从文件拷贝到 socket 套接字上的传输过程。</p>
<p>它将内核空间的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer）中，</p>
<p>由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中。</p>
<p>这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可，本质就是和虚拟内存映射的思路类似。</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190041641.png" alt="image-20230219004115488"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302182338999.png" alt="image-20230218233841832"></p>
<p>这里其实有 一次cpu 拷贝 kernel buffer -&gt; socket buffer 但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以 忽略</p>
<p>整个拷贝过程会发生 2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝。</p>
</li>
</ol>
<h4 id="拓展：Splice零拷贝技术"><a href="#拓展：Splice零拷贝技术" class="headerlink" title="拓展：Splice零拷贝技术"></a>拓展：Splice零拷贝技术</h4><p>Splice相当于在Sendfile+DMA gather copy上的提升</p>
<p>Splice 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302190031824.png" alt="image-20230219003153661"></p>
<p>基于 Splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝。</p>
<ul>
<li>用户进程通过 splice() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li>
<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li>
<li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li>
<li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li>
<li>上下文从内核态（kernel space）切换回用户态（user space），Splice 系统调用执行返回。</li>
</ul>
<p><strong>对比</strong></p>
<p>无论是传统 I&#x2F;O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。</p>
<table>
<thead>
<tr>
<th>拷贝方式</th>
<th>CPU拷贝</th>
<th>DMA拷贝</th>
<th>系统调用</th>
<th>上下文切换</th>
</tr>
</thead>
<tbody><tr>
<td>传统方式</td>
<td>2</td>
<td>2</td>
<td>read&#x2F;write</td>
<td>4</td>
</tr>
<tr>
<td>内存映射（mmap+write）</td>
<td>1</td>
<td>2</td>
<td>mmap&#x2F;write</td>
<td>4</td>
</tr>
<tr>
<td>sendfile</td>
<td>1</td>
<td>2</td>
<td>sendfile</td>
<td>2</td>
</tr>
<tr>
<td>sendfile+DMA gather copy</td>
<td>0</td>
<td>2</td>
<td>sendfile</td>
<td>2</td>
</tr>
<tr>
<td>splice</td>
<td>0</td>
<td>2</td>
<td>splice</td>
<td>2</td>
</tr>
</tbody></table>
<h4 id="零拷贝的再次理解"><a href="#零拷贝的再次理解" class="headerlink" title="零拷贝的再次理解"></a>零拷贝的再次理解</h4><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是 重复的（只有 kernel buffer 有一份数据）。 </li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下 文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</li>
</ol>
<h4 id="mmap和sendFile的区别"><a href="#mmap和sendFile的区别" class="headerlink" title="mmap和sendFile的区别"></a>mmap和sendFile的区别</h4><ol>
<li>mmap 适合小数据量读写，sendFile 适合大文件传输。 </li>
<li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最 少 2 次数据拷贝。 </li>
<li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝 到 Socket</li>
</ol>
<h4 id="NIO零拷贝案例"><a href="#NIO零拷贝案例" class="headerlink" title="NIO零拷贝案例"></a>NIO零拷贝案例</h4><p>案例要求： </p>
<ol>
<li>使用传统的IO 方法传递一个大文件 </li>
<li>使用NIO 零拷贝方式传递(transferTo)一个大文件 </li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<p>传统IO服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] byteArray = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> dataInputStream.read(byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传统IO客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldIOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="type">long</span> readCount;</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((readCount = inputStream.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送总字节数： &quot;</span> + total + <span class="string">&quot;, 耗时： &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NIO服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7001</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">s</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (readCount!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                     readCount = s.read(byteBuffer);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind();<span class="comment">//倒带 position=0，mark作废</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NIO客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;localhost&quot;, 7001));</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;jdk-sourall.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个文件Channel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在linux下一个transferTo方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows下一次调用transferTo只能发送8m，就需要分段传输文件，而且要注意传输时的位置</span></span><br><span class="line">        <span class="comment">//transferTo底层使用到零拷贝</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position&lt;fileChannel.size())&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferCount</span> <span class="operator">=</span> fileChannel.transferTo(position, fileChannel.size(), socketChannel);</span><br><span class="line">            <span class="keyword">if</span>(transferCount&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total+=transferCount;</span><br><span class="line">            position+=transferCount;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总字节数=&quot;</span>+total +<span class="string">&quot;耗时：&quot;</span>+(System.currentTimeMillis()-startTime));</span><br><span class="line"><span class="comment">//        long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;发送的总字节数=&quot;+transferCount +&quot;耗时：&quot;+(System.currentTimeMillis()-startTime));</span></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="14、Java-AIO基本介绍"><a href="#14、Java-AIO基本介绍" class="headerlink" title="14、Java AIO基本介绍"></a>14、Java AIO基本介绍</h3><ol>
<li>JDK 7 引入了 Asynchronous I&#x2F;O，即 AIO。在进行 I&#x2F;O 编程中，常用到两种模式： Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得 到通知，进行相应的处理 </li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作 系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时 间较长的应用 </li>
<li>目前 AIO 还没有广泛应用，Netty 也是基于NIO, 而不是AIO， 因此我们就不详解 AIO了，有兴趣可以参考 &lt;&gt; <a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html">http://www.52im.net/thread-306-1-1.html</a></li>
</ol>
<h3 id="15、BIO、NIO、AIO对比表"><a href="#15、BIO、NIO、AIO对比表" class="headerlink" title="15、BIO、NIO、AIO对比表"></a>15、BIO、NIO、AIO对比表</h3><table>
<thead>
<tr>
<th>模型</th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p>举例说明：</p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。 </li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说 下，我先干其他事情，一会过来看是否轮到自己. </li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事 情，理发师自己来家给你理发</li>
</ol>
<h2 id="四、Netty概述"><a href="#四、Netty概述" class="headerlink" title="四、Netty概述"></a>四、Netty概述</h2><h3 id="1、原生NIO存在的问题"><a href="#1、原生NIO存在的问题" class="headerlink" title="1、原生NIO存在的问题"></a>1、原生NIO存在的问题</h3><ol>
<li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、 SocketChannel、ByteBuffer 等。 </li>
<li>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。 </li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失 败缓存、网络拥塞和异常流的处理等等。 </li>
<li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导 致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h3 id="2、Netty官网说明"><a href="#2、Netty官网说明" class="headerlink" title="2、Netty官网说明"></a>2、Netty官网说明</h3><p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a> </p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; client</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302191432593.png" alt="image-20230219143218387"></p>
<ol>
<li>Netty 是由 JBOSS 提供的一个 Java 开源框架。Netty 提供异步的、基于事件驱动的网 络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序 </li>
<li>Netty 可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了 NIO 的 开发过程 </li>
<li>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游 戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采 用了 Netty</li>
</ol>
<h3 id="3、Netty的优点"><a href="#3、Netty的优点" class="headerlink" title="3、Netty的优点"></a>3、Netty的优点</h3><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。 </p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展 的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个 线程池. </li>
<li>使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。 </li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。 </li>
<li>安全：完整的 SSL&#x2F;TLS 和 StartTLS 支持。 </li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复， 同时，更多的新功能会被加入</li>
</ol>
<h3 id="4、Netty版本说明"><a href="#4、Netty版本说明" class="headerlink" title="4、Netty版本说明"></a>4、Netty版本说明</h3><ol>
<li>netty版本分为 netty3.x 和 netty4.x、netty5.x </li>
<li>因为Netty5出现重大bug，已经被官网废弃了，目前推荐使用的是Netty4.x的稳定版 本 </li>
<li>目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x </li>
<li>在本课程中，我们讲解 Netty4.1.x 版本 5</li>
</ol>
<h2 id="五、Netty高性能架构设计"><a href="#五、Netty高性能架构设计" class="headerlink" title="五、Netty高性能架构设计"></a>五、Netty高性能架构设计</h2><h3 id="1、线程模型基本介绍"><a href="#1、线程模型基本介绍" class="headerlink" title="1、线程模型基本介绍"></a>1、线程模型基本介绍</h3><ol>
<li><p>不同的线程模式，对程序的性能有很大影响，为了搞清Netty 线程模式，我们来系统 的讲解下 各个线程模式， 最后看看Netty 线程模型有什么优越性. </p>
</li>
<li><p>目前存在的线程模型有： </p>
<p>传统阻塞 I&#x2F;O 服务模型 </p>
<p>Reactor 模式 </p>
</li>
<li><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p>
<p>• 单 Reactor 单线程； </p>
<p>• 单 Reactor 多线程； </p>
<p>• 主从 Reactor 多线程 </p>
</li>
<li><p>Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</p>
</li>
</ol>
<h3 id="2、传统阻塞I-O服务模型"><a href="#2、传统阻塞I-O服务模型" class="headerlink" title="2、传统阻塞I&#x2F;O服务模型"></a>2、传统阻塞I&#x2F;O服务模型</h3><h4 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h4><p>黄色的框表示对象， 蓝色的框表示线程 白色的框表示方法(API)</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302191457030.png" alt="image-20230219145750926"></p>
<h4 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h4><ol>
<li>采用阻塞IO模式获取输入的数据 </li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回</li>
</ol>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源 </li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程 会阻塞在read 操作，造成线程资源浪费</li>
</ol>
<h3 id="3、Reactor模式"><a href="#3、Reactor模式" class="headerlink" title="3、Reactor模式"></a>3、Reactor模式</h3><h4 id="针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案："></a>针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案：</h4><ol>
<li>基于 I&#x2F;O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等 待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应 用程序，线程从阻塞状态返回，开始进行业务处理 Reactor 对应的叫法: <ul>
<li>反应器模式 </li>
<li>分发者模式(Dispatcher) </li>
<li>通知者模式(notifier)</li>
</ul>
</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理 任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138827.png" alt="image-20230219212720403"></p>
<h4 id="I-O-复用结合线程池，就是-Reactor-模式基本设计思想，-如图："><a href="#I-O-复用结合线程池，就是-Reactor-模式基本设计思想，-如图：" class="headerlink" title="I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想， 如图："></a>I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想， 如图：</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138828.png" alt="image-20230219212804053"></p>
<p>说明: </p>
<ol>
<li>Reactor 模式，通过一个或多个输 入同时传递给服务处理器的模式 (基于事件驱动) </li>
<li>服务器端程序处理传入的多个请求, 并将它们同步分派到相应的处理线 程， 因此Reactor模式也叫 Dispatcher模式 </li>
<li>Reactor 模式使用IO复用监听事件, 收到事件后，分发给某个线程(进 程), 这点就是网络服务器高并发处 理关键</li>
</ol>
<h4 id="Reactor-模式中-核心组成："><a href="#Reactor-模式中-核心组成：" class="headerlink" title="Reactor 模式中 核心组成："></a>Reactor 模式中 核心组成：</h4><ol>
<li>Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处 理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并 将线路转移到适当的联系人； </li>
<li>Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类似于客户想要与之交谈的公 司中的实际官员。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行 非阻塞操作</li>
</ol>
<h4 id="Reactor-模式分类："><a href="#Reactor-模式分类：" class="headerlink" title="Reactor 模式分类："></a>Reactor 模式分类：</h4><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 </p>
<ol>
<li>单 Reactor 单线程 </li>
<li>单 Reactor 多线程 </li>
<li>主从 Reactor</li>
</ol>
<h3 id="4、单Reactor单线程"><a href="#4、单Reactor单线程" class="headerlink" title="4、单Reactor单线程"></a>4、单Reactor单线程</h3><h4 id="工作原理示意图："><a href="#工作原理示意图：" class="headerlink" title="工作原理示意图："></a>工作原理示意图：</h4><p>演示下NIO 群聊,说 明</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138829.png" alt="image-20230219212939643"></p>
<h4 id="方案说明："><a href="#方案说明：" class="headerlink" title="方案说明："></a>方案说明：</h4><ol>
<li><p>Select 是前面 I&#x2F;O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻 塞对象监听多路连接请求</p>
</li>
<li><p>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发 </p>
</li>
<li><p>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理 </p>
</li>
<li><p>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应 </p>
</li>
<li><p>Handler 会完成 Read→业务处理→Send 的完整业务流程</p>
</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写 等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。</p>
<h4 id="方案优缺点分析："><a href="#方案优缺点分析：" class="headerlink" title="方案优缺点分析："></a>方案优缺点分析：</h4><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某 个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈 </li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不 可用，不能接收和处理外部消息，造成节点故障 </li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复 杂度 O(1) 的情况</li>
</ol>
<h3 id="5、单Reactor多线程"><a href="#5、单Reactor多线程" class="headerlink" title="5、单Reactor多线程"></a>5、单Reactor多线程</h3><h4 id="工作原理示意图：-1"><a href="#工作原理示意图：-1" class="headerlink" title="工作原理示意图："></a>工作原理示意图：</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138830.png" alt="image-20230219213148725"></p>
<h4 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h4><ol>
<li>Reactor 对象通过select 监控客户端请求 事件, 收到事件后，通过dispatch进行分发 </li>
<li>如果建立连接请求, 则右Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象 处理完成连接后的各种事件 </li>
<li>如果不是连接请求，则由reactor分发调用连接对 应的handler 来处理 </li>
<li>handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线 程池的某个线程处理业务 </li>
<li>worker 线程池会分配独立线程完成真正的业务， 并将结果返回给handler </li>
<li>handler收到响应后，通过send 将结果返回给 client</li>
</ol>
<h4 id="方案优缺点分析：-1"><a href="#方案优缺点分析：-1" class="headerlink" title="方案优缺点分析："></a>方案优缺点分析：</h4><ol>
<li>优点：可以充分的利用多核cpu 的处理能力 </li>
<li>缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在 单线程运行， 在高并发场景容易出现性能瓶颈</li>
</ol>
<h3 id="6、主从Reactor多线程"><a href="#6、主从Reactor多线程" class="headerlink" title="6、主从Reactor多线程"></a>6、主从Reactor多线程</h3><h4 id="工作原理示意图：-2"><a href="#工作原理示意图：-2" class="headerlink" title="工作原理示意图："></a>工作原理示意图：</h4><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运 行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138831.png" alt="image-20230219213313541"></p>
<p>subreactor可以有很多个</p>
<h4 id="方案说明-1"><a href="#方案说明-1" class="headerlink" title="方案说明"></a>方案说明</h4><ol>
<li>Reactor主线程 MainReactor 对象通过select 监听连接事件, 收 到事件后，通过Acceptor 处理连接事件 </li>
<li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor </li>
<li>subreactor 将连接加入到连接队列进行监听,并创建handler 进行各种事件处理 </li>
<li>当有新事件发生时， subreactor 就会调用对应的handler处 理 </li>
<li>handler 通过read 读取数据，分发给后面的worker 线程处理 </li>
<li>worker 线程池分配独立的worker 线程进行业务处理，并返 回结果</li>
</ol>
<h4 id="Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>Scalable IO in Java 对 Multiple Reactors 的原理图解：</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302192138832.png" alt="image-20230219213432838"></p>
<h4 id="方案优缺点说明："><a href="#方案优缺点说明：" class="headerlink" title="方案优缺点说明："></a>方案优缺点说明：</h4><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线 程完成后续的业务处理。 </li>
<li>优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线 程，子线程无需返回数据。 </li>
<li>缺点：编程复杂度较高 结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型， Memcached 主从多线程，Netty 主从多线程模型的支持</li>
</ol>
<h3 id="7、Reactor模式小结"><a href="#7、Reactor模式小结" class="headerlink" title="7、Reactor模式小结"></a>7、Reactor模式小结</h3><h4 id="3-种模式用生活案例来理解"><a href="#3-种模式用生活案例来理解" class="headerlink" title="3 种模式用生活案例来理解"></a>3 种模式用生活案例来理解</h4><ol>
<li><p>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服 </p>
</li>
<li><p>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待 </p>
</li>
<li><p>主从 Reactor 多线程，多个前台接待员，多个服务生</p>
</li>
</ol>
<h4 id="Reactor-模式具有如下的优点："><a href="#Reactor-模式具有如下的优点：" class="headerlink" title="Reactor 模式具有如下的优点："></a>Reactor 模式具有如下的优点：</h4><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的 </li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程 的切换开销 </li>
<li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源 </li>
<li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h3 id="8、Netty模型"><a href="#8、Netty模型" class="headerlink" title="8、Netty模型"></a>8、Netty模型</h3><h4 id="工作原理示意图1-简单版"><a href="#工作原理示意图1-简单版" class="headerlink" title="工作原理示意图1-简单版"></a>工作原理示意图1-简单版</h4><p>Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多 线程模型有多个 Reactor</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201137936.png" alt="image-20230220113710817"></p>
<ol>
<li>BossGroup 线程维护Selector , 只关注Accecpt </li>
<li>当接收到Accept事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel并注册到 Worker 线程(事件循环), 并进行维护 </li>
<li>当Worker线程监听到selector 中通道发生自己感 兴趣的事件后，就进行处理(就由handler)， 注意 handler 已经加入到通道</li>
</ol>
<h4 id="工作原理示意图2-进阶版"><a href="#工作原理示意图2-进阶版" class="headerlink" title="工作原理示意图2-进阶版"></a>工作原理示意图2-进阶版</h4><p>Netty 主要基于主从 Reactors 多线程模型（如 图）做了一定的改进，其 中主从 Reactor 多线程模 型有多个 Reactor</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201138072.png" alt="image-20230220113810938"></p>
<h4 id="工作原理示意图-详细版"><a href="#工作原理示意图-详细版" class="headerlink" title="工作原理示意图-详细版"></a>工作原理示意图-详细版</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302201138078.png" alt="image-20230220113836960"></p>
<ol>
<li>Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写 </li>
<li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup </li>
<li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循 环 ，每一个事件循环是 NioEventLoop </li>
<li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络 通讯 </li>
<li>NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop</li>
<li>每个Boss NioEventLoop 循环执行的步骤有3步 1. 轮询accept 事件 2. 处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其 注册到某个worker NIOEventLoop 上的 selector 3. 处理任务队列的任务 ， 即 runAllTasks </li>
<li>每个 Worker NIOEventLoop 循环执行的步骤<ul>
<li>轮询read, write 事件 </li>
<li>处理i&#x2F;o事件， 即read , write 事件，在对应NioScocketChannel 处理 </li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ul>
</li>
<li>每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道), pipeline中包含了channel，即通过pipeline可以获取到对应通道，管道中维护了很多的处理器</li>
</ol>
<h3 id="9、Netty快速入门实例-TCP服务"><a href="#9、Netty快速入门实例-TCP服务" class="headerlink" title="9、Netty快速入门实例-TCP服务"></a>9、Netty快速入门实例-TCP服务</h3><ol>
<li><p>实例要求：使用IDEA 创建Netty项目 </p>
</li>
<li><p>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~” </p>
</li>
<li><p>服务器可以回复消息给客户端 “hello, 客户端~” </p>
</li>
<li><p>目的：对Netty 线程模型 有一个初步认识, 便于理解Netty 模型理论 </p>
</li>
<li><p>看代码演示 </p>
<ul>
<li><p>编写服务端 </p>
</li>
<li><p>编写客户端 </p>
</li>
<li><p>对netty 程序进行分析，看看netty模型特点</p>
</li>
</ul>
</li>
</ol>
<p>说明: 创建Maven项目，并引入Netty </p>
<p>netty依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.86.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BOSSGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 说明</span></span><br><span class="line"><span class="comment">         * 1、创建了两个线程组boosGroup和workerGroup</span></span><br><span class="line"><span class="comment">         * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line"><span class="comment">         * 3、两个都是无限循环</span></span><br><span class="line"><span class="comment">         * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数</span></span><br><span class="line"><span class="comment">         * 默认是以cpu核数*2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioServerSocketChannel作为服务器的通道来实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">//设置线程队列等待连接的个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个初始化对象（匿名对象）</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);  <span class="comment">//给我们的workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器is ready......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">//启动服务器了（绑定好端口了）</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承入栈的handler适配器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范）</span></span><br><span class="line"><span class="comment"> * 2、这是我们自定义一个Handler，才能成为一个Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据事件（这里我们可以读取客户端发送过来的消息）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ：是上下文对象。含有管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg ：就是客户端发送过来的数据，默认是Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器读取线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx=&quot;</span>+ctx);</span><br><span class="line">        System.out.println(<span class="string">&quot;看看channel和pipeline的关系&quot;</span>);</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();<span class="comment">//本质是一个双向链表，出站入站</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将msg转成一个ByteBuf</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *ByteBuf是Netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址是：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//writeAndFlush是write+flush</span></span><br><span class="line">        <span class="comment">//将数据写入缓冲区，并刷新</span></span><br><span class="line">        <span class="comment">//一般来讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootStrap而是Bootstrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is ok ！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于ChannelFuture后面再分析，涉及到netty的异步模型</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client&quot;</span>+ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server！(&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10、Netty模型"><a href="#10、Netty模型" class="headerlink" title="10、Netty模型"></a>10、Netty模型</h3><h4 id="任务队列中的-Task-有-3-种典型使用场景"><a href="#任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="任务队列中的 Task 有 3 种典型使用场景"></a>任务队列中的 Task 有 3 种典型使用场景</h4><ol>
<li><p>用户程序自定义的普通任务 [举例说明]</p>
</li>
<li><p>用户自定义定时任务 </p>
</li>
<li><p>非当前 Reactor 线程调用 Channel 的各种方法 </p>
<p>例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后 调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到 任务队列中后被异步消费</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如我们这里有一个非常耗费时间的业务-&gt;异步执行-&gt;提交到该channel对应的NIOEventLoop的taskQueue中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Thread.sleep(10*1000);</span></span><br><span class="line"><span class="comment">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵2&quot;,CharsetUtil.UTF_8));*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案1：用户程序自定义的普通任务</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵2&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵3&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案2：用户自定义定时任务-&gt;该任务是提交到scheduleTaskQueue中</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵4&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;go on ...&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="方案再说明"><a href="#方案再说明" class="headerlink" title="方案再说明"></a>方案再说明</h4><ol>
<li><p>Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负 责网络读写操作。 </p>
</li>
<li><p>NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道。 </p>
</li>
<li><p>NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop 负责</p>
</li>
</ol>
<ul>
<li>NioEventLoopGroup 下包含多个 NioEventLoop </li>
<li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue </li>
<li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel </li>
<li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上 </li>
<li>每个 NioChannel 都绑定有一个自己的 ChannelPipelin</li>
</ul>
<h3 id="11、异步模型"><a href="#11、异步模型" class="headerlink" title="11、异步模型"></a>11、异步模型</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实 际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。 </li>
<li>Netty 中的 I&#x2F;O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。 </li>
<li>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获 取或者通过通知机制获得 IO 操作结果 </li>
<li>Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun返回 显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future去监控方法 fun 的处理过程(即 ： Future-Listener 机制)</li>
</ol>
<h4 id="Future说明"><a href="#Future说明" class="headerlink" title="Future说明"></a>Future说明</h4><ol>
<li><p>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等 等. </p>
</li>
<li><p>ChannelFuture 是一个接口 ： public interface ChannelFuture extends Future 我们可以添加监听器，当监听的事件发生时，就会通知到监听器. 案例说明</p>
</li>
</ol>
<h4 id="工作原理示意图"><a href="#工作原理示意图" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511744.png" alt="image-20230221211710764"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302212121961.png" alt="image-20230221212153883"></p>
<p>说明: </p>
<ol>
<li>在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。 </li>
<li>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</li>
</ol>
<h4 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h4><ol>
<li><p>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。 </p>
</li>
<li><p>常见有如下操作 • 通过 isDone 方法来判断当前操作是否完成； </p>
<ul>
<li><p>通过 isSuccess 方法来判断已完成的当前操作是否成功； </p>
</li>
<li><p>通过 getCause 方法来获取已完成的当前操作失败的原因； </p>
</li>
<li><p>通过 isCancelled 方法来判断已完成的当前操作是否被取消；<br>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知 指定的监听器；如果 Future 对象已完成，则通知指定的监听器</p>
</li>
</ul>
</li>
<li><p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">System.out.println(newDate() + <span class="string">&quot;: 端口[&quot;</span>+ port + <span class="string">&quot;]绑定成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;端口[&quot;</span>+ port + <span class="string">&quot;]绑定失败!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>相比传统阻塞 I&#x2F;O，执行 I&#x2F;O 操作后线程会被阻塞住, 直到操作完成；异步处理的好 处是不会造成线程阻塞，线程在 I&#x2F;O 操作期间可以执行别的程序，在高并发情形下会更稳 定和更高的吞吐量</p>
</li>
</ol>
<h3 id="13、快速入门实例-HTTP服务"><a href="#13、快速入门实例-HTTP服务" class="headerlink" title="13、快速入门实例-HTTP服务"></a>13、快速入门实例-HTTP服务</h3><ol>
<li>实例要求：使用IDEA 创建Netty项目 </li>
<li>Netty 服务器在 6668 端口监听，浏览器发出请求 “<a target="_blank" rel="noopener" href="http://localhost:6668/">http://localhost:6668/</a> “ </li>
<li>服务器可以回复消息给客户端 “Hello! 我是服务器 5 “ , 并 对特定请求资源进行过滤. </li>
<li>目的：Netty 可以做Http服务开发，并且理解Handler实例 和客户端及其请求的关系. </li>
<li>看代码演示</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302212122748.png" alt="image-20230221212230674"></p>
<p>TestServer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">TestServerInitializer</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">9999</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TestServerInitializer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty提供的httpServerCodec codec =&gt; coder - decoder</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HttpServerCodec说明</span></span><br><span class="line"><span class="comment">         * 1、HttpServerCodec 是netty提供的处理http的编码解码器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        <span class="comment">//2、增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">TestHttpServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestHttpServerHandler:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1、SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类</span></span><br><span class="line"><span class="comment"> * 2、HttpObject 表示 客户端和服务器端相互通讯的数据被封装成HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端数据，当有读取事件发生时触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断msg是不是一个httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;pipeline &quot;</span> + ctx.pipeline().hashCode()+<span class="string">&quot;TestHttpServerHandler hash=&quot;</span>+<span class="built_in">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg类型=&quot;</span>+msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri,过滤指定资源</span></span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了 favicon.ico，不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复信息给浏览器[http协议]</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">content</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello，我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的响应，即httpresponse</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Netty核心模块组件"><a href="#六、Netty核心模块组件" class="headerlink" title="六、Netty核心模块组件"></a>六、Netty核心模块组件</h2><h3 id="1、Bootstrap、ServerBootstrap"><a href="#1、Bootstrap、ServerBootstrap" class="headerlink" title="1、Bootstrap、ServerBootstrap"></a>1、Bootstrap、ServerBootstrap</h3><ol>
<li><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置 整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类， ServerBootstrap 是服务端启动引导类</p>
</li>
<li><p>常见的方法有 </p>
<ul>
<li>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法 用于服务器端，用来设置两个 EventLoop </li>
<li>public B group(EventLoopGroup group) ，该方法用于客户端，用来设置一个 EventLoop </li>
<li>public B channel(Class channelClass)，该方法用来设置一个服务器端的通道实现 </li>
<li>public  B option(ChannelOption option, T value)，用来给 ServerChannel 添加配置 </li>
<li>public  ServerBootstrap childOption(ChannelOption childOption, T value)，用来给接收到的 通道添加配置 </li>
<li>public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类 （自定义的 handler） </li>
<li>public ChannelFuture bind(int inetPort) ，该方法用于服务器端，用来设置占用的端口号 </li>
<li>public ChannelFuture connect(String inetHost, int inetPort) ，该方法用于客户端，用来连接服务器</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">childHandler()和childOption()都是给workerGroup （也就是group方法中的childGroup参数）进行设置的，option()和handler()都是给bossGroup（也就是group方法中的parentGroup参数）设置的。</span><br><span class="line"></span><br><span class="line">另一种方法说option()和handler()是在server启动时进行设置和调用，childHandler()和childOption()是在连接建立是设置和调用的。其实都是对的。</span><br><span class="line"></span><br><span class="line">bossGroup是在服务器一启动就开始工作，负责监听客户端的连接请求。当建立连接后就交给了workGroup进行事务处理，两种是从不同的角度解释的。</span><br><span class="line"></span><br><span class="line">handler在初始化时就会执行，而childHandler会在客户端成功connect后才执行，这是两者的区别。</span><br><span class="line"></span><br><span class="line">客户端Bootstrap只有handler()方法，因为客户端只需要一个事件线程组</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、Future、ChannelFuture"><a href="#2、Future、ChannelFuture" class="headerlink" title="2、Future、ChannelFuture"></a>2、Future、ChannelFuture</h3><ol>
<li>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以 过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发 注册的监听事件 </li>
<li>常见的方法有 <ul>
<li>Channel channel()，返回当前正在进行 IO 操作的通道 </li>
<li>ChannelFuture sync()，等待异步操作执行完毕</li>
</ul>
</li>
</ol>
<h3 id="3、Channel"><a href="#3、Channel" class="headerlink" title="3、Channel"></a>3、Channel</h3><ol>
<li><p>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。 </p>
</li>
<li><p>通过Channel 可获得当前网络连接的通道的状态 </p>
</li>
<li><p>通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小） </p>
</li>
<li><p>Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着 任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成 </p>
</li>
<li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 I&#x2F;O 操作与对应的处理程序 </p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型:</p>
<ul>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接。 </li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 </li>
<li>NioDatagramChannel，异步的 UDP 连接。 </li>
<li>NioSctpChannel，异步的客户端 Sctp 连接。 </li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li>
</ul>
</li>
</ol>
<h3 id="4、Selector"><a href="#4、Selector" class="headerlink" title="4、Selector"></a>4、Selector</h3><ol>
<li>Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连 接的 Channel 事件。 </li>
<li>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询 (Select) 这些注册的 Channel 是否有已就绪的 I&#x2F;O 事件（例如可读，可写，网络连接 完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channe</li>
</ol>
<h3 id="5、ChannelHandler-及其实现类"><a href="#5、ChannelHandler-及其实现类" class="headerlink" title="5、ChannelHandler 及其实现类"></a>5、ChannelHandler 及其实现类</h3><ol>
<li><p>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。 </p>
</li>
<li><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方 便使用期间，可以继承它的子类 </p>
</li>
<li><p>ChannelHandler 及其实现类一览图(后)</p>
<p>相关接口和类一览图：<img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222121907.png" alt="image-20230222212044989"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">• ChannelInboundHandler 用于处</span><br><span class="line">理入站 I/O 事件。</span><br><span class="line">• ChannelOutboundHandler 用于</span><br><span class="line">处理出站 I/O 操作。</span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line">• ChannelInboundHandlerAdapter</span><br><span class="line">用于处理入站 I/O 事件。</span><br><span class="line">• ChannelOutboundHandlerAdapt</span><br><span class="line">er 用于处理出站 I/O 操作。</span><br><span class="line">• ChannelDuplexHandler 用于处理</span><br><span class="line">入站和出站事件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们经常需要自定义一 个 Handler 类去继承 ChannelInboundHandlerA dapter，然后通过重写 相应方法实现业务逻辑， 我们接下来看看一般都 需要重写哪些方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ChannelInboundHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ChannelInboundHandlerAdapter</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireChannelUnregistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通道就绪事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireChannelActive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireChannelInactive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通道读取数据事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span></span><br><span class="line">Exception &#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据读取完毕事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    ctx.fireChannelReadComplete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx,Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    ctx.fireUserEventTriggered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    ctx.fireChannelWritabilityChanged();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwable cause)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6、Pipeline-和-ChannelPipeline"><a href="#6、Pipeline-和-ChannelPipeline" class="headerlink" title="6、Pipeline 和 ChannelPipeline"></a>6、Pipeline 和 ChannelPipeline</h3><p>ChannelPipeline 是一个重点： </p>
<ol>
<li><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解： ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站 事件和出站操作) </p>
</li>
<li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事 件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互</p>
</li>
<li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222124337.png" alt="image-20230222212410249"></p>
<p>• 一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler </p>
<p>• 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler， 出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• ChannelPipeline <span class="title function_">addFirst</span><span class="params">(ChannelHandler... handlers)</span>，把一个业务处理类（handler）</span><br><span class="line">添加到链中的第一个位置</span><br><span class="line">• ChannelPipeline <span class="title function_">addLast</span><span class="params">(ChannelHandler... handlers)</span>，把一个业务处理类（handler）</span><br><span class="line">添加到链中的最后一个位置</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7、ChannelHandlerContext"><a href="#7、ChannelHandlerContext" class="headerlink" title="7、ChannelHandlerContext"></a>7、ChannelHandlerContext</h3><ol>
<li><p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象 </p>
</li>
<li><p>即ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便 对 ChannelHandler进行调用. </p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture <span class="title function_">close</span><span class="params">()</span>，关闭通道</span><br><span class="line">• ChannelOutboundInvoker <span class="title function_">flush</span><span class="params">()</span>，刷新</span><br><span class="line">• ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> ， 将 数 据 写 到 ChannelPipeline 中 当 前</span><br><span class="line">• ChannelHandler 的下一个 ChannelHandler 开始处理</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8、ChannelOption"><a href="#8、ChannelOption" class="headerlink" title="8、ChannelOption"></a>8、ChannelOption</h3><ol>
<li><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。 </p>
</li>
<li><p>ChannelOption 参数如下: </p>
<p>ChannelOption.SO_BACKLOG ：</p>
<p>对应 TCP&#x2F;IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服 务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户 端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定 了队列的大小。 </p>
<p>ChannelOption.SO_KEEPALIVE ：</p>
<p>一直保持连接活动状态</p>
</li>
</ol>
<h3 id="9、EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#9、EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="9、EventLoopGroup 和其实现类 NioEventLoopGroup"></a>9、EventLoopGroup 和其实现类 NioEventLoopGroup</h3><ol>
<li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源， 一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。 </p>
</li>
<li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。</p>
</li>
<li><p>通常一个服务端口即一个 ServerSocketChannel对应一个Selector 和一个EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222127524.png" alt="image-20230222212737413"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">• BossEventLoopGroup 通常是一个单线</span><br><span class="line">程的 EventLoop，EventLoop 维护着一</span><br><span class="line">个注册了ServerSocketChannel 的</span><br><span class="line">Selector 实例BossEventLoop 不断轮询</span><br><span class="line">Selector 将连接事件分离出来</span><br><span class="line">• 通常是 OP_ACCEPT 事件，然后将接收</span><br><span class="line">到的 SocketChannel 交给</span><br><span class="line">WorkerEventLoopGroup</span><br><span class="line">• WorkerEventLoopGroup 会由 next 选择</span><br><span class="line">其中一个 EventLoop来将这个</span><br><span class="line">SocketChannel 注册到其维护的</span><br><span class="line">Selector 并对其后续的 IO 事件进行处</span><br><span class="line">理</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• <span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span>，构造方法</span><br><span class="line">• <span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully()，断开连接，关闭线程</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10、Upooled类"><a href="#10、Upooled类" class="headerlink" title="10、Upooled类"></a>10、Upooled类</h3><ol>
<li><p>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类 </p>
</li>
<li><p>常用方法如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">copiedBuffer</span><span class="params">(CharSequence string, Charset charse</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>举例说明Unpooled 获取 Netty的数据容器ByteBuf 的基本使用 【案例演示</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302222129613.png" alt="image-20230222212942505"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyByteBuf01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 说明</span></span><br><span class="line"><span class="comment">         * 1、创建对象，该对象包含一个数组arr，是一个byte[10]</span></span><br><span class="line"><span class="comment">         * 2、在netty的buffer中，不需要使用flip进行反转</span></span><br><span class="line"><span class="comment">         * 底层维护了readerIndex和writerIndex</span></span><br><span class="line"><span class="comment">         * 3、通过readerIndex和writerIndex还有capacity，将buffer分成了三个区域</span></span><br><span class="line"><span class="comment">         * 0--readerIndex ：已经读取的区域</span></span><br><span class="line"><span class="comment">         * 0-writerIndex：已经写的区域</span></span><br><span class="line"><span class="comment">         * readerIndex--writerIndex:可读的区域</span></span><br><span class="line"><span class="comment">         * writerIndex--capacity:表示可写的区域</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;capacity=&quot;</span>+buffer.capacity());</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyByteBuf02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相关的api</span></span><br><span class="line">        <span class="keyword">if</span>(byteBuf.hasArray())&#123; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将content转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf=&quot;</span>+byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset());<span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex());<span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex());<span class="comment">//12</span></span><br><span class="line">            System.out.println(byteBuf.capacity());<span class="comment">//36</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(byteBuf.readByte()); //读出一个字节 h--&gt;104</span></span><br><span class="line">            System.out.println(byteBuf.getByte(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readableBytes();<span class="comment">//可读的字节数等于12</span></span><br><span class="line">            System.out.println(<span class="string">&quot;len=&quot;</span>+len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;len ; i++) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从哪开始读，读几个字节，字节编码</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>,<span class="number">4</span>,Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">4</span>,<span class="number">6</span>,Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11、Netty应用实例-群聊系统"><a href="#11、Netty应用实例-群聊系统" class="headerlink" title="11、Netty应用实例-群聊系统"></a>11、Netty应用实例-群聊系统</h3><p>实例要求: </p>
<ol>
<li>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞） </li>
<li>实现多人群聊 </li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能 </li>
<li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用 户发送的消息(有服务器转发得到) </li>
<li>目的：进一步理解Netty非阻塞网络编程机制</li>
<li>看代码演示</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280854160.png" alt="image-20230228085410984"></p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> post;<span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">(<span class="type">int</span> post)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boosGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(boosGroup,workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="literal">true</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//获取到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                        <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                        <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                        <span class="comment">//加入自定义的业务处理handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatServerHandler</span>());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Netty服务器已经启动完毕！&quot;</span>);</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(post).sync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听关闭事件</span></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static List&lt;Channel&gt; channelList = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hashmap管理</span></span><br><span class="line"><span class="comment">//    public static Map&lt;String,Channel&gt; channels = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//    public static Map&lt;User,Channel&gt; channels2 = new HashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line"><span class="comment">     * 将当前channel加入到channelGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法会将channelGroup中所有channel遍历，并发送消息，我们不需要自己遍历</span></span><br><span class="line"><span class="comment">         * 因为是先发送再加入所以排除了新进来的自己</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;加入聊天室&quot;</span>+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        channels.put(&quot;id100&quot;,channel);</span></span><br><span class="line"><span class="comment">//          channels2.put(new User(10,&quot;小林&quot;),channel);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接，将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line">    <span class="comment">//不需要channelGroup.remove(channel);</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;离开聊天室&quot;</span>+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size=&quot;</span>+channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel处于活动状态，提示xx上线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;已上线~&quot;</span>+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel处于非活动状态，提示xx下线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;已离线~&quot;</span>+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup，根据不同的情况，回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel!=ch)&#123;<span class="comment">//不是当前channel，进行消息转发</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;发送消息：&quot;</span>+msg+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[您]发送了消息：&quot;</span>+msg+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host=host;</span><br><span class="line">        <span class="built_in">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//得到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">//加入相关handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//加入自定义handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>+channel.localAddress()+<span class="string">&quot;------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span>  <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280911560.png" alt="image-20230228091159459"></p>
<h3 id="12、Netty心跳检测机制案例"><a href="#12、Netty心跳检测机制案例" class="headerlink" title="12、Netty心跳检测机制案例"></a>12、Netty心跳检测机制案例</h3><p>实例要求: </p>
<ol>
<li>编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲 </li>
<li>当服务器超过5秒没有写操作时，就提示写空闲 </li>
<li>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</li>
</ol>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))<span class="comment">//在bossGroup增加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//获取pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//加入一个netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 说明</span></span><br><span class="line"><span class="comment">                             * 1、IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                             * 2、long readerIdleTime：表示多长时间没有读操作，就会发送一个心跳监测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 3、long writerIdleTime：表示多长时间没有写操作，就会发送一个心跳监测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 4、long allIdleTime：表示多长时间没有读和写操作，就会发送一个心跳监测包检测是否还是连接状态</span></span><br><span class="line"><span class="comment">                             * 5、文档说明：</span></span><br><span class="line"><span class="comment">                             * Triggers an IdleStateEvent when a Channel has not performed read, write,</span></span><br><span class="line"><span class="comment">                             * or both operation for a while</span></span><br><span class="line"><span class="comment">                             * 6、当IdleStateEvent被触发后，就会传递给管道的下一个handler去处理</span></span><br><span class="line"><span class="comment">                             * 通过调用（触发）下一个handler的userEventTiggered，在该方法中去处理IdleStateEvent（读空闲、写空闲、读写空闲）</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">//加入一个对空闲监测进一步处理的handler（自定义）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端初始化完成&quot;</span>);</span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息：&quot;</span>+msg);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;I am alive&quot;</span>.equals(msg)) &#123;</span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;ok&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将evt向下转型 IdleStateEvent</span></span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span>  ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;---超时事件---&quot;</span>+eventType);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器做相应处理.....&quot;</span>);</span><br><span class="line">            times++;</span><br><span class="line">            <span class="comment">//如果发生空闲次数过多，我们关闭通道</span></span><br><span class="line">            <span class="keyword">if</span> (times&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;空闲次数超过三次 关闭连接&quot;</span>);</span><br><span class="line">                ctx.writeAndFlush(<span class="string">&quot;you are out&quot;</span>);</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户端只需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">//    客户端启动的对象</span></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HreatbeatClientHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端初始化完成&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;I am alive&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (future.channel().isActive()) &#123;</span><br><span class="line">                <span class="comment">//模拟空闲状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);</span><br><span class="line">                Thread.sleep(num * <span class="number">1000</span>);</span><br><span class="line">                future.channel().writeAndFlush(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//future.channel().closeFuture().sync();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HreatbeatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server data:&quot;</span> + s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;you are out&quot;</span>.equals(s)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">                channelHandlerContext.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="13、Netty-通过WebSocket编程实现服务器和客户端长连接"><a href="#13、Netty-通过WebSocket编程实现服务器和客户端长连接" class="headerlink" title="13、Netty 通过WebSocket编程实现服务器和客户端长连接"></a>13、Netty 通过WebSocket编程实现服务器和客户端长连接</h3><p>实例要求: </p>
<ol>
<li>Http协议是无状态的, 浏览器和服务 器间的请求响应一次，下一次会重 新创建连接. </li>
<li>要求：实现基于webSocket的长连接 的全双工的交互 </li>
<li>改变Http协议多次请求的约束，实 现长连接了， 服务器可以发送消息 给浏览器 </li>
<li>客户端浏览器和服务器端会相互感 知，比如服务器关闭了，浏览器会 感知，同样浏览器关闭了，服务器 会感知</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302280913781.png" alt="image-20230228091337714"></p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.heartbeat.MyServerHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))<span class="comment">//在bossGroup增加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//获取pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">//因为基于http协议，使用http的编码和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                            <span class="comment">//是以块方式写的，添加ChunkedWrite处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 说明</span></span><br><span class="line"><span class="comment">                             * 1、http数据在传输过程中是分段的，HttpObjectAggregator就可以将多个段聚合起来</span></span><br><span class="line"><span class="comment">                             * 2、这就是为什么当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));</span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                             * 说明</span></span><br><span class="line"><span class="comment">                             * 1、对于websocket，它的数据是以帧（frame）的形式传递</span></span><br><span class="line"><span class="comment">                             * 2、可以看到WebSocketFrame下面有六个子类</span></span><br><span class="line"><span class="comment">                             * 3、浏览器发送请求时：ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                             * 4、WebSocketServerProtocolHandler核心功能是将http协议升级为ws协议，保持长链接</span></span><br><span class="line"><span class="comment">                             * 5、是通过一个 状态码101</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//自定义的handler，处理业务逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端初始化完成&quot;</span>);</span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame类型，表示一个文本帧（frame）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端收到消息:&quot;</span>+msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;服务器时间：&quot;</span>+ LocalDateTime.now()+<span class="string">&quot;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;,收到消息：&quot;</span>+msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当web客户端连接后，触发方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//id 表示唯一的标识，LongText是唯一的，shortText不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用了&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用了&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved被调用&quot;</span> + ctx.channel().id().asLongText() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生&quot;</span>+cause.getMessage());</span><br><span class="line">        ctx.close();<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="language-javascript">        socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7000/hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于channelRead0，ev收到服务器端回送的消息</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + ev.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接开启（感知到连接开启）</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span>= <span class="keyword">function</span> (<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = <span class="string">&quot;连接开启了...&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接关闭（感知到连接关闭）</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onclose</span>= <span class="keyword">function</span> (<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;连接关闭了...&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;当前浏览器不支持WebSocket&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送消息到服务器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">socket</span>)&#123;<span class="comment">//先判断socket是否创建好</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//通过socket发送消息</span></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="title function_">send</span>(message)</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;连接没有开启！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px;width: 300px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px;width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、Google-Protobuf"><a href="#七、Google-Protobuf" class="headerlink" title="七、Google Protobuf"></a>七、Google Protobuf</h2><h3 id="1、编码和解码的基本介绍"><a href="#1、编码和解码的基本介绍" class="headerlink" title="1、编码和解码的基本介绍"></a>1、编码和解码的基本介绍</h3><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送 数据时就需要编码，接收数据时就需要解码 [示意图] </li>
<li>codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。 encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成 业务数据</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511747.png" alt="image-20230228150935632"></p>
<h3 id="2、Netty-本身的编码解码的机制和问题分析"><a href="#2、Netty-本身的编码解码的机制和问题分析" class="headerlink" title="2、Netty 本身的编码解码的机制和问题分析"></a>2、Netty 本身的编码解码的机制和问题分析</h3><ol>
<li><p>Netty 自身提供了一些 codec(编解码器) </p>
</li>
<li><p>Netty 提供的编码器 </p>
<p>• StringEncoder，对字符串数据进行编码 </p>
<p>• ObjectEncoder，对 Java 对象进行编码 </p>
<p>• … </p>
</li>
<li><p>Netty 提供的解码器 </p>
<p>• StringDecoder, 对字符串数据进行解码 </p>
<p>• ObjectDecoder，对 Java 对象进行解码 </p>
<p>• …</p>
</li>
</ol>
<ol start="4">
<li><p>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象 的编码和解码，底层使用的仍是 Java 序列化技术 , 而Java 序列化技术本身效率就不高，存 在如下问题：</p>
<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的 5 倍多。 </li>
<li>序列化性能太低</li>
</ul>
<p>&#x3D;&gt;引出新的解决方案[Google的Protobuf]</p>
</li>
</ol>
<h3 id="3、Protobuf"><a href="#3、Protobuf" class="headerlink" title="3、Protobuf"></a>3、Protobuf</h3><h4 id="Protobuf基本介绍和使用示意图"><a href="#Protobuf基本介绍和使用示意图" class="headerlink" title="Protobuf基本介绍和使用示意图"></a>Protobuf基本介绍和使用示意图</h4><ol>
<li><p>Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高 效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做 数据存储或 <strong>RPC[远程过程调用 remote procedure call ] 数据交换格式</strong> 。 目前很多公司 http+json →tcp+protobuf </p>
</li>
<li><p>参考文档 : <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南 (翻墙)</p>
</li>
<li><p>Protobuf 是以 message 的方式来管理数据的. </p>
</li>
<li><p>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的] （支持目前绝 大多数语言，例如 C++、C#、Java、python 等</p>
</li>
<li><p>高性能，高可靠性 </p>
</li>
<li><p>使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描 述。说明，在idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮。 </p>
</li>
<li><p>然后通过 protoc.exe 编译器根据.proto 自动生成.java 文件 </p>
</li>
<li><p>protobuf 使用示意图：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511746.png" alt="image-20230228150645544"></p>
</li>
</ol>
<h4 id="Protobuf快速入门实例"><a href="#Protobuf快速入门实例" class="headerlink" title="Protobuf快速入门实例"></a>Protobuf快速入门实例</h4><p>编写程序，使用Protobuf完成如下功能 </p>
<ol>
<li>客户端可以发送一个Student PoJo 对象到服 务器 (通过 Protobuf 编码) </li>
<li>服务端能接收Student PoJo 对象，并显示信 息(通过 Protobuf 解码) </li>
<li>具体 看演示步骤</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281511748.png" alt="image-20230228151055659"></p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BOSSGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 说明</span></span><br><span class="line"><span class="comment">         * 1、创建了两个线程组boosGroup和workerGroup</span></span><br><span class="line"><span class="comment">         * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line"><span class="comment">         * 3、两个都是无限循环</span></span><br><span class="line"><span class="comment">         * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数</span></span><br><span class="line"><span class="comment">         * 默认是以cpu核数*2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioServerSocketChannel作为服务器的通道来实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">//设置线程队列等待连接的个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    <span class="comment">//.handler(null) //该handler对应boosGroup，childHandler对应workGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个初始化对象（匿名对象）</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtobufDecoder</span></span><br><span class="line">                            <span class="comment">//指定哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;Decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);  <span class="comment">//给我们的workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器is ready......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">//启动服务器了（绑定好端口了）</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf注册监听器，监控我们关心的事件</span></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cf.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承入栈的handler适配器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范）</span></span><br><span class="line"><span class="comment"> * 2、这是我们自定义一个Handler，才能成为一个Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;StudentPOJO.Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    *</span></span><br><span class="line"><span class="comment">//     * 读取数据事件（这里我们可以读取客户端发送过来的消息）</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     * @param ctx ：是上下文对象。含有管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">//     * @param msg ：就是客户端发送过来的数据，默认是Object</span></span><br><span class="line"><span class="comment">//     * @throws Exception</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //读取从客户端发送的StudentPOJO.Student</span></span><br><span class="line"><span class="comment">//        StudentPOJO.Student student = (StudentPOJO.Student) msg;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端发送的数据：id=&quot;+student.getId()+&quot;,名字=&quot;+student.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StudentPOJO.Student student)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的数据：id=&quot;</span>+student.getId()+<span class="string">&quot;,名字=&quot;</span>+student.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//writeAndFlush是write+flush</span></span><br><span class="line">        <span class="comment">//将数据写入缓冲区，并刷新</span></span><br><span class="line">        <span class="comment">//一般来讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootStrap而是Bootstrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//在pipeline中加入ProtoBufEncoder</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is ok ！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于ChannelFuture后面再分析，涉及到netty的异步模型</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发送一个Student对象到服务器</span></span><br><span class="line">        StudentPOJO.<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> StudentPOJO.Student.newBuilder().setId(<span class="number">4</span>).setName(<span class="string">&quot;李四&quot;</span>).build();</span><br><span class="line">        <span class="comment">//发送Teacher。Member......</span></span><br><span class="line">        ctx.writeAndFlush(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Student.proto:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;//版本</span><br><span class="line">option java_outer_classname = &quot;StudentPOJO&quot;;//生成的外部类名，同时也是文件名</span><br><span class="line">//protobuf是使用message管理数据</span><br><span class="line">message Student&#123;//会在StudentPOJO外部类生成一个内部类Student，他是真正发送的POJO对象</span><br><span class="line">  int32 id=1;//Student类中有一个属性 名字为id类型为int32（protobuf类型），1表示属性序号，不是值</span><br><span class="line">  string name = 2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为StudentPOJO.java</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303011514102.png" alt="image-20230301145715697"></p>
<h4 id="Protobuf快速入门实例2"><a href="#Protobuf快速入门实例2" class="headerlink" title="Protobuf快速入门实例2"></a>Protobuf快速入门实例2</h4><p>编写程序，使用Protobuf完成如下功能 </p>
<ol>
<li>客户端可以随机发送Student PoJo&#x2F; Worker PoJo 对 象到服务器 (通过 Protobuf 编码) </li>
<li>服务端能接收Student PoJo&#x2F; Worker PoJo 对象(需要 判断是哪种类型)，并显示信息(通过 Protobuf 解码) </li>
<li>具体 看演示步骤</li>
</ol>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BOSSGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 说明</span></span><br><span class="line"><span class="comment">         * 1、创建了两个线程组boosGroup和workerGroup</span></span><br><span class="line"><span class="comment">         * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line"><span class="comment">         * 3、两个都是无限循环</span></span><br><span class="line"><span class="comment">         * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数</span></span><br><span class="line"><span class="comment">         * 默认是以cpu核数*2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioServerSocketChannel作为服务器的通道来实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">//设置线程队列等待连接的个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    <span class="comment">//.handler(null) //该handler对应boosGroup，childHandler对应workGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个初始化对象（匿名对象）</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtobufDecoder</span></span><br><span class="line">                            <span class="comment">//指定哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;Decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);  <span class="comment">//给我们的workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器is ready......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">//启动服务器了（绑定好端口了）</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf注册监听器，监控我们关心的事件</span></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cf.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承入栈的handler适配器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范）</span></span><br><span class="line"><span class="comment"> * 2、这是我们自定义一个Handler，才能成为一个Handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MyDataInfo.MyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    *</span></span><br><span class="line"><span class="comment">//     * 读取数据事件（这里我们可以读取客户端发送过来的消息）</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     * @param ctx ：是上下文对象。含有管道pipeline，通道channel，地址</span></span><br><span class="line"><span class="comment">//     * @param msg ：就是客户端发送过来的数据，默认是Object</span></span><br><span class="line"><span class="comment">//     * @throws Exception</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //读取从客户端发送的StudentPOJO.Student</span></span><br><span class="line"><span class="comment">//        StudentPOJO.Student student = (StudentPOJO.Student) msg;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端发送的数据：id=&quot;+student.getId()+&quot;,名字=&quot;+student.getName());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//根据datatype来显示不同的信息</span></span><br><span class="line">        MyDataInfo.MyMessage.<span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span>(dataType== MyDataInfo.MyMessage.DataType.StudentType)&#123;</span><br><span class="line"></span><br><span class="line">            MyDataInfo.<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> msg.getStudent();</span><br><span class="line">            System.out.println(<span class="string">&quot;学生id为：&quot;</span>+student.getId()+<span class="string">&quot;，姓名为：&quot;</span>+student.getName());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dataType== MyDataInfo.MyMessage.DataType.workerType)&#123;</span><br><span class="line">            MyDataInfo.<span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> msg.getWorker();</span><br><span class="line">            System.out.println(<span class="string">&quot;工人年龄为：&quot;</span>+worker.getAge()+<span class="string">&quot;，姓名为：&quot;</span>+worker.getName());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传输的数据类型不正确，请检查！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//writeAndFlush是write+flush</span></span><br><span class="line">        <span class="comment">//将数据写入缓冲区，并刷新</span></span><br><span class="line">        <span class="comment">//一般来讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootStrap而是Bootstrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//在pipeline中加入ProtoBufEncoder</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is ok ！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于ChannelFuture后面再分析，涉及到netty的异步模型</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//随机发送一个Student或Worker对象到服务器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">        MyDataInfo.<span class="type">MyMessage</span> <span class="variable">myMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==random)&#123;<span class="comment">//发送Student对象</span></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder()</span><br><span class="line">                    .setId(<span class="number">5</span>).setName(<span class="string">&quot;王五&quot;</span>).build()).build();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//发送一个Worker对象</span></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.workerType).setWorker(MyDataInfo.Worker.newBuilder()</span><br><span class="line">                    .setAge(<span class="number">20</span>).setName(<span class="string">&quot;小林&quot;</span>).build()).build();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(myMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>proto文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">option optimize_for = SPEED;//加快解析</span><br><span class="line">option java_package=&quot;com.lxg.netty.codec2&quot;;//指定生成到哪个包下</span><br><span class="line">option java_outer_classname=&quot;MyDataInfo&quot;;//外部类名</span><br><span class="line"></span><br><span class="line">//Protobuf可以使用message管理其他的message</span><br><span class="line">message MyMessage&#123;</span><br><span class="line">  //定义一个枚举类型</span><br><span class="line">  enum DataType&#123;</span><br><span class="line">    StudentType=0;//在proto3要求enum的编号从0开始</span><br><span class="line">    workerType=1;</span><br><span class="line">  &#125;</span><br><span class="line">  //用data_type来标识传的是哪个枚举类型</span><br><span class="line">  DataType data_type = 1;</span><br><span class="line"></span><br><span class="line">  //标识每次枚举类型最多只能出现其中的一个，节省空间</span><br><span class="line">  oneof dataBody&#123;</span><br><span class="line">    Student student = 2;</span><br><span class="line">    Worker worker = 3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Student&#123;</span><br><span class="line">  int32 id=1;//Student类的属性</span><br><span class="line">  string name=2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Worker&#123;</span><br><span class="line">  string name=1;</span><br><span class="line">  int32 age=2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="八、Netty编解码器和handler的调用机制"><a href="#八、Netty编解码器和handler的调用机制" class="headerlink" title="八、Netty编解码器和handler的调用机制"></a>八、Netty编解码器和handler的调用机制</h2><h3 id="1、基本说明"><a href="#1、基本说明" class="headerlink" title="1、基本说明"></a>1、基本说明</h3><ol>
<li><p>netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、 ChannelHandler、ChannelPipe等 </p>
</li>
<li><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。例如，实 现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就 可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响 应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或 者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不 过它是用来处理出站数据的</p>
</li>
<li><p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如 果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即 客户端发送给服务端的数据会通过pipeline中的一系列 ChannelOutboundHandler，并被这些Handler处理，反之则称为入站的</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281513405.png" alt="image-20230228151325335"></p>
</li>
</ol>
<h3 id="2、编码解码器"><a href="#2、编码解码器" class="headerlink" title="2、编码解码器"></a>2、编码解码器</h3><ol>
<li>当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会 被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会 被编码成字节。 </li>
<li>Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHadnler或者 ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。 以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后， 它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发 给ChannelPipeline中的下一个ChannelInboundHandler。</li>
</ol>
<h3 id="3、解码器-ByteToMessageDecoder"><a href="#3、解码器-ByteToMessageDecoder" class="headerlink" title="3、解码器-ByteToMessageDecoder"></a>3、解码器-ByteToMessageDecoder</h3><ol>
<li><p>关系继承图 </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517146.png" alt="image-20230228151713056"></p>
</li>
<li><p>由于不可能知道远程节点是否会 一次性发送一个完整的信息， tcp有可能出现粘包拆包的问题， 这个类会对入站数据进行缓冲， 直到它准备好被处理</p>
</li>
<li><p>一个关于ByteToMessageDecoder实例分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">out.add(in.readInt());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) 这个例子，每次入站从ByteBuf中读取<span class="number">4</span>字节，将其解码为一个<span class="type">int</span>，然后将它添加到下一个List中。</span><br><span class="line">当没有更多元素可以被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。</span><br><span class="line"><span class="type">int</span>在被添加到List中时，会被自动装箱为Integer。在调用readInt()方法前必须验证所输入的ByteBuf是</span><br><span class="line">否具有足够的数据</span><br><span class="line"><span class="number">2</span>) decode 执行分析图 [示意图]</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517527.png" alt="image-20230228151738418"></p>
</li>
</ol>
<h3 id="4、Netty的handler链的调用机制"><a href="#4、Netty的handler链的调用机制" class="headerlink" title="4、Netty的handler链的调用机制"></a>4、Netty的handler链的调用机制</h3><p>实例要求: </p>
<ol>
<li><p>使用自定义的编码器和解码器来 说明Netty的handler 调用机制 </p>
<p>客户端发送long -&gt; 服务器 服务端发送long -&gt; 客户端 </p>
</li>
<li><p>案例演示 </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281517959.png" alt="image-20230228151757830"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012005169.png" alt="image-20230301195441077"></p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boosGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boosGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">MyServerInitializer</span>());<span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端Initializer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//入站的handler进行解码MyByteToLongDecoder</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyByteToLongDecoder</span>());</span><br><span class="line">        <span class="comment">//出站的handler进行编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyLongToByteEncoder</span>());</span><br><span class="line">        <span class="comment">//加入自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端：&quot;</span>+ctx.channel().remoteAddress()+<span class="string">&quot;读取到long&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端发送一个long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Decoder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * decode会根据接收到的数据，被调用多次，直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * 或者是ByteBuf没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out不为空，就会将list的内容传递给下一个channelinboundhandler处理</span></span><br><span class="line"><span class="comment">     * 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx：上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> byteBuf：入站的ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list：list集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder中的decode被调用了！&quot;</span>);</span><br><span class="line">        <span class="comment">//因为long8个字节,需要判断有8个字节才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(byteBuf.readableBytes()&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">            list.add(byteBuf.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Encoder:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="comment">//编码方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyLongToByteEncoder中encode被调用了！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;msg=&quot;</span>+msg);</span><br><span class="line">        byteBuf.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">MyClientInitializer</span>());<span class="comment">//自定义初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端Initializer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//加入出站的handler对数据进行一个编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyLongToByteEncoder</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是入站的解码器（入站handler）</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyByteToLongDecoder</span>());</span><br><span class="line">        <span class="comment">//加入自定义的handler，处理业务</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, Long msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的ip=&quot;</span>+channelHandlerContext.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器的消息是=&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive发送数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler发送数据&quot;</span>);</span><br><span class="line"><span class="comment">//        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;&quot;));</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">123456L</span>);<span class="comment">//发送的是一个long</span></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1、&quot;abcdabcdabcdacbd&quot;是16个字节</span></span><br><span class="line">        <span class="comment">//2、该处理器的前一个handler是MyLongToByteEncoder</span></span><br><span class="line">        <span class="comment">//3、MyLongToByteEncoder父类MessageToByteEncoder会判断当前msg是不是应该处理的类型</span></span><br><span class="line">        <span class="comment">//如果是就处理，不是就跳过</span></span><br><span class="line">        <span class="comment">//4、因此我们在编写Encoder时要注意传入的数据类型和处理的数据类型一致</span></span><br><span class="line"><span class="comment">//        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;abcdabcdasdfasdf&quot;, CharsetUtil.UTF_8));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>结论： </p>
<ul>
<li>不论解码器handler 还是 编码器handler 即接 收的消息类型必须与待处理的消息类型一致， 否则该handler不会被执行 </li>
<li>在解码器 进行数据解码时，需要判断 缓存 区(ByteBuf)的数据是否足够 ，否则接收到的结果和期望结果可能不一致</li>
</ul>
</li>
</ol>
<h3 id="5、解码器-ReplayingDecoder"><a href="#5、解码器-ReplayingDecoder" class="headerlink" title="5、解码器-ReplayingDecoder"></a>5、解码器-ReplayingDecoder</h3><ol>
<li><p>public abstract class ReplayingDecoder extends ByteToMessageDecoder </p>
</li>
<li><p>ReplayingDecoder扩展了ByteToMessageDecoder类，使用这个类，我们不必调用 readableBytes()方法。参数S指定了用户状态管理的类型，其中Void代表不需要状态 管理 </p>
</li>
<li><p>应用实例：使用ReplayingDecoder 编写解码器，对前面的案例进行简化 [案例演示]</p>
</li>
</ol>
<ol start="4">
<li><p>ReplayingDecoder使用方便，但它也有一些局限性： </p>
<ul>
<li>并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException。 </li>
<li>ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格 式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder2中的decode被调用了！&quot;</span>);</span><br><span class="line">        <span class="comment">//在ReplayingDecoder中不需要判断数据是否足够读取，内部会进行处理判断</span></span><br><span class="line">        list.add(byteBuf.readLong());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6、其它编解码器"><a href="#6、其它编解码器" class="headerlink" title="6、其它编解码器"></a>6、其它编解码器</h3><p>其它解码器</p>
<ol>
<li>LineBasedFrameDecoder：这个类在Netty内 部也有使用，它使用行尾控制字符（\n或者\r\n） 作为分隔符来解析数据。 </li>
<li>DelimiterBasedFrameDecoder：使用自定义 的特殊字符作为消息的分隔符。 </li>
<li>HttpObjectDecoder：一个HTTP数据的解码器 </li>
<li>LengthFieldBasedFrameDecoder：通过指定 长度来标识整包消息，这样就可以自动的处理 黏包和半包消息。</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281520613.png" alt="image-20230228152033499"></p>
<h3 id="7、Log4j-整合到Netty"><a href="#7、Log4j-整合到Netty" class="headerlink" title="7、Log4j 整合到Netty"></a>7、Log4j 整合到Netty</h3><ol>
<li><p>在Maven 中添加对Log4j的依赖 在 pom.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Log4j , 在 resources&#x2F;log4j.propertie</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG,stdout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%p] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>演示整合</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202302281524162.png" alt="image-20230228152445966"></p>
</li>
</ol>
<h2 id="九、TCP粘包和拆包-及解决方案"><a href="#九、TCP粘包和拆包-及解决方案" class="headerlink" title="九、TCP粘包和拆包 及解决方案"></a>九、TCP粘包和拆包 及解决方案</h2><h3 id="1、TCP-粘包和拆包基本介绍"><a href="#1、TCP-粘包和拆包基本介绍" class="headerlink" title="1、TCP 粘包和拆包基本介绍"></a>1、TCP 粘包和拆包基本介绍</h3><ol>
<li>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端） 都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发 给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合 并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于 分辨出完整的数据包了，因为面向流的通信是无消息保护边界的 </li>
<li>由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘 包、拆包问题, 看一张图</li>
<li>示意图TCP粘包、拆包图解</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012202253.png" alt="image-20230301220244154"></p>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</span><br><span class="line">1) 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</span><br><span class="line">2) 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包</span><br><span class="line">3) 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包</span><br><span class="line">4) 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</span><br></pre></td></tr></table></figure>

<h3 id="2、TCP-粘包和拆包现象实例"><a href="#2、TCP-粘包和拆包现象实例" class="headerlink" title="2、TCP 粘包和拆包现象实例"></a>2、TCP 粘包和拆包现象实例</h3><p>在编写Netty 程序时，如果没有做处理，就会发生粘包和拆包的问题 </p>
<p>看一个具体的实例：</p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boosGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boosGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">MyServerInitializer</span>());<span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端Initializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line">        <span class="comment">//将buffer转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端接收到数据&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息量=&quot;</span>+(++<span class="built_in">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器回送数据给客户端,回送一个随机id</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">responseByteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(UUID.randomUUID().toString()+<span class="string">&quot;、&quot;</span>, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        ctx.writeAndFlush(responseByteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">MyClientInitializer</span>());<span class="comment">//自定义初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端Initializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 hello，server</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            ctx.writeAndFlush(byteBuf);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息=&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息数量=&quot;</span>+(++<span class="built_in">this</span>.count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、TCP-粘包和拆包解决方案"><a href="#3、TCP-粘包和拆包解决方案" class="headerlink" title="3、TCP 粘包和拆包解决方案"></a>3、TCP 粘包和拆包解决方案</h3><ol>
<li><p>使用自定义协议 + 编解码器 来解决 </p>
</li>
<li><p>关键就是要解决 服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服 务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</p>
</li>
</ol>
<p>看一个具体的实例: </p>
<ol>
<li>要求客户端发送 5 个 Message 对象, 客户端每次发送一个 Message 对象 </li>
<li>服务器端每次接收一个Message, 分5次进行解码， 每读取到 一个Message , 会回 复一个Message 对象 给客户端</li>
<li>代码演示</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012205652.png" alt="image-20230301220513560"></p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boosGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boosGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">MyServerInitializer</span>());<span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端Initializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyMessageDecoder</span>());<span class="comment">//解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyMessageEncoder</span>());<span class="comment">//编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理业务的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageProtocol&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//接收到数据，并处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> msg.getLen();</span><br><span class="line">        <span class="type">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接收到信息如下：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span>+len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(content,Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息包数量=&quot;</span>+(++<span class="built_in">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">responseContent</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">byte</span>[] responseContent2 = responseContent.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">responseLen</span> <span class="operator">=</span> responseContent2.length;</span><br><span class="line">        <span class="comment">//构建一个协议包</span></span><br><span class="line">        <span class="type">MessageProtocol</span> <span class="variable">messageProtocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProtocol</span>();</span><br><span class="line">        messageProtocol.setLen(responseLen);</span><br><span class="line">        messageProtocol.setContent(responseContent2);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(messageProtocol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">MyClientInitializer</span>());<span class="comment">//自定义初始化类</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端Initializer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> socketChannel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyMessageEncoder</span>());<span class="comment">//加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyMessageDecoder</span>());<span class="comment">//解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;MessageProtocol&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 今天天气真不错！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="string">&quot;今天天气真不错！&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] content = mes.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> content.length;</span><br><span class="line">            <span class="comment">//创建协议包对象</span></span><br><span class="line">            <span class="type">MessageProtocol</span> <span class="variable">messageProtocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProtocol</span>();</span><br><span class="line">            messageProtocol.setLen(len);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> msg.getLen();</span><br><span class="line">        <span class="type">byte</span>[] content = msg.getContent();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息如下：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span>+len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(content,Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到的消息数量=&quot;</span>+(++<span class="built_in">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常消息=&quot;</span>+cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>协议包类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//协议包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLen</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(<span class="type">byte</span>[] content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageDecoder decode被调用了！&quot;</span>);</span><br><span class="line">        <span class="comment">//需要将得到的二进制字节码转换为MessageProtocol数据包（对象）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] content = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成MessageProtocol对象，放入out，传递给下一个handler业务处理</span></span><br><span class="line">        <span class="type">MessageProtocol</span> <span class="variable">messageProtocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageProtocol</span>();</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line"></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;MessageProtocol&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder encode 方法被调用了！&quot;</span>);</span><br><span class="line">        out.writeInt(messageProtocol.getLen());</span><br><span class="line">        out.writeBytes(messageProtocol.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="十、Netty核心源码剖析"><a href="#十、Netty核心源码剖析" class="headerlink" title="十、Netty核心源码剖析"></a>十、Netty核心源码剖析</h2><h3 id="1、基本说明-1"><a href="#1、基本说明-1" class="headerlink" title="1、基本说明"></a>1、基本说明</h3><ol>
<li>只有看过Netty源码，才能说是真的掌握了Netty框 架。 </li>
<li>在 io.netty.example 包下，有很多Netty源码案例， 可以用来分析 </li>
<li>源码分析章节 是针对有Java项目经验，并且玩过 框架源码的人员讲的，否则你听起来会有相当的难度。</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012206340.png" alt="image-20230301220635258"></p>
<h3 id="2、Netty-启动过程源码剖析"><a href="#2、Netty-启动过程源码剖析" class="headerlink" title="2、Netty 启动过程源码剖析"></a>2、Netty 启动过程源码剖析</h3><h4 id="源码剖析目的"><a href="#源码剖析目的" class="headerlink" title="源码剖析目的"></a><strong>源码剖析目的</strong></h4><p>用源码分析的方式走一下 Netty （服务器）的启动过程，更好的理解Netty 的整体 设计和运行机制。</p>
<h4 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明： </p>
<ol>
<li>源码需要剖析到Netty 调用doBind方法， 追踪到NioServerSocketChannel的doBind </li>
<li>并且要Debug 程序到 NioEventLoop类 的run代码 ，无限循环，在服务器端运行</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012208931.png" alt="image-20230301220801863"></p>
<h4 id="源码剖析过程"><a href="#源码剖析过程" class="headerlink" title="源码剖析过程"></a>源码剖析过程</h4><p>1、demo源码的基本理解</p>
<p>服务器启动类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2012 The Netty Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Netty Project licenses this file to you under the Apache License,</span></span><br><span class="line"><span class="comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment"> * with the License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span></span><br><span class="line"><span class="comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class="line"><span class="comment"> * License for the specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment"> * under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.lxg.netty.source.echo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.source.util.ServerUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.ssl.SslContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SslContext</span> <span class="variable">sslCtx</span> <span class="operator">=</span> ServerUtil.buildSslContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EchoServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="literal">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1)先看启动类：main方法中，首先创建了关于SSL的配置类。</span><br><span class="line">2)重点分析下创建了两个EventLoopGroup对象：</span><br><span class="line">EventLoopGroup bossGroup new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup new NioEventLoopGroupO;</span><br><span class="line">(I)这两个对象是整个Nety的核心对象，可以说，整个Nety的运作都依赖于他们。bossGroup用于接受Tcp请求，他会将请求交给workerGroup，workerGroup会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</span><br><span class="line">(2)EventLoopGroup是事件循环组（线程组）含有多个EventLoop,可以注册channel,用于在事件循不中去进行选择（和选择器相关）.[debug看]</span><br><span class="line">(3)new NioEventLoopGroup(1);这个1表示bossGroup事件组有1个线程你可以指定，如果new NioEventLoopGroup()会含有默认个线程cpu核数*2，即可以充分的利用多核的优势，【可以dubug一把】</span><br><span class="line">DEFAULT_EVENT_LOOP_THREADS Math.max(1,SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;,NettyRuntime.availableProcessors()*2));</span><br><span class="line">会创建EventExecutor数组children=new EventExecutor[nThreads];/debug一下</span><br><span class="line">每个元素的类型就是NIOEventLoop,.NIOEventLoop实现了EventLoop接口和Executor接口 </span><br><span class="line">try块中创建了一个ServerBootstrap对象，他是一个引导类，用于启动服务器和引导整个稈序的初始化.（看下源码allows easy bootstrap of&#123;@link ServerChannel&#125;)。它和ServerChannel关联，而ServerChannel继承了Channel,.有一些方法remoteAddress等[可以Debug下]</span><br><span class="line">随后，变量b调用了group方法将两个group放入了自己的字段中，用于后期引导使用【dbug下group方法*</span><br><span class="line">Set the @link EventLoopGroup for the parent (acceptor)and the child (client).These</span><br><span class="line">*&#123;@link EventLoopGroup)&#x27;s are used to handle all the events and IO for &#123;@link ServerChannel&#125;and</span><br><span class="line">@link Channel&#x27;s.</span><br><span class="line">*/】。</span><br><span class="line">(4)然后添加了一个channel,其中参数一个Class对象，引导类将通过这个Class对象反射创建ChannelFactory。然后添加了一些TCP的参数。[说明：Channel的创建在bind方法，可以Debug下bind,会找channel channelFactory.newChannelO);</span><br><span class="line">(5)再添加了一个服务器专属的日志处理器handler.</span><br><span class="line">(6再添加一个SocketChannel(不是ServerSocketChannel)的handler。.</span><br><span class="line">(7)然后绑定端口并阻塞至连接成功。</span><br><span class="line">(8)最后main线程阻塞等待关闭.</span><br><span class="line">(9)finally块中的代码将在服务器关闭时优雅关闭所有资源</span><br></pre></td></tr></table></figure>

<p>服务器处理器类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2012 The Netty Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Netty Project licenses this file to you under the Apache License,</span></span><br><span class="line"><span class="comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment"> * with the License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span></span><br><span class="line"><span class="comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class="line"><span class="comment"> * License for the specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment"> * under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.lxg.netty.source.echo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler.Sharable;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler implementation for the echo server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1)这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</span><br><span class="line">2)大致讲解了我们的demo源码的作用。后面的debug的时候会详细</span><br></pre></td></tr></table></figure>

<p>2、分析EventLoopGroup的过程</p>
<p>构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(nThreads, (Executor)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的this(nThreads, (Executor)null);调用构造器（通过alt+d看即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>this(nThreads, executor, SelectorProvider.provider());又调用下面构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, SelectorProvider selectorProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);又调用如下构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, SelectorProvider selectorProvider, SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nThreads, executor, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>super(nThreads, executor, new Object[]{selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()});方法的父类是MultithreadEventLoopGroup，构造器为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>追踪到源码，真正的构造器是MultithreadEventExecutorGroup类的</p>
<p>分析如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nThreads:使用的线程数，默认是core*2</span></span><br><span class="line"><span class="comment">* executor：执行器，如果传入null，则采用Netty默认的线程工厂和默认的执行器ThreadPerTaskExecutor</span></span><br><span class="line"><span class="comment">* chooserFactory：单例 new DefaultEventExecutorChooseFactory()</span></span><br><span class="line"><span class="comment">* args:args在创建执行器时传入的固定参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">        checkPositive(nThreads, <span class="string">&quot;nThreads&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123; <span class="comment">//如果传入的执行器为空，采用默认的线程工厂和默认的执行器</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//创建指定线程数的执行器数组</span></span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line">		<span class="comment">//初始化线程数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建new NioEventLoop</span></span><br><span class="line">                children[i] = newChild(executor, args);</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//如果创建失败，优雅关闭</span></span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                        children[j].shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                        <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                            <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                    terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//为每一个单例线程池添加一个关闭监听器</span></span><br><span class="line">        <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">            e.terminationFuture().addListener(terminationListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    	<span class="comment">//将所有的单例线程池添加到一个HashSet中</span></span><br><span class="line">        Collections.addAll(childrenSet, children);</span><br><span class="line">        readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">l)如果executor是null,创建一个默认的ThreadPerTaskExecutor,使用Netty默认的线程工厂。</span><br><span class="line">2)根据传入的线程数(CPU*2)创建一个线程池（单例线程池）数组。</span><br><span class="line">3)循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</span><br><span class="line">4)根据线程选择工厂创建一个线程选择器。</span><br><span class="line">5)为每一个单例线程池添加一个关闭监听器。</span><br><span class="line">6将所有的单例线程池添加到一个HashSet中。</span><br></pre></td></tr></table></figure>

<p>3、ServerBootstrap创建和构造过程</p>
<p>ServerBootstrap是个空构造器，但是有默认的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">logger</span> <span class="operator">=</span> InternalLoggerFactory.getInstance(ServerBootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The order in which child ChannelOptions are applied is important they may depend on each other for validation</span></span><br><span class="line">    <span class="comment">// purposes.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line"><span class="comment">//config对象，会在后面起很大作用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServerBootstrapConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrapConfig</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br></pre></td></tr></table></figure>

<p>分析一下ServerBootstrap的基本使用情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="literal">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1)链式调用：group方法，将boss和worker传入，boss赋值给parentGroup属性，worker赋值给childGroup属性</span><br><span class="line">2)channel方法传入NioServerSocketChannel class对象。会根据这个class创建channel对象。</span><br><span class="line">3)option方法传入TCP参数，放在一个LinkedHashMap中。</span><br><span class="line">4)handler方法传入一个handler中，这个hanlder只专属于ServerSocketChannel而不是SocketChannel</span><br><span class="line">S)childHandler传入一个hanlder,这个handler将会在每个客户端连接的时候调用。供SocketChannel使用</span><br></pre></td></tr></table></figure>

<p>4、绑定端口的分析</p>
<p>服务器就是在这个bind方法里启动完成的<br>bind方法代码，追踪到创建了一个端口对象，并做了一些空判断，核心代码doBind,我们看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress)</span> &#123;</span><br><span class="line">        validate();</span><br><span class="line">        <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>doBind源码剖析，核心是两个方法initAndRegister和doBind0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">            <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析说明initAndRegister</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//说明：channelFactory.newChannel();方法的作用通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel。追踪源码可以得到下面结论</span></span><br><span class="line">            </span><br><span class="line">            (<span class="number">1</span>)通过NIO的SelectorProvider的openServerSocketChannel方法得到JDK的channel。目</span><br><span class="line">的是让Netty包装JDK的channel。</span><br><span class="line">(<span class="number">2</span>)创建了一个唯一的Channelld,创建了一个NioMessageUnsafe,用于操作消息，创建了一</span><br><span class="line">个DefaultChannelPipeline管道，是个双向链表结构，用于过滤所有的进出的消息。</span><br><span class="line">(<span class="number">3</span>)创建了一个NioServerSocketChannelConfig对象，用于对外展示一些配置。</span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//说明：init初始化这个NioServerSocketChannel具体追踪源码可以得到如下结论</span></span><br><span class="line">            </span><br><span class="line">            (I)init方法，这是个抽象方法(AbstractBootstrap类的)，由ServerBootstrap实现（可以追一下源码∥setChannelOptions(channel,options,logger);)。</span><br><span class="line">(<span class="number">2</span>)设置NioServerSocketChannel的TCP属性。</span><br><span class="line">(<span class="number">3</span>)由于LinkedHashMap是非线程安全的，使用同步进行处理。</span><br><span class="line">(<span class="number">4</span>)对NioServerSocketChannel的ChannelPipeline添加ChannelInitializer处理器。</span><br><span class="line">(<span class="number">5</span>)可以看出，init的方法的核心作用在和ChannelPipeline相关。</span><br><span class="line">(<span class="number">6</span>)从NioServerSocketChannel的初始化过程中，我们知道，pipeline是一个双向链表，并且，他本身就初始化了head和tail,这里调用了他的addLast方法，也就是将整个handler插入到tail的前面，因为tail永远会在后面，需要做一些系统的固定工作。</span><br><span class="line">                </span><br><span class="line">                  </span><br><span class="line">            init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">                <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span></span><br><span class="line">        <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">        <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">        <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">        <span class="comment">//    added to the event loop&#x27;s task queue for later execution.</span></span><br><span class="line">        <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span></span><br><span class="line">        <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">        <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">l)基本说明：initAndRegister()初始化NioServerSocketChannel通道并注册各个handler,返回一个future</span><br><span class="line">2)通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel。</span><br><span class="line">3)init初始化这个NioServerSocketChannel.</span><br><span class="line">4)config().group().register(channel)通过ServerBootstrap的bossGroup注册NioServerSocketChannel.</span><br><span class="line">5)最后，返回这个异步执行的占位符即regFuture。</span><br></pre></td></tr></table></figure>

<p>init方法会调用addLast，现在进入addLast方法内查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">            addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">l)addLast方法，在DefaultChannelPipeline类中</span><br><span class="line">2)addLast方法这就是pipeline方法的核心</span><br><span class="line">3)检杳该handler是否符合标准。</span><br><span class="line">4)创建一个AbstractChannelHandlerContext对象，这里说一下，ChannelHandlerContext对象是</span><br><span class="line">ChannelHandler和ChannelPipeline之间的关联，每当有ChannelHandler添加到Pipeline中时，都会创建Context,.Context的主要功能是管理他所关联的Handler和同一个Pipeline中的其他Handler之间的交互。</span><br><span class="line">S)将Contexl添加到链表中。也就是追加到tail节点的前面。</span><br><span class="line">6)最后，同步或者异步或者晚点异步的调用callHandlerAdded0方法</span><br></pre></td></tr></table></figure>

<p>前面说了dobind方法有两个重要的步骤，initAndRegister说完了，现在看看doBind0方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line">        <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line">        channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(regFuture.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1、该方法的参数为initAndRegister的future,NioServerSocketChannel,端口地址，NioServerSocketChannel promise</span><br></pre></td></tr></table></figure>

<p>2、这里就可以根据前面的断点，一直debug</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">将调用LoggingHandler的invokeBind方法，最后会追到</span><br><span class="line"><span class="comment">//DefaultChannelPipeline类的bind</span></span><br><span class="line"><span class="comment">//然后进入到unsafe.bind方法debug,注意要追踪到</span></span><br><span class="line">    <span class="comment">//unsafe.bind,要debug第二圈的时候，才能看到</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ChannelHandlerContext ctx,SocketAddress localAddress,ChannelPromise promise)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">unsafe.bind(localAddress,promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">继续追踪AbstractChannel的</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress,<span class="keyword">final</span> ChannelPromise promise)</span>&#123;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">//!小红旗可以看到，这里最终的方法就是doBind方法，执行成功后，执行通道的fireChannelActive方法，告诉所有的handler,已经成功绑定。</span></span><br><span class="line">doBind(localAddress);<span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;&#125;</span><br><span class="line">safeSetFailure(promise,t);</span><br><span class="line">closeIfClosed();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>)最终doBind就会追踪到NioServerSocketChannel的doBind,说明Netty底层使用的是Nio</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress localAddress)</span><span class="keyword">throws</span> Exception</span><br><span class="line"><span class="title function_">if</span> <span class="params">(PlatformDependent.java Version()</span>&gt;=<span class="number">7</span>)&#123;</span><br><span class="line">javaChannel(.bind(localAddress,config.getBacklog();</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">javaChannel().socket().bind(localAddress,config.getBacklog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到bind方法(alt+v),最后一步：safeSetSuccess(promise),告诉promise任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，0k了</p>
<p>继续atl+V服务器就回进入到(NioEventLoop类)一个循环代码，进行监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Netty启动过程梳理"><a href="#Netty启动过程梳理" class="headerlink" title="Netty启动过程梳理"></a>Netty启动过程梳理</h4><ol>
<li>创建2个 EventLoopGroup 线程池数组。数组默认大小CPU*2，方便chooser选择 线程池时提高性能 </li>
<li>BootStrap 将 boss 设置为 group属性，将 worker 设置为 childer 属性 </li>
<li>通过 bind 方法启动，内部重要方法为 initAndRegister 和 dobind 方法 </li>
<li>initAndRegister 方法会反射创建 NioServerSocketChannel 及其相关的 NIO 的对象， pipeline ， unsafe，同时也为 pipeline 初始了 head 节点和 tail 节点。 </li>
<li>在register0 方法成功以后调用在 dobind 方法中调用 doBind0 方法，该方法会 调 用 NioServerSocketChannel 的 doBind 方法对 JDK 的 channel 和端口进行绑定， 完成 Netty 服务器的所有启动，并开始监听连接事件</li>
</ol>
<h3 id="3、Netty-接受请求过程源码剖析"><a href="#3、Netty-接受请求过程源码剖析" class="headerlink" title="3、Netty 接受请求过程源码剖析"></a>3、Netty 接受请求过程源码剖析</h3><h4 id="源码剖析目的-1"><a href="#源码剖析目的-1" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><ol>
<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分 析 Netty 在启动之后是如何接受客户端请求的 </li>
<li>在 io.netty.example 包</li>
</ol>
<h4 id="源码剖析-1"><a href="#源码剖析-1" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明： </p>
<ol>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 Accept 事件等待 客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线 程池（reactor 线程）上，也就是 EventLoop 。 </li>
<li>先简单说下EventLoop的逻辑(后面我们详细讲解EventLoop) ü EventLoop 的作用是一个死循环，而这个循环中做3件事情：<ul>
<li>有条件的等待 Nio 事件。 </li>
<li>处理 Nio 事件。 </li>
<li>处理消息队列中的任务。</li>
</ul>
</li>
<li>仍用前面的项目来分析：进入到 NioEventLoop 源码中后，在private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) 方法开始调试</li>
<li>最终我们要分析到AbstractNioChannel 的 doBeginRead 方法， 当到这个方法时， 针对于这个客户端的连接就完成了，接下来就可以监听读事件</li>
</ol>
<p>源码分析过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>断点位置NioEventLoop的如下方法processSelectedKey</span><br><span class="line">    </span><br><span class="line"><span class="title function_">if</span><span class="params">((readyOps &amp;(SelectionKey.OP READ | SelectionKey.OP ACCEPT)</span>)!=<span class="number">0</span> readyOps ==<span class="number">0</span>)&#123;</span><br><span class="line">unsafe.read();/断点位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>执行浏览器http:<span class="comment">//localhost::8007/客户端发出请求</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>从的断点我们可以看到，readyOps是<span class="number">16</span>，也就是Accept事件。说明浏览器的请求已经进来了。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>这个unsafe是boss线程中NioServerSocketChannel的AbstractNioMessageChannelSNioMessageUnsafe对象。</span><br><span class="line">我们进入到AbstractNioMessageChannelSNioMessageUnsafe的read方法中</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>read方法代码并分析：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span></span><br><span class="line"><span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop();</span><br><span class="line"><span class="keyword">final</span> ChannelConfig config=config();</span><br><span class="line"><span class="keyword">final</span> ChannelPipeline pipeline=pipeline();</span><br><span class="line"><span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle <span class="title function_">unsafe</span><span class="params">()</span>.recvBufAllocHandle();</span><br><span class="line">allocHandle.reset(config);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">localRead</span> <span class="operator">=</span> doReadMessages(readBuf);</span><br><span class="line">			<span class="keyword">if</span> (localRead ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (localRead &lt;<span class="number">0</span>)</span><br><span class="line">                closed = <span class="literal">true</span>;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">            allocHandle.incMessagesRead(localRead);</span><br><span class="line">        &#125;<span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            exception = t;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readBuf.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i+)&#123;</span><br><span class="line">                readPending = <span class="literal">false</span>;</span><br><span class="line">                pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">                readBuf.clear();</span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();</span><br><span class="line">                <span class="keyword">if</span> (exception !=<span class="literal">null</span>)&#123;</span><br><span class="line">                    closed = closeOnReadError(exception);</span><br><span class="line">                   pipeline.fireExceptionCaught(exception);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(closed)&#123;</span><br><span class="line">                    inputShutdown = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isOpen())&#123;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;<span class="keyword">finally</span></span><br><span class="line">                  <span class="comment">//Check if there is a readPending which was not processed yet.</span></span><br><span class="line">                 <span class="comment">//This could be for two reasons:</span></span><br><span class="line">                 <span class="comment">//The user called Channel.readO or ChannelHandlerContext.read()in channelRead(...)method</span></span><br><span class="line">                <span class="comment">//The user called Channel.read()or ChannelHandlerContext.read()in channelReadComplete(...)method</span></span><br><span class="line">                              <span class="comment">//</span></span><br><span class="line">               <span class="comment">//See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">               <span class="keyword">if</span> (!readPending &amp;&amp;!config.isAutoRead())&#123;</span><br><span class="line">                                  removeReadOp();</span><br><span class="line">               &#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	<span class="number">1</span>)检查该eventloop线程是否是当前线程。<span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop()</span><br><span class="line">    <span class="number">2</span>)执行doReadMessages方法，并传入一个readBuf变量，这个变量是一个List,也就是容器。</span><br><span class="line">    <span class="number">3</span>)循环容器，执行pipeline.fireChannelRead(readBuf..get(①)；                     <span class="number">4</span>)doReadMessages是读取boss线程中的NioServerSocketChannel接受到的请求。并把这些请求放进容器,一会我们debug下doReadMessages方法</span><br><span class="line">    <span class="number">5</span>)循环遍历容器中的所有请求，调用pipeline的fireChannelRead方法，用于处理这些接受的请求或者其他事件，在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的</span><br><span class="line">handler的ChannelRead方法(debug进入)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>追踪一下doReadMessages方法，就可以看得更清晰</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doReadMessages</span><span class="params">(List&lt;Object&gt;buf)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	SocketChannel ch SocketUtils.accept(javaChannelO);</span><br><span class="line">	buf.add(<span class="keyword">new</span> <span class="title class_">NioSocketChannel</span>(<span class="built_in">this</span>,ch));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">l)通过工具类，调用NioServerSocketChannel内部封装的serverSocketChannel的accept方法，这是Nio做法。</span><br><span class="line"><span class="number">2</span>)获取到一个JDK的SocketChannel,然后，使用NioSocketChannel进行封装。最后添加到容器中</span><br><span class="line"><span class="number">3</span>)这样容器buf中就有了NioSocketChannel[如果有兴趣可以追一下NioSocketChannel是如何创建的，我就不追了]</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>回到read方法，继续分析循环执行pipeline.fireChannelRead方法</span><br><span class="line"></span><br><span class="line">l)前面分析doReadMessages方法的作用是通过ServerSocket的accept方法获取到Tcp连接，然后封装成Netty的NioSocketChannel对象。最后添加到容器中</span><br><span class="line"><span class="number">2</span>)在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的handler的ChannelRead方法(debug进入)</span><br><span class="line"><span class="number">3</span>)经过dubug(多次)，可以看到会反复执行多个handler的ChannelRead,我们知道，pipeline里面有<span class="number">4</span>个handler ，分别是Head,LoggingHandler,ServerBootstrapAcceptor,Tail.</span><br><span class="line"><span class="number">4</span>)我们重点看看ServerBootstrapAcceptor。debug之后，断点会进入到ServerBootstrapAcceptor中来。我们来看看ServerBootstrapAcceptor的channelRead方法（要多次debug才可以）</span><br><span class="line"><span class="number">5</span>)channelRead方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span>(Channel)msg;</span><br><span class="line">	child.pipeline().addLast(childHandler);</span><br><span class="line">	setChannelOptions(child,childOptions,logger);</span><br><span class="line">	<span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;,Object&gt;e:childAttrs)&#123;	   child.attr((AttributeKey&lt;Object)e.getKey().set(e.getValue());</span><br><span class="line">ty&#123;<span class="comment">//将客户端连接注册到worker线程池</span></span><br><span class="line">	childGroup.register(child).addListener(<span class="keyword">new</span> 		<span class="title class_">ChannelFutureListener</span>()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">			<span class="keyword">if</span>(!future.isSuccess()&#123;</span><br><span class="line">				forceClose(child,future.cause();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">	forceClose(child,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">	l)msg强转成Channel,实际上就是NioSocketChannel。</span><br><span class="line">	<span class="number">2</span>)添加NioSocketChannel的pipeline的handler,就是我们main方法里面设置的childHandler方法里的。</span><br><span class="line">	<span class="number">3</span>)设置NioSocketChannel的各种属性。</span><br><span class="line">	<span class="number">4</span>)将该NioSocketChannel注册到childGroup中的一个EventLoop上，并添加一个监听器。</span><br><span class="line">	<span class="number">5</span>)这个childGroup就是我们main方法创建的数组workerGroup.</span><br></pre></td></tr></table></figure>

<p>8、进入register方法查看（步步追踪到）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop,<span class="keyword">final</span> ChannelPromise promise)</span></span><br><span class="line">AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"><span class="keyword">if</span> (eventLoop.inEventLoop())&#123;</span><br><span class="line">register0(promise);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">register0(promise),<span class="comment">//进入到这里</span></span><br><span class="line">			&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">继续进入到下面方法，执行管道中可能存在的任务、这里我们就不追了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9.</span>最终会调用doBeginRead方法，也就是AbstractNioChannel类的方法</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//Channel.read()or ChannelHandlerContext.read()was called</span></span><br><span class="line">	<span class="keyword">final</span> SelectionKey selectionKey <span class="built_in">this</span>.selectionKey;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (!selectionKey.is <span class="title function_">Valid</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	readPending = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">	<span class="keyword">if</span> ((interestOps &amp; readInterestOp)==<span class="number">0</span>)&#123;</span><br><span class="line">		selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在doBeginRead(需要先放过该断点，然</span><br><span class="line">后浏览器请求，才能看到效果)</span><br><span class="line">11.执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</span><br></pre></td></tr></table></figure>



<h4 id="Netty接受请求过程梳理"><a href="#Netty接受请求过程梳理" class="headerlink" title="Netty接受请求过程梳理"></a>Netty接受请求过程梳理</h4><p>总体流程：接受连接—–&gt;创建一个新的NioSocketChannel———–&gt;注册到一个 worker EventLoop 上——–&gt; 注册selecot Read 事件。 </p>
<ol>
<li>服务器轮询 Accept 事件，获取事件后调用 unsafe 的 read 方法，这个 unsafe 是 ServerSocket 的内部类，该方 法内部由2部分组成 </li>
<li>doReadMessages 用于创建 NioSocketChannel 对象，该对象包装 JDK 的 Nio Channel 客户端。该方法会像创建 ServerSocketChanel 类似创建相关的 pipeline ， unsafe，config </li>
<li>随后执行 执行 pipeline.fireChannelRead 方法，并将自己绑定到一个 chooser 选择器选择的 workerGroup 中的 一个 EventLoop。并且注册一个0，表示注册成功，但并没有注册读（1）事件</li>
</ol>
<h3 id="4、Pipeline-Handler-HandlerContext创建源码剖析"><a href="#4、Pipeline-Handler-HandlerContext创建源码剖析" class="headerlink" title="4、Pipeline Handler HandlerContext创建源码剖析"></a>4、Pipeline Handler HandlerContext创建源码剖析</h3><h4 id="源码剖析目的-2"><a href="#源码剖析目的-2" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><p>Netty 中的 ChannelPipeline 、 ChannelHandler 和 ChannelHandlerContext 是非常 核心的组件, 我们从源码来分析Netty 是如何设计这三个核心组件的，并分析是如何创建 和协调工作的.</p>
<h4 id="源码剖析-2"><a href="#源码剖析-2" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明 ：</p>
<p>分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p>
<p>源码剖析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. ChannelPipeline | ChannelHandler | ChannelHandlerContext 介绍</span><br><span class="line">1.1 三者关系</span><br><span class="line">1) 每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。</span><br><span class="line">2) 每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline）</span><br><span class="line">3) 每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context）</span><br><span class="line">4) 他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称</span><br><span class="line">handler）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041358021.png" alt="image-20230304135843837"></p>
<ol>
<li>上图中：ChannelSocket 和 ChannelPipeline  是一对一的关联关系，而 pipeline  内部的多个 Context  形成了链  表，Context 只是对  Handler 的封装。</li>
</ol>
<ol start="2">
<li>当一个请求进来的时候，会进入  Socket 对应的  pipeline，并经过  pipeline 所有的  handler，对，就是设计模式  中的过滤器模式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.2 ChannelPipeline 作用及设计</span><br><span class="line">1) pipeline 的接口设计</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041359814.png" alt="image-20230304135932740"></p>
<p>部分源码：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041400840.png" alt="image-20230304140010711"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表， 看看他的几个代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，类似是一个 LinkedList。同时，也能返回 channel（也就是 socket）</span><br><span class="line">1) 在 pipeline 的接口文档上，提供了一幅图</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041400443.png" alt="image-20230304140037268"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对上图的解释说明：</span><br><span class="line">* 这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户控制事件如何处理以及 handler 在 pipeline 中如何交互。</span><br><span class="line">* 上图描述了一个典型的 handler 在 pipeline 中处理 I/O 事件的方式，IO 事件由 inboundHandler 或者outBoundHandler 处理，并通过调用 ChannelHandlerContext.fireChannelRead 方法转发给其最近的处理程序 </span><br><span class="line">* 入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 I / O 线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer) 获取。</span><br><span class="line">* 通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序</span><br><span class="line">协议解码器 - 将二进制数据转换为 Java 对象。</span><br><span class="line">协议编码器 - 将 Java 对象转换为二进制数据。</span><br><span class="line">业务逻辑处理程序 - 执行实际业务逻辑（例如数据库访问）</span><br><span class="line"></span><br><span class="line">* 你的业务程序不能将线程阻塞，会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如：</span><br><span class="line">// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池</span><br><span class="line">pipeline.addLast（group，“handler”，new MyBusinessLogicHandler（））;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.3 ChannelHandler 作用及设计</span><br><span class="line">1) 源码</span><br><span class="line">public interface ChannelHandler &#123;</span><br><span class="line"></span><br><span class="line">//当把 ChannelHandler 添加到 pipeline 时被调用</span><br><span class="line">void handlerAdded(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line"></span><br><span class="line">//当从 pipeline 中移除时调用</span><br><span class="line">void handlerRemoved(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line">// 当处理过程中在 pipeline 发生异常时调用</span><br><span class="line">@Deprecated</span><br><span class="line">void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2) ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。</span><br><span class="line">Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承</span><br><span class="line">ChannelHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ChannelInboundHandler 入站事件接口</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041401141.png" alt="image-20230304140144040"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* channelActive 用于当 Channel 处于活动状态时被调用；</span><br><span class="line">* channelRead 当从 Channel 读取数据时被调用等等方法。</span><br><span class="line">* 程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty 会</span><br><span class="line">回调对应的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ChannelOutboundHandler  出站事件接口  </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041402715.png" alt="image-20230304140217616"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* bind 方法，当请求将 Channel 绑定到本地地址时调用</span><br><span class="line">* close 方法，当请求关闭 Channel 时调用等等</span><br><span class="line">* 出站操作都是一些连接和写出数据类似的方法。</span><br></pre></td></tr></table></figure>

<p>ChannelDuplexHandler 处理出站和入站事件</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041402224.png" alt="image-20230304140248112"></p>
<ul>
<li>ChannelDuplexHandler  间接实现了入站接口并直接实现了出站接口。  </li>
<li>是一个通用的能够同时处理入站事件和出站事件的类。</li>
</ul>
<p>1.4 ChannelHandlerContext 作用及设计</p>
<ol>
<li>ChannelHandlerContext UML 图</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041403864.png" alt="image-20230304140321793"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandlerContext 继承了出站方法调用接口和入站方法调用接口</span><br><span class="line">1) ChannelOutboundInvoker 和 ChannelInboundInvoker 部分源码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041403348.png" alt="image-20230304140346245"></p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041404095.png" alt="image-20230304140422929"></p>
<ul>
<li>这两个 invoker  就是针对入站或出站方法来的，就是在 入站或出站  handler 的外层再包装一层，达到在方法前</li>
</ul>
<p>  后拦截并做一些特定操作的目的  </p>
<p>ChannelHandlerContext 部分源码</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303041404584.png" alt="image-20230304140439455"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* ChannelHandlerContext 不仅仅继承了他们两个的方法，同时也定义了一些自己的方法</span><br><span class="line">* 这些方法能够获取 Context 上下文环境中对应的比如 channel，executor，handler ，pipeline，内存分配器，关</span><br><span class="line">联的 handler 是否被删除。</span><br><span class="line">* Context 就是包装了 handler 相关的一切，以方便 Context 可以在 pipeline 方便的操作 handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> ChannelPipeline | ChannelHandler | ChannelHandlerContext 创建过程</span><br><span class="line">分为 <span class="number">3</span> 个步骤来看创建的过程：</span><br><span class="line">* 任何一个 ChannelSocket 创建的同时都会创建 一个 pipeline。</span><br><span class="line">* 当用户或系统内部调用 pipeline 的 add*** 方法添加 handler 时，都会创建一个包装这 handler 的 Context。</span><br><span class="line">* 这些 Context 在 pipeline 中组成了双向链表。</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span> Socket 创建的时候创建 pipeline</span><br><span class="line">在 SocketChannel 的抽象父类 AbstractChannel 的构造方法中</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parent = parent; <span class="comment">//断点测试</span></span><br><span class="line">id = newId();</span><br><span class="line">unsafe = newUnsafe();</span><br><span class="line">pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Debug 一下, 可以看到代码会执行到这里, 然后继续追踪到</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">voidPromise = <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line">tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>）将 channel 赋值给 channel 字段，用于 pipeline 操作 channel。</span><br><span class="line"><span class="number">2</span>）创建一个 future 和 promise，用于异步回调使用。</span><br><span class="line"><span class="number">3</span>）创建一个 inbound 的 tailContext，创建一个既是 inbound 类型又是 outbound 类型的 headContext.</span><br><span class="line"><span class="number">4</span>）最后，将两个 Context 互相连接，形成双向链表。</span><br><span class="line"><span class="number">5</span>）tailContext 和 HeadContext 非常的重要，所有 pipeline 中的事件都会流经他们，</span><br><span class="line">    </span><br><span class="line"><span class="number">2.2</span> 在 add** 添加处理器的时候创建 Context**</span><br><span class="line">看下 DefaultChannelPipeline 的 addLast 方法如何创建的 Context，代码如下</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (handlers == <span class="literal">null</span>) &#123; <span class="comment">//断点</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;handlers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">addLast(executor, <span class="literal">null</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">继续 Debug</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">checkMultiplicity(handler);</span><br><span class="line">newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">addLast0(newCtx);</span><br><span class="line"><span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line"><span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line"><span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line"><span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">newCtx.setAddPending();</span><br><span class="line">callHandlerCallbackLater(newCtx, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> newCtx.executor();</span><br><span class="line"><span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">newCtx.setAddPending();</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">callHandlerAdded0(newCtx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">callHandlerAdded0(newCtx);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line"><span class="number">1</span>) pipeline 添加 handler，参数是线程池，name 是 <span class="literal">null</span>， handler 是我们或者系统传入的 handler。Netty 为了防止</span><br><span class="line">多个线程导致安全问题，同步了这段代码，步骤如下：</span><br><span class="line"><span class="number">2</span>) 检查这个 handler 实例是否是共享的，如果不是，并且已经被别的 pipeline 使用了，则抛出异常。</span><br><span class="line"><span class="number">3</span>) 调用 newContext(group, filterName(name, handler), handler) 方法，创建一个 Context。从这里可以看出来了，</span><br><span class="line">每次添加一个 handler 都会创建一个关联 Context。</span><br><span class="line"><span class="number">4</span>) 调用 addLast 方法，将 Context 追加到链表中。</span><br><span class="line"><span class="number">5</span>) 如果这个通道还没有注册到 selecor 上，就将这个 Context 添加到这个 pipeline 的待办任务中。当注册好了以</span><br><span class="line">后，就会调用 callHandlerAdded0 方法（默认是什么都不做，用户可以实现这个方法）。</span><br><span class="line"><span class="number">6</span>) 到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 ChannelSocket 的时候都会创建</span><br><span class="line">一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成最初的链表。tail</span><br><span class="line">是入站 inbound 类型的 handler， head 既是 inbound 也是 outbound 类型的 handler。在调用 pipeline 的 addLast</span><br><span class="line">方法的时候，会根据给定的 handler 创建一个 Context，然后，将这个 Context 插入到链表的尾端（tail 前面）。</span><br><span class="line">到此就 OK 了</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Pipeline-Handler-HandlerContext创建过程梳理"><a href="#Pipeline-Handler-HandlerContext创建过程梳理" class="headerlink" title="Pipeline Handler HandlerContext创建过程梳理"></a>Pipeline Handler HandlerContext创建过程梳理</h4><ol>
<li>每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成最初的链表。 </li>
<li>在调用 pipeline 的 addLast 方法的时候，会根据给定的 handler 创建一个 Context， 然后，将这个 Context 插入到链表的尾端（tail 前面）。 </li>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表 </li>
<li>入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开</li>
</ol>
<h3 id="5、ChannelPipeline-调度-handler-的源码剖析"><a href="#5、ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="5、ChannelPipeline 调度 handler 的源码剖析"></a>5、ChannelPipeline 调度 handler 的源码剖析</h3><h4 id="源码剖析目的-3"><a href="#源码剖析目的-3" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><ol>
<li>当一个请求进来的时候，ChannelPipeline 是如何调用内部的这些 handler 的呢？ 我们一起来分析下。 </li>
<li>首先，当一个请求进来的时候，会第一个调用 pipeline 的 相关方法，如果是入站 事件，这些方法由 fire 开头，表示开始管道的流动。让后面的 handler 继续处理</li>
</ol>
<h4 id="源码剖析-3"><a href="#源码剖析-3" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明 ：</p>
<ol>
<li><p>当浏览器输入 <a href="http://localhost:8007。可以看到会执行handler">http://localhost:8007。可以看到会执行handler</a> </p>
</li>
<li><p>在Debug时，可以将断点下在 DefaultChannelPipeline 类的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelActive</span><span class="params">()</span> &#123; AbstractChannelHandlerContext.invokeChannelActive(head);<span class="comment">//断点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">3. DefaultChannelPipeline 是如何实现这些 fire 方法的</span><br><span class="line"></span><br><span class="line">3.1 DefaultChannelPipeline 源码</span><br><span class="line"></span><br><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireChannelActive() &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireChannelInactive() &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeChannelInactive(head);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireExceptionCaught(Throwable cause) &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireUserEventTriggered(Object event) &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireChannelRead(Object msg) &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireChannelReadComplete() &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeChannelReadComplete(head);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline fireChannelWritabilityChanged() &#123;</span><br><span class="line">AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">可以看出来，这些方法都是 inbound 的方法，也就是入站事件，调用静态方法传入的也是 inbound 的类型 head</span><br><span class="line">handler。这些静态方法则会调用 head 的 ChannelInboundInvoker 接口的方法，再然后调用 handler 的真正方法</span><br><span class="line"></span><br><span class="line">3.2 再看下 piepline 的 outbound 的 fire 方法实现</span><br><span class="line">源码</span><br><span class="line"></span><br><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">return tail.bind(localAddress);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture connect(SocketAddress remoteAddress) &#123;</span><br><span class="line">return tail.connect(remoteAddress);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) &#123;</span><br><span class="line">return tail.connect(remoteAddress, localAddress);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture disconnect() &#123;</span><br><span class="line">return tail.disconnect();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture close() &#123;</span><br><span class="line">return tail.close();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture deregister() &#123;</span><br><span class="line">return tail.deregister();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelPipeline flush() &#123;</span><br><span class="line">tail.flush();</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">return tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">return tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture connect(</span><br><span class="line">SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">return tail.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final ChannelFuture disconnect(ChannelPromise promise) &#123;</span><br><span class="line">return tail.disconnect(promise);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1) 这些都是出站的实现，但是调用的是 outbound 类型的 tail handler 来进行处理，因为这些都是 outbound 事</span><br><span class="line">件。</span><br><span class="line">2) 出站是 tail 开始，入站从 head 开始。因为出站是从内部向外面写，从 tail 开始，能够让前面的 handler 进</span><br><span class="line">行处理，防止 handler 被遗漏，比如编码。反之，入站当然是从 head 往内部输入，让后面的 handler 能够处理这</span><br><span class="line">些输入的数据。比如解码。因此虽然 head 也实现了 outbound 接口，但不是从 head 开始执行出站任务</span><br><span class="line">4. 关于如何调度，用一张图来表示:</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050932443.png" alt="image-20230305093242263"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1) pipeline 首先会调用 Context 的静态方法 fireXXX，并传入 Context</span><br><span class="line">2) 然后，静态方法调用 Context 的 invoker 方法，而 invoker 方法内部会调用该 Context 所包含的</span><br><span class="line">Handler 的真正的 XXX 方法，调用结束后，如果还需要继续向后传递，就调用 Context 的 fireXXX2 方法，循环</span><br><span class="line">往复。</span><br></pre></td></tr></table></figure>



<h4 id="ChannelPipeline-调度-handler-梳理"><a href="#ChannelPipeline-调度-handler-梳理" class="headerlink" title="ChannelPipeline 调度 handler 梳理"></a>ChannelPipeline 调度 handler 梳理</h4><ol>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始。 </li>
<li>而节点中间的传递通过 AbstractChannelHandlerContext 类内部的 fire 系列方法，找 到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对handler 的调度</li>
</ol>
<h3 id="6、Netty-心跳-heartbeat-服务源码剖析"><a href="#6、Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="6、Netty 心跳(heartbeat)服务源码剖析"></a>6、Netty 心跳(heartbeat)服务源码剖析</h3><h4 id="源码剖析目的-4"><a href="#源码剖析目的-4" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><p>Netty 作为一个网络框架，提供了诸多功能，比如编码解码等，Netty 还提供了非常重 要的一个服务—–心跳机制heartbeat。通过心跳检查对方是否有效，这是 RPC 框架 中是必不可少的功能。下面我们分析一下Netty内部 心跳服务源码实现</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012215841.png" alt="image-20230301221512771"></p>
<h4 id="源码剖析-4"><a href="#源码剖析-4" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明： </p>
<ol>
<li><p>Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 三 个Handler 检测连接的有效性，重点分析 IdleStateHandler .</p>
</li>
<li><p>如图</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012215207.png" alt="image-20230301221550133"></p>
</li>
</ol>
<p>源码剖析：</p>
<ol start="5">
<li>Netty  提供的心跳介绍</li>
</ol>
<ol>
<li><p>Netty 提供了  IdleStateHandler  ，ReadTimeoutHandler，WriteTimeoutHandler  三个 Handler  检测连接的有效性。  </p>
</li>
<li><p>如图</p>
<p>  <img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050950234.png" alt="image-20230305095027126"></p>
</li>
<li><p>ReadTimeout 事件和  WriteTimeout  事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以</p>
</li>
</ol>
<p>   下，我们重点看 IdleStateHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span> IdleStateHandler 分析</span><br><span class="line"><span class="number">6.1</span> <span class="number">4</span> 个属性</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> observeOutput; <span class="comment">//是否考虑出站时较慢的情况。默认值是 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> readerIdleTimeNanos;<span class="comment">//读事件空闲时间，0 则禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> writerIdleTimeNanos;<span class="comment">//写事件空闲时间，0 则禁用事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> allIdleTimeNanos;<span class="comment">//读或写空闲时间，0 则禁用事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6.2</span> handlerAdded 方法</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="comment">// channelActive() event has been fired already, which means this.channelActive() will</span></span><br><span class="line">            <span class="comment">// not be invoked. We have to initialize here instead.</span></span><br><span class="line">            initialize(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// channelActive() event has not been fired yet.  this.channelActive() will be invoked</span></span><br><span class="line">            <span class="comment">// and initialization will occur there.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">当该 handler 被添加到 pipeline 中时，则调用 initialize 方法</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line"><span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line"><span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">state = <span class="number">1</span>;</span><br><span class="line">initOutputChanged(ctx);</span><br><span class="line">lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class="line"><span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span></span><br><span class="line">readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">ReaderIdleTimeoutTask</span>(ctx),</span><br><span class="line">readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">WriterIdleTimeoutTask</span>(ctx),</span><br><span class="line">writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">allIdleTimeout = schedule(ctx, <span class="keyword">new</span> <span class="title class_">AllIdleTimeoutTask</span>(ctx),</span><br><span class="line">allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">只要给定的参数大于 <span class="number">0</span>，就创建一个定时任务，每个事件都创建。同时，将 state 状态设置为 <span class="number">1</span>，防止重复初始化。</span><br><span class="line">调用 initOutputChanged 方法，初始化 “监控出站数据属性”。</span><br></pre></td></tr></table></figure>

<p>  6.3 该类内部的 3 个定时任务类  </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303050951476.png" alt="image-20230305095152401"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 这 <span class="number">3</span> 个定时任务分别对应 读，写，读或者写 事件。共有一个父类(AbstractIdleTask)。这个父类提供了一</span><br><span class="line">个模板方法</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbstractIdleTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelHandlerContext ctx;</span><br><span class="line">AbstractIdleTask(ChannelHandlerContext ctx) &#123;</span><br><span class="line"><span class="built_in">this</span>.ctx = ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!ctx.channel().isOpen()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">run(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ChannelHandlerContext ctx)</span>;</span><br><span class="line">&#125;</span><br><span class="line">说明： 当通道关闭了，就不执行任务了。反之，执行子类的 run 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7.</span> 读事件的 run 方法（即 ReaderIdleTimeoutTask 的 run 方法）分析</span><br><span class="line"><span class="number">1</span>) 代码及其说明</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">nextDelay</span> <span class="operator">=</span> readerIdleTimeNanos;<span class="comment">//读操作超时时间</span></span><br><span class="line"><span class="keyword">if</span> (!reading) &#123; <span class="comment">//当前是否在读操作</span></span><br><span class="line">    <span class="comment">//不是</span></span><br><span class="line">    <span class="comment">//计算设置的超时时间-距离上次读操作时间间隔</span></span><br><span class="line">nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//计算结果小于0，说明已经超时</span></span><br><span class="line"><span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line"><span class="comment">// 用于取消任务 promise</span></span><br><span class="line">readerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> firstReaderIdleEvent;</span><br><span class="line">firstReaderIdleEvent = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//再次提交任务</span></span><br><span class="line"><span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line"><span class="comment">//触发用户 handler use</span></span><br><span class="line">channelIdle(ctx, event);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">ctx.fireExceptionCaught(t);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//计算结果大于0，说明没超时</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">readerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) 得到用户设置的超时时间。</span><br><span class="line"><span class="number">2</span>) 如果读取操作结束了（执行了 channelReadComplete 方法设置） ，就用当前时间减去给定时间和最后一次读（执操作的时间行了 channelReadComplete 方法设置），如果小于 <span class="number">0</span>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</span><br><span class="line"><span class="number">3</span>) 触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 promise 对象，用于做取消操作。然后，设置 first 属性为 <span class="literal">false</span> ，表示，下一次读取不再是第一次了，这个属性在 channelRead 方法会被改成 <span class="literal">true</span>。</span><br><span class="line"><span class="number">4</span>) 创建一个 IdleStateEvent 类型的写事件对象，将此对象传递给用户的 UserEventTriggered 方法。完成触</span><br><span class="line">发事件的操作。</span><br><span class="line"><span class="number">5</span>) 总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 UserEventTriggered 方法。<span class="comment">//前面介绍 IdleStateHandler 说过,</span></span><br><span class="line">可以看一下</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8.</span> 写事件的 run 方法(即 WriterIdleTimeoutTask 的 run 方法)分析</span><br><span class="line"><span class="number">1</span>) run 代码和分析</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">lastWriteTime</span> <span class="operator">=</span> IdleStateHandler.<span class="built_in">this</span>.lastWriteTime;</span><br><span class="line"><span class="type">long</span> <span class="variable">nextDelay</span> <span class="operator">=</span> writerIdleTimeNanos - (ticksInNanos() - lastWriteTime);</span><br><span class="line"><span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Writer is idle - set a new timeout and notify the callback.</span></span><br><span class="line">writerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> firstWriterIdleEvent;</span><br><span class="line">firstWriterIdleEvent = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasOutputChanged(ctx, first)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> newIdleStateEvent(IdleState.WRITER_IDLE, first);</span><br><span class="line">channelIdle(ctx, event);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">ctx.fireExceptionCaught(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Write occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">writerIdleTimeout = schedule(ctx, <span class="built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">写任务的 run 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对 出站较慢数据的判断</span><br><span class="line">hasOutputChanged</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9.</span> 所有事件的 run 方法(即 AllIdleTimeoutTask 的 run 方法)分析</span><br><span class="line">代码分析</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">nextDelay</span> <span class="operator">=</span> allIdleTimeNanos;</span><br><span class="line"><span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Both reader and writer are idle - set a new timeout and</span></span><br><span class="line"><span class="comment">// notify the callback.</span></span><br><span class="line">allIdleTimeout = schedule(ctx, <span class="built_in">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> firstAllIdleEvent;</span><br><span class="line">firstAllIdleEvent = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (hasOutputChanged(ctx, first)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> newIdleStateEvent(IdleState.ALL_IDLE, first);</span><br><span class="line">channelIdle(ctx, event);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">ctx.fireExceptionCaught(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Either read or write occurred before the timeout - set a new</span></span><br><span class="line"><span class="comment">// timeout with shorter delay.</span></span><br><span class="line">allIdleTimeout = schedule(ctx, <span class="built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) 表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</span><br><span class="line"><span class="number">2</span>) 需要大家注意的地方是</span><br><span class="line"><span class="type">long</span> <span class="variable">nextDelay</span> <span class="operator">=</span> allIdleTimeNanos;</span><br><span class="line"><span class="keyword">if</span> (!reading) &#123;</span><br><span class="line"><span class="comment">// 当前时间减去 最后一次写或读 的时间 ，若大于 0，说明超时了</span></span><br><span class="line">nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>) 这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10. 小结 Netty 的心跳机制</span><br><span class="line">1) IdleStateHandler 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 handler 的 userEventTriggered 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关</span><br><span class="line">闭连接。</span><br><span class="line">2) IdleStateHandler 的实现基于 EventLoop 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</span><br><span class="line">3) 内部有 3 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</span><br><span class="line">4) 同时，IdleStateHandler 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。Netty 通过构造方法中的 observeOutput 属性来决定是否对出站缓冲区的情况进行判断。</span><br><span class="line">5) 如果出站缓慢，Netty 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 OOM , OOM 比空闲的问题更大。</span><br><span class="line">6) 所以，当你的应用出现了内存溢出，OOM 之类，并且写空闲极少发生（使用了 observeOutput 为 true），那么就需要注意是不是数据出站速度过慢。</span><br><span class="line">7) 还有一个注意的地方：就是 ReadTimeoutHandler ，它继承自 IdleStateHandler，当触发读空闲事件的时候，就触发 ctx.fireExceptionCaught 方法，并传入一个 ReadTimeoutException，然后关闭 Socket。</span><br><span class="line">8) 而 WriteTimeoutHandler 的实现不是基于IdleStateHandler 的，他的原理是，当调用 write 方法的时候，会创建一个定时任务，任务内容是根据传入的 promise 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 promise 的 isDone 方法返回 false，表明还没有写完，说明超时了，则抛出异常。当 write方法完成后，会打断定时任务。</span><br></pre></td></tr></table></figure>

<h3 id="7、Netty-核心组件-EventLoop-源码剖析"><a href="#7、Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="7、Netty 核心组件 EventLoop 源码剖析"></a>7、Netty 核心组件 EventLoop 源码剖析</h3><h4 id="源码剖析目的-5"><a href="#源码剖析目的-5" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><p>Echo第一行代码就是 ：EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1); </p>
<p>下面分析其最核心的组件 EventLoop。</p>
<h4 id="源码剖析-5"><a href="#源码剖析-5" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>源码剖析：</p>
<ol>
<li>EventLoop 介绍<br>1.1 首先看看 NioEventLoop 的继承图</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051110412.png" alt="image-20230305111016235"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明重点：</span><br><span class="line">1) ScheduledExecutorService 接口表示是一个定时任务接口，EventLoop 可以接受定时任务。</span><br><span class="line">2) EventLoop 接口：Netty 接口文档说明该接口作用：一旦 Channel 注册了，就处理该 Channel 对应的所有I/O 操作。</span><br><span class="line">3) SingleThreadEventExecutor 表示这是一个单个线程的线程池</span><br><span class="line">4) EventLoop 是一个单例的线程池，里面含有一个死循环的线程不断的做着 3 件事情：监听端口，处理端口事件，处理队列事件。每个 EventLoop 都可以绑定多个 Channel，而每个 Channel 始终只能由一个 EventLoop 来处理</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>NioEventLoop  的使用 - execute 方法  </p>
<p>2.1 execute 源码剖析</p>
</li>
</ol>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051111021.png" alt="image-20230305111104870"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在EventLoop 的 使 用 ， 一 般 就 是</span><br><span class="line">SingleThreadEventExecutor 类中)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line"><span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">addTask(task);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">startThread();</span><br><span class="line">addTask(task);</span><br><span class="line"><span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">reject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">wakeup(inEventLoop);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明:</span><br><span class="line"><span class="number">1</span>) 首先判断该 EventLoop 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试</span><br><span class="line">启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</span><br><span class="line"><span class="number">2</span>) 如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</span><br><span class="line"><span class="number">3</span>) 如果 addTaskWakesUp 是 <span class="literal">false</span>，并且任务不是 NonWakeupRunnable 类型的，就尝试唤醒 selector。这</span><br><span class="line">个时候，阻塞在 selecor 的线程就会立即返回</span><br><span class="line"><span class="number">4</span>) 可以下断点来追踪</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.2</span> 我们 debug addTask 和 offerTask 方法源码</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">reject(task);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">offerTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">reject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> NioEventLoop 的父类 SingleThreadEventExecutor 的 startThread 方法</span><br><span class="line"><span class="number">3.1</span> 当执行 execute 方法的时候，如果当前线程不是 EventLoop 所属线程，则尝试启动线程，也就是 startThread 方</span><br><span class="line">法，dubug 代码如下：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line"><span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doStartThread();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">STATE_UPDATER.set(<span class="built_in">this</span>, ST_NOT_STARTED);</span><br><span class="line">PlatformDependent.throwException(cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明:</span><br><span class="line">该方法首先判断是否启动过了，保证 EventLoop 只有一个线程，如果没有启动过，则尝试使用 compareAndSet 将 state 状态改为 ST_STARTED，也就是已启动。然后调用 doStartThread 方法。如果失败，则进行回滚</span><br><span class="line">看下 doStartThread 方法</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">updateLastExecutionTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">success = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">oldState</span> <span class="operator">=</span> state;</span><br><span class="line"><span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">SingleThreadEventExecutor.<span class="built_in">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cleanup();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">STATE_UPDATER.set(SingleThreadEventExecutor.<span class="built_in">this</span>, ST_TERMINATED);</span><br><span class="line">threadLock.release();</span><br><span class="line">terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) 首先调用 executor 的 execute 方法，这个 executor 就是在创建 Event LoopGroup 的时候创建的</span><br><span class="line">ThreadPerTaskExecutor 类。该 execute 方法会将 Runnable 包装成 Netty 的 FastThreadLocalThread。</span><br><span class="line"><span class="number">2</span>) 任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</span><br><span class="line"><span class="number">3</span>) 执行当前 NioEventLoop 的 run 方法，注意：这个方法是个死循环，是整个 EventLoop 的核心</span><br><span class="line"><span class="number">4</span>) 在 <span class="keyword">finally</span> 块中，使用 CAS 不断修改 state 状态，改成 ST_SHUTTING_DOWN。也就是当线程 Loop 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <span class="keyword">break</span>。然后，执行 cleanup 操作，更新状</span><br><span class="line">态为</span><br><span class="line"><span class="number">5</span>) ST_TERMINATED，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。</span><br><span class="line">并回调 terminationFuture 方法。</span><br><span class="line"><span class="number">6</span>) 其实最核心的就是 Event Loop 自身的 run 方法。再继续深入 run 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> EventLoop 中的 Loop 是靠 run 实现的, 我们分析下 </span><br><span class="line"></span><br><span class="line">run 方法(该方法在 NioEventLoop)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line"><span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">select(wakenUp.getAndSet(<span class="literal">false</span>));</span><br><span class="line"><span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">selector.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">cancelledKeys = <span class="number">0</span>;</span><br><span class="line">needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line"><span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processSelectedKeys();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">runAllTasks();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processSelectedKeys();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Ensure we always run tasks.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">handleLoopException(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">closeAll();</span><br><span class="line"><span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">handleLoopException(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明:</span><br><span class="line"><span class="number">1</span>) 从上面的步骤可以看出，整个 run 方法做了 <span class="number">3</span> 件事情：</span><br><span class="line"> select 获取感兴趣的事件。</span><br><span class="line"> processSelectedKeys 处理事件。</span><br><span class="line"> runAllTasks 执行队列中的任务。</span><br><span class="line"><span class="number">2</span>) 上面的三个方法，我们就追一下 select 方法(体现非阻塞)</span><br><span class="line">核心 select 方法解析</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(<span class="type">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.selector;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">currentTimeNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">long</span> <span class="variable">selectDeadLineNanos</span> <span class="operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line"><span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">selector.selectNow();</span><br><span class="line">selectCnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span></span><br><span class="line"><span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class="line"><span class="comment">// If we don&#x27;t, the task might be pended until select operation was timed out.</span></span><br><span class="line"><span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span></span><br><span class="line"><span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">selector.selectNow();</span><br><span class="line">selectCnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.select(timeoutMillis);<span class="comment">//否则阻塞给定时间，默认一秒</span></span><br><span class="line">selectCnt ++;</span><br><span class="line"><span class="comment">// 如果 1 秒后返回，有返回值 || select 被用户唤醒 || 任务队列有任务 || 有定时任务即将被</span></span><br><span class="line">执行； 则跳出循环</span><br><span class="line"><span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line"><span class="comment">// - Selected something,</span></span><br><span class="line"><span class="comment">// - waken up by user, or</span></span><br><span class="line"><span class="comment">// - the task queue has a pending task.</span></span><br><span class="line"><span class="comment">// - a scheduled task is ready for processing</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line"><span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class="line"><span class="comment">// As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span></span><br><span class="line"><span class="comment">// also log it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See https://github.com/netty/netty/issues/2426</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Selector.select() returned prematurely because &quot;</span> +</span><br><span class="line"><span class="string">&quot;Thread.currentThread().interrupt() was called. Use &quot;</span> +</span><br><span class="line"><span class="string">&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">selectCnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line"><span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">selectCnt = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line"><span class="comment">// The selector returned prematurely many times in a row.</span></span><br><span class="line"><span class="comment">// Rebuild the selector to work around the problem.</span></span><br><span class="line">logger.warn(</span><br><span class="line"><span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">selectCnt, selector);</span><br><span class="line">rebuildSelector();</span><br><span class="line">selector = <span class="built_in">this</span>.selector;</span><br><span class="line"><span class="comment">// Select again to populate selectedKeys.</span></span><br><span class="line">selector.selectNow();</span><br><span class="line">selectCnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">currentTimeNanos = time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">&quot; raised by a Selector &#123;&#125; - JDK</span></span><br><span class="line"><span class="string">bug?&quot;</span>,</span><br><span class="line">selector, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line">调用 selector 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <span class="number">0.5</span></span><br><span class="line">秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，唤醒 selecor，防止 selecotr 阻塞时间过</span><br><span class="line">长</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5. EventLoop 作为 Netty 的核心的运行机制 小结</span><br><span class="line">1) 每次执行 ececute 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 run 方法，而 run 方法</span><br><span class="line">是整个 EventLoop 的核心，就像 EventLoop 的名字一样，Loop Loop ，不停的 Loop ，Loop 做什么呢？做 3 件</span><br><span class="line">事情。</span><br><span class="line"> 调用 selector 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 0.5</span><br><span class="line">秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，唤醒 selecor，防止 selecotr 阻塞时间过</span><br><span class="line">长。</span><br><span class="line"> 当 selector 返回的时候，回调用 processSelectedKeys 方法对 selectKey 进行处理。</span><br><span class="line"> 当 processSelectedKeys 方法执行结束后，则按照 ioRatio 的比例执行 runAllTasks 方法，默认是 IO 任务时间和非 IO 任务时间是相同的，你也可以根据你的应用特点进行调优 。比如 非 IO 任务比较多，那么你就将ioRatio 调小一点，这样非 IO 任务就能执行的长一点。防止队列积攒过多的任务</span><br></pre></td></tr></table></figure>



<h3 id="8、handler-中加入线程池和Context-中添加线程池的源码剖析"><a href="#8、handler-中加入线程池和Context-中添加线程池的源码剖析" class="headerlink" title="8、handler 中加入线程池和Context 中添加线程池的源码剖析"></a>8、handler 中加入线程池和Context 中添加线程池的源码剖析</h3><h4 id="源码剖析目的-6"><a href="#源码剖析目的-6" class="headerlink" title="源码剖析目的"></a>源码剖析目的</h4><ol>
<li>在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。 </li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲， 可以有2种方式，而且这2种方式实现的区别也蛮大的。 </li>
<li>处理耗时业务的第一种方式—handler 中加入线程池 </li>
<li>处理耗时业务的第二种方式—Context 中添加线程池 </li>
<li>我们就来分析下两种方式</li>
</ol>
<h4 id="源码剖析-6"><a href="#源码剖析-6" class="headerlink" title="源码剖析"></a>源码剖析</h4><p>说明： </p>
<p>演示两种方式的实现，以及从源码来追踪两种方式执行流程</p>
<p>源码剖析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11.</span> 处理耗时业务的第一种方式--handler 种加入线程池</span><br><span class="line"></span><br><span class="line"><span class="number">11.1</span> 对前面的 Netty demo 源码进行修改，在 EchoServerHandler 的 channelRead 方法进行异步</span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EventExecutorGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(<span class="number">16</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> UnsupportedEncodingException,</span><br><span class="line">InterruptedException &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">msgCop</span> <span class="operator">=</span> msg;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ChannelHandlerContext</span> <span class="variable">cxtCop</span> <span class="operator">=</span> ctx;</span><br><span class="line">group.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msgCop;</span><br><span class="line"><span class="type">byte</span>[] req = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">buf.readBytes(req);</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(req, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">System.err.println(body + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName());</span><br><span class="line"><span class="type">String</span> <span class="variable">reqString</span> <span class="operator">=</span> <span class="string">&quot;Hello i am server~~~&quot;</span>;</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(reqString.getBytes());</span><br><span class="line">cxtCop.writeAndFlush(resp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;go on ..&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">ctx.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line"><span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">cause.printStackTrace();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) 在 channelRead 方法，模拟了一个耗时 <span class="number">10</span> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池group中，这样，就不会阻塞 Netty 的 IO 线程。</span><br></pre></td></tr></table></figure>

<p>  11.2 这样处理之后，整个程序的逻辑如图  </p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303051549646.png" alt="image-20230305153809443"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1) 解释一下上图，当 IO 线程轮询到一个 socket 事件，然后，IO 线程开始处理，当走到耗时 handler 的时</span><br><span class="line">候，将耗时任务交给业务线程池。</span><br><span class="line">2) 当耗时任务执行完毕再执行 pipeline write 方法的时候 ，(代码中使用的是 context 的 write 方法，上图画</span><br><span class="line">的是执行 pipeline 方法, 是一个意思)会将任务这个任务交给 IO 线程</span><br><span class="line">11.3 write 方法的源码(在 AbstractChannelHandlerContext 类)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11.3</span> write 方法的源码(在 AbstractChannelHandlerContext 类)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line"><span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> findContextOutbound();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> pipeline.touch(msg, next);</span><br><span class="line"><span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line"><span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line"><span class="keyword">if</span> (flush) &#123;</span><br><span class="line">next.invokeWriteAndFlush(m, promise);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next.invokeWrite(m, promise);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">AbstractWriteTask task;</span><br><span class="line"><span class="keyword">if</span> (flush) &#123;</span><br><span class="line">task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">&#125;</span><br><span class="line">safeExecute(executor, task, promise, m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">说明:</span><br><span class="line"><span class="number">1</span>) 当判定下个 outbound 的 executor 线程不是当前线程的时候，会将当前的工作封装成 task ，然后放入</span><br><span class="line">mpsc 队列中，等待 IO 任务执行完毕后执行队列中的任务。</span><br><span class="line"><span class="number">2</span>) 这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug ,客户端 Run 的方式)，当我们使用了</span><br><span class="line">group.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;()&#123;&#125; 在 handler 中 加 入 线 程 池 ， 就 会 进 入 到 safeExecute(executor, task,</span><br><span class="line">promise, m); 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 safeExecute(executor,</span><br><span class="line">task, promise, m); （说明：普通方式执行耗时代码，看我准备好的案例即可）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.</span> 处理耗时业务的第二种方式-Context 中添加线程池</span><br><span class="line">    </span><br><span class="line"><span class="number">1.1</span> 在添加 pipeline 中的 handler 时候，添加一个线程池</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EventExecutorGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(<span class="number">16</span>);</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"><span class="keyword">if</span> (sslCtx != <span class="literal">null</span>) &#123;</span><br><span class="line">p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line"><span class="comment">//p.addLast(new EchoServerHandler());</span></span><br><span class="line">p.addLast(group,<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>) handler 中的代码就使用普通的方式来处理耗时业务。</span><br><span class="line"><span class="number">2</span>) 当我们在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池，如果不添加，将使用 IO 线程</span><br><span class="line"><span class="number">3</span>) 当走到 AbstractChannelHandlerContext 的 invokeChannelRead 方法的时候，executor.inEventLoop() 是不会通过的，因为当前线程是 IO 线程 Contex（t 也就是 Handler）的 executor 是业务线程，所以会异步执行, debug</span><br><span class="line">下源码</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line"><span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line"><span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">next.invokeChannelRead(m);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//执行 run</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">next.invokeChannelRead(m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) 验 证 时 ， 我 们 如 果 去 掉 p.addLast(group,<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>() ); 改 成 p.addLastnew</span><br><span class="line"><span class="title function_">EchoServerHandler</span><span class="params">()</span> ); 你会发现代码不会进行异步执行</span><br><span class="line"><span class="number">5</span>) 后面的整个流程就变成和第一个方式一样了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">13. 两种方式的比较</span><br><span class="line">1) 第一种方式在 handler 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需</span><br><span class="line">要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 mpscTask 中。如果 IO 时间很短，task 很多，可</span><br><span class="line">能一个循环下来，都没时间执行整个 task，导致响应时间达不到指标。</span><br><span class="line">2) 第二种方式是 Netty 标准方式(即加入到队列)，但是，这么做会将整个 handler 都交给业务线程池。不论</span><br><span class="line">耗时不耗时，都加入到队列里，不够灵活。</span><br><span class="line">3) 各有优劣，从灵活性考虑，第一种较好</span><br></pre></td></tr></table></figure>



<h2 id="十一、用Netty自己实现dubbo-RPC"><a href="#十一、用Netty自己实现dubbo-RPC" class="headerlink" title="十一、用Netty自己实现dubbo RPC"></a>十一、用Netty自己实现dubbo RPC</h2><h3 id="1、RPC基本介绍"><a href="#1、RPC基本介绍" class="headerlink" title="1、RPC基本介绍"></a>1、RPC基本介绍</h3><ol>
<li><p>RPC（Remote Procedure Call）— 远程 过程调用，是一个计算机 通信协议。该协议允许运 行于一台计算机的程序调 用另一台计算机的子程序， 而程序员无需额外地为这 个交互作用编程 </p>
</li>
<li><p>两个或多个应用程序都分 布在不同的服务器上，它 们之间的调用都像是本地 方法调用一样(如图)</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012218070.png" alt="image-20230301221855994"></p>
</li>
<li><p>常见的 RPC 框架有: 比较知名的如阿里的Dubbo、google的gRPC、Go语言的rpcx、 Apache的thrift， Spring旗下的 Spring Cloud。</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012219117.png" alt="image-20230301221927036"></p>
</li>
</ol>
<h3 id="2、RPC调用流程"><a href="#2、RPC调用流程" class="headerlink" title="2、RPC调用流程"></a>2、RPC调用流程</h3><h4 id="RPC调用流程图"><a href="#RPC调用流程图" class="headerlink" title="RPC调用流程图"></a>RPC调用流程图</h4><p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303012219257.png" alt="image-20230301221955196"></p>
<p>术语说明：在RPC 中， Client 叫服务消费者，Server 叫服 务提供者</p>
<h4 id="PRC调用流程说明"><a href="#PRC调用流程说明" class="headerlink" title="PRC调用流程说明"></a>PRC调用流程说明</h4><ol>
<li><p>服务消费方(client)以本地调用方式调用服务 </p>
</li>
<li><p>client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体 </p>
</li>
<li><p>client stub 将消息进行编码并发送到服务端 </p>
</li>
<li><p>server stub 收到消息后进行解码 </p>
</li>
<li><p>server stub 根据解码结果调用本地的服务 </p>
</li>
<li><p>本地服务执行并将结果返回给 server stub </p>
</li>
<li><p>server stub 将返回导入结果进行编码并发送至消费方 </p>
</li>
<li><p>client stub 接收到消息并进行解码 </p>
</li>
<li><p>服务消费方(client)得到结果</p>
</li>
</ol>
<p>小结：RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调 用本地方法一样即可完成远程服务调用。</p>
<h3 id="3、自己实现-dubbo-RPC-基于Netty"><a href="#3、自己实现-dubbo-RPC-基于Netty" class="headerlink" title="3、自己实现 dubbo RPC(基于Netty)"></a>3、自己实现 dubbo RPC(基于Netty)</h3><h4 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h4><ol>
<li><p>dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框 架 </p>
</li>
<li><p>模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供 者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20</p>
</li>
</ol>
<h4 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h4><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。 </li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。 </li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求 提供者返回数据</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>dubbo RPC 思路分析图：</p>
<p><img src="https://gitee.com/lin-xugeng/image2/raw/master/img/202303052240143.png" alt="image-20230305224019821"></p>
<p>代码实现</p>
<p>公共接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.publicinterface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是接口，是服务提供方和服务消费方都需要</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">hello</span><span class="params">(String mes)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有消费方调用该方法时，就返回一个结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String mes)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端消息=&quot;</span> + mes);</span><br><span class="line">        <span class="comment">//根据mes返回不同的结果</span></span><br><span class="line">        <span class="keyword">if</span> (mes!= <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好客户端，我已经收到你的消息 [&quot;</span> + mes + <span class="string">&quot;] 第&quot;</span>+ (++count) +<span class="string">&quot;次&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好客户端，我已经收到你的消息&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">(String hostname, <span class="type">int</span> port)</span>&#123;</span><br><span class="line">        startServer0(hostname, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对NettyServer的初始化和启动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startServer0</span><span class="params">(String hostname, <span class="type">int</span> port)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">//解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">//编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>()); <span class="comment">//自定义的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(hostname, port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务提供方开始提供服务~~&quot;</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.customer.ClientBootstrap;</span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.provider.HelloServiceImpl;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器这边的handler比较简单</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取客户端发送的消息，并调用服务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;msg=&quot;</span> + msg);</span><br><span class="line">        <span class="comment">//客户端在调用服务器的api时，我们需要定义一个协议</span></span><br><span class="line">        <span class="comment">//比如我们要求每次发消息都必须以某个字符串开头 &quot;我来啦#你好呀#&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>().hello(msg.toString()</span><br><span class="line">                    .substring(msg.toString().lastIndexOf(<span class="string">&quot;#&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">            ctx.writeAndFlush(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器端启动器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.netty.NettyServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerBootstrap 启动一个服务提供者，就是NettyServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个服务提供者，发布服务</span></span><br><span class="line">        NettyServer.startServer(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7005</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyClientHandler client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法使用代理模式，获取一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serviceClass, <span class="keyword">final</span> String providerName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;serviceClass&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;(proxy, method, args) 进入.....&quot;</span> + (++count) + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">                    <span class="comment">//客户端在调用服务器api 时，我们会去调用 invoke 方法</span></span><br><span class="line">                    <span class="keyword">if</span>(client == <span class="literal">null</span>)&#123;</span><br><span class="line">                        initClient();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//设置要发给服务器端的信息</span></span><br><span class="line">                    <span class="comment">//providerName 协议头 args[0]就是客户端调用api hello(??)时传入的参数</span></span><br><span class="line">                    client.setPara(providerName + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//返回值</span></span><br><span class="line">                    <span class="keyword">return</span> executor.submit(client).get();</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>();</span><br><span class="line">        <span class="comment">//创建EventLoopGroup</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            pipeline.addLast(client); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7005</span>).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext context; <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">private</span> String result; <span class="comment">//返回的结果</span></span><br><span class="line">    <span class="keyword">private</span> String para; <span class="comment">//客户端调用方法时，传入的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务器的连接创建后，就会被调用，这个方法是第一个被调用(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; channelActive 被调用  &quot;</span>);</span><br><span class="line">        context=ctx; <span class="comment">//因为我们在其它方法会使用到ctx</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到服务器的数据后，调用方法(4)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; channelRead 被调用  &quot;</span>);</span><br><span class="line">        result=msg.toString();</span><br><span class="line">        notify(); <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生异常后，关闭通道(5)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象调用，发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果(3)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; call1 被调用  &quot;</span>);</span><br><span class="line">        context.writeAndFlush(para);</span><br><span class="line">        <span class="comment">//进行wait</span></span><br><span class="line">        wait(); <span class="comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span></span><br><span class="line">        System.out.println(<span class="string">&quot; call2 被调用  &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">//服务方返回的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置参数(2)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPara</span><span class="params">(String para)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; setPara 被调用  &quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.para=para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端启动器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.netty.dubborpc.customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.netty.NettyClient;</span><br><span class="line"><span class="keyword">import</span> com.lxg.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientBootstrap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里定义协议头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">providerName</span> <span class="operator">=</span> <span class="string">&quot;我来啦#你好呀#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        <span class="type">NettyClient</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">service</span> <span class="operator">=</span> (HelloService) customer</span><br><span class="line">                .getBean(HelloService.class, providerName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span>*<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//通过代理对象调用服务提供者的方法(服务)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> service.hello(<span class="string">&quot;你好 dubbo~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;调用的结果 res= &quot;</span> + res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>听我说，谢谢你<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/img/weixin.jpg">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">Netty</a>
        		</li>
      		
		</ul>
	</div>

	 
		
		
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/网络编程//" class="article-tag-list-link color5">网络编程</a>
        		</li>
      		
		</ul>
	</div>


      

      
        
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://tobetou.cn/2023/10/12/Netty/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2023/10/12/Nginx/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Nginx
        
      </div>
    </a>
  
  
    <a href="/2023/10/12/MySQL/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">MySQL</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category"></i>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Netty%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">一、Netty介绍和应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1、Netty的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Netty%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">2、Netty的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Netty%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.3.</span> <span class="toc-text">3、Netty的学习参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-BIO%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、Java BIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81I-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1、I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2、BIO、NIO、AIO适用场景分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Java-BIO%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3、Java BIO基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Java-BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4、Java BIO工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Java-BIO%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">5、Java BIO应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Java-BIO%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.6.</span> <span class="toc-text">6、Java BIO问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java-NIO%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Java NIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java-NIO%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">1、Java NIO基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81NIO%E5%92%8CBIO%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.</span> <span class="toc-text">2、NIO和BIO的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3、NIO三大核心原理示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">4、缓冲区（Buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E9%81%93%EF%BC%88channel%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">5、通道（channel）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E7%B1%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">FileChannel类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B1-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.3.</span> <span class="toc-text">应用实例1-本地文件写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B2-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.4.</span> <span class="toc-text">应用实例2-本地文件读数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B3-%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AABuffer%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">3.5.5.</span> <span class="toc-text">应用实例3-使用一个Buffer完成文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B4-%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6transferFrom%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.6.</span> <span class="toc-text">应用实例4-拷贝文件transferFrom方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EBuffer%E5%92%8CChannel%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">3.5.7.</span> <span class="toc-text">关于Buffer和Channel的注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Selector%EF%BC%88%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">6、Selector（选择器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%92%8C%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">3.6.2.</span> <span class="toc-text">Selector示意图和特点说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">Selector类相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.6.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81NIO%E9%9D%9E%E9%98%BB%E5%A1%9E-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%9B%BE"><span class="toc-number">3.7.</span> <span class="toc-text">7、NIO非阻塞 网络编程原理分析图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81NIO%E9%9D%9E%E9%98%BB%E5%A1%9E-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">3.8.</span> <span class="toc-text">8、NIO非阻塞 网络编程快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81SelectionKey"><span class="toc-number">3.9.</span> <span class="toc-text">9、SelectionKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81ServerSocketChannel"><span class="toc-number">3.10.</span> <span class="toc-text">10、ServerSocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81SocketChannel"><span class="toc-number">3.11.</span> <span class="toc-text">11、SocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81NIO-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.12.</span> <span class="toc-text">12、NIO 网络编程应用实例-群聊系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.13.</span> <span class="toc-text">13、NIO与零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.13.1.</span> <span class="toc-text">零拷贝基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9FIO%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.13.2.</span> <span class="toc-text">传统IO数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9FIO"><span class="toc-number">3.13.3.</span> <span class="toc-text">传统IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA%E6%8A%80%E6%9C%AF%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.13.4.</span> <span class="toc-text">DMA技术存在的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%83%B3%E6%B3%95"><span class="toc-number">3.13.5.</span> <span class="toc-text">零拷贝的想法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%9B%B4%E6%8E%A5IO"><span class="toc-number">3.13.6.</span> <span class="toc-text">用户态直接IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">3.13.7.</span> <span class="toc-text">写时复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E4%BC%98%E5%8C%96"><span class="toc-number">3.13.8.</span> <span class="toc-text">mmap优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendFile%E4%BC%98%E5%8C%96"><span class="toc-number">3.13.9.</span> <span class="toc-text">sendFile优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9ASplice%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF"><span class="toc-number">3.13.10.</span> <span class="toc-text">拓展：Splice零拷贝技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3"><span class="toc-number">3.13.11.</span> <span class="toc-text">零拷贝的再次理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%92%8CsendFile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.13.12.</span> <span class="toc-text">mmap和sendFile的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-number">3.13.13.</span> <span class="toc-text">NIO零拷贝案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81Java-AIO%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.14.</span> <span class="toc-text">14、Java AIO基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">3.15.</span> <span class="toc-text">15、BIO、NIO、AIO对比表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Netty%E6%A6%82%E8%BF%B0"><span class="toc-number">4.</span> <span class="toc-text">四、Netty概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E7%94%9FNIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">1、原生NIO存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Netty%E5%AE%98%E7%BD%91%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">2、Netty官网说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Netty%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">3、Netty的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Netty%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">4、Netty版本说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">五、Netty高性能架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">1、线程模型基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9EI-O%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">2、传统阻塞I&#x2F;O服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">5.2.1.</span> <span class="toc-text">工作原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.2.</span> <span class="toc-text">模型特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3、Reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E7%9A%84-2-%E4%B8%AA%E7%BC%BA%E7%82%B9%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-%E5%A4%8D%E7%94%A8%E7%BB%93%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E5%B0%B1%E6%98%AF-Reactor-%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C-%E5%A6%82%E5%9B%BE%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想， 如图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-%E6%A8%A1%E5%BC%8F%E4%B8%AD-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">5.3.3.</span> <span class="toc-text">Reactor 模式中 核心组成：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">5.3.4.</span> <span class="toc-text">Reactor 模式分类：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4、单Reactor单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">工作原理示意图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">5.4.2.</span> <span class="toc-text">方案说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">5.4.3.</span> <span class="toc-text">方案优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5、单Reactor多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%9A-1"><span class="toc-number">5.5.1.</span> <span class="toc-text">工作原理示意图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AF%B4%E6%98%8E"><span class="toc-number">5.5.2.</span> <span class="toc-text">方案说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">5.5.3.</span> <span class="toc-text">方案优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">6、主从Reactor多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%9A-2"><span class="toc-number">5.6.1.</span> <span class="toc-text">工作原理示意图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E8%AF%B4%E6%98%8E-1"><span class="toc-number">5.6.2.</span> <span class="toc-text">方案说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scalable-IO-in-Java-%E5%AF%B9-Multiple-Reactors-%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="toc-number">5.6.3.</span> <span class="toc-text">Scalable IO in Java 对 Multiple Reactors 的原理图解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">5.6.4.</span> <span class="toc-text">方案优缺点说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Reactor%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">5.7.</span> <span class="toc-text">7、Reactor模式小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%94%A8%E7%94%9F%E6%B4%BB%E6%A1%88%E4%BE%8B%E6%9D%A5%E7%90%86%E8%A7%A3"><span class="toc-number">5.7.1.</span> <span class="toc-text">3 种模式用生活案例来理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-%E6%A8%A1%E5%BC%8F%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">5.7.2.</span> <span class="toc-text">Reactor 模式具有如下的优点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Netty%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.8.</span> <span class="toc-text">8、Netty模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE1-%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">5.8.1.</span> <span class="toc-text">工作原理示意图1-简单版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE2-%E8%BF%9B%E9%98%B6%E7%89%88"><span class="toc-number">5.8.2.</span> <span class="toc-text">工作原理示意图2-进阶版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE-%E8%AF%A6%E7%BB%86%E7%89%88"><span class="toc-number">5.8.3.</span> <span class="toc-text">工作原理示意图-详细版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B-TCP%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.9.</span> <span class="toc-text">9、Netty快速入门实例-TCP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Netty%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.10.</span> <span class="toc-text">10、Netty模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84-Task-%E6%9C%89-3-%E7%A7%8D%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.10.1.</span> <span class="toc-text">任务队列中的 Task 有 3 种典型使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="toc-number">5.10.2.</span> <span class="toc-text">方案再说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.11.</span> <span class="toc-text">11、异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">5.11.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E8%AF%B4%E6%98%8E"><span class="toc-number">5.11.2.</span> <span class="toc-text">Future说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">5.11.3.</span> <span class="toc-text">工作原理示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-Listener-%E6%9C%BA%E5%88%B6"><span class="toc-number">5.11.4.</span> <span class="toc-text">Future-Listener 机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B-HTTP%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.12.</span> <span class="toc-text">13、快速入门实例-HTTP服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">六、Netty核心模块组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Bootstrap%E3%80%81ServerBootstrap"><span class="toc-number">6.1.</span> <span class="toc-text">1、Bootstrap、ServerBootstrap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Future%E3%80%81ChannelFuture"><span class="toc-number">6.2.</span> <span class="toc-text">2、Future、ChannelFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Channel"><span class="toc-number">6.3.</span> <span class="toc-text">3、Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Selector"><span class="toc-number">6.4.</span> <span class="toc-text">4、Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ChannelHandler-%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">5、ChannelHandler 及其实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Pipeline-%E5%92%8C-ChannelPipeline"><span class="toc-number">6.6.</span> <span class="toc-text">6、Pipeline 和 ChannelPipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81ChannelHandlerContext"><span class="toc-number">6.7.</span> <span class="toc-text">7、ChannelHandlerContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81ChannelOption"><span class="toc-number">6.8.</span> <span class="toc-text">8、ChannelOption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81EventLoopGroup-%E5%92%8C%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB-NioEventLoopGroup"><span class="toc-number">6.9.</span> <span class="toc-text">9、EventLoopGroup 和其实现类 NioEventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Upooled%E7%B1%BB"><span class="toc-number">6.10.</span> <span class="toc-text">10、Upooled类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81Netty%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.11.</span> <span class="toc-text">11、Netty应用实例-群聊系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81Netty%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E6%A1%88%E4%BE%8B"><span class="toc-number">6.12.</span> <span class="toc-text">12、Netty心跳检测机制案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81Netty-%E9%80%9A%E8%BF%87WebSocket%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.13.</span> <span class="toc-text">13、Netty 通过WebSocket编程实现服务器和客户端长连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Google-Protobuf"><span class="toc-number">7.</span> <span class="toc-text">七、Google Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">1、编码和解码的基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Netty-%E6%9C%AC%E8%BA%AB%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%88%B6%E5%92%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">2、Netty 本身的编码解码的机制和问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Protobuf"><span class="toc-number">7.3.</span> <span class="toc-text">3、Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">7.3.1.</span> <span class="toc-text">Protobuf基本介绍和使用示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.3.2.</span> <span class="toc-text">Protobuf快速入门实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B2"><span class="toc-number">7.3.3.</span> <span class="toc-text">Protobuf快速入门实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%92%8Chandler%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">八、Netty编解码器和handler的调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">8.1.</span> <span class="toc-text">1、基本说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">2、编码解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8-ByteToMessageDecoder"><span class="toc-number">8.3.</span> <span class="toc-text">3、解码器-ByteToMessageDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Netty%E7%9A%84handler%E9%93%BE%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">8.4.</span> <span class="toc-text">4、Netty的handler链的调用机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8-ReplayingDecoder"><span class="toc-number">8.5.</span> <span class="toc-text">5、解码器-ReplayingDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%85%B6%E5%AE%83%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">8.6.</span> <span class="toc-text">6、其它编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Log4j-%E6%95%B4%E5%90%88%E5%88%B0Netty"><span class="toc-number">8.7.</span> <span class="toc-text">7、Log4j 整合到Netty</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85-%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.</span> <span class="toc-text">九、TCP粘包和拆包 及解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">1、TCP 粘包和拆包基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E7%8E%B0%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">9.2.</span> <span class="toc-text">2、TCP 粘包和拆包现象实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.3.</span> <span class="toc-text">3、TCP 粘包和拆包解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">十、Netty核心源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-1"><span class="toc-number">10.1.</span> <span class="toc-text">1、基本说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Netty-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">2、Netty 启动过程源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84"><span class="toc-number">10.2.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.2.2.</span> <span class="toc-text">源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">10.2.3.</span> <span class="toc-text">源码剖析过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">10.2.4.</span> <span class="toc-text">Netty启动过程梳理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Netty-%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.3.</span> <span class="toc-text">3、Netty 接受请求过程源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-1"><span class="toc-number">10.3.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-1"><span class="toc-number">10.3.2.</span> <span class="toc-text">源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">10.3.3.</span> <span class="toc-text">Netty接受请求过程梳理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Pipeline-Handler-HandlerContext%E5%88%9B%E5%BB%BA%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.4.</span> <span class="toc-text">4、Pipeline Handler HandlerContext创建源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-2"><span class="toc-number">10.4.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-2"><span class="toc-number">10.4.2.</span> <span class="toc-text">源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-Handler-HandlerContext%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">10.4.3.</span> <span class="toc-text">Pipeline Handler HandlerContext创建过程梳理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ChannelPipeline-%E8%B0%83%E5%BA%A6-handler-%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.5.</span> <span class="toc-text">5、ChannelPipeline 调度 handler 的源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-3"><span class="toc-number">10.5.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-3"><span class="toc-number">10.5.2.</span> <span class="toc-text">源码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelPipeline-%E8%B0%83%E5%BA%A6-handler-%E6%A2%B3%E7%90%86"><span class="toc-number">10.5.3.</span> <span class="toc-text">ChannelPipeline 调度 handler 梳理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Netty-%E5%BF%83%E8%B7%B3-heartbeat-%E6%9C%8D%E5%8A%A1%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.6.</span> <span class="toc-text">6、Netty 心跳(heartbeat)服务源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-4"><span class="toc-number">10.6.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-4"><span class="toc-number">10.6.2.</span> <span class="toc-text">源码剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.7.</span> <span class="toc-text">7、Netty 核心组件 EventLoop 源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-5"><span class="toc-number">10.7.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-5"><span class="toc-number">10.7.2.</span> <span class="toc-text">源码剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81handler-%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CContext-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">10.8.</span> <span class="toc-text">8、handler 中加入线程池和Context 中添加线程池的源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E7%9A%84-6"><span class="toc-number">10.8.1.</span> <span class="toc-text">源码剖析目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-6"><span class="toc-number">10.8.2.</span> <span class="toc-text">源码剖析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%94%A8Netty%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0dubbo-RPC"><span class="toc-number">11.</span> <span class="toc-text">十一、用Netty自己实现dubbo RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81RPC%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">1、RPC基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">2、RPC调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">11.2.1.</span> <span class="toc-text">RPC调用流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PRC%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">11.2.2.</span> <span class="toc-text">PRC调用流程说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-dubbo-RPC-%E5%9F%BA%E4%BA%8ENetty"><span class="toc-number">11.3.</span> <span class="toc-text">3、自己实现 dubbo RPC(基于Netty)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="toc-number">11.3.1.</span> <span class="toc-text">需求说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E"><span class="toc-number">11.3.2.</span> <span class="toc-text">设计说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>



  
  
  

  

  

  <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">

if(true){
	var gitalk = new Gitalk({
  	clientID: '5bf314ac57155a51893c',
  	clientSecret: '6bc2f2ad3e5a34704e1be03c84cd32356355f669',
  	repo: 'blog-comment',
  	owner: 'xiaolin-zi',
  	admin: ['xiaolin-zi'],
  	id: 'Thu Oct 12 2023 20:40:48 GMT+0800',
  	distractionFreeMode: 'true'
})
gitalk.render('gitalk-container') 
}
</script>


  

  



          </div>
        </div>
      </div>
      <footer id="footer">

  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2023 小林子
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
	<div calss="count-span">
      <span id="busuanzi_container_site_pv">
        总访问量: <span id="busuanzi_value_site_pv"></span>
      </span>

      <span id="busuanzi_container_site_uv">
        总访客: <span id="busuanzi_value_site_uv"></span>
      </span>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">cookie session</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">ajax</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">axios</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">dubbo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">es6、js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">filter</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">EL表达式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jquery</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">jsp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">json</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">i18n</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">jdbc</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Jenkins</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Markdown</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Maven</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MyBatis</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Nginx</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">MySQL</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">SpringSecurity</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Redis</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">RabbitMQ</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Netty</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">SpringMVC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">springcloud</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Thymeleaf</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">XML</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Tomcat、Servlet</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">html、css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">SpringCloud</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Vue3</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">项目</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">springboot</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">JavaWeb</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Html-css</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://lookforward.top/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>个人简约版blog</a>
            </li>
          
            <li class="search-li">
              <a href="https://tobeyou.cn" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>个人主页</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">01.12.26 男 24届广东财经大学软件工程专业学生</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>