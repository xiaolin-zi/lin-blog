var tipuesearch = {"pages":[{"title":"文件的上传和下载","url":"/2023/10/12/文件的上传和下载/","text":"文件的上传和下载1、文件的上传介绍（重点）文件的上传和下载，是非常常见的功能，很多的系统中，或者软件中都会经常使用文件的上传和下载。 比如：qq头像，邮箱，OA系统 1234567步骤如下：1、要有一个form标签，method=post请求2、form标签的enType属性值必须为multipart/form-data值3、在form标签中使用input type=file添加上传的文件4、编写服务器代码（Servlet程序）接收，处理上传的数据enType=multipart/form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器 一、上传文件的Http协议 二、commons-fileupload.jar常用API介绍说明第一步需要导入两个jar包： commons-fileupload-1.2.1.jar commons-io-1.4.jar 2、文件下载下载的常用API的说明： 12345678910111213141516171819202122232425262728293031323334353637383940package com.lxg.pojo.Servlet;import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;import org.apache.commons.io.IOUtils;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URLEncoder;public class DownLoadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取要下载的文件名 String downloadFileName=&quot;2.jpg&quot;; //2、读取要下载的文件内容(通过ServletContext对象可以读取） ServletContext servletContext = getServletContext(); //获取要下载的文件类型 String mimeType = servletContext.getMimeType(&quot;/imgs/&quot; + downloadFileName); System.out.println(&quot;下载的文件类型：&quot;+mimeType); //4、在回传之前，通过响应头告诉客户端返回的数据类型 resp.setContentType(mimeType); //5、还要告诉客户端收到的数据是用于下载使用（还是使用响应头） //Content-Disposition响应头，表示收到的数据怎么处理 //attachment表示附件 //filename=表示指定下载的文件名 //url编码是把汉字转换成 resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(&quot;美女.jpg&quot;,&quot;UTF-8&quot;)); InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/imgs/&quot; + downloadFileName); OutputStream outputStream = resp.getOutputStream(); //3、把下载的文件内容回传给客户端 //读取输入流中全部数据，复制给输出流，输出给客户端 IOUtils.copy(resourceAsStream,outputStream); &#125;&#125; 中文名乱码问题解决方案：方案一、URLEncoder解决IE和谷歌浏览器 方案二、BASE64编解码解决火狐浏览器","tags":"javaweb"},{"title":"XML","url":"/2023/10/12/XML/","text":"XML1、XML简介 什么是xml？ xml是可扩展的标记性语言 xml的作用？ xml的主要作用有： 用来保存数据，而且这些数据具有自我描述性 它还可以作为项目或者模块的配置文件 还可以作为网络传输数据的格式（现在以JSON为主） 2、xml语法 文档声明 元素（标签） xml属性 xml注释 文本区域（CDATA区） 2.1、文档声明1234567891011121314151617181920xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!-- &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 以上内容是XML文件的声明 version=&quot;1.0&quot; version 是XML文件的版本 encoding=&quot;utf-8&quot; encoding 是XML文件本身的编码--&gt;&lt;books&gt;&lt;!--books表示多个图书信息--&gt; &lt;book sn=&quot;SN001&quot;&gt;&lt;!--book表示一个图书信息，sn属性表示图书馆序列号--&gt; &lt;name&gt;C语言程序设计&lt;/name&gt;&lt;!--name表示图书名称--&gt; &lt;author&gt;William&lt;/author&gt;&lt;!--author表示图书作者--&gt; &lt;price&gt;100&lt;/price&gt;&lt;!--price表示图书价格--&gt; &lt;/book&gt; &lt;book sn=&quot;SN002&quot;&gt; &lt;name&gt;java程序设计&lt;/name&gt; &lt;author&gt;林老师&lt;/author&gt; &lt;price&gt;100&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; 2.2、xml注释一样的： 2.3、元素（标签）先回忆一下： 1234567html标签： 格式：&lt;标签名&gt;封装的数据&lt;/标签名&gt; 单标签：&lt;标签名/&gt; &lt;br/&gt;换行 &lt;hr/&gt;水平线 双标签：&lt;标签名&gt;封装的数据&lt;/标签名&gt; 标签名大小写不敏感 标签有属性，有基本属性和事件属性 标签要闭合（不闭合，html中不报错，但我们要养成良好的书写习惯，注意闭合） 2.3.1、什么是xml元素？ 什么是 XML 元素？ XML元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。 元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。 1234567891011121314&lt;bookstore&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 2.3.2、xml的命名规则XML元素必须遵循以下命名规则 名称可以含字母、数字以及其他字符 名称不能以数字或者表单符号开始 名称不能以字符”xml“（或者XML，Xml）开始 名称不能包含空格 2.3.3、xml中的元素（标签）也分成单标签和双标签单标签 ​ 格式：&lt;标签名 属性&#x3D;”值“ 属性&#x3D;”值“……&#x2F;&gt; 双标签： ​ 格式：&lt;标签名 属性&#x3D;”值“ 属性&#x3D;”值“……&gt;文本数据或者子标签&lt;&#x2F;标签名&gt; 123456&lt;book sn=&quot;SN002&quot;&gt; &lt;name&gt;java程序设计&lt;/name&gt; &lt;author&gt;林老师&lt;/author&gt; &lt;price&gt;100&lt;/price&gt;&lt;/book&gt;&lt;book sn=&quot;SN003&quot; name=&quot;Web&quot; author=&quot;林老师&quot; price=&quot;100&quot;/&gt; 2.4 、xml属性xml的标签属性和html的标签属性是非常类似的，属性可以提供元素的额外信息 在标签是可以书写属性： ​ 一个标签上可以书写多个属性。每个属性的值必须用引号引起来。 注意：如果属性值本身包含双引号，那么有必要使用单引号包围它 2.5、xml其他语法规则 所有XML元素都必须有关闭标签（也就是闭合） 不闭合就会报错 XML标签对大小写敏感 XML必须正确的嵌套 XML文档必须有根元素 根元素就是顶级元素 没有父标签的元素，叫做顶级元素 根元素是没有父标签的顶级元素，而且是唯一一个才行。 xml属性值必须加引号 xml中的特殊字符 &amp;lt； &lt; 小于 &amp;gt； &gt; 大于 &amp;amp； &amp; 和号 &amp;apos； ‘ 省略号 &amp;quot； “ 引号 文本区域（CDATA区） CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析。 CDATA格式： 1&lt;![CDATA[这里可以把想输入的字符原样显示，不会解析xml]]&gt; 3、xml解析技术介绍xml是可扩展的标记语言。 ​ 不管是html文件还是xml文件它们都是标记型文档，都可以使用w3c组织制定的dom技术来解析。 12XML文档对象模型定义访问和操作XML文档的标准方法DOM将XML文档作为一个树形结构，而树叶被定义为节点。 document对象表示的是整个文档（可以是html文档也可以是xml文档） 1早期jdk为我们提供了两种xml解析技术Dom和Sax简介（已经过时，但是我们需要知道这两种技术） 这个Dom4j它是第三方的解析技术，我们需要使用第三方给我们提供好多类库才能解析xml文件 4、dom4j解析技术（重点）由于dom4j它不是sun公司的技术，而属于第三方公司，我们需要使用dom4j就需要到dom4j官网下载dom4j的jar包 4.1、Dom4j类库的使用4.2、Dom4j常用目录介绍4.3、dom4j编程步骤：12345第一步：先加载xml文件创建Document对象第二步：提供Document对象拿到根元素对象第三步：提供根元素.elements(标签名);可以返回一个集合，这个集合里放着所有你指定的标签名的元素对象第四步：找到你想修改、删除的子元素，进行相应的操作第五步：保存到硬盘上 4.4、获取document对象创建一个lib目录，并添加到dom4j的jar包，并添加到类路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.lxg.pojo;import jdk.jfr.StackTrace;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.junit.Test;import java.util.List;public class Dom4jTest &#123; @Test public void test1() throws DocumentException &#123; //创建一个SaxReader输入流，去读取xml配置文件，生成Document对象 SAXReader saxReader = new SAXReader(); Document document = saxReader.read(&quot;src/books.xml&quot;); System.out.println(document); &#125; /** * 读取books.xml文件生成book类 */ @Test public void test2() throws DocumentException &#123; //1、读取books.xml文件 SAXReader saxReader = new SAXReader(); //在Junit测试中，相对路径是从模块名称开始算 Document document=saxReader.read(&quot;src/books.xml&quot;); //2、通过Document对象获取根元素 Element rootElement = document.getRootElement(); //System.out.println(document); //3、通过根元素获取book标签对象 //element()和elements()都是通过标签名称来获取子元素对象 List&lt;Element&gt; books = rootElement.elements(&quot;book&quot;); //4、通过遍历，处理每个book标签转换为Book类 for (Element book : books) &#123; //asXML()方法，返回标签对象的xml格式字符串 //System.out.println(book.asXML()); Element nameElement = book.element(&quot;name&quot;); //getText()方法，返回标签对象的文本内容 String nameText = nameElement.getText(); //System.out.println(nameText); //直接获取指定标签的文本内容 String priceText = book.elementText(&quot;price&quot;); String authorText = book.elementText(&quot;author&quot;); String snVlaue = book.attributeValue(&quot;sn&quot;); System.out.println(new Book(snVlaue, nameText,authorText,priceText)); &#125; &#125;&#125; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;books&gt; &lt;book sn=&quot;SN001&quot;&gt; &lt;name&gt;The Hitchhiker&#x27;s Guide to the Galaxy&lt;/name&gt; &lt;author&gt;Douglas Adams&lt;/author&gt; &lt;price&gt;5.99&lt;/price&gt; &lt;/book&gt; &lt;book sn=&quot;SN002&quot;&gt; &lt;name&gt;The Restaurant at the End of the Universe&lt;/name&gt; &lt;author&gt;Douglas Adams&lt;/author&gt; &lt;price&gt;5.99&lt;/price&gt; &lt;/book&gt;&lt;/books&gt;","tags":"xml"},{"title":"Vue3","url":"/2023/10/12/vue3快速上手/","text":"Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% …… 2.源码的升级 使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking …… 3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API（组合API） setup配置 ref与reactive watch与watchEffect provide与inject …… 新的内置组件 Fragment Teleport Suspense 其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除keyCode支持作为 v-on 的修饰符 …… 一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 123456789## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve 2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图 12345678## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev 二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 1.拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 3.reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 4.Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 1234Object.defineProperty(data, &#x27;count&#x27;, &#123; get () &#123;&#125;, set () &#123;&#125;&#125;) 存在问题： 新增属性、删除属性, 界面不会更新。 解决方案：this.$set Vue.set this.$delete Vue.delete 直接通过下标修改数组, 界面不会自动更新。 解决方法：this.$set Vue.set 或 数组的七个方法 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect 12345678910111213141516new Proxy(data, &#123; // 拦截读取属性值 get (target, prop) &#123; return Reflect.get(target, prop) &#125;, // 拦截设置属性值或添加新属性 set (target, prop, value) &#123; return Reflect.set(target, prop, value) &#125;, // 拦截删除属性 deleteProperty (target, prop) &#123; return Reflect.deleteProperty(target, prop) &#125;&#125;)proxy.name = &#x27;tom&#x27; 5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 7.计算属性与监视1.computed函数 与Vue2.x中computed配置功能一致 写法 1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123; ... //计算属性——简写 let fullName = computed(()=&gt;&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;) //计算属性——完整 let fullName = computed(&#123; get()&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;, set(value)&#123; const nameArr = value.split(&#x27;-&#x27;) person.firstName = nameArr[0] person.lastName = nameArr[1] &#125; &#125;)&#125; 2.watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 1234567891011121314151617181920212223242526272829303132//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123; const x1 = sum.value const x2 = person.age console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;) 8.生命周期vue2.x的生命周期vue3.0的生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate&#x3D;&#x3D;&#x3D;&gt;setup() created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup() beforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted beforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate updated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated beforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount unmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted 9.自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 10.toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,&#39;name&#39;) 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 三、其它 Composition API1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt; &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; import &#123;ref,customRef&#125; from &#x27;vue&#x27; export default &#123; name:&#x27;Demo&#x27;, setup()&#123; // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay)&#123; let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; track() //告诉Vue这个value值是需要被“追踪”的 return value &#125;, set(newValue)&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; value = newValue trigger() //告诉Vue去更新界面 &#125;,delay) &#125; &#125; &#125;) &#125; let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref return &#123; keyword &#125; &#125; &#125;&lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代（跨级）组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： 123456setup()&#123; ...... let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;) provide(&#x27;car&#x27;,car) ......&#125; 后代组件中： 123456setup(props,context)&#123; ...... const car = inject(&#x27;car&#x27;) return &#123;car&#125; ......&#125; 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 12345678&lt;teleport to=&quot;移动位置&quot;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;)) 使用Suspense包裹组件，并配置好default 与 fallback 12345678910111213&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt; 六、其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123; data: () =&gt; (&#123; count: 0 &#125;), template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123; inserted: el =&gt; el.focus()&#125; Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 12345678.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; Vue3.x写法 123456789.v-enter-from,.v-leave-to &#123; opacity: 0;&#125;.v-leave-from,.v-enter-to &#123; opacity: 1;&#125; 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 1234&lt;my-component v-on:close=&quot;handleComponentEvent&quot; v-on:click=&quot;handleNativeClickEvent&quot;/&gt; 子组件中声明自定义事件 12345&lt;script&gt; export default &#123; emits: [&#x27;close&#x27;] &#125;&lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ……","tags":"vue3"},{"title":"Vue","url":"/2023/10/12/Vue（尚硅谷）/","text":"Vue（尚硅谷）[Toc] 1、Vue简介1、Vue是什么？Vue是一套用于构建用户界面的渐进式JavaScript框架 渐进式：Vue可以自底向上逐层的应用，简单应用：只需一个轻量小巧的核心库，复杂应用：可以引入各式各样的Vue插件 2、谁开发的？ 后起之秀，生态完善，已然成为国内前端工程师必备技能。 3、Vue的特点1、采用组件化模式，提高代码复用率，且让代码更好维护 2、声明式编码，让编码人员无需直接操作DOM，提高开发效率 3、使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点 还得写判断条件 4、学习Vue之前要掌握的JavaScript基础知识？ES6语法规范 ES6模块化 包管理器 原型、原型链 数组常用方法 axios promise …….. 5、Vue官网 Vue2 Vue3 2、配置Vue环境1、安装Vue.js开发版本 生产版本 2、安装Vue开发者工具Installation | Vue Devtools (vuejs.org) 谷歌浏览器使用下面链接搜索下载： 极简插件_Chrome扩展插件商店_优质crx应用下载 (zzzmh.cn) 3、阻止vue在启动时生成生产提提示Vue.config.productionTip &#x3D;false; 12正常情况下在html页面用script标签写就可以了，但是现在好像得在vue.js中修改，Vue3新版本移除了 3、初识Vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;初识vue&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 初识Vue： 1、想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； 2、root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； 3、root容器里的代码被称为【Vue模板】； 4、容器和Vue实例是一对一关系（后面Vue有组件化） 5、真实开发中只有一个vue实例，并且会配合着组件一起使用； 6、&#123;&#123;xxx&#125;&#125;中要写js表达式，且xxx可以自动读取到data中的所有属性； 7、一旦data中的数据发送改变，那么模板中用到数据的地方也会自动更新； 注意区分：js表达式和js代码（语句） 1、表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方 (1)a (2)a+b (3)demo(1) (4)x===y?&#x27;a&#x27;:&#x27;b&#x27; 2、js代码（语句） (1)if()&#123;&#125; (2)for()&#123;&#125; --&gt; &lt;!-- &lt;div class=&quot;root&quot;&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125; 1&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;root&quot;&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125; 2&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;root1&quot;&gt; &lt;h1&gt;Hello, &#123;&#123;name.toUpperCase()&#125;&#125;,&#123;&#123;address&#125;&#125;,&#123;&#123;Date.now()&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;!-- &lt;div id=&quot;root2&quot;&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;,&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip =false;//阻止vue在启动时生成生产提提示 // 创建Vue实例 new Vue(&#123; el:&quot;#root1&quot;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。或者直接使用document.getxxxx data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象 name:&#x27;我是Vue&#x27;, address:&quot;广州&quot; &#125; &#125;); /* new Vue(&#123; el:&quot;#root2&quot;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。或者直接使用document.getxxxx data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象 name:&quot;HHH&quot;, address:&quot;广东&quot; &#125; &#125;); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、Vue模板语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Vue模板语法有两大类： 1、插值语法： 功能：用于解析标签体内容 写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性 2、指令语法： 功能：用于解析标签(包括：标签属性、标签体内容、绑定事件......) 举例：v-bind:href=&quot;xxx&quot; 或者简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式 且可以直接读取到data中的所有属性 备注：Vue中有很多指令，功能都大不相同，且形式都是：v-????，此处只是讲了一个v-bind作为例子 --&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;hr&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;douyin.url.toUpperCase()&quot; v-bind:x=&quot;hello&quot;&gt;点我去看&#123;&#123;douyin.name&#125;&#125;&lt;/a&gt; &lt;!-- &lt;a v-bind:href=&quot;url&quot;&gt;点我去逛b站&lt;/a&gt; --&gt; &lt;a :href=&quot;bilibili.url&quot; x=&quot;hello&quot;&gt;点我去逛&#123;&#123;bilibili.name&#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip=false;//阻止Vue启动时生成生产提示 new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&quot;Jack&quot;, bilibili:&#123; name:&quot;b站&quot;, url:&quot;https://www.bilibili.com&quot; &#125;, douyin:&#123; name:&quot;抖音&quot;, url:&quot;https://www.douyin.com&quot; &#125;, hello:&#x27;你好&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; data中可以使用对象分层级存放数据，取数据时按对象形式取即可 5、数据绑定1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Vue中有两种数据绑定的方式： 1、单向绑定（v-bind）：数据只能从data流向页面 2、双向绑定（v-model）：数据不仅能从data流向页面，也能从页面流向data 备注： 1、双向绑定一般都应用于表单类元素上（如：input、select等） 2、v-model：value可以简写为v-model，因为v-model默认收集的就是value值。 --&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单项数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br&gt; --&gt; &lt;!-- 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br&gt; --&gt; &lt;!-- 简写 --&gt; 单项数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好&lt;/h2&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&quot;Vue&quot; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 6、el与data的两种写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- data和el有两种写法： 1、el有两种写法 ①new Vue的时候配置el属性 ②先创建Vue实例，随后通过vm.$mount(&quot;#root&quot;)指定el的值 2、data有两种写法 ①对象式 ②函数式 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错 3、一个重要原则： 由vue管理的函数：一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了 --&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;你好,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; /* const v = new Vue(&#123; // 第一种写法 // el:&#x27;#root&#x27;, data:&#123; name:&quot;Vue&quot; &#125; &#125;); console.log(v); // 第二种写法，mount挂载 v.$mount(&#x27;#root&#x27;); */ new Vue(&#123; el:&#x27;#root&#x27;, // data第一种写法：对象式 /* data:&#123; name:&quot;Vue&quot; &#125; */ // data的第二种写法：函数式 data()&#123; console.log(this);//此处的this是Vue实例对象 return&#123; name:&quot;Vue&quot; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 7、MVVM模型1、M：模型（Model）：对象data中的数据 2、V：视图（View）：模板 3、VM：视图模型（View Model）：Vue实例对象 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- MVVM模型： 1、M：模型（Model）：对象data中的数据 2、V：视图（View）：模板 3、VM：视图模型（View Model）：Vue实例对象 观察发现： 1、data中所有属性，最后都出现在了vm身上 2、vm身上所有的属性，及Vue原型上所有属性，在Vue模板中都可以直接使用 --&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;!-- &lt;h1&gt;测试一下1：&#123;&#123;1+1&#125;&#125;&lt;/h1&gt; &lt;h1&gt;测试一下2：&#123;&#123;$options&#125;&#125;&lt;/h1&gt; &lt;h1&gt;测试一下3：&#123;&#123;$emit&#125;&#125;&lt;/h1&gt; &lt;h1&gt;测试一下4：&#123;&#123;_c&#125;&#125;&lt;/h1&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;广东财经大学&quot;, address:&quot;广州&quot; &#125; &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 8、数据代理1、回顾Object.defineProperty()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let number = 18; let person=&#123; name:&quot;张三&quot;, sex:&quot;男&quot;, // age:18, // age:number &#125;; Object.defineProperty(person,&#x27;age&#x27;,&#123; // value:18, // enumerable:true, //设置属性是否可枚举，默认值是false // writable:true, //设置属性是否可以被修改，默认值是false // configurable:true //设置属性是否可以被删除，默认值是false // 当有人读取person的age属性时，get(getter)函数就会被调用，且返回值就是age的值 get()&#123; console.log(&quot;有人读取age属性了&quot;); return number; &#125;, // 当有人修改person的age属性时，set(setter)函数就会被调用，且会收到修改后的具体值 set(value)&#123; console.log(&quot;有人修改了age属性，且值是：&quot;+value); number=value; &#125; &#125;); // console.log(Object.keys(person)); /* for (const key in person) &#123; console.log(person[key]); &#125; */ console.log(person); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、何为数据代理123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 数据代理：通过一个对象代理对另外一个对象中的属性的操作（读/写） --&gt; &lt;script&gt; let obj = &#123;x:100&#125;; let obj2 = &#123;y:200&#125;; Object.defineProperty(obj2,&#x27;x&#x27;,&#123; get()&#123; return obj.x; &#125;, set(value)&#123; obj.x=value; &#125; &#125;) ; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、Vue中的数据代理123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、Vue中的数据代理： 通过vm对象来代理data对象中属性的操作（读/写） 2、Vue中数据代理的好处： 更加方便的操作data中的数据 3、基本原理： 通过Object.defineProperty()把data对象中所有属性添加到vm上 为每一个添加到vm上的属性，都指定一个getter/setter 在getter/setter内部去操作（读/写）data中对应的属性 --&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; /* let data = &#123; name:&quot;广东财经大学&quot;, address:&quot;广州&quot; &#125; */ const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;广东财经大学&quot;, address:&quot;广州&quot; &#125; // data &#125;); &lt;/script&gt;&lt;/html&gt; 9、事件处理1、事件的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 事件的基本使用： 1、使用v-on:xxx 或@xxx绑定事件，其中xxx是事件名 2、事件的回调需要配置在methods对象中，最终会在vm上 3、methods中配置的函数，不要用箭头函数，否则this就不是vm了 4、methods中配置的函数，都是被Vue所管理的函数，this的指向就是vm或组件实例对象 5、@click=&quot;demo&quot;和 @click=&quot;demo($event)&quot;效果一致，但是后者可以传参 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来&#123;&#123;name&#125;&#125;学习Vue!&lt;/h2&gt; &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我获取提示&lt;/button&gt; --&gt; &lt;button @click=&quot;showInfo1&quot;&gt;点我获取提示1(不传参)&lt;/button&gt; &lt;button @click=&quot;showInfo2(66,$event)&quot;&gt;点我获取提示2(传参)&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; /* function showInfo()&#123; alert(&quot;你好，欢迎呀&quot;); &#125; */ const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;b站&quot; &#125;, methods:&#123; showInfo1(event)&#123; event = event || window.event; // console.log(event.target.innerText); // console.log(this);//此处this是Vue实例对象 // console.log(this==vm);//true alert(&quot;你好，欢迎呀!&quot;); &#125;, showInfo2(number,event)&#123; console.log(number,event); alert(&quot;你好，欢迎呀!!&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、事件修饰符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; *&#123; margin-top: 20px; &#125; .demo1&#123; height: 50px; background-color: #bfa; &#125; .box1&#123; padding: 5px; background-color: yellowgreen; &#125; .box2&#123; padding: 5px; background-color: yellow; &#125; .list&#123; width: 200px; height: 200px; background-color: skyblue; overflow: auto; &#125; li&#123; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Vue中的事件修饰符： 1、prevent：阻止默认事件（常用） 2、stop：阻止事件冒泡（常用） 3、once：事件只触发一次（常用） 4、capture：使用事件的捕获方式 5、self：只有event.taegent是当前操作的元素时才触发事件 6、passive：事件的默认认为立即执行，无需等待事件回调执行完毕 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习Vue！&lt;/h2&gt; &lt;!-- prevent：阻止默认事件（常用） --&gt; &lt;a href=&quot;https://www.bilibili.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; &lt;!-- stop:阻止事件冒泡（常用） --&gt; &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt; &lt;button @click.stop=&quot;showInfo&quot;&gt;点我一下&lt;/button&gt; &lt;/div&gt; &lt;!-- once:事件只触发一次（常用） --&gt; &lt;button @click.once=&quot;showInfo&quot;&gt;点我一下&lt;/button&gt; &lt;!-- capture：使用事件的捕获方式 --&gt; &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(&#x27;box1&#x27;)&quot;&gt; div1 &lt;div class=&quot;box2&quot; @click=&quot;showMsg(&#x27;box2&#x27;)&quot;&gt; div2 &lt;/div&gt; &lt;/div&gt; &lt;!-- self:只有event.taegent是当前操作的元素时才触发事件 --&gt; &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt; &lt;button @click=&quot;showInfo&quot;&gt;点我一下&lt;/button&gt; &lt;/div&gt; &lt;!-- passive：事件的默认认为立即执行，无需等待事件回调执行完毕 --&gt; &lt;ul @scroll=&quot;demo1&quot; class=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;ul @wheel.passive=&quot;demo2&quot; class=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;b站&quot; &#125;, methods:&#123; showInfo(e)&#123; // e.stopPropagation();//阻止冒泡 // e.cancelBubble=true;//阻止冒泡 // e.preventDefault();//取消默认行为 console.log(e.target); alert(&quot;你好呀！&quot;); &#125;, showMsg(msg)&#123; console.log(&quot;你好&quot;+msg); &#125;, demo1()&#123; console.log(&quot;滚动了1&quot;); &#125;, demo2()&#123; for(let i=0;i&lt;100000;i++)&#123; console.log(&quot;#&quot;); &#125; console.log(&quot;累坏了&quot;); console.log(&quot;滚动了2&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、键盘事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、Vue常用的按键别名： 1、回车=&gt;enter 2、删除=&gt;delete （捕获“删除”和“退格”键） 3、退出=&gt;esc 4、空格=&gt;space 5、换行=&gt;tab(特殊，必须配合keydown去使用) 6、上=&gt;up 7、下=&gt;down 8、左=&gt;left 9、右=&gt;right 2、Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 3、系统修饰键（用法特殊）：ctrl、alt、shift、meta（window） (1).配合keyup使用，按下修饰符的同时按下其他键，随后释放其他键，事件才会被触发 (2).配合keydown使用：正常触发事件 4、也可以使用keyCode去指定具体的按键(不推荐) 5、Vue.config.keyCodes.自定义键名 = 键码。可以定制按键别名 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习Vue！&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.huiche=&quot;showInfo&quot;&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; Vue.config.keyCodes.huiche=[13,65];//可以指定数组 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;b站&quot; &#125;, methods:&#123; showInfo(e)&#123; console.log(e.key,e.keyCode); // if(e.keyCode!==13) return; console.log(e.target.value); &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 4、事件总结修饰符是可以连着写的，注意顺序有别！ 给键盘事件绑定时，可以连着绑定多个键名，代表一起时才生效！ 10、计算属性1、姓名案例—-插值语法实现12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 姓名：&lt;span&gt;&#123;&#123;firstName+&quot;-&quot;+lastName&#125;&#125;&lt;/span&gt; --&gt; 姓名：&lt;span&gt;&#123;&#123;firstName.slice(0,3)&#125;&#125;-&#123;&#123;lastName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、姓名案例—-methods实现12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 姓名：&lt;span&gt;&#123;&#123;firstName+&quot;-&quot;+lastName&#125;&#125;&lt;/span&gt; --&gt; 姓名：&lt;span&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot; &#125;, methods:&#123; getFullName()&#123; console.log(&quot;执行getFullName&quot;); return this.firstName.slice(0,3)+&#x27;-&#x27;+this.lastName; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、姓名案例—计算属性实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 计算属性： 1、定义：要用的属性不存在，要通过已有属性计算得来 2、原理：底层借助了Object.defineproperty方法提供的getter和setter 3、get函数声明时候执行？ （1）初次读书时会执行一次 （2）当依赖的数据发生改变时会被再次被调用 4、优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便 5、备注： 1、计算属性最终会出现在vm上，直接读取使用即可 2、如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发送改变 --&gt; &lt;div id=&quot;root&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 姓名：&lt;span&gt;&#123;&#123;firstName+&quot;-&quot;+lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- 有缓存机制，只调用一次get --&gt; 姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; --&gt; &lt;!-- 姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot; &#125;, computed:&#123; /* vm中存在的fullName是保存了调用get得到的返回值同名属性，而不是直接将此处的fullName放到vm中 */ fullName:&#123; // get有什么作用？ // 当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 // get什么时候调用？ /* 1、初次读取fullName时 2、所依赖的数据发生变化时 */ get()&#123; console.log(&quot;get被调用了&quot;); return this.firstName+&#x27;-&#x27;+this.lastName; &#125;, /* set什么时候调用，当fullName被修改时 */ set(value)&#123; console.log(&quot;set被调用了&quot;); const arr =value.split(&quot;-&quot;); this.firstName=arr[0]; this.lastName=arr[1]; &#125; &#125; &#125; &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 4、姓名案例—计算属性简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; 姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot; &#125;, computed:&#123; // 完整写法 /* fullName:&#123; get()&#123; console.log(&quot;get被调用了&quot;); return this.firstName+&#x27;-&#x27;+this.lastName; &#125;, set(value)&#123; console.log(&quot;set被调用了&quot;); const arr =value.split(&quot;-&quot;); this.firstName=arr[0]; this.lastName=arr[1]; &#125; &#125; */ // 简写 fullName()&#123; console.log(&quot;get被调用了&quot;); return this.firstName+&#x27;-&#x27;+this.lastName; &#125; &#125; &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 11、监视属性1、天气案例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- &lt;h2&gt;今天天气很&#123;&#123;isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&#125;&lt;/h2&gt; --&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;,&#123;&#123;x&#125;&#125;&lt;/h2&gt; &lt;!-- 事件@xxx=&quot;yyy&quot; yyy可以写一些简单的语句 --&gt; &lt;!-- &lt;button 绑定事件的时候 @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt; --&gt; &lt;!-- &lt;button @click=&quot;isHot=!isHot&quot;&gt;切换天气&lt;/button&gt; --&gt; &lt;button @click=&quot;window.alert(1)&quot;&gt;切换天气&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&quot;#root&quot;, data:&#123; isHot:true, x:1, window &#125;, computed:&#123; info()&#123; return this.isHot?&quot;炎热&quot;:&quot;凉爽&quot;; &#125; &#125;, methods: &#123; /* changeWeather()&#123; this.isHot=!this.isHot; this.x++; &#125; */ &#125;, &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 2、天气案例—-监视属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、当被监视的属性变化时，回调函数自动调用，进行相关操作 2、监视的属性必须存在，才能进行监视 3、监视的两种写法： （1）new Vue 时传入watch配置 （2）通过vm.$watch监视 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&quot;#root&quot;, data:&#123; isHot:true &#125;, computed:&#123; info()&#123; return this.isHot?&quot;炎热&quot;:&quot;凉爽&quot;; &#125; &#125;, methods: &#123; changeWeather()&#123; this.isHot=!this.isHot; this.x++; &#125; &#125;, /* watch:&#123; //也能监视info isHot:&#123; immediate:true,//初始化时让handler调用一下 // handler什么时候调用？当isHot发生改变时 handler(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125; &#125; &#125; */ &#125;); vm.$watch(&#x27;isHot&#x27;,&#123; immediate:true,//初始化时让handler调用一下 // handler什么时候调用？当isHot发生改变时 handler(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、深度监视123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 深度监视： （1）Vue中的watch默认不检测对象内部值的改变（一层） （2）配置deep:true可以监测对象内布值改变（多层） 备注: （1）Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以 （2）使用watch时可以根据数据的具体结构，决定是否采用深度监视 --&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt; &lt;hr&gt; &lt;h3&gt;a的值是&#123;&#123;numbers.a&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a加1&lt;/button&gt; &lt;h3&gt;b的值是&#123;&#123;numbers.b&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b加1&lt;/button&gt; &lt;button @click=&quot;numbers=&#123;a:666,b:999&#125;&quot;&gt;替换numbers&lt;/button&gt; &#123;&#123;numbers.c.d.e&#125;&#125; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&quot;#root&quot;, data:&#123; isHot:true, numbers:&#123; a:1, b:1, c:&#123; d:&#123; e:100 &#125; &#125; &#125; &#125;, computed:&#123; info()&#123; return this.isHot?&quot;炎热&quot;:&quot;凉爽&quot;; &#125; &#125;, methods: &#123; changeWeather()&#123; this.isHot=!this.isHot; this.x++; &#125; &#125;, watch:&#123; //也能监视info isHot:&#123; // immediate:true,//初始化时让handler调用一下 // handler什么时候调用？当isHot发生改变时 handler(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125; &#125;, //监视多级结构中某个属性的变化 /* &#x27;numbers.a&#x27;:&#123; handler()&#123; console.log(&quot;a被改变了&quot;); &#125; &#125; */ // 监视多级结构中所有属性的变化 numbers:&#123; deep:true, handler()&#123; console.log(&quot;numbers改变了&quot;); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 4、深度监视—简写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&quot;#root&quot;, data:&#123; isHot:true, &#125;, computed:&#123; info()&#123; return this.isHot?&quot;炎热&quot;:&quot;凉爽&quot;; &#125; &#125;, methods: &#123; changeWeather()&#123; this.isHot=!this.isHot; this.x++; &#125; &#125;, watch:&#123; //也能监视info // 正常写法 /* isHot:&#123; // deep:true,//深度监视 // immediate:true,//初始化时让handler调用一下 handler(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125; &#125;, */ // 简写 /* isHot(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125;, */ &#125; &#125;); // 正常写法 /* vm.$watch(&#x27;isHot&#x27;,&#123; // deep:true,//深度监视 // immediate:true,//初始化时让handler调用一下 handler(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125; &#125;); */ vm.$watch(&#x27;isHot&#x27;,function(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;,newValue,oldValue); &#125;); &lt;/script&gt;&lt;/html&gt; 5、姓名案例–watch实现（监视和计算的区别）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- computed和watch之间的区别： 1、computed能完成的功能，watch都能完成 2、watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作 两个重要小原则： 1、所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象 2、所有不被Vue管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等），最好都写成箭头函数 这样this的指向才是vm或组件实例对象 --&gt; &lt;div id=&quot;root&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br&gt;&lt;br&gt; 姓名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; firstName:&quot;张&quot;, lastName:&quot;三&quot;, fullName:&quot;张-三&quot; &#125;, watch:&#123; firstName(newValue)&#123; //可以实现异步操作 // 定时器由js引擎调用 /* setTimeout(()=&gt;&#123; this.fullName = newValue+&quot;-&quot;+this.lastName; &#125;,1000); */ this.fullName = newValue+&quot;-&quot;+this.lastName; &#125;, lastName(newValue)&#123; this.fullName = this.firstName+&quot;-&quot;+newValue; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 12、绑定样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .basic&#123; width: 400px; height: 100px; border: 1px solid black; &#125; .happy&#123; border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); &#125; .sad&#123; border: 4px dashed rgb(2, 197, 2); background-color: gray; &#125; .normal&#123; background-color: skyblue; &#125; .atguigu1&#123; background-color: yellowgreen; &#125; .atguigu2&#123; font-size: 30px; text-shadow:2px 2px 10px red; &#125; .atguigu3&#123; border-radius: 20px; &#125; &lt;/style&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 绑定样式： 1、class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组 字符串写法适用于：类名不确定，要动态获取 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定 数组写法适用于：要绑定多个样式，个数确定，名字确定，1但是不确定用不用 2、style样式 :style=&quot;&#123;fontSize:xxx&quot;&#125;&quot;其中xxx是动态值 :style=&quot;[a,b]&quot; 其中a，b是样式对象 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 绑定class样式---字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 绑定class样式---数组写法，适用于：要绑定的样式个数不确定，名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 绑定class样式---对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- &lt;div class=&quot;basic&quot; :style=&quot;&#123;fontSize:fsize+&#x27;px&#x27;&#125;&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; --&gt; &lt;!-- 绑定style---对象写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 绑定style---数组写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;[styleObj,styleObj2]&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;Vue&quot;, mood:&#x27;normal&#x27;, classArr:[&#x27;atguigu1&#x27;,&#x27;atguigu2&#x27;,&#x27;atguigu3&#x27;], classObj:&#123; atguigu1:false, atguigu2:false, &#125;, // fsize:40 styleObj:&#123; fontSize:&#x27;40px&#x27;, color:&#x27;red&#x27;, // backgroundColor:&#x27;yellow&#x27;, &#125;, styleObj2:&#123; /* fontSize:&#x27;40px&#x27;, color:&#x27;red&#x27;, */ backgroundColor:&#x27;yellow&#x27;, &#125;, styleArr:[ &#123; fontSize:&#x27;40px&#x27;, color:&#x27;blue&#x27;, backgroundColor:&#x27;green&#x27;, &#125;, ] &#125;, methods: &#123; changeMood()&#123; const arr = [&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;]; let i =Math.floor(Math.random()*3); console.log(i); this.mood=arr[i]; &#125; &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 13、条件渲染12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 条件渲染： 1、v-if 写法： （1）v-if=&quot;表达式&quot; （2）v-else-if=&quot;表达式&quot; （3）v-else=&quot;表达式&quot; 适用于：切换频率较低的场景 特点：不展示的DOM元素直接被移除 注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被打断 2、v-show 写法：v-show=&quot;表达式&quot; 适用于：切换频率较高的场景 特点：不展示的DOM元素未被移除，仅仅是使用样式进行隐藏 3、备注：使用v-if时，元素可能无法获取到，而使用v-show一定可以获取到 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;当前的n值是&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;!-- 使用v-show做条件渲染---display=none --&gt; &lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- &lt;h2 v-show=&quot;1===1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- 使用v-if做条件渲染---直接删除页面结构 --&gt; &lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- &lt;h2 v-if=&quot;1===1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- &lt;div v-show=&quot;n===1&quot;&gt;Angular&lt;/div&gt; &lt;div v-show=&quot;n===2&quot;&gt;React&lt;/div&gt; &lt;div v-show=&quot;n===3&quot;&gt;Vue&lt;/div&gt; --&gt; &lt;!-- v-else和v-else-if --&gt; &lt;!-- &lt;div v-if=&quot;n===1&quot;&gt;Angular&lt;/div&gt; &lt;div v-else-if=&quot;n===2&quot;&gt;React&lt;/div&gt; &lt;div v-else-if=&quot;n===3&quot;&gt;Vue&lt;/div&gt; &lt;div v-else&gt;其他都是我&lt;/div&gt; --&gt; &lt;!-- &lt;div v-show=&quot;n===1&quot;&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;Vue&lt;/h2&gt; &lt;h2&gt;Hhhhh&lt;/h2&gt; &lt;/div&gt; --&gt; &lt;!-- 只能写v-if与template配合使用 --&gt; &lt;template v-if=&quot;n===1&quot;&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;Vue&lt;/h2&gt; &lt;h2&gt;Hhhhh&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&quot;Vue&quot;, n:0, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 14、列表渲染1、基本列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- v-for 1、用于展示列表数据 2、语法：v-for=&quot;(item,index) in xxx&quot; :key=&quot;yyy&quot; 3、可遍历：数组、对象、字符串（用得少）、指定次数（用得少） --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 遍历数组 --&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历对象 --&gt; &lt;h2&gt;汽车信息&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,k) in car&quot; :key=&quot;k&quot;&gt; &#123;&#123;k&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历字符串 --&gt; &lt;h2&gt;测试遍历字符串&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(char,index) in str&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;char&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历指定次数 --&gt; &lt;h2&gt;测试遍历指定次数&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(number,index) in 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;number&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;王五&#x27;,age:20&#125;, ], car:&#123; name:&#x27;奥迪A8&#x27;, price: &#x27;70w&#x27;, color:&#x27;黑色&#x27; &#125;, str:&#x27;hello&#x27;, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、key的原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 面试题：react、vue中的key有什么作用，（key的内部原理） 1、虚拟DOM中key的作用： key是虚拟DOM对象的标识，当状态中的数据发送变化时，Vue会根据【新数据生成【新的虚拟DOM】 随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的差异比较，比较规则如下： 2、对比规则： （1）旧虚拟DOM中找到了与新虚拟DOM相同的key： ①若虚拟DOM中内容吗没变，直接使用之前的真实DOM ②若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM （2）就虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到页面 3、用index作为key可能会引发的问题： 1、若对数据进行：逆序添加、逆序删除等破坏顺序的操作： 会产生没有必要的真实DOM更新==&gt;界面效果没问题，但是效率低 2、如果结构中还包含输入类的DOM： 会产生错误的DOM更新==&gt;界面有问题 4、开发中如何选择key： 1、最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值 2、如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 遍历数组 --&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;button @click.once=&quot;add&quot;&gt;在开头添加一个老刘&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;王五&#x27;,age:20&#125;, ], &#125;, methods: &#123; add()&#123; const p = &#123;id:&#x27;004&#x27;,name:&quot;老刘&quot;,age:40&#125;; this.persons.unshift(p); &#125; &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 3、列表的过滤123456789101112131415161718192021222324252627282930/* filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。 filter()基本语法： arr.filter(callback[, thisArg]) filter()参数介绍： 参数名 说明 callback 用来测试数组的每个元素的函数。调用时使用参数 (element, index, array) 返回true表示保留该元素（通过测试），false则不保留。 thisArg 可选。执行 callback 时的用于 this 的值。 filter()用法说明： filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。 callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。 callback 被调用时传入三个参数： 元素的值 元素的索引 被遍历的数组 如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的this 值在非严格模式下将是全局对象，严格模式下为 undefined。 filter 不会改变原数组。 filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。 如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyword&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) in filterPersons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 用watch实现 /* new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; keyword:&#x27;&#x27;, persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:18,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,sex:&#x27;男&#x27;&#125;, ], filterPersons:[] &#125;, watch:&#123; keyword:&#123; immediate:true, handler(val)&#123; // console.log(&quot;keyword被该了：&quot;+newValue); this.filterPersons = this.persons.filter((p)=&gt;&#123; return p.name.indexOf(val)!==-1; &#125;) &#125; &#125; &#125; &#125;); */ // 用computed实现 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; keyword:&#x27;&#x27;, persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:18,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,sex:&#x27;男&#x27;&#125;, ], &#125;, computed:&#123; filterPersons()&#123; return this.persons.filter((p)=&gt;&#123; return p.name.indexOf(this.keyword)!==-1 &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 4、列表排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyword&quot;&gt; &lt;button @click=&quot;sortType=2&quot;&gt;年龄升序&lt;/button&gt; &lt;button @click=&quot;sortType=1&quot;&gt;年龄降序&lt;/button&gt; &lt;button @click=&quot;sortType=0&quot;&gt;原顺序&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) in filterPersons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 用computed实现 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; keyword:&#x27;&#x27;, sortType:0,//0原顺序，1降序，2升序 persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:28,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:30,sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:11,sex:&#x27;男&#x27;&#125;, ], &#125;, computed:&#123; filterPersons()&#123; const arr= this.persons.filter((p)=&gt;&#123; return p.name.indexOf(this.keyword)!==-1 &#125;); // 判断是否需要排序 if(this.sortType)&#123; arr.sort((p1,p2)=&gt;&#123; // 升序 return this.sortType===2?p1.age-p2.age:p2.age-p1.age; &#125;); &#125; return arr; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 5、更新数据时的一个问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 用computed实现 const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; persons:[ &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:28,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:30,sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:11,sex:&#x27;男&#x27;&#125;, ], &#125;, methods:&#123; updateMei()&#123; /* this.persons[0].name=&#x27;马老师&#x27;; this.persons[0].age=50; this.persons[0].sex=&#x27;男&#x27;; */ //奏效 /* this.persons[0]=&#123; id:&#x27;001&#x27;, name:&#x27;马老师&#x27;, age:50, sex:&#x27;男&#x27; &#125;; */ this.persons.splice(0,1,&#123;id:&#x27;001&#x27;, name:&#x27;马老师&#x27;, age:50, sex:&#x27;男&#x27;&#125;); &#125; &#125; &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 6、Vue监测数据改变的原理12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, student:&#123; name:&#x27;tom&#x27;, age:&#123; rage:40, sage:18 &#125;, friends:[ &#123; name:&#x27;jol&#x27;, age:19 &#125; ] &#125; &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 7、模拟一个数据的监测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let data = &#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27; &#125;; // 创建一个监视的实例对象，用于监视data中属性的变化 const obs = new Observer(data); console.log(obs); // 准备一个vm实例对象 let vm = &#123;&#125; vm._data = data = obs; function Observer(obj)&#123; // 汇总对象中所有的属性形成一个数组 const keys = Object.keys(obj); // 遍历 keys.forEach((k)=&gt;&#123; Object.defineProperty(this,k,&#123; get()&#123; return obj[k]; &#125;, set(val)&#123; console.log(`$&#123;k&#125;被改了，我要去解析模板，生成虚拟DOM.....`); obj[k]=val; &#125; &#125;) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8、Vue.set()的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;学校信息&lt;/h1&gt; &lt;h2&gt;学校名称：&#123;&#123;school.name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;school.address&#125;&#125;&lt;/h2&gt; &lt;h2&gt;校长：&#123;&#123;school.leader&#125;&#125;&lt;/h2&gt; &lt;hr&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=&quot;addSex&quot;&gt;添加一个性别属性，默认值男&lt;/button&gt; &lt;h2&gt;姓名:&#123;&#123;student.name&#125;&#125;&lt;/h2&gt; &lt;h2 v-if=&quot;student.sex&quot;&gt;性别:&#123;&#123;student.sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;年龄: 真实：&#123;&#123;student.age.rage&#125;&#125;，对外：&#123;&#123;student.age.sage&#125;&#125;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;朋友们&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot; (f,index) in student.friends&quot; :key=&quot;index&quot;&gt; &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; school:&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125;, student:&#123; name:&#x27;tom&#x27;, age:&#123; rage:40, sage:18 &#125;, friends:[ &#123; name:&#x27;jol&#x27;, age:19 &#125;, &#123; name:&#x27;lili&#x27;, age:20 &#125; ] &#125;, &#125;, methods: &#123; addSex()&#123; // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); this.$set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 9、Vue监测数据改变的原理—数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;学校信息&lt;/h1&gt; &lt;h2&gt;学校名称：&#123;&#123;school.name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;school.address&#125;&#125;&lt;/h2&gt; &lt;h2&gt;校长：&#123;&#123;school.leader&#125;&#125;&lt;/h2&gt; &lt;hr&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=&quot;addSex&quot;&gt;添加一个性别属性，默认值男&lt;/button&gt; &lt;h2&gt;姓名:&#123;&#123;student.name&#125;&#125;&lt;/h2&gt; &lt;h2 v-if=&quot;student.sex&quot;&gt;性别:&#123;&#123;student.sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;年龄: 真实：&#123;&#123;student.age.rage&#125;&#125;，对外：&#123;&#123;student.age.sage&#125;&#125;&lt;/h2&gt; &lt;hr&gt; &lt;h2&gt;爱好&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot; (h,index) in student.hobbies&quot; :key=&quot;index&quot;&gt; &#123;&#123;h&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;朋友们&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot; (f,index) in student.friends&quot; :key=&quot;index&quot;&gt; &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; school:&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125;, student:&#123; name:&#x27;tom&#x27;, age:&#123; rage:40, sage:18 &#125;, hobbies:[ &#x27;抽烟&#x27;,&#x27;喝酒&#x27;,&#x27;烫头&#x27;], friends:[ &#123; name:&#x27;jol&#x27;, age:19 &#125;, &#123; name:&#x27;lili&#x27;, age:20 &#125; ] &#125;, &#125;, methods: &#123; addSex()&#123; // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); this.$set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 10、总结Vue数据监测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;总结数据监视&lt;/title&gt; &lt;style&gt; button&#123; margin-top: 10px; &#125; &lt;/style&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Vue监视数据的原理： 1. vue会监视data中所有层次的数据。 2. 如何监测对象中的数据？ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 (1).对象中后追加的属性，Vue默认不做响应式处理 (2).如需给后添加的属性做响应式，请使用如下API： Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value) 3. 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事： (1).调用原生对应的方法对数组进行更新。 (2).重新解析模板，进而更新页面。 4.在Vue修改数组中的某个元素一定要用如下方法： 1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() 2.Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！ --&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;student.sex==&#x27;男&#x27; ? student.sex=&#x27;女&#x27;: student.sex=&#x27;男&#x27; &quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;updateFName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;updateFHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt; &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt; &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt; &lt;h3&gt;爱好：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt; &#123;&#123;h&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;朋友们：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt; &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; student:&#123; name:&#x27;tom&#x27;, age:18, hobby:[&#x27;抽烟&#x27;,&#x27;喝酒&#x27;,&#x27;烫头&#x27;], friends:[ &#123;name:&#x27;jerry&#x27;,age:35&#125;, &#123;name:&#x27;tony&#x27;,age:36&#125; ] &#125; &#125;, methods: &#123; addSex()&#123; // Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); this.$set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;); &#125;, addFriend()&#123; this.student.friends.unshift(&#123;name:&#x27;jack&#x27;,age:23&#125;); &#125;, updateFName()&#123; this.student.friends[0].name=&#x27;张三&#x27;; &#125;, addHobby()&#123; this.student.hobby.unshift(&#x27;学习&#x27;); &#125;, updateFHobby()&#123; // this.student.hobby.splice(0,1,&#x27;开车&#x27;); // this.$set(this.student.hobby,0,&#x27;开车&#x27;); Vue.set(this.student.hobby,0,&#x27;开车&#x27;); &#125;, removeSmoke()&#123; this.student.hobby = this.student.hobby.filter((h)=&gt;&#123; return h!==&#x27;抽烟&#x27;; &#125;); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/html&gt; 15、收集表单数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 收集表单数据： 若:&lt;input type=&quot;text&quot;/&gt;.则v-model收集的是value值，用户输入的就是value值 若:&lt;input type=&quot;radio&quot;/&gt;.则v-model收集的就是value值，且要给标签配置value值 若：&lt;input type=&quot;checkbox&quot;/&gt; 1、没有配置input的value属性，那么收集的就是checked（勾选为true，未勾选为false） 2、配置input的value属性： （1）v-model的初始值是非数组，那么收集的就是checked（勾选为true，未勾选为false） （2）v-model的初始值是数组，那么收集的就是value组成的数组 3、备注：v-model的三个修饰符 lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;form @submit.prevent=&quot;demo&quot;&gt; &lt;!-- &lt;label for=&quot;uno&quot;&gt;账号: &lt;/label&gt; --&gt; &lt;!-- &lt;input type=&quot;text&quot; id=&quot;uno&quot;&gt; --&gt; 账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt;&lt;br&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; v-model.trim=&quot;userInfo.password&quot;&gt;&lt;br&gt;&lt;br&gt; 年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;&lt;br&gt;&lt;br&gt; 性别： 男&lt;input type=&quot;radio&quot; value=&quot;male&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; &gt; 女&lt;input type=&quot;radio&quot; value=&quot;female&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot;&gt;&lt;br&gt;&lt;br&gt; 爱好： 学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt; 打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt; 打篮球&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;basketball&quot;&gt;&lt;br&gt;&lt;br&gt; 所属校区： &lt;select v-model=&quot;userInfo.city&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt; &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;br&gt;&lt;br&gt; 其他信息： &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;https://www.bilibili.com&quot;&gt;《用户协议》&lt;/a&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; userInfo:&#123; account:&#x27;&#x27;, password:&#x27;&#x27;, sex:&#x27;male&#x27;, age:&#x27;&#x27;, hobby:[], city:&#x27;&#x27;, other:&#x27;&#x27;, agree:false &#125;, &#125;, methods: &#123; demo()&#123; // alert(1); console.log(JSON.stringify(this.userInfo)); &#125; &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 16、过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/dayjs.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 过滤器： 定义：要对显示的数据进行特定格式化后显示（适用于一些简单逻辑的处理） 语法： 1、注册过滤器：Vue.fliter(name,callback)或 new Vue(filters:&#123;&#125;) 2、使用过滤器：&#123;&#123;xxx | 过滤器名&#125;&#125; 或 v-bind:属性 = &#x27;xxx | 过滤器名&#x27; 备注： 1、过滤器也可以接收额外参数、多个过滤器也可以串联 2、并没有改变原本的数据，是产生新的对应的数据 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是:&#123;&#123;fmTime&#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是:&#123;&#123;getFmTime()&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是:&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器传参实现 --&gt; &lt;h3&gt;现在是:&#123;&#123;time | timeFormater(&#x27;YYYY-MM-DD&#x27;)&#125;&#125;&lt;/h3&gt; &lt;!-- 多个过滤器传参实现 --&gt; &lt;h3&gt;现在是:&#123;&#123;time | timeFormater(&#x27;YYYY-MM-DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt; &lt;!-- 不允许以下形式 --&gt; &lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;msg | mySlice&quot;&gt; --&gt; &lt;/div&gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123;msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 必须写在new Vue前 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4); &#125;); new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:Date.now(),//时间戳 msg:&#x27;你好，Vue！&#x27;, &#125;, computed:&#123; fmTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;); &#125; &#125;, methods:&#123; getFmTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;); &#125; &#125;, filters:&#123; timeFormater(value,str=&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; return dayjs(value).format(str); &#125;, &#125; &#125;); new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,Vue!&#x27;, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 17、内置指令1、v-text1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我们学过的指令： v-bind：单向数据绑定解析表达式，可简写为：xxx v-model：双向数据绑定 v-for：遍历数组/对象/字符串 v-on：绑定事件监听，可简写为@ v-if：条件渲染（动态控制节点是否存在） v-else：条件渲染（动态控制节点是否存在） v-show：条件渲染（动态控制节点是否展示） v-text指令： 1、作用：向其所在的节点中渲染文本内容 2、与插值语法的区别：v-text会替换掉节点的内容，&#123;&#123;xxx&#125;&#125;则不会 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt; &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;Vue&#x27;, str:&#x27;&lt;h3&gt;你好！&lt;/h3&gt;&#x27;, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、v-html123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- v-html指令： 1、作用：向指定节点中渲染包含html结构的内容 2、与插值语法的区别： （1）v-html会替换掉节点中所有的内容，&#123;&#123;xxx&#125;&#125;不会 （2）v-html可以识别html结构 3、严重注意：v-html有安全性问题！！！ （1）在网站上动态渲染任意HTML是非常危险的，容易导致xss攻击 （2）一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ --&gt; &lt;div id=&quot;root&quot;&gt; &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt; &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;Vue&#x27;, str:&#x27;&lt;h3&gt;你好！&lt;/h3&gt;&#x27;, str2:&#x27;&lt;a href=javascript:location.href=&quot;https://www.bilibili.com?&quot;+document.cookie&gt;18禁！！！&lt;/a&gt;&#x27;, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、v-cloak指令1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak]&#123; display: none; &#125; &lt;/style&gt; &lt;!-- &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- v-cloak指令（无值）： 1、本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-vloak属性 2、使用css配合v-cloak可以解决网速慢时页面显示出&#123;&#123;XXX&#125;&#125;的问题 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- vue接管容器后，v-cloak就会被删除，样式失效，重新显示 --&gt; &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;//加载慢5s&lt;/body&gt; &lt;script&gt; console.log(1); new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;Vue&#x27; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 4、v-once1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- v-once指令： 1、v-once所在节点在初次动态渲染后，就视为静态内容了 2、以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 v-once&gt;初识化的n值：&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; n:1, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 5、v-pre指令12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- v-pre指令： 1、跳过所在节点的编译的过程 2、可利用它跳过：没有使用指令语法、插值语法的节点，会加快编译 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt; &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; n:1 &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 18、自定义指令1、函数式1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; n:1, &#125;, directives:&#123; /* big:&#123; &#125; */ /* big:function()&#123; &#125; */ // big函数何时被调用？ // 1、指令与元素成功绑定时（一上来）2、指令所在的模板被重新解析时 big(element,binding)&#123; // console.log(element instanceof HTMLElement); // console.log(element,binding.value); element.innerText = binding.value*10; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、对象式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;input type=&quot;text&quot; :value=&quot;n&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div id=&quot;root2&quot;&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;x&quot;&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 定义全局自定义指令 Vue.directive(&#x27;fbind&#x27;,&#123; bind(element,binding)&#123; element.value=binding.value; &#125;, inserted(element,binding)&#123; element.focus(); &#125;, update(element,binding)&#123; element.value=binding.value; &#125; &#125;); new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; n:1, &#125;, directives:&#123; // 1、指令与元素成功绑定时（一上来）2、指令所在的模板被重新解析时 /* fbind(element,binding)&#123; element.value=binding.value; element.focus(); &#125; */ /* fbind:&#123; // 指令与元素成功绑定时（一上来） // 下面的this都是window bind(element,binding)&#123; console.log(&#x27;fbind-bind&#x27;,this); console.log(&#x27;bind&#x27;); element.value=binding.value; &#125;, // 指令所在元素被插入页面时 inserted(element,binding)&#123; console.log(&#x27;fbind-inserted&#x27;,this); console.log(&#x27;inserted&#x27;); element.focus(); &#125;, // 指令所在的模板被重新解析时 update(element,binding)&#123; console.log(&#x27;fbind-update&#x27;,this); console.log(&#x27;update&#x27;); element.value=binding.value; // element.focus(); &#125; &#125; */ &#125; &#125;); new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; x:1 &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、回顾一个DOM操作1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .demo&#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;点我创建一个输入框&lt;/button&gt; &lt;script&gt; const btn = document.getElementById(&#x27;btn&#x27;); btn.onclick=()=&gt;&#123; const input = document.createElement(&#x27;input&#x27;); // 执行不了 // input.focus(); input.className=&#x27;demo&#x27;; input.value =99; input.onclick=()=&gt;&#123; alert(1); &#125;; // 执行不了 // input.parentElement.style.backgroundColor=&#x27;skyblue&#x27;; document.body.appendChild(input); input.focus(); input.parentElement.style.backgroundColor=&#x27;skyblue&#x27;; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、指令总结12345678910111213141516171819202122232425&lt;!-- 自定义指令总结： 一、定义语法: （1）局部指令： new Vue(&#123; directives:&#123; 指令名:配置对象 &#125; &#125;); 或 new Vue(&#123; directives:&#123; 指令名：回调函数 &#125; &#125;); （2）全局指令： Vue.directive(指令名，配置对象)或 Vue.directive(指令名，回调函数) 二、配置对象中常用的三个回调： （1）bind：指令与元素成功绑定时调用 （2）inserted：指令所在模板插入页面时调用 （3）update：指令所在模板结构被重新解析时调用 三、备注： 1、指令定义时不加v-，但在使用时需要加v- 2、指令名如果是多个单词，需要使用kebab-case命名方式，不要用camelCase命名 --&gt; 19、生命周期1、引出生命周期12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 生命周期： 1、又名：生命周期回调函数、生命周期函数、生命周期钩子 2、是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数 3、生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 4、生命周期函数中的this指向是vm或组件实例对象 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; opacity:1, &#125;, methods: &#123; &#125;, // Vue完成模板的解析并把初始的真实的DOM元素放入页面后（挂载完毕）调用mounted mounted() &#123; setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0)&#123; this.opacity=1; &#125; &#125;,16); &#125;, &#125;); // 通过外部的定时器实现（不推荐） /* setInterval(()=&gt;&#123; vm.opacity-=0.01; if(vm.opacity&lt;=0)&#123; vm.opacity=1; &#125; &#125;,16); */ &lt;/script&gt;&lt;/html&gt; 2、分析生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 v-text=&quot;n&quot;&gt;&lt;/h2&gt; &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt; &lt;button @click=&quot;bye&quot;&gt;点我销毁vm&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#root&#x27;, /* template:` &lt;div&gt; &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt; `, */ data:&#123; n:1, &#125;, methods: &#123; add()&#123; console.log(&#x27;add&#x27;); this.n++; &#125;, bye()&#123; console.log(&#x27;bye&#x27;); this.$destroy(); &#125; &#125;, watch:&#123; n()&#123; console.log(&quot;n变了&quot;); &#125; &#125;, beforeCreate() &#123; // 数据代理还未开始 console.log(&#x27;beforeCreate&#x27;); console.log(this); // debugger; &#125;, created() &#123; console.log(&#x27;created&#x27;); // console.log(this); // debugger; &#125;, beforeMount() &#123; console.log(&#x27;beforeMount&#x27;); // console.log(this); // debugger; &#125;, mounted() &#123; console.log(&#x27;mounted&#x27;); // console.log(this); // debugger; &#125;, beforeUpdate() &#123; console.log(&#x27;beforeUpdate&#x27;); // 数据更新了，页面还未更新 console.log(this.n); // debugger; &#125;, updated() &#123; console.log(&#x27;updated&#x27;); // 数据更新了，页面还未更新 console.log(this.n); // debugger; &#125;, beforeDestroy() &#123; console.log(&#x27;beforeDestroy&#x27;); this.add(); &#125;, destroyed() &#123; // 没什么用 console.log(&#x27;destroyed&#x27;); console.log(this.n); &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 3、生命周期总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 常用的生命周期钩子： 1、mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅信息等（初始化操作） 2、beforeDestory：清除定时器、解绑自定义事件、取消订阅消息等（收尾工作） 关于销毁Vue实例： 1、销毁后借助Vue开发者工具看不到任何信息 2、销毁后自定义事件会失效、但原生DOM事件依然有效 3、一般不会在beforeDestory操作数据，因为即使操作了数据，也不会再触发更新流程了 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt; &lt;button @click=&quot;opacity=1&quot;&gt;透明度设置为1&lt;/button&gt; &lt;button @click=&quot;stop&quot;&gt;点我停止变化&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; opacity:1, &#125;, methods: &#123; stop()&#123; // clearInterval(this.timer); vm.$destroy(); &#125; &#125;, // Vue完成模板的解析并把初始的真实的DOM元素放入页面后（挂载完毕）调用mounted mounted() &#123; this.timer = setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0)&#123; this.opacity=1; &#125; &#125;,16); &#125;, beforeDestroy() &#123; clearInterval(this.timer); console.log(&quot;vm已经结束了&quot;); &#125;, &#125;); // 通过外部的定时器实现（不推荐） /* setInterval(()=&gt;&#123; vm.opacity-=0.01; if(vm.opacity&lt;=0)&#123; vm.opacity=1; &#125; &#125;,16); */ &lt;/script&gt;&lt;/html&gt; 20、Vue组件化编程 模块： 1、理解：向外提供特定功能的js程序，一般就是一个js文件 2、为什么：js文件很多很复杂 3、作用：复用js、简化js的编写、提高js运行效率 组件： 1、理解：用来实现局部（特定）功能效果的代码集合（html&#x2F;css&#x2F;js&#x2F;image&#x2F;…) 2、为什么：一个界面的功能很复杂 3、作用：复用编码、简化项目编码、提高运行效率 模块化： 当应用中的js都以模块来编写的，那么这个应用就是一个模块化应用 组件化： 当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 21、非单文件组件一个文件中包含有n个组件 1、基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Vue中使用组件的三大步骤： 一、定义组件（创建组件） 二、注册组件 三、使用组件（写组件标签） 一、如何定义一个组件？ 使用Vue.extend(options)创建，其中options和new Vue(options)是传入的那个options几乎一模一样，但是 区别如下： 1、el不要写，为什么？——最终所有的组件都要经过一个vm的管理，由vm中的el决定服务于哪个容器 2、data必须写成函数，为什么？——避免组件被复用是，数据存在引用关系 备注：使用template可以配置组件结构 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 3、使用school组件 --&gt; &lt;school&gt;&lt;/school&gt; &lt;!-- &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; --&gt; &lt;hr&gt; &lt;!-- 3、使用student组件 --&gt; &lt;student&gt;&lt;/student&gt; &lt;!-- &lt;student&gt;&lt;/student&gt; --&gt; &lt;!-- &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; --&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;root2&quot;&gt; &lt;!-- &lt;student&gt;&lt;/student&gt; --&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 1、创建school组件 const school = Vue.extend(&#123; // el:&#x27;#root&#x27;,//组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器 template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&#x27;showName&#x27;&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data()&#123; return&#123; schoolName:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125;, methods: &#123; showName()&#123; alert(this.schoolName); &#125; &#125;, &#125;); // 1、创建student组件 const student = Vue.extend(&#123; // el:&#x27;#root&#x27;,//组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器 template:` &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; studentName:&#x27;小林&#x27;, age:18, &#125; &#125; &#125;); // 1、创建hello组件 const hello = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;Vue!&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; msg:&#x27;你好&#x27; &#125; &#125; &#125;); // 2、注册组件（全局注册） Vue.component(&#x27;hello&#x27;,hello); // 创建vm new Vue(&#123; el:&#x27;#root&#x27;, /* data:&#123; schoolName:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, studentName:&#x27;小林&#x27;, age:18, &#125; */ data:&#123; msg:&#x27;你好！&#x27;, &#125;, // 2、注册组件（局部注册） components:&#123; /* school:school, student:student, */ school, student, &#125; &#125;); new Vue(&#123; el:&#x27;#root2&#x27;, components:&#123; student, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 2、几个注意点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 几个注意点： 1、关于组件名： 一个单词组成： 第一种写法（首字母小写）：school 第二种写法（首字母大写）；School 多个单词组成： 第一种写法（kebab-case命名）：my-school 第二种写法（CamelCase命名）：MySchool（需要Vue脚手架支持） 备注： （1）组件名尽可能回避Html中已有的元素名称，例如：h2、H2都不行 （2）可以使用name配置项指定组件在vue开发者工具中显示的名字 2、关于组件标签： 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt; 备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染 3、一个简写方法： const school = Vue.extend(options) 可简写为：const school = options --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;school&gt;&lt;/school&gt; &lt;!-- &lt;my-school&gt;&lt;/my-school&gt; --&gt; &lt;!-- &lt;my-school/&gt; &lt;my-school/&gt; &lt;my-school/&gt; --&gt; &lt;!-- &lt;MySchool&gt;&lt;/MySchool&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; /* const s = Vue.extend(&#123; name:&#x27;gdufe&#x27;, template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; schoolName:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125; &#125;); */ const s =&#123; name:&#x27;gdufe&#x27;, template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; schoolName:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125; &#125;; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; msg:&#x27;欢迎来学习Vue！&#x27;, &#125;, components:&#123; school:s, // &#x27;my-school&#x27;:s, // MySchool:s, &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 3、组件的嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; --&gt; &lt;!-- &lt;app&gt;&lt;/app&gt; --&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 定义student组件 const student =Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;学生名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return&#123; name:&#x27;小林&#x27;, age:18, &#125; &#125; &#125;); // 定义school组件 const school =Vue.extend(&#123; name:&#x27;gdufe&#x27;, template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; `, data()&#123; return&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125;, // 注册组件（局部） components:&#123; student, &#125; &#125;); // 定义hello组件 const hello = Vue.extend(&#123; template:` &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; `, data()&#123; return&#123; msg:&#x27;欢迎学习Vue&#x27;, &#125; &#125;, &#125;); // 定义app组件 const app = Vue.extend(&#123; template:` &lt;div&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; `, components:&#123; school, hello &#125; &#125;); // 创建vue实例 new Vue(&#123; template:` &lt;app&gt;&lt;/app&gt; `, el:&#x27;#root&#x27;, // 注册组件（局部注册） components:&#123; app &#125; &#125;); &lt;/script&gt;&lt;/html&gt; app一人之下，万人之上 4、VueComponent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 关于：VueComponent： 1、school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的 2、我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;,Vue解析时会帮我们创建school组件的实例对象 即Vue帮我们执行的：new VueComponent(options). 3、特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent！！！ 4、关于this指向： （1）组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数，他们的this都是【VueComponent实例对象】 （2）new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数，他们的this都是【Vue实例对象】 5、VueComponent的实例对象，以后简称vc（也可以称为：组件实例对象） Vue的实例对象，以后简称vm --&gt; &lt;div id=&quot;root&quot;&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; // 定义school组件 const school =Vue.extend(&#123; name:&#x27;gdufe&#x27;, template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&#x27;showName&#x27;&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data()&#123; return&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125;, methods: &#123; showName()&#123; console.log(this); alert(this.name); &#125; &#125;, &#125;); // 定义test组件 const test = Vue.extend(&#123; template:` &lt;span&gt;&#123;&#123;test&#125;&#125;&lt;/span&gt; `, data()&#123; return&#123; test:&#x27;This is a test&#x27;, &#125; &#125;, &#125;); // 定义hello组件 const hello = Vue.extend(&#123; template:` &lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `, data()&#123; return&#123; msg:&#x27;欢迎学习Vue&#x27;, &#125; &#125;, components:&#123; test, &#125; &#125;); // console.log(school); // console.log(hello); // console.log(school===hello); // 创建vue实例 const vm = new Vue(&#123; el:&#x27;#root&#x27;, // 注册组件（局部注册） components:&#123; school, hello, &#125; &#125;); console.log(vm); &lt;/script&gt;&lt;/html&gt; 5、一个重要的内置关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、一个重要的内置关系：VueComponent.prototype.__proto__==Vue.prototype 2、为什么要有这个关系：让组件实例对象（vc）可以1访问到Vue原型上的属性、方法。 --&gt; &lt;div id=&quot;root&quot;&gt; school &lt;/div&gt;&lt;/body&gt; &lt;script&gt; Vue.prototype.x=99; // 定义school组件 const school =Vue.extend(&#123; name:&#x27;gdufe&#x27;, template:` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showX&quot;&gt;点我输出x&lt;/button&gt; &lt;/div&gt; `, data()&#123; return&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125;, methods: &#123; showX()&#123; console.log(this.x); &#125; &#125;, &#125;); // 创建一个vm new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; msg:&#x27;hello&#x27; &#125;, components:&#123; school, &#125; &#125;); // console.log(school.prototype.__proto__===Vue.prototype);//true // 定义一个构造函数 /* function Demo()&#123; this.a=1; this.b=2; &#125; // 创建一个Demo实例对象 const d = new Demo(); console.log(Demo.prototype);//显示原型属性 console.log(d.__proto__);//隐式原型属性 // 通过显示原型属性操作原型对象，追加一个x属性，值为99 Demo.prototype.x = 99; // console.log(d.__proto__.x); console.log(d.x); */ &lt;/script&gt;&lt;/html&gt; 22、单文件组件一个文件中只包含有一个组件 School.vue1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!-- 组件的结构 --&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;点我输出学校名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 组件交互相关的代码（数据、方法等等） export default &#123; name:&#x27;School&#x27;, data()&#123; return&#123; name:&#x27;广东财经大学&#x27;, address:&#x27;广州&#x27;, &#125; &#125;, methods: &#123; showName()&#123; console.log(this.name); &#125; &#125;, &#125;; // export &#123;school&#125; // export default school;&lt;/script&gt;&lt;style&gt; /* 组件的样式 */ .demo&#123; background-color:orange; &#125;&lt;/style&gt; Student.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;!-- 组件的结构 --&gt; &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 组件交互相关的代码（数据、方法等等） export default &#123; name:&#x27;Student&#x27;, data()&#123; return&#123; name:&#x27;小林&#x27;, age:21, &#125; &#125; &#125;;&lt;/script&gt; App.vue123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入组件 import SchoolVue from &#x27;./School.vue&#x27;; import StudentVue from &#x27;./Student.vue&#x27;; export default &#123; name:&#x27;App&#x27;, components:&#123; School, Student, &#125; &#125;&lt;/script&gt; main.js123456789import AppVue from &#x27;./App.vue&#x27;new Vue(&#123; el:(&quot;#root&quot;), template:`&lt;App&gt;&lt;/App&gt;`, components:&#123; App, &#125;,&#125;); index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习一下单文件组件的语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- &lt;App&gt;&lt;/App&gt; --&gt; &lt;/div&gt; &lt;!-- &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 以上代码还不能直接执行，需要在脚手架中才可以！！！ 23、Vue脚手架1、Vue脚手架是Vue官方提供的标准化开发工具（开发平台） 2、最新版本是4.x 3、文档：https://cli.vuejs.org/zh/ 1、操作步骤配置 npm 淘宝镜像：npm config set registry https://registry.npm.taobao.org 1234561、全局安装@vue/clinpm install -g @vue/cli2、切换到要创建项目的目录，创建项目vue create xxxx3、启动项目npm run serve 高版本启动报错—name 组件名需要多个单词，且使用驼峰写法 2、脚手架项目main.js 1234567891011121314151617181920212223242526272829303132333435/* 该文件是整个项目的入口文件*/// 引入Vue// import Vue from &quot;vue/dist/vue&quot;;import Vue from &quot;vue&quot;;// 引入App组件，它是所有组件的父组件import App from &#x27;./App.vue&#x27;// 关闭vue的生产提示Vue.config.productionTip=false/* 关于不同版本的Vue： 1、vue.js与vue.runtime.xxx.js的区别 （1）vue.js是完整版的vue，包含：核心功能+模板解析器 （2）vue.runtime.xxx.js是运行版的Vue，只包含：核心功能，没有模板解析器 2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用 render函数接收到的createElement函数去指定具体内容*/// 创建vue实例对象--vmnew Vue(&#123; el:(&quot;#app&quot;), // 将App组件放入容器中 render:h=&gt;h(App), // render:createElement=&gt;createElement(&#x27;h1&#x27;,&#x27;你好啊&#x27;) /* template:`&lt;App&gt;&lt;/App&gt;`, components:&#123; App, &#125;, */&#125;); 其他与上面代码一致 3、修改脚手架默认配置Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpakc 配置， 请执行：vue inspect &gt; output.js 修改默认配置：vue.config.js 123456789101112131415161718192021222324const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true&#125;)/* module.exports = &#123; pages: &#123; index: &#123; // page 的入口 entry: &#x27;src/index/main.js&#x27;, // 模板来源 template: &#x27;public/index.html&#x27;, // 在 dist/index.html 的输出 filename: &#x27;index.html&#x27;, // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: &#x27;Index Page&#x27;, // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: [&#x27;chunk-vendors&#x27;, &#x27;chunk-common&#x27;, &#x27;index&#x27;] &#125;, &#125;, linOnSave:false//关闭语法检查 &#125; */ 4、脚手架文件结构12345678910111213141516├── node_modules ├── public│ ├── favicon.ico: 页签图标│ └── index.html: 主页面├── src│ ├── assets: 存放静态资源│ │ └── logo.png│ │── component: 存放组件│ │ └── HelloWorld.vue│ │── App.vue: 汇总所有组件│ │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件 关于不同版本的Vue： 12341、vue.js与vue.runtime.xxx.js的区别 （1）vue.js是完整版的vue，包含：核心功能+模板解析器 （2）vue.runtime.xxx.js是运行版的Vue，只包含：核心功能，没有模板解析2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用 render函数接收到的createElement函数去指定具体内容 vue.config.js配置文件123使用vue inspect &gt; output.js 可以查看Vue脚手架的默认配置使用vue.config.js 可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh 24、ref属性12345671、被用来给元素或子组件注册引用信息（id的替换者）2、应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）3、使用方式： 打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;或&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt; 获取：this.$refs.xxx 源代码School.vue123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;SchoolS&#x27;, data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt; .school&#123; background-color: yellow; &#125;&lt;/style&gt; App.vue12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h1 v-text=&#x27;msg&#x27; ref=&quot;title&quot;&gt;&lt;/h1&gt; &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt; &lt;School ref=&quot;sch&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;School&#125;, data() &#123; return &#123; msg:&#x27;欢迎学习Vue！&#x27; &#125; &#125;, methods:&#123; showDOM()&#123; console.log(this.$refs.title);//真实DOM元素 console.log(this.$refs.btn);//真实DOM元素 console.log(this.$refs.sch);//School组件的实例对象vc &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; main.js12345678910111213// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); 25、props配置项配置项props 12345678910111213141516171819功能：让组件接收外部传过来的数据（1）传递数据： &lt;Demo name=&#x27;xxx&#x27;/&gt;（2）接收数据： 第一种方式（只接收）： props:[&#x27;name&#x27;] 第二种方式（限制类型）： props:&#123; name:Number &#125; 第三种方式（限制类型、限制必要性、指定默认值） props:&#123; name:&#123; type:String,//类型 required:true,//必要性 default:&#x27;老王&#x27;//默认值 &#125; &#125;备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 源代码student.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;myAge+1&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; msg:&#x27;我是一个学生&#x27;, // name:&#x27;小林&#x27;, // sex:&#x27;男&#x27;, // age:21 myAge:this.age, &#125; &#125;, methods:&#123; updateAge()&#123; this.myAge ++; &#125; &#125;, props:[&#x27;name&#x27;,&#x27;sex&#x27;,&#x27;age&#x27;],//简单声明接收 //接收的同时对数据类型限制 /* props:&#123; name:String, age:Number, sex:String, &#125; */ // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制 /* props:&#123; name:&#123; type:String,//name的类型是字符串的 required:true,//name是必要的 &#125;, age:&#123; type:Number, default:1 // 默认值 &#125;, sex:&#123; type:String, required:true, &#125; &#125; */&#125;&lt;/script&gt; App.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;!-- &lt;Student name=&#x27;李四&#x27; sex=&#x27;男&#x27; :age=&#x27;18&#x27;/&gt; --&gt; &lt;!-- &lt;Student name=&#x27;李四&#x27; sex=&#x27;男&#x27; :age=&#x27;18&#x27;/&gt; --&gt; &lt;Student name=&#x27;李四&#x27; sex=&#x27;男&#x27; :age=&#x27;18&#x27;/&gt; &lt;!-- &lt;Student name=&#x27;小红&#x27; sex=&#x27;女&#x27; age=&#x27;20&#x27;/&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student&#125;, &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; main.js12345678910111213// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); 26、minxin混入1234567891011功能：可以把多个组件共用的配置提取成一个混入对象使用方式： 第一步（新建一个js文件）定义混合，例如： &#123; data()&#123;...&#125;, methods:&#123;...&#125;, ... &#125; 第二步使用混入，例如： （1）全局混入：在main.js中：Vue.mixin(xxx) （2）局部混入：在vc中配置项：mixins:[&#x27;xxx&#x27;] 源代码School.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h2 @click=&quot;showName&quot;&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入一个mixinimport &#123;mixin&#125; from &#x27;../mixin&#x27;export default &#123; name:&#x27;SchoolS&#x27;, data() &#123; return &#123; msg:&#x27;我是一个学生&#x27;, name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, mixins:[mixin]&#125;&lt;/script&gt; Student.vue1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h2 @click=&quot;showName&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mixin,mixin2&#125; from &#x27;../mixin&#x27;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; msg:&#x27;我是一个学生&#x27;, name:&#x27;小林&#x27;, sex:&#x27;男&#x27;, &#125; &#125;, mixins:[mixin,mixin2],&#125;&lt;/script&gt; App.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;School/&gt; &lt;hr&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27;; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student,School&#125;, &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; main.js123456789101112131415161718// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// import &#123;mixin,mixin2&#125; from &#x27;./mixin&#x27;// 关闭生产提示Vue.config.productionTip=false;// Vue.mixin(mixin);// Vue.mixin(mixin2);// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); mixin.js12345678910111213141516export const mixin = &#123; methods:&#123; showName()&#123; alert(this.name); &#125; &#125;&#125;export const mixin2 = &#123; data()&#123; return&#123; x:99, &#125; &#125;&#125; 27、插件123456789101112131415功能：用于增强Vue本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据定义插件： 对象.install = function(Vue,options)&#123; //1、添加全局过滤器 Vue.filter(...) //2、添加全局指令 Vue.directive(...) //3、配置全局混入 Vue.mixin(...) //4、添加实例方法 Vue.prototype.$myMethod = function()&#123;...&#125; Vue.prototype.$myProperty = xxx &#125;使用插件：Vue.use() 源代码school.vue1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;name | mySlice&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;test&quot;&gt;点我测试一下hello&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;SchoolS&#x27;, data() &#123; return &#123; name:&#x27;尚硅谷66666&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, methods:&#123; test()&#123; this.hello(); &#125; &#125;&#125;&lt;/script&gt; Student.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; name:&#x27;小林&#x27;, sex:&#x27;男&#x27;, &#125; &#125;&#125;&lt;/script&gt; App.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;School/&gt; &lt;hr&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27;; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student,School&#125;, &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; main.js1234567891011121314151617181920// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 引入插件import plugins from &#x27;./plugins&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 应用（使用）插件Vue.use(plugins);// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); plugins.js1234567891011121314151617181920212223242526272829303132333435363738export default &#123; install(Vue)&#123; // console.log(&#x27;install&#x27;,Vue); // 全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4); &#125;); // 自定义全局指令 Vue.directive(&#x27;fbind&#x27;,&#123; bind(element,binding)&#123; element.value=binding.value; &#125;, inserted(element)&#123; element.focus(); &#125;, update(element,binding)&#123; element.value=binding.value; &#125; &#125;); // 定义混入 Vue.mixin(&#123; data()&#123; return&#123; x:100, y:200, &#125; &#125;, &#125;); // 给Vue原型上添加一个方法(vm和vc都能用) Vue.prototype.hello= ()=&gt;&#123; alert(&quot;你好&quot;); &#125;; &#125;&#125; 28、scoped样式123scoped样式： 作用：让样式在局部生效，防止冲突 写法：&lt;style scoped&gt;&lt;/style&gt; 源代码School.vue1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2 class=&quot;qwe&quot;&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;SchoolS&#x27;, data() &#123; return &#123; name:&#x27;尚硅谷66666&#x27;, address:&#x27;北京&#x27;, &#125; &#125;,&#125;&lt;/script&gt;&lt;!-- &lt;style scoped&gt; .demo&#123; background-color: skyblue; &#125;&lt;/style&gt; --&gt;&lt;!-- 需要先安装less解析器 npm i less-loader --&gt;&lt;style lang=&quot;less&quot; scoped&gt; .demo&#123; background-color: skyblue; .qwe&#123; font-size: 40px; &#125; &#125;&lt;/style&gt; Student.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; name:&#x27;小林&#x27;, sex:&#x27;男&#x27;, &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .demo&#123; background-color: orange; &#125;&lt;/style&gt; App.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;title&quot;&gt;你好啊！&lt;/h1&gt; &lt;School/&gt; &lt;hr&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27;; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student,School&#125;, &#125;&lt;/script&gt;&lt;!-- &lt;style&gt; .title&#123; color: red; &#125;&lt;/style&gt; --&gt; main.js123456789101112131415161718// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); 29、Todo-list案例组件化编码流程（通用）123451、实现静态组件：抽取组件，使用组件实现静态页面效果2、展示动态数据： 2.1、数据的类型、名称是什么？ 数组里面放对象 2.2、数据保存在哪个组件？ List3、交互---从绑定事件监听开始 一开始展示的数据是放在List中的，但是Header要添加一条数据，现阶段很难实现从Header向List传送一条数据，解决方案： 1231、将数据放在App.vue（父组件）2、由App.vue将数据传送给List.vue（使用props）3、App.vue声明一个向数组添加数据的方法，并把方法传递给Header组件，Header使用该方法向数组添加数据 源代码MyHeader.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;todo-header&quot;&gt; &lt;!-- &lt;input v-model=&quot;title&quot; type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; @keyup.enter=&quot;add&quot;/&gt; --&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; @keyup.enter=&quot;add&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;nanoid&#125; from &#x27;nanoid&#x27; export default &#123; name:&#x27;MyHeader&#x27;, /* data()&#123; return&#123; title:&#x27;&#x27;, &#125; &#125;, */ props:[ &#x27;addTodo&#x27; ], methods: &#123; add(event)&#123; // 判断输入框是否为空 if(!event.target.value.trim())&#123; return alert(&quot;输入不能为空！&quot;); &#125; // 将用户的输入包装成为一个todo对象 const todoObj = &#123; id:nanoid(), title:event.target.value, done:false &#125; // 将对象交给App,让App添加对象 this.addTodo(todoObj); // 清空输入框 event.target.value=&#x27;&#x27;; // console.log(event.target.value); &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; /*header*/ .todo-header input &#123; width: 560px; height: 28px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; padding: 4px 7px; &#125; .todo-header input:focus &#123; outline: none; border-color: rgba(82, 168, 236, 0.8); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6); &#125;&lt;/style&gt; MyList.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;ul class=&quot;todo-main&quot;&gt; &lt;MyItem :checkTodo=&#x27;checkTodo&#x27; v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :thing=&quot;todoObj&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import MyItem from &#x27;./MyItem&#x27;; export default &#123; name:&#x27;MyList&#x27;, components:&#123; MyItem, &#125;, props:[ &#x27;todos&#x27;, &#x27;checkTodo&#x27;, &#x27;deleteTodo&#x27; ] &#125;&lt;/script&gt;&lt;style scoped&gt; /*main*/ .todo-main &#123; margin-left: 0px; border: 1px solid #ddd; border-radius: 2px; padding: 0px; &#125; .todo-empty &#123; height: 40px; line-height: 40px; border: 1px solid #ddd; border-radius: 2px; padding-left: 5px; margin-top: 10px; &#125;&lt;/style&gt; MyItem.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;template&gt; &lt;li &gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; :checked=&#x27;thing.done&#x27; @change=&quot;handleCheck(thing.id)&quot;/&gt; &lt;!-- 如下代码也能实现功能，但是不太推荐，违背了不能修改props的原则 --&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;thing.done&quot;/&gt; --&gt; &lt;span&gt;&#123;&#123;thing.title&#125;&#125;&lt;/span&gt; &lt;/label&gt; &lt;button @click=&quot;deleteItem(thing.id,thing.title)&quot; class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;MyItem&#x27;, props:[ // 声明接收thing对象 &#x27;thing&#x27;, &#x27;checkTodo&#x27;, &#x27;deleteTodo&#x27; ], methods:&#123; // 勾选or取消勾选 handleCheck(id)&#123; // console.log(id); // 通知App组件将对应的todo对象的done值取反 this.checkTodo(id); &#125;, deleteItem(id,title)&#123; if(confirm(&#x27;确定删除&quot;&#x27;+title+&#x27;&quot;这个任务项吗？&#x27;))&#123; // console.log(id,title); // 通知App删除 this.deleteTodo(id); &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /*item*/ li &#123; list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; &#125; li label &#123; float: left; cursor: pointer; &#125; li label li input &#123; vertical-align: middle; margin-right: 6px; position: relative; top: -1px; &#125; li button &#123; float: right; display: none; margin-top: 3px; &#125; li:before &#123; content: initial; &#125; li:last-child &#123; border-bottom: none; &#125; li:hover&#123; background-color: yellowgreen; &#125; li:hover button&#123; display: block; &#125;&lt;/style&gt; MyFooter.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt; &lt;label&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&#x27;isAll&#x27; @change=&#x27;checkAll&#x27;/&gt; --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt; &lt;/label&gt; &lt;span&gt; &lt;span&gt;已完成&#123;&#123;doneTotal&#125;&#125;&lt;/span&gt; / 全部&#123;&#123;total&#125;&#125; &lt;/span&gt; &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearDone&quot;&gt;清除已完成任务&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;MyFooter&#x27;, props:[ &#x27;todos&#x27;, &#x27;checkAllTodo&#x27;, &#x27;deleteDoneTodo&#x27; ], computed:&#123; total()&#123; return this.todos.length; &#125;, doneTotal()&#123; /* let i = 0; this.todos.forEach((todo)=&gt;&#123; if(todo.done)&#123; i++; &#125; &#125;) return i; */ /* const x = this.todos.reduce((pre,current)=&gt;&#123; console.log(&quot;@&quot;,pre,current); return pre+(current.done ? 1 : 0); &#125;,0); return x; */ return this.todos.reduce((pre,current)=&gt;pre+(current.done ? 1 : 0),0); &#125;, /* isAll()&#123; return (this.doneTotal===this.total &amp;&amp;this.total&gt;0); &#125; */ isAll:&#123; get()&#123; return (this.doneTotal===this.total &amp;&amp;this.total&gt;0); &#125;, set(value)&#123; this.checkAllTodo(value); &#125; &#125; &#125;, methods:&#123; /* checkAll(e)&#123; this.checkAllTodo(e.target.checked); &#125; */ clearDone()&#123; this.deleteDoneTodo(); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /*footer*/ .todo-footer &#123; height: 40px; line-height: 40px; padding-left: 6px; margin-top: 5px; &#125; .todo-footer label &#123; display: inline-block; margin-right: 20px; cursor: pointer; &#125; .todo-footer label input &#123; position: relative; top: -1px; vertical-align: middle; margin-right: 5px; &#125; .todo-footer button &#123; float: right; margin-top: 5px; &#125;&lt;/style&gt; App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;div class=&quot;todo-container&quot;&gt; &lt;div class=&quot;todo-wrap&quot;&gt; &lt;MyHeader :addTodo=&quot;addTodo&quot;&gt;&lt;/MyHeader&gt; &lt;MyList :deleteTodo=&quot;deleteTodo&quot; :checkTodo=&quot;checkTodo&quot; :todos=&quot;todos&quot;&gt;&lt;/MyList&gt; &lt;MyFooter :deleteDoneTodo=&quot;deleteDoneTodo&quot; :checkAllTodo=&quot;checkAllTodo&quot; :todos=&quot;todos&quot;&gt;&lt;/MyFooter&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import MyHeader from &#x27;./components/MyHeader&#x27;; import MyList from &#x27;./components/MyList&#x27;; import MyFooter from &#x27;./components/MyFooter&#x27;; export default &#123; name:&#x27;App&#x27;, components:&#123; MyHeader, MyList, MyFooter &#125;, data()&#123; return&#123; todos:[ &#123;id:&#x27;001&#x27;,title:&#x27;吃饭&#x27;,done:true&#125;, &#123;id:&#x27;002&#x27;,title:&#x27;睡觉&#x27;,done:true&#125;, &#123;id:&#x27;003&#x27;,title:&#x27;打代码&#x27;,done:false&#125;, ] &#125; &#125;, methods: &#123; // 添加一个todo addTodo(todoObj)&#123; // console.log(&#x27;我是App组件，我收到了数据：&#x27;+x); this.todos.unshift(todoObj); &#125;, //取消勾选一个todo checkTodo(id)&#123; this.todos.forEach((todo)=&gt;&#123; if(todo.id===id) todo.done=!todo.done; &#125;) &#125;, // 删除一个todo项 deleteTodo(id)&#123; this.todos = this.todos.filter(todo=&gt;todo.id !==id); &#125;, // 全选/取消全选 checkAllTodo(done)&#123; this.todos.forEach((todo)=&gt;&#123; todo.done=done; &#125;); &#125;, // 删除已完成的任务（即done为true的todo） deleteDoneTodo()&#123; // 删除 // 遍历所有todo /* this.todos.forEach((todo)=&gt;&#123; // 调用方法删除 if(todo.done)&#123; this.deleteTodo(todo.id); &#125; &#125;); */ // 提示 if(confirm(&#x27;你确定要清除已完成的任务吗？&#x27;))&#123; // 过滤掉 this.todos = this.todos.filter((todo)=&gt;&#123; return !todo.done; &#125;); &#125; &#125; &#125;, &#125;&lt;/script&gt;&lt;style&gt; /*base*/ body &#123; background: #fff; &#125; .btn &#123; display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; &#125; .btn-danger &#123; color: #fff; background-color: #da4f49; border: 1px solid #bd362f; &#125; .btn-danger:hover &#123; color: #fff; background-color: #bd362f; &#125; .btn:focus &#123; outline: none; &#125; .todo-container &#123; width: 600px; margin: 0 auto; &#125; .todo-container .todo-wrap &#123; padding: 10px; border: 1px solid #ddd; border-radius: 5px; &#125;&lt;/style&gt; main.js123456789101112131415161718// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App),&#125;); 总结1234567891011121314151617181920211. 组件化编码流程： ​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。 ​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： ​ 1).一个组件在用：放在组件自身即可。 ​ 2). 一些组件在用：放在他们共同的父组件上（&lt;span style=&quot;color:red&quot;&gt;状态提升&lt;/span&gt;）。 ​ (3).实现交互：从绑定事件开始。2. props适用于： ​ (1).父组件 ==&gt; 子组件 通信 ​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。 30、webStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样） 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 相关API： xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 xxxxxStorage.getItem(&#39;person&#39;); 该方法接受一个键名作为参数，返回键名对应的值。 xxxxxStorage.removeItem(&#39;key&#39;); 该方法接受一个键名作为参数，并把该键名从存储中删除。 xxxxxStorage.clear() 该方法会清空存储中的所有数据。 备注： SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 31、TodoList案例—-本地存储版本只需要在原来的代码上，添加监视：todos 在App.vue中添加： 12345678watch:&#123; todos:&#123; deep:true, handler(value)&#123; localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value)); &#125; &#125;&#125; 修改data中todos的取值： 12345data()&#123; return&#123; todos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || [] &#125;&#125;, 32、组件自定义事件源代码School.vue123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendSchoolName&quot;&gt;把学校名给App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;SchoolS&#x27;, props:[ &#x27;getSchollName&#x27; ], data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, methods:&#123; sendSchoolName()&#123; this.getSchollName(this.name); &#125; &#125;&#125;&lt;/script&gt;&lt;!-- &lt;style scoped&gt; .demo&#123; background-color: skyblue; &#125;&lt;/style&gt; --&gt;&lt;!-- 需要先安装less解析器 npm i less-loader --&gt;&lt;style lang=&quot;less&quot; scoped&gt; .school&#123; background-color: skyblue; padding: 5px; &#125;&lt;/style&gt; Student.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;student&quot;&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;当前求和为：&#123;&#123;number&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;add&quot;&gt;点我number++&lt;/button&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;点我把学生姓名给App&lt;/button&gt; &lt;button @click=&quot;unbind&quot;&gt;解绑xiaolin事件&lt;/button&gt; &lt;button @click=&quot;death&quot;&gt;销毁当前Student组件的实例(vc)&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; name:&#x27;小林&#x27;, sex:&#x27;男&#x27;, number:0 &#125; &#125;, methods:&#123; add()&#123; console.log(&#x27;add回调被调用了&#x27;); this.number++; &#125;, sendStudentName()&#123; // 触发Studnet组件实例身上的xiaolin事件 this.$emit(&#x27;xiaolin&#x27;,this.name,1,2,3,4) // this.$emit(&#x27;demo&#x27;); &#125;, unbind()&#123; this.$off(&#x27;xiaolin&#x27;);//解绑一个自定义事件 // this.$off([&#x27;xiaolin&#x27;,&#x27;demo&#x27;]);//解绑多个自定义事件 // this.$off();//解绑所有自定义事件 &#125;, death()&#123; this.$destroy();//销毁了当前Student组件的实例，销毁后所有Student实例的自定义事件全都不奏效了 &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .student&#123; background-color: orange; padding: 5px; margin-top: 30px; &#125;&lt;/style&gt; App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;,学生姓名是:&#123;&#123;studentName&#125;&#125;&lt;/h1&gt; &lt;!-- 通过父组件给子组件传递函数类型的props实现：子给父传递数据 --&gt; &lt;School :getSchollName=&#x27;getSchollName&#x27;/&gt; &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据(第一种写法，使用v-on，或@) --&gt; &lt;!-- &lt;Student @xiaolin=&#x27;getStudentName&#x27; @demo=&#x27;m1&#x27;/&gt; --&gt; &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据(第二种写法，使用ref) --&gt; &lt;!-- native声明使用原生的js事件click --&gt; &lt;!-- 会把Student组件最外层容器作为触发事件的元素 --&gt; &lt;Student ref=&#x27;studnet&#x27; @click.native=&#x27;show&#x27;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27;; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student,School&#125;, data()&#123; return&#123; msg:&#x27;你好啊！&#x27;, studentName:&#x27;&#x27; &#125; &#125;, methods:&#123; getSchollName(name)&#123; console.log(&quot;App收到了学校名:&quot;,name); &#125;, getStudentName(name,...params)&#123; console.log(&#x27;App收到了学生姓名:&#x27;,name,params); this.studentName = name; &#125;, m1()&#123; console.log(&#x27;demo事件被触发了&#x27;); &#125;, show()&#123; console.log(111); &#125; &#125;, mounted()&#123; // setTimeout(()=&gt;&#123; // this.$refs.studnet.$on(&#x27;xiaolin&#x27;,this.getStudentName); //绑定自定义事件 // &#125;,3000); // this.$refs.studnet.$once(&#x27;xiaolin&#x27;,this.getStudentName);//绑定自定义事件（一次性） this.$refs.studnet.$on(&#x27;xiaolin&#x27;,this.getStudentName); /* this.$refs.studnet.$on(&#x27;xiaolin&#x27;,(name,...params)=&gt;&#123; console.log(&#x27;App收到了学生姓名:&#x27;,name,params); // console.log(this);//此处的this是Studnet组件 this.studentName = name; &#125;); */ &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .app&#123; background-color: gray; padding: 5px; &#125;&lt;/style&gt; main.js1234567891011121314151617181920212223// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App), /* mounted()&#123; setTimeout(()=&gt;&#123; this.$destroy(); &#125;,3000); &#125; */&#125;); 总结 一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。 绑定自定义事件： 第一种方式，在父组件中：&lt;Demo @atguigu=&quot;test&quot;/&gt; 或 &lt;Demo v-on:atguigu=&quot;test&quot;/&gt; 第二种方式，在父组件中： 12345&lt;Demo ref=&quot;demo&quot;/&gt;......mounted()&#123; this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test)&#125; 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。 触发自定义事件：this.$emit(&#39;atguigu&#39;,数据) 解绑自定义事件this.$off(&#39;atguigu&#39;) 组件上也可以绑定原生DOM事件，需要使用native修饰符。 注意：通过this.$refs.xxx.$on(&#39;atguigu&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！ 33、ToDoList—–自定义事件修改App组件 1234567891011&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;div class=&quot;todo-container&quot;&gt; &lt;div class=&quot;todo-wrap&quot;&gt; &lt;MyHeader @addTodo=&quot;addTodo&quot;&gt;&lt;/MyHeader&gt; &lt;MyList :deleteTodo=&quot;deleteTodo&quot; :checkTodo=&quot;checkTodo&quot; :todos=&quot;todos&quot;&gt;&lt;/MyList&gt; &lt;MyFooter @deleteDoneTodo=&quot;deleteDoneTodo&quot; @checkAllTodo=&quot;checkAllTodo&quot; :todos=&quot;todos&quot;&gt;&lt;/MyFooter&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 修改MyHeader组件 1234567891011121314151617181920212223methods: &#123; add(event)&#123; // 判断输入框是否为空 if(!event.target.value.trim())&#123; return alert(&quot;输入不能为空！&quot;); &#125; // 将用户的输入包装成为一个todo对象 const todoObj = &#123; id:nanoid(), title:event.target.value, done:false &#125; //修改此部分 // 将对象交给App,让App添加对象 this.$emit(&#x27;addTodo&#x27;,todoObj); // 清空输入框 event.target.value=&#x27;&#x27;; // console.log(event.target.value); &#125; &#125;, 修改MyFooter组件 1234567891011121314151617181920212223computed:&#123; total()&#123; return this.todos.length; &#125;, doneTotal()&#123; return this.todos.reduce((pre,current)=&gt;pre+(current.done ? 1 : 0),0); &#125;, isAll:&#123; get()&#123; return (this.doneTotal===this.total &amp;&amp;this.total&gt;0); &#125;, set(value)&#123; // this.checkAllTodo(value); this.$emit(&#x27;checkAllTodo&#x27;,value); &#125; &#125; &#125;, methods:&#123; clearDone()&#123; // this.deleteDoneTodo(); this.$emit(&#x27;deleteDoneTodo&#x27;); &#125; &#125; 另外删除props中没用的值的引入 34、全局事件总线–实现任意组件间通信源代码SChool.vue123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;SchoolS&#x27;, data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, mounted()&#123; // console.log(&#x27;School&#x27;,window.x); // console.log(&#x27;School&#x27;,this.x); this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123; console.log(&#x27;我是School组件，我收到了数据：&#x27;,data); &#125;); &#125;, beforeDestroy()&#123; this.$bus.$off(&#x27;hello&#x27;); &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; .school&#123; background-color: skyblue; padding: 5px; &#125;&lt;/style&gt; Student.vue1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;student&quot;&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;StudentS&#x27;, data() &#123; return &#123; name:&#x27;小林&#x27;, sex:&#x27;男&#x27;, &#125; &#125;, mounted()&#123; // console.log(&#x27;Student&#x27;,window.x); // console.log(&#x27;Student&#x27;,this.x); &#125;, methods: &#123; sendStudentName()&#123; this.$bus.$emit(&#x27;hello&#x27;,this.name); &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt; .student&#123; background-color: orange; padding: 5px; margin-top: 30px; &#125;&lt;/style&gt; App.vue123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;School/&gt; &lt;Student/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27;; import Student from &#x27;./components/Student&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;Student,School&#125;, data()&#123; return&#123; msg:&#x27;你好啊！&#x27; &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .app&#123; background-color: gray; padding: 5px; &#125;&lt;/style&gt; main.js123456789101112131415161718192021222324// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// window.x=false;// const Demo = Vue.extend(&#123;&#125;);// const d = new Demo();// Vue.prototype.x = d;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App), beforeCreate()&#123; Vue.prototype.$bus = this; //安装全局事件总线 &#125;&#125;); 总结 一种组件间通信的方式，适用于任意组件间通信。 安装全局事件总线： 1234567new Vue(&#123; ...... beforeCreate() &#123; Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm &#125;, ......&#125;) 使用事件总线： 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted() &#123; this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125; 提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据) 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。 35、ToDoList—–全局事件总线在ToDoList自定义事件的基础上修改 1、安装全局事件总线（main.js） 123beforeCreate()&#123; Vue.prototype.$bus = this; // 安装全局事件总线 &#125; 2、删除App组件给MyList组件传的数据(剩下todos) 1&lt;MyList :todos=&quot;todos&quot;&gt;&lt;/MyList&gt; 3、删除MyList接收的数据（剩下todos）以及不要向MyItem传送数据 1234567891、props:[&#x27;todos&#x27;]2、&lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :thing=&quot;todoObj&quot;/&gt; 4、删除MyItem接收的数据（剩下thing） 1props:[ &#x27;thing&#x27;] 5、在App组件声明绑定事件和解绑事件逻辑 12345678mounted()&#123; this.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo); this.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo);&#125;,beforeDestroy()&#123; this.$bus.$off(&#x27;checkTodo&#x27;); this.$bus.$off(&#x27;deleteTodo&#x27;);&#125; 6、在MyItem中声明触发事件逻辑（即传送数据） 123456789101112131415// 勾选or取消勾选 handleCheck(id)&#123; // console.log(id); // 通知App组件将对应的todo对象的done值取反 // this.checkTodo(id); this.$bus.$emit(&#x27;checkTodo&#x27;,id); &#125;, deleteItem(id,title)&#123; if(confirm(&#x27;确定删除&quot;&#x27;+title+&#x27;&quot;这个任务项吗？&#x27;))&#123; // console.log(id,title); // 通知App删除 // this.deleteTodo(id); this.$bus.$emit(&#x27;deleteTodo&#x27;,id); &#125; &#125; 36、消息订阅与发布 一种组件间通信的方式，适用于任意组件间通信。 使用步骤： 安装pubsub：npm i pubsub-js 引入: import pubsub from &#39;pubsub-js&#39; 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted() &#123; this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息&#125; 提供数据：pubsub.publish(&#39;xxx&#39;,数据) 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。 订阅消息 1234567891011121314151617methods: &#123; demo(msgName,data)&#123; console.log(&quot;有人发布了hello消息，hello消息的回调执行了&quot;,data); &#125; &#125;, mounted()&#123; /* this.pubId = pubsub.subscribe(&#x27;hello&#x27;,(msgName,data)=&gt;&#123; console.log(this); console.log(&quot;有人发布了hello消息，hello消息的回调执行了&quot;,data); &#125;); */ this.pubId = pubsub.subscribe(&#x27;hello&#x27;,this.demo); &#125;, beforeDestroy()&#123; // this.$bus.$off(&#x27;hello&#x27;); pubsub.unsubscribe(this.pubId); &#125; 发布消息 123456methods: &#123; sendStudentName()&#123; // this.$bus.$emit(&#x27;hello&#x27;,this.name); pubSub.publish(&#x27;hello&#x27;,666); &#125; &#125;, 37、TodoList—消息订阅与发布在之前案例的基础上修改 1、修改App组件methods中的deleteTodo方法，参数需要改成两个，使用_占位 1234// 删除一个todo项deleteTodo(_,id)&#123; this.todos = this.todos.filter(todo=&gt;todo.id !==id);&#125;, 2、修改App组件 123456789mounted()&#123; this.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo); this.pubId=pubsub.subscribe(&#x27;deleteTodo&#x27;,this.deleteTodo)&#125;,beforeDestroy()&#123; this.$bus.$off(&#x27;checkTodo&#x27;); // this.$bus.$off(&#x27;deleteTodo&#x27;); pubsub.unsubscribe(this.pubId);&#125; 3、修改MyItem组件methods 123456789deleteItem(id,title)&#123; if(confirm(&#x27;确定删除&quot;&#x27;+title+&#x27;&quot;这个任务项吗？&#x27;))&#123; // console.log(id,title); // 通知App删除 // this.deleteTodo(id); // this.$bus.$emit(&#x27;deleteTodo&#x27;,id); pubSub.publish(&#x27;deleteTodo&#x27;,id); &#125;&#125; 38、TodoList–添加编辑功能源码MyHeader.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;todo-header&quot;&gt; &lt;!-- &lt;input v-model=&quot;title&quot; type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; @keyup.enter=&quot;add&quot;/&gt; --&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; @keyup.enter=&quot;add&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;nanoid&#125; from &#x27;nanoid&#x27; export default &#123; name:&#x27;MyHeader&#x27;, /* data()&#123; return&#123; title:&#x27;&#x27;, &#125; &#125;, */ methods: &#123; add(event)&#123; // 判断输入框是否为空 if(!event.target.value.trim())&#123; return alert(&quot;输入不能为空！&quot;); &#125; // 将用户的输入包装成为一个todo对象 const todoObj = &#123; id:nanoid(), title:event.target.value, done:false &#125; // 将对象交给App,让App添加对象 this.$emit(&#x27;addTodo&#x27;,todoObj); // 清空输入框 event.target.value=&#x27;&#x27;; // console.log(event.target.value); &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; /*header*/ .todo-header input &#123; width: 560px; height: 28px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; padding: 4px 7px; &#125; .todo-header input:focus &#123; outline: none; border-color: rgba(82, 168, 236, 0.8); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6); &#125;&lt;/style&gt; MyList.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;ul class=&quot;todo-main&quot;&gt; &lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :thing=&quot;todoObj&quot; /&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import MyItem from &#x27;./MyItem&#x27;; export default &#123; name:&#x27;MyList&#x27;, components:&#123; MyItem, &#125;, props:[ &#x27;todos&#x27;, ] &#125;&lt;/script&gt;&lt;style scoped&gt; /*main*/ .todo-main &#123; margin-left: 0px; border: 1px solid #ddd; border-radius: 2px; padding: 0px; &#125; .todo-empty &#123; height: 40px; line-height: 40px; border: 1px solid #ddd; border-radius: 2px; padding-left: 5px; margin-top: 10px; &#125;&lt;/style&gt; MyItem.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;template&gt; &lt;li &gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; :checked=&#x27;thing.done&#x27; @change=&quot;handleCheck(thing.id)&quot;/&gt; &lt;!-- 如下代码也能实现功能，但是不太推荐，违背了不能修改props的原则 --&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;thing.done&quot;/&gt; --&gt; &lt;span v-show=&quot;!thing.isEdit&quot;&gt;&#123;&#123;thing.title&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-show=&quot;thing.isEdit&quot; :value=&quot;thing.title&quot; @blur=&quot;handleBlur(thing,$event)&quot; ref=&quot;inputTitle&quot; &gt; &lt;/label&gt; &lt;button @click=&quot;deleteItem(thing.id,thing.title)&quot; class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt; &lt;button v-show=&quot;!thing.isEdit&quot; @click=&quot;handleEdit(thing)&quot; class=&quot;btn btn-edit&quot;&gt;编辑&lt;/button&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt; import pubSub from &#x27;pubsub-js&#x27;import func from &#x27;vue-editor-bridge&#x27;; export default &#123; name:&#x27;MyItem&#x27;, props:[ // 声明接收thing对象 &#x27;thing&#x27;, ], methods:&#123; // 勾选or取消勾选 handleCheck(id)&#123; // console.log(id); // 通知App组件将对应的todo对象的done值取反 // this.checkTodo(id); this.$bus.$emit(&#x27;checkTodo&#x27;,id); &#125;, deleteItem(id,title)&#123; if(confirm(&#x27;确定删除&quot;&#x27;+title+&#x27;&quot;这个任务项吗？&#x27;))&#123; // console.log(id,title); // 通知App删除 // this.deleteTodo(id); // this.$bus.$emit(&#x27;deleteTodo&#x27;,id); pubSub.publish(&#x27;deleteTodo&#x27;,id); &#125; &#125;, // 编辑功能 handleEdit(thing)&#123; if(Object.prototype.hasOwnProperty.call(thing, &#x27;isEdit&#x27;))&#123; console.log(&#x27;有&#x27;); thing.isEdit=true; &#125;else&#123; console.log(&#x27;无&#x27;); this.$set(thing,&#x27;isEdit&#x27;,true); &#125; /* setTimeout(()=&gt;&#123; this.$refs.inputTitle.focus(); &#125;,200) ; */ // 页面重新解析完毕再执行这个函数 this.$nextTick(function()&#123; this.$refs.inputTitle.focus(); &#125;); &#125;, // 失去焦点回调，实现修改数据的地方 handleBlur(thing,e)&#123; thing.isEdit=false; if(!e.target.value.trim())&#123; return alert(&#x27;输入不能为空！&#x27;); &#125; this.$bus.$emit(&#x27;updateTodo&#x27;,thing.id,e.target.value); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /*item*/ li &#123; list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; &#125; li label &#123; float: left; cursor: pointer; &#125; li label li input &#123; vertical-align: middle; margin-right: 6px; position: relative; top: -1px; &#125; li button &#123; float: right; display: none; margin-top: 3px; &#125; li:before &#123; content: initial; &#125; li:last-child &#123; border-bottom: none; &#125; li:hover&#123; background-color: yellowgreen; &#125; li:hover button&#123; display: block; &#125;&lt;/style&gt; MyFooter.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt; &lt;label&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&#x27;isAll&#x27; @change=&#x27;checkAll&#x27;/&gt; --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt; &lt;/label&gt; &lt;span&gt; &lt;span&gt;已完成&#123;&#123;doneTotal&#125;&#125;&lt;/span&gt; / 全部&#123;&#123;total&#125;&#125; &lt;/span&gt; &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearDone&quot;&gt;清除已完成任务&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;MyFooter&#x27;, props:[ &#x27;todos&#x27;, ], computed:&#123; total()&#123; return this.todos.length; &#125;, doneTotal()&#123; /* let i = 0; this.todos.forEach((todo)=&gt;&#123; if(todo.done)&#123; i++; &#125; &#125;) return i; */ /* const x = this.todos.reduce((pre,current)=&gt;&#123; console.log(&quot;@&quot;,pre,current); return pre+(current.done ? 1 : 0); &#125;,0); return x; */ return this.todos.reduce((pre,current)=&gt;pre+(current.done ? 1 : 0),0); &#125;, /* isAll()&#123; return (this.doneTotal===this.total &amp;&amp;this.total&gt;0); &#125; */ isAll:&#123; get()&#123; return (this.doneTotal===this.total &amp;&amp;this.total&gt;0); &#125;, set(value)&#123; // this.checkAllTodo(value); this.$emit(&#x27;checkAllTodo&#x27;,value); &#125; &#125; &#125;, methods:&#123; /* checkAll(e)&#123; this.checkAllTodo(e.target.checked); &#125; */ clearDone()&#123; // this.deleteDoneTodo(); this.$emit(&#x27;deleteDoneTodo&#x27;); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /*footer*/ .todo-footer &#123; height: 40px; line-height: 40px; padding-left: 6px; margin-top: 5px; &#125; .todo-footer label &#123; display: inline-block; margin-right: 20px; cursor: pointer; &#125; .todo-footer label input &#123; position: relative; top: -1px; vertical-align: middle; margin-right: 5px; &#125; .todo-footer button &#123; float: right; margin-top: 5px; &#125;&lt;/style&gt; App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;div class=&quot;todo-container&quot;&gt; &lt;div class=&quot;todo-wrap&quot;&gt; &lt;MyHeader @addTodo=&quot;addTodo&quot;&gt;&lt;/MyHeader&gt; &lt;MyList :todos=&quot;todos&quot;&gt;&lt;/MyList&gt; &lt;MyFooter @deleteDoneTodo=&quot;deleteDoneTodo&quot; @checkAllTodo=&quot;checkAllTodo&quot; :todos=&quot;todos&quot;&gt;&lt;/MyFooter&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import pubsub from &#x27;pubsub-js&#x27;; import MyHeader from &#x27;./components/MyHeader&#x27;; import MyList from &#x27;./components/MyList&#x27;; import MyFooter from &#x27;./components/MyFooter&#x27;; export default &#123; name:&#x27;App&#x27;, components:&#123; MyHeader, MyList, MyFooter &#125;, data()&#123; return&#123; todos:JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || [] &#125; &#125;, methods: &#123; // 添加一个todo addTodo(todoObj)&#123; // console.log(&#x27;我是App组件，我收到了数据：&#x27;+x); this.todos.unshift(todoObj); &#125;, //取消勾选一个todo checkTodo(id)&#123; this.todos.forEach((todo)=&gt;&#123; if(todo.id===id) todo.done=!todo.done; &#125;) &#125;, //更新一个todo updateTodo(id,title)&#123; this.todos.forEach((todo)=&gt;&#123; if(todo.id===id) todo.title=title; &#125;) &#125;, // 删除一个todo项 deleteTodo(_,id)&#123; this.todos = this.todos.filter(todo=&gt;todo.id !==id); &#125;, // 全选/取消全选 checkAllTodo(done)&#123; this.todos.forEach((todo)=&gt;&#123; todo.done=done; &#125;); &#125;, // 删除已完成的任务（即done为true的todo） deleteDoneTodo()&#123; // 删除 // 遍历所有todo /* this.todos.forEach((todo)=&gt;&#123; // 调用方法删除 if(todo.done)&#123; this.deleteTodo(todo.id); &#125; &#125;); */ // 提示 if(confirm(&#x27;你确定要清除已完成的任务吗？&#x27;))&#123; // 过滤掉 this.todos = this.todos.filter((todo)=&gt;&#123; return !todo.done; &#125;); &#125; &#125; &#125;, watch:&#123; todos:&#123; deep:true, handler(value)&#123; localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value)); &#125; &#125; &#125;, mounted()&#123; this.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo); this.$bus.$on(&#x27;updateTodo&#x27;,this.updateTodo); this.pubId=pubsub.subscribe(&#x27;deleteTodo&#x27;,this.deleteTodo) &#125;, beforeDestroy()&#123; this.$bus.$off(&#x27;checkTodo&#x27;); this.$bus.$off(&#x27;updateTodo&#x27;); // this.$bus.$off(&#x27;deleteTodo&#x27;); pubsub.unsubscribe(this.pubId); &#125; &#125;&lt;/script&gt;&lt;style&gt; /*base*/ body &#123; background: #fff; &#125; .btn &#123; display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; &#125; .btn-danger &#123; color: #fff; background-color: #da4f49; border: 1px solid #bd362f; &#125; .btn-edit &#123; color: #fff; background-color: skyblue; border: 1px solid rgb(70, 158, 193); margin-right: 5px; &#125; .btn-danger:hover &#123; color: #fff; background-color: #bd362f; &#125; .btn-edit:hover &#123; color: #fff; background-color: rgb(70, 158, 193); &#125; .btn:focus &#123; outline: none; &#125; .todo-container &#123; width: 600px; margin: 0 auto; &#125; .todo-container .todo-wrap &#123; padding: 10px; border: 1px solid #ddd; border-radius: 5px; &#125;&lt;/style&gt; main.js12345678910111213141516171819202122// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App), beforeCreate()&#123; Vue.prototype.$bus = this; // 安装全局事件总线 &#125;&#125;); nextTick1231. 语法：```this.$nextTick(回调函数)```2. 作用：在下一次 DOM 更新结束后执行其指定的回调。3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。 39、Vue中的过渡和动画效果 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。 图示： 写法： 准备好样式： 元素进入的样式： v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点 元素离开的样式： v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 使用&lt;transition&gt;包裹要过度的元素，并配置name属性： 123&lt;transition name=&quot;hello&quot;&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt; 备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定key值。 源码test.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;isShow=!isShow&quot;&gt;显示/隐藏&lt;/button&gt; &lt;transition name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊&lt;/h1&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;TestS&#x27;, data()&#123; return &#123; isShow:true &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt; h1&#123; background-color: orange; &#125; .hello-enter-active&#123; animation: xiaolin 1s; &#125; .hello-leave-active&#123; animation: xiaolin 1s reverse; &#125; @keyframes xiaolin &#123; from&#123; transform: translateX(-100%); &#125; to&#123; transform: translateX(0px); &#125; &#125;&lt;/style&gt; test2.vue123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;isShow=!isShow&quot;&gt;显示/隐藏&lt;/button&gt; &lt;!-- &lt;transition name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊&lt;/h1&gt; &lt;/transition&gt; --&gt; &lt;transition-group name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊&lt;/h1&gt; &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷&lt;/h1&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;TestS&#x27;, data()&#123; return &#123; isShow:true &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt; h1&#123; background-color: orange; &#125; /* 进入的起点 离开的终点*/ .hello-enter,.hello-leave-to&#123; transform: translateX(-100%); &#125; .hello-enter-active,.hello-leave-active&#123; transition: 0.5s linear; &#125; /* 进入的终点 离开的起点*/ .hello-enter-to,.hello-leave&#123; transform: translateX(0); &#125; &lt;/style&gt; test3.vue123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;isShow=!isShow&quot;&gt;显示/隐藏&lt;/button&gt; &lt;!-- &lt;transition name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊&lt;/h1&gt; &lt;/transition&gt; --&gt; &lt;transition-group appear name=&quot;animate__animated animate__bounce&quot; enter-active-class=&quot;animate__swing&quot; leave-active-class=&quot;animate__backOutUp&quot; &gt; &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊&lt;/h1&gt; &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷&lt;/h1&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#x27;animate.css&#x27;export default &#123; name:&#x27;TestS&#x27;, data()&#123; return &#123; isShow:true &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt; h1&#123; background-color: orange; &#125;&lt;/style&gt; App.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;Test&gt;&lt;/Test&gt; &lt;hr&gt; &lt;Test2&gt;&lt;/Test2&gt; &lt;hr&gt; &lt;Test3&gt;&lt;/Test3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test from &#x27;./components/test&#x27;; import Test2 from &#x27;./components/test2&#x27;; import Test3 from &#x27;./components/test3&#x27;; export default &#123; name:&#x27;App&#x27;, components:&#123; Test, Test2, Test3, &#125; &#125;&lt;/script&gt; main.js123456789101112131415161718192021// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App), beforeCreate()&#123; Vue.prototype.$bus = this; // 安装全局事件总线 &#125;&#125;); 40、TodoList案例—动画两种方案1、修改MyList.vue(使用transition-group) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;ul class=&quot;todo-main&quot;&gt; &lt;transition-group name=&quot;todo&quot; appear&gt; &lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :thing=&quot;todoObj&quot; /&gt; &lt;/transition-group&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import MyItem from &#x27;./MyItem&#x27;; export default &#123; name:&#x27;MyList&#x27;, components:&#123; MyItem, &#125;, props:[ &#x27;todos&#x27;, ] &#125;&lt;/script&gt;&lt;style scoped&gt; /*main*/ .todo-main &#123; margin-left: 0px; border: 1px solid #ddd; border-radius: 2px; padding: 0px; &#125; .todo-empty &#123; height: 40px; line-height: 40px; border: 1px solid #ddd; border-radius: 2px; padding-left: 5px; margin-top: 10px; &#125; .todo-enter-active&#123; animation: xiaolin 1s; &#125; .todo-leave-active&#123; animation: xiaolin 1s reverse; &#125; @keyframes xiaolin &#123; from&#123; transform: translateX(+100%); &#125; to&#123; transform: translateX(0px); &#125; &#125;&lt;/style&gt; 2、修改MyItem.vue(使用transition) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;transition name=&quot;todo&quot; appear&gt; &lt;li &gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; :checked=&#x27;thing.done&#x27; @change=&quot;handleCheck(thing.id)&quot;/&gt; &lt;!-- 如下代码也能实现功能，但是不太推荐，违背了不能修改props的原则 --&gt; &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;thing.done&quot;/&gt; --&gt; &lt;span v-show=&quot;!thing.isEdit&quot;&gt;&#123;&#123;thing.title&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-show=&quot;thing.isEdit&quot; :value=&quot;thing.title&quot; @blur=&quot;handleBlur(thing,$event)&quot; ref=&quot;inputTitle&quot; &gt; &lt;/label&gt; &lt;button @click=&quot;deleteItem(thing.id,thing.title)&quot; class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt; &lt;button v-show=&quot;!thing.isEdit&quot; @click=&quot;handleEdit(thing)&quot; class=&quot;btn btn-edit&quot;&gt;编辑&lt;/button&gt; &lt;/li&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt; import pubSub from &#x27;pubsub-js&#x27; export default &#123; name:&#x27;MyItem&#x27;, props:[ // 声明接收thing对象 &#x27;thing&#x27;, ], methods:&#123; // 勾选or取消勾选 handleCheck(id)&#123; // console.log(id); // 通知App组件将对应的todo对象的done值取反 // this.checkTodo(id); this.$bus.$emit(&#x27;checkTodo&#x27;,id); &#125;, deleteItem(id,title)&#123; if(confirm(&#x27;确定删除&quot;&#x27;+title+&#x27;&quot;这个任务项吗？&#x27;))&#123; // console.log(id,title); // 通知App删除 // this.deleteTodo(id); // this.$bus.$emit(&#x27;deleteTodo&#x27;,id); pubSub.publish(&#x27;deleteTodo&#x27;,id); &#125; &#125;, // 编辑功能 handleEdit(thing)&#123; if(Object.prototype.hasOwnProperty.call(thing, &#x27;isEdit&#x27;))&#123; console.log(&#x27;有&#x27;); thing.isEdit=true; &#125;else&#123; console.log(&#x27;无&#x27;); this.$set(thing,&#x27;isEdit&#x27;,true); &#125; /* setTimeout(()=&gt;&#123; this.$refs.inputTitle.focus(); &#125;,200) ; */ // 页面重新解析完毕再执行这个函数 this.$nextTick(function()&#123; this.$refs.inputTitle.focus(); &#125;); &#125;, // 失去焦点回调，实现修改数据的地方 handleBlur(thing,e)&#123; thing.isEdit=false; if(!e.target.value.trim())&#123; return alert(&#x27;输入不能为空！&#x27;); &#125; this.$bus.$emit(&#x27;updateTodo&#x27;,thing.id,e.target.value); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /*item*/ li &#123; list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; &#125; li label &#123; float: left; cursor: pointer; &#125; li label li input &#123; vertical-align: middle; margin-right: 6px; position: relative; top: -1px; &#125; li button &#123; float: right; display: none; margin-top: 3px; &#125; li:before &#123; content: initial; &#125; li:last-child &#123; border-bottom: none; &#125; li:hover&#123; background-color: yellowgreen; &#125; li:hover button&#123; display: block; &#125; /* .todo-enter-active&#123; animation: xiaolin 1s; &#125; .todo-leave-active&#123; animation: xiaolin 1s reverse; &#125; @keyframes xiaolin &#123; from&#123; transform: translateX(+100%); &#125; to&#123; transform: translateX(0px); &#125; &#125; */&lt;/style&gt; 41、Vue脚手架配置代理服务器方法一 在vue.config.js中添加如下配置： 123devServer:&#123; proxy:&quot;http://localhost:5000&quot;&#125; 说明： 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 方法二 编写vue.config.js配置具体代理规则： 123456789101112131415161718192021module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径 target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; &#125;, &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径 target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125; &#125; &#125; &#125;&#125;/* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true*/ 说明： 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 跨域请求：协议、域名、端口号 解决跨域：1、cors 2、jsonp 3、代理服务器 4、Nginx反向代理 服务器之间不使用ajax请求，没有跨域问题，不受同源策略影响 源码App.vue 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;button @click=&quot;getStudnets&quot;&gt;获取学生信息&lt;/button&gt; &lt;button @click=&quot;getCars&quot;&gt;获取汽车信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &#x27;axios&#x27; export default &#123; name:&#x27;App&#x27;, methods: &#123; getStudnets()&#123; axios.get(&#x27;http://localhost:8080/xiaolin/students&#x27;).then( response=&gt;&#123; console.log(&#x27;请求成功了&#x27;,response.data); &#125;, error=&gt;&#123; console.log(&#x27;请求失败了&#x27;,error.message); &#125; ) &#125;, getCars()&#123; axios.get(&#x27;http://localhost:8080/lxg/cars&#x27;).then( response=&gt;&#123; console.log(&#x27;请求成功了&#x27;,response.data); &#125;, error=&gt;&#123; console.log(&#x27;请求失败了&#x27;,error.message); &#125; ) &#125; &#125;, &#125;&lt;/script&gt; main.js 123456789101112131415161718192021// 引入Vueimport Vue from &quot;vue&quot;;// 引入Appimport App from &#x27;./App.vue&#x27;;// 关闭生产提示Vue.config.productionTip=false;// 创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render:h=&gt;h(App), beforeCreate()&#123; Vue.prototype.$bus = this; // 安装全局事件总线 &#125;&#125;); vue.config.js 123456789101112131415161718192021222324252627const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, //开启代理服务器(方式一) /* devServer:&#123; proxy: &#x27;http://localhost:5000&#x27; &#125; */ //开启代理服务器(方式二) devServer:&#123; proxy:&#123; &#x27;/xiaolin&#x27;:&#123; target: &#x27;http://localhost:5000&#x27;, // 匹配所有/xiaolin开头的替换成空字符串 pathRewrite:&#123;&#x27;^/xiaolin&#x27;:&#x27;&#x27;&#125;, // ws:true, //用于支持websocket,默认true // changeOrigin: true //用于控制请求头中的host值，默认是true &#125;, &#x27;/lxg&#x27;:&#123; target: &#x27;http://localhost:5001&#x27;, // 匹配所有/xiaolin开头的替换成空字符串 pathRewrite:&#123;&#x27;^/lxg&#x27;:&#x27;&#x27;&#125;, // ws:true, //用于支持websocket,默认true // changeOrigin: true //用于控制请求头中的host值，默认是true &#125;, &#125; &#125;&#125;) 42、GitHub用户搜索案例接口地址：https://api.github.com/search/users?q=xxx 源码MyList.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 展示用户列表 --&gt; &lt;div v-show=&quot;info.users.length&quot; class=&quot;card&quot; v-for=&quot;user in info.users&quot; :key=&quot;user.id&quot; &gt; &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt; &lt;img :src=&quot;user.avatar_url&quot; style=&#x27;width:100px&#x27;/&gt; &lt;/a&gt; &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;user.login&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- 展示欢迎词 --&gt; &lt;h1 v-show=&quot;info.isFirst&quot;&gt;欢迎使用Github用户查询中心！&lt;/h1&gt; &lt;!-- 展示加载中 --&gt; &lt;div v-show=&quot;info.isLoading&quot;&gt; &lt;img src=&quot;../assets/img/loading.gif&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;loading&quot;&gt;正在努力加载中......请您耐心等待！&lt;/span&gt; &lt;/div&gt; &lt;!-- 展示错误信息 --&gt; &lt;h1 v-show=&quot;info.errMsg&quot;&gt;您的请求出错啦！&#123;&#123;info.errMsg&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;MyList&#x27;, data()&#123; return &#123; info:&#123; isFirst:true, isLoading:false, errMsg:&#x27;&#x27;, users:[] &#125; &#125; &#125;, mounted()&#123; // this.$bus.$on(&#x27;updateListData&#x27;,(isFirst,isLoading,errMsg,users)=&gt;&#123; this.$bus.$on(&#x27;updateListData&#x27;,(dataObj)=&gt;&#123; // console.log(&quot;我是List组件，我收到了数据：&quot;,users); this.info= &#123;...this.info,...dataObj&#125;; /* this.users=users; this.isFirst=isFirst; this.isLoading=isLoading; this.errMsg=errMsg; */ &#125;); &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .album &#123; min-height: 50rem; /* Can be removed; just added for demo purposes */ padding-top: 3rem; padding-bottom: 3rem; background-color: #f7f7f7; &#125; .card &#123; float: left; width: 33.333%; padding: .75rem; margin-bottom: 2rem; border: 1px solid #efefef; text-align: center; &#125; .card &gt; img &#123; margin-bottom: .75rem; border-radius: 100px; &#125; .card-text &#123; font-size: 85%; &#125; .loading&#123; font-size: 40px; &#125;&lt;/style&gt; Search.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;section class=&quot;jumbotron&quot;&gt; &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt; &lt;div&gt; &lt;input v-model=&quot;keyWord&quot; type=&quot;text&quot; placeholder=&quot;enter the name you search&quot;/&gt;&amp;nbsp; &lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; import axios from &#x27;axios&#x27;; export default &#123; name:&#x27;SearchS&#x27;, data()&#123; return&#123; keyWord:&#x27;&#x27;, &#125; &#125;, methods: &#123; searchUsers()&#123; // 请求更新List的数据 // this.$bus.$emit(&#x27;updateListData&#x27;,false,true,&#x27;&#x27;,[]); this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isFirst:false,isLoading:true,errMsg:&#x27;&#x27;,users:[]&#125;); //https://api.github.com/search/users?q=$&#123;this.keyWord&#125; axios.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then( response =&gt; &#123; console.log(&#x27;请求成功了&#x27;,response.data.items); // this.$bus.$emit(&#x27;getUsers&#x27;,response.data.items); // this.$bus.$emit(&#x27;updateListData&#x27;,false,false,&#x27;&#x27;,response.data.items) // 请求成功后 this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:&#x27;&#x27;,users:response.data.items&#125;); &#125;, error =&gt;&#123; console.log(&#x27;请求失败了&#x27;,error.message); // 请求失败后 this.$bus.$emit(&#x27;updateListData&#x27;,&#123;isLoading:false,errMsg:error.message,users:[]&#125;); &#125; ); &#125; &#125;, &#125;&lt;/script&gt; App.vue123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;Search/&gt; &lt;MyList/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // import &#x27;./assets/css/bootstrap.css&#x27; import Search from &#x27;./components/Search&#x27; import MyList from &#x27;./components/MyList&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; Search, MyList &#125; &#125;&lt;/script&gt; main.js123456789101112131415//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;//关闭Vue的生产提示Vue.config.productionTip = false//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this; &#125;,&#125;) bootstrap.css上官网下载 43、github搜索案例—-vue-resource现已不维护，不推荐使用，但需要了解一下 1、安装插件库：npm i vue-resource 2、引入插件库：import vueResource from ‘vue-resource’ 3、使用插件库：Vue.use(vueResource) 4、在Search.vue中：只需要将axios更改为this.$http即可，功能一模一样 44、slot插槽1、效果一（不使用插槽） 2、效果二（默认插槽） Category.vue 1234567891011&lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;!-- &lt;ul&gt; &lt;li v-for=&quot;(item,index) in listData&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;!-- &lt;img v-show=&quot;title==&#x27;美食&#x27;&quot; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;&gt; --&gt; &lt;!-- 定义一个插槽（占个位，等着组件的使用者进行填充） --&gt; &lt;slot&gt;默认值，若使用者没有传具体结构，我会出现&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; App.vue 123456789101112131415&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;Category title=&quot;美食&quot; :listData=&quot;foods&quot;&gt; &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;&gt; &lt;/Category&gt; &lt;Category title=&quot;游戏&quot; :listData=&quot;games&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Category&gt; &lt;Category title=&quot;电影&quot; :listData=&quot;films&quot;&gt; &lt;video controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt; &lt;/Category&gt; &lt;/div&gt;&lt;/template&gt; 3、具名插槽Category.vue 123456789101112&lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;!-- &lt;ul&gt; &lt;li v-for=&quot;(item,index) in listData&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;!-- &lt;img v-show=&quot;title==&#x27;美食&#x27;&quot; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;&gt; --&gt; &lt;!-- 定义一个插槽（占个位，等着组件的使用者进行填充） --&gt; &lt;slot name=&quot;center&quot;&gt;默认值，若使用者没有传具体结构，我会出现&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;默认值，若使用者没有传具体结构，我会出现&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; App.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;Category title=&quot;美食&quot; :listData=&quot;foods&quot;&gt; &lt;img slot=&quot;center&quot; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;&gt; &lt;a slot=&quot;footer&quot; href=&quot;https://www.bilibili.com&quot;&gt;更多美食&lt;/a&gt; &lt;/Category&gt; &lt;Category title=&quot;游戏&quot; :listData=&quot;games&quot;&gt; &lt;ul slot=&quot;center&quot;&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;div slot=&quot;footer&quot; class=&quot;foot&quot;&gt; &lt;a href=&quot;https://www.bilibili.com&quot;&gt;单击游戏&lt;/a&gt; &lt;a href=&quot;https://www.bilibili.com&quot;&gt;网络游戏&lt;/a&gt; &lt;/div&gt; &lt;/Category&gt; &lt;Category title=&quot;电影&quot; :listData=&quot;films&quot;&gt; &lt;video slot=&quot;center&quot; controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt; &lt;template v-slot:footer&gt; &lt;div class=&quot;foot&quot;&gt; &lt;a href=&quot;https://www.bilibili.com&quot;&gt;经典&lt;/a&gt; &lt;a href=&quot;https://www.bilibili.com&quot;&gt;热门&lt;/a&gt; &lt;a href=&quot;https://www.bilibili.com&quot;&gt;推荐&lt;/a&gt; &lt;/div&gt; &lt;h4&gt;欢迎前来观影&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt; &lt;/div&gt;&lt;/template&gt; 4、作用域插槽App.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;Category title=&quot;游戏&quot;&gt; &lt;template scope=&quot;xiaolin&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game,index) in xiaolin.games&quot; :key=&quot;index&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category title=&quot;游戏&quot; &gt; &lt;template scope=&#x27;&#123;games&#125;&#x27;&gt; &lt;ol&gt; &lt;li v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category title=&quot;游戏&quot;&gt; &lt;template slot-scope=&quot;&#123;games&#125;&quot;&gt; &lt;h4 v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt; &lt;/div&gt;&lt;/template&gt; Category.vue 123456&lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;slot :games=&quot;games&quot; msg=&quot;哈哈哈&quot;&gt;默认值，若使用者没有传具体结构，我会出现&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 5、总结 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 。 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽： 1234567891011父组件中： &lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 具名插槽： 123456789101112131415161718父组件中： &lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域插槽： 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定） 具体编码： 123456789101112131415161718192021222324252627282930313233343536373839404142 父组件中： &lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt; 子组件中： &lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125; &lt;/script&gt;## 45、vuex### 1、理解vuex1、vuex是什么？ 1、概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于组件间通信。2、GitHub地址：https://github.com/vuejs/vuex 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768692、什么时候使用vuex1. 多个组件依赖同一状态2. 来自不同组件的行为需要变更同一状态![image-20221109211649101](https://gitee.com/lin-xugeng/image/raw/master/img/202211092116245.png)![image-20221109233034400](https://gitee.com/lin-xugeng/image/raw/master/img/202211092330526.png)### 2、案例-vue版本Count.vue```vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;当前求和为:&#123;&#123;sum&#125;&#125;&lt;/h1&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;!-- &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; --&gt; &lt;/select&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt; &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;CountS&#x27;, data()&#123; return&#123; sum:0,//当前的和 n:1,//用户选中的数字 &#125; &#125;, methods:&#123; increment()&#123; this.sum+=this.n; &#125;, decrement()&#123; this.sum-=this.n; &#125;, incrementOdd()&#123; if(this.sum%2)&#123; this.sum+=this.n; &#125; &#125;, incrementWait()&#123; setTimeout(()=&gt;&#123; this.sum+=this.n; &#125;,300); &#125;, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; button&#123; margin-right: 10px; &#125;&lt;/style&gt; App.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;Count&gt;&lt;/Count&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Count from &#x27;./components/Count&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; Count &#125;, &#125;&lt;/script&gt; main.js 123456789101112131415161718//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;//引入插件import vueResource from &#x27;vue-resource&#x27;//关闭Vue的生产提示Vue.config.productionTip = false// 使用插件Vue.use(vueResource)//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this; &#125;,&#125;) 3、Vuex工作原理图 Mutate：包含多个直接更新state的方法，值为对象，不能写异步代码 State：vuex管理的状态对象——保存数据，唯一的 Actions：包含多个响应用户动作的回调函数，值为对象；通过commit()触发mutation函数调用，间接更新state；使用dispatch触发actions中的回调；可以包含异步代码 getters：包含多个用于返回数据的函数，值为对象 modules：包含多个module，一个module就是一个store的配置对象，与一个组件（包含有共享数据）对应 4、搭建vuex环境1、npm i vuex 2、Vue.use(Vuex) 3、store 4、vc&#x3D;&gt;store vue2中用vuex的3版本：npm i vuex@3 vue3中用vuex的4版本 1231、在src下新建文件夹store，在文件夹中新建文件index.js2、在main.js中引入store3、在new Vue中添加store配置项 index.js 12345678910111213141516171819202122// 该文件用于创建Vuex中最为核心的storeimport Vue from &#x27;vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;Vue.use(Vuex)// 准备actions---用于响应组件中的动作const actions = &#123;&#125;// 准备mutations---用于操作数据（state）const mutations = &#123;&#125;// 准备state---用于存储数据const state = &#123;&#125;// 创建store 暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) 5、vuex实现案例Count.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div&gt; &lt;h1&gt;当前求和为:&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;!-- &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; --&gt; &lt;/select&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt; &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;CountS&#x27;, data()&#123; return&#123; n:1,//用户选中的数字 &#125; &#125;, methods:&#123; increment()&#123; // this.$store.dispatch(&#x27;add&#x27;,this.n); this.$store.commit(&#x27;ADD&#x27;,this.n); &#125;, decrement()&#123; // this.$store.dispatch(&#x27;decrement&#x27;,this.n); this.$store.commit(&#x27;DECREMENT&#x27;,this.n); &#125;, incrementOdd()&#123; /* if(this.$store.state.sum % 2)&#123; this.$store.dispatch(&#x27;add&#x27;,this.n); &#125; */ this.$store.dispatch(&#x27;addOdd&#x27;,this.n); &#125;, incrementWait()&#123; /* setTimeout(()=&gt;&#123; this.$store.dispatch(&#x27;add&#x27;,this.n); &#125;,500); */ this.$store.dispatch(&#x27;addWait&#x27;,this.n); &#125;, &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; button&#123; margin-right: 10px; &#125;&lt;/style&gt; index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 该文件用于创建Vuex中最为核心的storeimport Vue from &#x27;vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;Vue.use(Vuex)// 准备actions---用于响应组件中的动作const actions = &#123; /* add(context,value)&#123; // console.log(&#x27;actions中的add被调用了&#x27;,context,value); context.commit(&#x27;ADD&#x27;,value); &#125;, decrement(context,value)&#123; context.commit(&#x27;DECREMENT&#x27;,value); &#125;, */ addOdd(context,value)&#123; // console.log(&#x27;actions中的add被调用了&#x27;,context,value); if(context.state.sum % 2)&#123; context.commit(&#x27;ADD&#x27;,value); &#125; &#125;, addWait(context,value)&#123; // console.log(&#x27;actions中的add被调用了&#x27;,context,value); setTimeout(()=&gt;&#123; context.commit(&#x27;ADD&#x27;,value); &#125;,500) &#125;, &#125;// 准备mutations---用于操作数据（state）const mutations = &#123; ADD(state,value)&#123; // console.log(&#x27;mutations中的ADD被调用了&#x27;,state,value); state.sum+=value; &#125;, DECREMENT(state,value)&#123; state.sum-=value; &#125;&#125;// 准备state---用于存储数据const state = &#123; sum:0,//当前的和&#125;// 创建store 暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) App.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;Count&gt;&lt;/Count&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Count from &#x27;./components/Count&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; Count &#125;, mounted() &#123; console.log(&#x27;App&#x27;,this); &#125;, &#125;&lt;/script&gt; main.js 1234567891011121314151617181920212223242526272829//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;//引入插件import vueResource from &#x27;vue-resource&#x27;// 引入storeimport store from &#x27;./store&#x27;//关闭Vue的生产提示Vue.config.productionTip = false// 使用插件Vue.use(vueResource)// Vue.use(Vuex)//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this; &#125;, // store:&#x27;hello&#x27;, store, data:&#123; msg:&#x27;test&#x27; &#125;&#125;) 6、总结 初始化数据、配置actions、配置mutations，操作文件store.js 12345678910111213141516171819202122232425262728293031323334//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123; //响应组件中加的动作 jia(context,value)&#123; // console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value) context.commit(&#x27;JIA&#x27;,value) &#125;,&#125;const mutations = &#123; //执行加 JIA(state,value)&#123; // console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value) state.sum += value &#125;&#125;//初始化数据const state = &#123; sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或 $store.commit(&#39;mutations中的方法名&#39;,数据) 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit 7、getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 12345678910111213......const getters = &#123; bigSum(state)&#123; return state.sum * 10 &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; ...... getters&#125;) 组件中读取数据：$store.getters.bigSum 1、修改index.js 1234567891011121314// 准备getters----用于量state中的数据进行加工const getters = &#123; bigSum(state)&#123; return state.sum*10 &#125;&#125;// 创建store 暴露storeexport default new Vuex.Store(&#123; actions, mutations, state, getters&#125;) 2、 修该Count.vue 1&lt;h3&gt;当前求和的10倍是：&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;/h3&gt; 8、mapState与mapGetters修改Count.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;h1&gt;当前求和为:&#123;&#123;sum&#125;&#125;&lt;/h1&gt; &lt;h3&gt;当前求和的10倍是：&#123;&#123;bigSum&#125;&#125;&lt;/h3&gt; &lt;h3&gt;我在&#123;&#123;school&#125;&#125;，学习&#123;&#123;subject&#125;&#125;&lt;/h3&gt;computed:&#123; // 靠程序员自己去写计算属性 /* he()&#123; return this.$store.state.sum &#125;, xuexiao()&#123; return this.$store.state.school &#125;, subject()&#123; return this.$store.state.subject &#125;, */ sum()&#123; return this.$store.state.sum &#125;, school()&#123; return this.$store.state.school &#125;, subject()&#123; return this.$store.state.subject &#125;, // 借助mapState生成计算属性，从state读取数据（对象写法） // ...mapState(&#123;he:&#x27;sum&#x27;,xuexiao:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;), // 借助mapState生成计算属性，从state读取数据（数组写法） ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), /* ******************************* */ /* bigSum()&#123; return this.$store.getters.bigSum &#125;, */ // 借助mapGetters生成计算属性，从state读取数据（对象写法） // ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;) // 借助mapGetters生成计算属性，从state读取数据（数组写法） ...mapGetters([&#x27;bigSum&#x27;]) &#125;, 9、mapMutation和mapActions修改Count.vue 12345678910111213141516171819202122232425262728293031323334 &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt; &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;methods:&#123; // 自己写 /* increment()&#123; this.$store.commit(&#x27;ADD&#x27;,this.n); &#125;, decrement()&#123; this.$store.commit(&#x27;DECREMENT&#x27;,this.n); &#125;, */ // 借助mapMutations生成对应的方法，方法中会调用commit去联系mutation（对象写法） ...mapMutations(&#123;increment:&#x27;ADD&#x27;,decrement:&#x27;DECREMENT&#x27;&#125;), // 借助mapMutations生成对应的方法，方法中会调用commit去联系mutation（数组写法） // ...mapMutations([&#x27;ADD&#x27;,&#x27;DECREMENT&#x27;]), /* ************************************* */ /* incrementOdd()&#123; this.$store.dispatch(&#x27;addOdd&#x27;,this.n); &#125;, incrementWait()&#123; this.$store.dispatch(&#x27;addWait&#x27;,this.n); &#125;, */ ...mapActions(&#123;incrementOdd:&#x27;addOdd&#x27;,incrementWait:&#x27;addWait&#x27;&#125;), // ...mapActions([&#x27;addOdd&#x27;,&#x27;addWait&#x27;]), &#125;, 10、四个map方法总结 mapState方法：用于帮助我们映射state中的数据为计算属性 1234567computed: &#123; //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;, mapGetters方法：用于帮助我们映射getters中的数据为计算属性 1234567computed: &#123; //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([&#x27;bigSum&#x27;])&#125;, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数 1234567methods:&#123; //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125; mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数 1234567methods:&#123; //靠mapActions生成：increment、decrement（对象形式） ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125; 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。 11、多组件共享数据新建Person.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div&gt; &lt;h1&gt;人员列表&lt;/h1&gt; &lt;h3 style=&quot;color:red&quot;&gt;Count组件的求和为:&#123;&#123;sum&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt; &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;nanoid&#125; from &#x27;nanoid&#x27;// import &#123; mapState &#125; from &#x27;vuex&#x27; export default &#123; name:&quot;PersonS&quot;, data()&#123; return&#123; name:&#x27;&#x27; &#125; &#125;, computed:&#123; personList()&#123; return this.$store.state.personList; &#125;, sum()&#123; return this.$store.state.sum; &#125; // ...mapState([&#x27;personList&#x27;]), &#125;, methods:&#123; add()&#123; const personObj = &#123;id:nanoid(),name:this.name&#125; // console.log(person); this.$store.commit(&#x27;ADD_PERSON&#x27;,personObj) this.name = &#x27;&#x27; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 修改index.js 1234567891011121314151617181920212223// 准备mutations---用于操作数据（state）const mutations = &#123; ADD(state,value)&#123; console.log(&#x27;mutations中的ADD被调用了&#x27;,state,value); state.sum+=value; &#125;, DECREMENT(state,value)&#123; state.sum-=value; &#125;, ADD_PERSON(state,value)&#123; console.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;,state,value); state.personList.unshift(value) &#125;&#125;// 准备state---用于存储数据const state = &#123; sum:0,//当前的和 school:&#x27;尚硅谷&#x27;, subject:&#x27;前端&#x27;, personList:[ &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;&#125; ]&#125; 在Count组件中使用personList数据 12&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是:&#123;&#123;personList.length&#125;&#125;&lt;/h3&gt; ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;,&#x27;personList&#x27;]), 12、模块化和命名空间 目的：让代码更好维护，让多种数据分类更加明确。 修改store.js 12345678910111213141516171819202122232425const countAbout = &#123; namespaced:true,//开启命名空间 state:&#123;x:1&#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; bigSum(state)&#123; return state.sum * 10 &#125; &#125;&#125;const personAbout = &#123; namespaced:true,//开启命名空间 state:&#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; countAbout, personAbout &#125;&#125;) 开启命名空间后，组件中读取state数据： 1234//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), 开启命名空间后，组件中读取getters数据： 1234//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]) 开启命名空间后，组件中调用dispatch 1234//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) 开启命名空间后，组件中调用commit 1234//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), 源码Count.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div&gt; &lt;h1&gt;当前求和为:&#123;&#123;sum&#125;&#125;&lt;/h1&gt; &lt;h3&gt;当前求和的10倍是：&#123;&#123;bigSum&#125;&#125;&lt;/h3&gt; &lt;h3&gt;我在&#123;&#123;school&#125;&#125;，学习&#123;&#123;subject&#125;&#125;&lt;/h3&gt; &lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是:&#123;&#123;personList.length&#125;&#125;&lt;/h3&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt; &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapState,mapMutations,mapGetters,mapActions&#125; from &#x27;vuex&#x27; export default &#123; name:&#x27;CountS&#x27;, data()&#123; return&#123; n:1,//用户选中的数字 &#125; &#125;, computed:&#123; // 借助mapState生成计算属性，从state读取数据（数组写法） // ...mapState([&#x27;countAbout&#x27;,&#x27;personAbout&#x27;]), ...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), ...mapState(&#x27;personAbout&#x27;,[&#x27;personList&#x27;]), // 借助mapGetters生成计算属性，从state读取数据（数组写法） ...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]) &#125;, methods:&#123; // 借助mapMutations生成对应的方法，方法中会调用commit去联系mutation（对象写法） ...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;ADD&#x27;,decrement:&#x27;DECREMENT&#x27;&#125;), ...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;addOdd&#x27;,incrementWait:&#x27;addWait&#x27;&#125;), &#125;, mounted()&#123; // const x = mapState(&#123;he:&#x27;sum&#x27;,xuexiao:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;) // console.log(x); &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; button&#123; margin-right: 10px; &#125;&lt;/style&gt; Person.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;h1&gt;人员列表&lt;/h1&gt; &lt;h3 style=&quot;color:red&quot;&gt;Count组件的求和为:&#123;&#123;sum&#125;&#125;&lt;/h3&gt; &lt;h3&gt;列表中第一个人的名字是：&#123;&#123;firstPersonName&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt; &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt; &lt;button @click=&quot;addWang&quot;&gt;添加一个姓王的人&lt;/button&gt; &lt;button @click=&quot;addText&quot;&gt;添加一句话&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;nanoid&#125; from &#x27;nanoid&#x27;// import &#123; mapState &#125; from &#x27;vuex&#x27; export default &#123; name:&quot;PersonS&quot;, data()&#123; return&#123; name:&#x27;&#x27; &#125; &#125;, computed:&#123; personList()&#123; return this.$store.state.personAbout.personList; &#125;, sum()&#123; return this.$store.state.countAbout.sum; &#125;, firstPersonName()&#123; return this.$store.getters[&#x27;personAbout/firstPersonName&#x27;] &#125; // ...mapState([&#x27;personList&#x27;]), &#125;, methods:&#123; add()&#123; const personObj = &#123;id:nanoid(),name:this.name&#125; // console.log(person); this.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,personObj) this.name = &#x27;&#x27; &#125;, addWang()&#123; const personObj = &#123;id:nanoid(),name:this.name&#125; this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,personObj) this.name = &#x27;&#x27; &#125;, addText()&#123; this.$store.dispatch(&#x27;personAbout/addPersonServer&#x27;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; App.vue1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;Count&gt;&lt;/Count&gt; &lt;hr&gt; &lt;Person&gt;&lt;/Person&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Count from &#x27;./components/Count&#x27; import Person from &#x27;./components/Person&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; Count, Person &#125;, mounted() &#123; // console.log(&#x27;App&#x27;,this); &#125;, &#125;&lt;/script&gt; main.js1234567891011121314151617181920212223242526272829//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;//引入插件import vueResource from &#x27;vue-resource&#x27;// 引入storeimport store from &#x27;./store&#x27;//关闭Vue的生产提示Vue.config.productionTip = false// 使用插件Vue.use(vueResource)// Vue.use(Vuex)//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this; &#125;, // store:&#x27;hello&#x27;, store, data:&#123; msg:&#x27;test&#x27; &#125;&#125;) count.js123456789101112131415161718192021222324252627282930313233343536373839// 求和组件相关的配置const countOptions = &#123; namespaced:true, actions:&#123; addOdd(context,value)&#123; console.log(&#x27;actions中的add被调用了&#x27;,context,value); if(context.state.sum % 2)&#123; context.commit(&#x27;ADD&#x27;,value); &#125; &#125;, addWait(context,value)&#123; // console.log(&#x27;actions中的add被调用了&#x27;,context,value); setTimeout(()=&gt;&#123; context.commit(&#x27;ADD&#x27;,value); &#125;,500) &#125;, &#125;, mutations:&#123; ADD(state,value)&#123; console.log(&#x27;mutations中的ADD被调用了&#x27;,state,value); state.sum+=value; &#125;, DECREMENT(state,value)&#123; state.sum-=value; &#125;, &#125;, state:&#123; sum:0,//当前的和 school:&#x27;尚硅谷&#x27;, subject:&#x27;前端&#x27;, &#125;, getters:&#123; bigSum(state)&#123; return state.sum*10 &#125; &#125;&#125;export default countOptions person.js123456789101112131415161718192021222324252627282930313233343536373839404142434445// 人员管理组件相关的配置import axios from &quot;axios&quot;;import &#123; nanoid &#125; from &quot;nanoid&quot;;const personOptions = &#123; namespaced:true, actions:&#123; addPersonWang(context,value)&#123; // console.log(context,value) if(value.name.indexOf(&#x27;王&#x27;)===0)&#123; context.commit(&#x27;ADD_PERSON&#x27;,value) &#125;else&#123; alert(&#x27;只能添加姓王的人哦&#x27;) &#125; &#125;, addPersonServer(context)&#123; axios.get(&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;).then( response=&gt;&#123; context.commit(&#x27;ADD_PERSON&#x27;,&#123;id:nanoid(),name:response.data&#125;) &#125;, error=&gt;&#123; alert(error.message) &#125; ) &#125; &#125;, mutations:&#123; ADD_PERSON(state,value)&#123; console.log(&#x27;mutations中的ADD_PERSON被调用了&#x27;,state,value); state.personList.unshift(value) &#125; &#125;, state:&#123; personList:[ &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;&#125; ] &#125;, getters:&#123; firstPersonName(state)&#123; return state.personList[0].name &#125; &#125;&#125;export default personOptions index.js123456789101112131415161718192021222324// 该文件用于创建Vuex中最为核心的storeimport Vue from &#x27;vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;import countOptions from &#x27;./count&#x27;import personOptions from &#x27;./person&#x27;Vue.use(Vuex)// 创建store 暴露storeexport default new Vuex.Store(&#123; modules:&#123; countAbout:countOptions, personAbout:personOptions &#125;&#125;) 46、vue-router1、基本介绍 1、理解：vue的一个插件库，专门用来实现SPA应用 2、SPA的理解 12341、单页Web应用（single page web application，SPA）2、整个应用只有一个完整的页面3、点击页面中的导航链接不会刷新页面，只会做页面的局部更新4、数据需要通过ajax请求获取 3、路由的理解 123456789101、什么是路由 1.一个路由就是一组映射关系（key - value） 2. key 为路径, value 可能是 function 或 component 2、路由分类 1. 后端路由： 1) 理解：value 是 function, 用于处理客户端提交的请求。 2) 工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数 来处理请求, 返回响应数据。 2. 前端路由： 1) 理解：value 是 component，用于展示页面内容。 2) 工作过程：当浏览器的路径改变时, 对应的组件就会显示 2、基本路由 安装vue-router，命令：npm i vue-router@3 应用插件：Vue.use(VueRouter) 编写router配置项: 12345678910111213141516171819202122//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home &#125; ]&#125;)//暴露routerexport default router 实现切换（active-class可配置高亮样式） 1&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 指定展示位置 1&lt;router-view&gt;&lt;/router-view&gt; 源码About.vue 1234567891011 &lt;template&gt; &lt;h2&gt;我是About的内容&lt;/h2&gt; &lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;AboutMe&quot;&#125;&lt;/script&gt; Home.vue12345678910&lt;template&gt;&lt;h2&gt;我是Home的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;TheHome&quot;&#125;&lt;/script&gt; router&#x2F;index.js123456789101112131415161718192021//该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建一个路由器const router = new VueRouter(&#123;routes:[&#123;path:&#x27;/about&#x27;,component:About&#125;,&#123;path:&#x27;/home&#x27;,component:Home&#125;,]&#125;)export default router App.vue12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt;&lt;div&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;&lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;&lt;div class=&quot;list-group&quot;&gt;&lt;!-- 原始html我们使用a标签实现页面的跳转 --&gt;&lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt; --&gt;&lt;!-- &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;&lt;!-- Vue中接祖router-link实现路径切换 --&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;col-xs-6&quot;&gt;&lt;div class=&quot;panel&quot;&gt;&lt;div class=&quot;panel-body&quot;&gt;&lt;!-- 此处看用户点击什么，再展示什么 --&gt;&lt;!-- 指定组件的呈现位置 --&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&#x27;App&#x27;,&#125;&lt;/script&gt; main.js123456789101112131415161718//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;// 引入VueRouterimport VueRouter from &#x27;vue-router&#x27;// 引入路由器import router from &#x27;./router&#x27;//关闭Vue的生产提示Vue.config.productionTip = false// 应用插件Vue.use(VueRouter)//创建vmnew Vue(&#123;el:&#x27;#app&#x27;,render: h =&gt; h(App),router:router&#125;) 3、几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 4、嵌套（多级）路由 配置路由规则，使用children配置项： 1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ //通过children配置子级路由 &#123; path:&#x27;news&#x27;, //此处一定不要写：/news component:News &#125;, &#123; path:&#x27;message&#x27;,//此处一定不要写：/message component:Message &#125; ] &#125;] 跳转（要写完整路径）： 1&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt; 源码Banner.vue1234567891011121314&lt;template&gt;&lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;&lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Vue Router Demo&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;BannerS&quot;&#125;&lt;/script&gt; Home.vue12345678910111213141516171819202122232425262728293031&lt;template&gt;&lt;div&gt;&lt;h2&gt;Home组件内容&lt;/h2&gt;&lt;div&gt;&lt;ul class=&quot;nav nav-tabs&quot;&gt;&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt;&lt;li&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;TheHome&quot;,/* beforeDestroy() &#123;console.log(&quot;home即将销毁了&quot;)&#125;, *//* mounted()&#123;console.log(&quot;home挂载好了&quot;,this);window.hoemRoute = this.$routewindow.homeRouter = this.$router&#125; */&#125;&lt;/script&gt; Message.vue1234567891011121314151617181920212223&lt;template&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/message1&quot;&gt;message001&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/message2&quot;&gt;message002&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/message/3&quot;&gt;message003&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;MessageS&quot;&#125;&lt;/script&gt; News.vue123456789101112131415&lt;template&gt;&lt;ul&gt;&lt;li&gt;news001&lt;/li&gt;&lt;li&gt;news002&lt;/li&gt;&lt;li&gt;news003&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;NewS&quot;&#125;&lt;/script&gt; router&#x2F;index.js123456789101112131415161718192021222324252627282930313233//该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../pages/About&#x27;import Home from &#x27;../pages/Home&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;// 创建一个路由器const router = new VueRouter(&#123;routes:[&#123;path:&#x27;/about&#x27;,component:About&#125;,&#123;path:&#x27;/home&#x27;,component:Home,children:[&#123;path:&quot;message&quot;,component:Message,&#125;,&#123;path:&quot;news&quot;,component:News,&#125;]&#125;,]&#125;)export default router App.vue12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt;&lt;div&gt;&lt;div class=&quot;row&quot;&gt;&lt;Banner&gt;&lt;/Banner&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;&lt;div class=&quot;list-group&quot;&gt;&lt;!-- 原始html我们使用a标签实现页面的跳转 --&gt;&lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt; --&gt;&lt;!-- &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;&lt;!-- Vue中接祖router-link实现路径切换 --&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;col-xs-6&quot;&gt;&lt;div class=&quot;panel&quot;&gt;&lt;div class=&quot;panel-body&quot;&gt;&lt;!-- 此处看用户点击什么，再展示什么 --&gt;&lt;!-- 指定组件的呈现位置 --&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Banner from &#x27;./components/Banner&#x27;export default &#123;name:&#x27;App&#x27;,components:&#123;Banner&#125;&#125;&lt;/script&gt; main.js123456789101112131415161718//引入Vueimport Vue from &#x27;vue&#x27;//引入Appimport App from &#x27;./App.vue&#x27;// 引入VueRouterimport VueRouter from &#x27;vue-router&#x27;// 引入路由器import router from &#x27;./router&#x27;//关闭Vue的生产提示Vue.config.productionTip = false// 应用插件Vue.use(VueRouter)//创建vmnew Vue(&#123;el:&#x27;#app&#x27;,render: h =&gt; h(App),router:router&#125;) About.vue12345678910111213141516171819&lt;template&gt;&lt;h2&gt;我是About的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&quot;AboutMe&quot;,/* beforeDestroy() &#123;console.log(&quot;about即将销毁了&quot;)&#125;, */mounted()&#123;console.log(&quot;about挂载好了&quot;,this);window.aboutRoute = this.$routewindow.aboutRouter = this.$router&#125;&#125;&lt;/script&gt; 5、路由传参 传递参数 12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数： 12$route.query.id$route.query.title 源码Detail.vue12345678910111213141516171819&lt;template&gt; &lt;ul&gt; &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt; &lt;li&gt;消息标题：&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;DetailS&quot;, mounted()&#123; console.log(this.$route); &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Message.vue12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt; &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt; &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt; &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt; &lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt; &#123;&#123;m.title&#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;MessageS&quot;, data()&#123; return &#123; messageList:[ &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;, &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;, &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;, ] &#125; &#125; &#125;&lt;/script&gt; router&#x2F;index.js12345678910111213141516171819202122232425262728293031323334353637383940//该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../pages/About&#x27;import Home from &#x27;../pages/Home&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;// 创建一个路由器const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&quot;message&quot;, component:Message, children:[ &#123; path:&#x27;detail&#x27;, component:Detail &#125; ] &#125;, &#123; path:&quot;news&quot;, component:News, &#125; ] &#125;, ]&#125;)export default router 6、命名路由 作用：可以简化路由的跳转。 如何使用 给路由命名： 1234567891011121314151617&#123; path:&#x27;/demo&#x27;, component:Demo, children:[ &#123; path:&#x27;test&#x27;, component:Test, children:[ &#123; name:&#x27;hello&#x27; //给路由命名 path:&#x27;welcome&#x27;, component:Hello, &#125; ] &#125; ]&#125; 简化跳转： 12345678910111213141516&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;hello&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 7、params参数 配置路由，声明接收params参数 1234567891011121314151617181920&#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; component:Message, children:[ &#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数 component:Detail &#125; ] &#125; ]&#125; 传递参数 12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！ 接收参数： 12$route.params.id$route.params.title 8、路由的props配置 作用：让路由组件更方便的收到参数 12345678910111213141516171819202122232425262728293031323334353637&#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id&#x27;, component:Detail, *//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件* *// props:&#123;a:900&#125;* *//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件* *// props:true* *//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件* props(route)&#123;​ return &#123;​ id:route.query.id,​ title:route.query.title​ &#125; &#125;&#125; 源码index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../pages/About&#x27;import Home from &#x27;../pages/Home&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;// 创建一个路由器const router = new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; // name:&#x27;xiaoxi&#x27;, path:&quot;message&quot;, component:Message, children:[ &#123; name:&#x27;xiangqing&#x27;, // path:&#x27;detail/:id/:title&#x27;, path:&#x27;detail&#x27;, component:Detail, // props的第一种写法，值为对象,该对象的所有key-value都会以props的形式传给Detail组件 /* props:&#123; a:1, b:&quot;hello&quot; &#125; */ // props的第二种写法，值为布尔值，若为true则会把该路由组件收到的所有params参数，以props的形式传给detail组件 // props:true // props的第三种写法，值为函数 /* props($route)&#123; return &#123; id:$route.query.id, title:$route.query.title &#125; &#125; */ props(&#123;query:&#123;id,title&#125;&#125;)&#123; return &#123;id,title&#125; &#125; &#125; ] &#125;, &#123; path:&quot;news&quot;, component:News, &#125; ] &#125;, ]&#125;)export default router Detail.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;ul&gt; &lt;!-- &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt; &lt;li&gt;消息标题：&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt; --&gt; &lt;!-- &lt;li&gt;消息编号：&#123;&#123;$route.params.id&#125;&#125;&lt;/li&gt; &lt;li&gt;消息标题：&#123;&#123;$route.params.title&#125;&#125;&lt;/li&gt; --&gt; &lt;li&gt;消息编号：&#123;&#123;id&#125;&#125;&lt;/li&gt; &lt;li&gt;消息标题：&#123;&#123;title&#125;&#125;&lt;/li&gt; &lt;!-- &lt;li&gt;a:&#123;&#123;a&#125;&#125;&lt;/li&gt; &lt;li&gt;b:&#123;&#123;b&#125;&#125;&lt;/li&gt; --&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;DetailS&quot;, // props:[&#x27;a&#x27;,&#x27;b&#x27;], props:[&#x27;id&#x27;,&#x27;title&#x27;], mounted()&#123; console.log(this.$route); &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Message.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt; &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt; &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt; &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt; &lt;router-link :to=&quot;&#123; // path:&#x27;/home/message/detail&#x27;, name:&#x27;xiangqing&#x27;, /* params:&#123; id:m.id, title:m.title &#125; */ query:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt; &#123;&#123;m.title&#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;MessageS&quot;, data()&#123; return &#123; messageList:[ &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;, &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;, &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;, ] &#125; &#125; &#125;&lt;/script&gt; 9、&lt;router-link&gt;的replace属性1、作用：控制路由跳转时操作浏览器历史记录的模式 2、浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 2、如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt; 10、编程式路由导航1、作用：不借助&lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活 2、具体编码： 12345678910111213141516171819 //$router的两个API this.$router.push(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125; &#125;) this.$router.replace(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125; &#125;) this.$router.forward() //前进 this.$router.back() //后退 this.$router.go() //可前进也可后退 源码banner.vue12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h2&gt;Vue Router Demo&lt;/h2&gt; &lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt; &lt;button @click=&quot;forward&quot;&gt;前进&lt;/button&gt; &lt;button @click=&quot;go&quot;&gt;go前进三步&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;BannerS&quot;, methods:&#123; back()&#123; // console.log(this.$router); this.$router.back() &#125;, forward()&#123; // console.log(this.$router); this.$router.forward() &#125;, go()&#123; // console.log(this.$router); this.$router.go(3) &#125;, &#125; &#125;&lt;/script&gt; Message.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt; &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt; &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt; &lt;!-- 跳转路由并携带params参数，to的字符串写法 --&gt; &lt;router-link :to=&quot;&#123; // path:&#x27;/home/message/detail&#x27;, name:&#x27;xiangqing&#x27;, /* params:&#123; id:m.id, title:m.title &#125; */ query:&#123; id:m.id, title:m.title &#125; &#125;&quot;&gt; &#123;&#123;m.title&#125;&#125; &lt;/router-link&gt; &lt;button @click=&quot;pushShow(m)&quot;&gt;push查看&lt;/button&gt; &lt;button @click=&quot;replaceShow(m)&quot;&gt;replace查看&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;MessageS&quot;, data()&#123; return &#123; messageList:[ &#123;id:&#x27;001&#x27;,title:&#x27;消息001&#x27;&#125;, &#123;id:&#x27;002&#x27;,title:&#x27;消息002&#x27;&#125;, &#123;id:&#x27;003&#x27;,title:&#x27;消息003&#x27;&#125;, ] &#125; &#125;, methods:&#123; pushShow(m)&#123; // console.log(this.$router); this.$router.push(&#123; name:&#x27;xiangqing&#x27;, query:&#123; id:m.id, title:m.title &#125; &#125;) &#125;, replaceShow(m)&#123; // console.log(this.$router); this.$router.replace(&#123; name:&#x27;xiangqing&#x27;, query:&#123; id:m.id, title:m.title &#125; &#125;) &#125; &#125;, &#125;&lt;/script&gt; 11、缓存路由组件1、作用：让不展示的路由组件保持挂载，不被销毁。 2、 具体编码：(include填写组件名) 123456789&lt;!-- 缓存多个路由组件 --&gt; &lt;!-- &lt;keep-alive :include=&quot;[&#x27;NewS&#x27;,&#x27;Message&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; --&gt; &lt;!-- 缓存一个路由组件 --&gt; &lt;keep-alive include=&quot;NewS&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 12、两个新的生命周期1、作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 2、 具体名字： 123456789101112131415161718192021222324252627282930313233343536​ ```deactivated```路由组件失活时触发。### 13、路由守卫1. 作用：对路由进行权限控制2. 分类：全局守卫、独享守卫、组件内守卫3. 全局守卫: ```js //全局前置守卫：初始化时执行、每次路由切换前执行 router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则 next() //放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() //放行 &#125; &#125;) //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title //修改网页的title &#125;else&#123; document.title = &#x27;vue_test&#x27; &#125; &#125;) 独享守卫: 12345678910111213beforeEnter(to,from,next)&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; next() &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() &#125;&#125; 组件内守卫： 123456//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125; 源码router&#x2F;index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;// 引入组件import About from &#x27;../pages/About&#x27;import Home from &#x27;../pages/Home&#x27;import News from &#x27;../pages/News&#x27;import Message from &#x27;../pages/Message&#x27;import Detail from &#x27;../pages/Detail&#x27;// 创建一个路由器const router = new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About, meta:&#123;isAuth:true,title:&#x27;关于&#x27;&#125; &#125;, &#123; name:&quot;zhuye&quot;, path:&#x27;/home&#x27;, component:Home, meta:&#123;title:&#x27;主页&#x27;&#125;, children:[ &#123; name:&#x27;xiaoxi&#x27;, path:&quot;message&quot;, component:Message, meta:&#123;isAuth:true,title:&#x27;消息&#x27;&#125;, children:[ &#123; name:&#x27;xiangqing&#x27;, // path:&#x27;detail/:id/:title&#x27;, path:&#x27;detail&#x27;, component:Detail, meta:&#123;isAuth:true,title:&#x27;详情&#x27;&#125;, // props的第一种写法，值为对象,该对象的所有key-value都会以props的形式传给Detail组件 /* props:&#123; a:1, b:&quot;hello&quot; &#125; */ // props的第二种写法，值为布尔值，若为true则会把该路由组件收到的所有params参数，以props的形式传给detail组件 // props:true // props的第三种写法，值为函数 /* props($route)&#123; return &#123; id:$route.query.id, title:$route.query.title &#125; &#125; */ props(&#123;query:&#123;id,title&#125;&#125;)&#123; return &#123;id,title&#125; &#125; &#125; ] &#125;, &#123; name:&#x27;xinwen&#x27;, path:&quot;news&quot;, component:News, meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;, /* beforeEnter:(to,from,next)=&gt;&#123; console.log(&#x27;独享路由守卫&#x27;,to,from,next) if(to.meta.isAuth)&#123; if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123; next() &#125;else&#123; alert(&#x27;学校名不对，没有权限查看&#x27;) &#125; &#125;else&#123; next() &#125; &#125; */ &#125; ] &#125;, ]&#125;)// 全局前置路由守卫----初始化时被调用，还有每次路由切换之前被调用/* router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;前置路由守卫&#x27;,to,from,next) // if(to.path===&#x27;/home/news&#x27; || to.path===&#x27;/home/message&#x27;)&#123; // if(to.name===&#x27;xinwen&#x27; || to.name===&#x27;xiaoxi&#x27;)&#123; if(to.meta.isAuth)&#123; if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123; // document.title=to.meta.title || &#x27;尚硅谷系统&#x27; next() &#125;else&#123; alert(&#x27;学校名不对，没有权限查看&#x27;) &#125; &#125;else&#123; // document.title=to.meta.title || &#x27;尚硅谷系统&#x27; next() &#125;&#125;) */// 全局后置路由守卫----初始化时被调用，还有每次路由切换之后被调用/* router.afterEach((to,from)=&gt;&#123; console.log(&#x27;后置路由守卫&#x27;,to,from) document.title=to.meta.title || &#x27;尚硅谷系统&#x27; &#125;) */export default router About.vue1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;h2&gt;我是About的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;AboutMe&quot;, /* beforeDestroy() &#123; console.log(&quot;about即将销毁了&quot;) &#125;, */ /* mounted()&#123; console.log(&quot;about挂载好了&quot;,this); window.aboutRoute = this.$route window.aboutRouter = this.$router &#125; */ // 通过路由规则，进入该组件时被调用 beforeRouteEnter(to,from,next)&#123; console.log(&#x27;About---beforeRouteEnter&#x27;,to,from,next) if(to.meta.isAuth)&#123; if(localStorage.getItem(&#x27;school&#x27;)===&#x27;atguigu&#x27;)&#123; next() &#125;else&#123; alert(&#x27;学校名不对，没有权限查看&#x27;) &#125; &#125;else&#123; next() &#125; &#125;, // 通过路由规则，离开该组件被调用 beforeRouteLeave(to,from,next)&#123; console.log(&#x27;About---beforeRouteLeave&#x27;,to,from,next) next() &#125; &#125;&lt;/script&gt; 14.路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。 hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。 hash模式： 地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式： 地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。 1、修改路由器工作模式(mode配置项)12345678910// 创建一个路由器const router = new VueRouter(&#123; mode:&#x27;history&#x27;, routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About, meta:&#123;isAuth:true,title:&#x27;关于&#x27;&#125; &#125;, 2、将vue项目打包成静态资源npm run build 3、使用node.js写一台简易服务器 初始化项目 npm init 安装express框架 npm i express 新建server.js编写服务器逻辑代码 12345678910111213const express = require(&#x27;express&#x27;)const app = express()app.use(express.static(__dirname+&#x27;/static&#x27;))app.get(&#x27;/person&#x27;,(req,res)=&gt;&#123; res.send(&#123; name:&#x27;tom&#x27;, age:18 &#125;)&#125;)app.listen(5005,(err)=&gt;&#123; if(!err) console.log(&#x27;服务器启动成功了！&#x27;)&#125;) 安装history中间件解决，404问题 npm i connect-history-api-fallback 引入并使用 12345678910111213141516171819const express = require(&#x27;express&#x27;)const history = require(&#x27;connect-history-api-fallback&#x27;)const app = express()//以下这行代码必须在使用静态资源之前app.use(history())app.use(express.static(__dirname+&#x27;/static&#x27;))app.get(&#x27;/person&#x27;,(req,res)=&gt;&#123; res.send(&#123; name:&#x27;tom&#x27;, age:18 &#125;)&#125;)app.listen(5005,(err)=&gt;&#123; if(!err) console.log(&#x27;服务器启动成功了！&#x27;)&#125;) 47、Vue—-UI组件库1、移动端常用 UI 组件库 Vant https://youzan.github.io/vant Cube UI https://didi.github.io/cube-ui Mint UI http://mint-ui.github.io 2、PC端常用UI组件库 Element UI https://element.eleme.cn IView UI https://www.iviewui.co","tags":"vue"},{"title":"Thymeleaf","url":"/2023/10/12/Thymeleaf/","text":"Thymeleaf视图模板技术 JavaWeb教程目录 | 代码重工 (gitee.io) 123456786. thymeleaf的部分标签 1） 使用步骤： 添加jar ， 新建ViewBaseServlet(有两个方法） ， 配置两个&lt;context-param&gt; : view-prefix , view-suffix 2） 部分标签： &lt;th:if&gt; , &lt;th:unless&gt; , &lt;th:each&gt; , &lt;th:text&gt;7、Thymeleaf-视图模板技术(1)添加thymeleaf的jar包（2）在web.xml文件中添加配置（3）新建一个Servlet类ViewBaseServlet（4）使得我们的Servlet继承ViewBaseServlet","tags":"thymeleaf"},{"title":"SpringCloud","url":"/2023/10/12/SpringCloud/","text":"# SpringCloud 一、微服务的概述1、什么是微服务，什么是微服务架构？业界大牛马丁.福勒（Martin Fowler） 这样描述微服务：论文网址：https://martinfowler.com/articles/microservices.html 微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题&#x2F;提供落地对应服务的一个服务应用, 狭意的看,可以看作Eclipse里面的一个个微服务工程&#x2F;或者Module 微服务架构 微服务架构是⼀种架构模式，它提倡将单⼀应⽤程序划分成⼀组⼩的服务，服务之间互相协调、互相配合，为⽤户提供最终价值。每个服务运⾏在其独⽴的进程中，服务与服务间采⽤轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进⾏构建，并且能够被独⽴的部署到⽣产环境、类⽣产环境等。另外，应当尽量避免统⼀的、集中式的服务管理机制，对具体的⼀个服务⽽⾔，应根据业务上下⽂，选择合适的语⾔、⼯具对其进⾏构建。 技术维度理解 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。 2、微服务技术栈有哪些？ 微服务条目 落地技术 备注 服务开发 Springboot、Spring、SpringMVC 服务配置与管理 Netflix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、RPC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用(客户端调用服务的简化工具) Feign等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由（API网关） Zuul等 服务监控 Zabbix、Nagios、Metrics、Spectator等 全链路追踪 Zipkin，Brave、Dapper等 服务部署 Docker、OpenStack、Kubernetes等 数据流操作开发包 SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息） 事件消息总线 Spring Cloud Bus 现在有些已经不再使用，有新的技术进行替代 详情看组件替换 二、SpringCloud1、官网说明 12345SpringCloud，基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。 SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到一键启动和部署。 SpringBoot并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包 2、概述SpringCloud&#x3D;分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶 3、SpringCloud和SpringBoot的关系SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务 SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系. SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。 4、Dubbo是怎么到SpringCloud的？哪些优缺点让你去技术选型4.1、目前成熟的互联网架构（分布式+服务治理Dubbo） 4.2、SpringCloud和Dubbo对比 12345678最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。 品牌机与组装机的区别很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 社区支持与更新力度最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。 4.3、总结问题：曾风靡国内的开源 RPC 服务框架 Dubbo 在重启维护后，令许多用户为之雀跃，但同时，也迎来了一些质疑的声音。互联网技术发展迅速，Dubbo 是否还能跟上时代？Dubbo 与 Spring Cloud 相比又有何优势和差异？是否会有相关举措保证 Dubbo 的后续更新频率？ 人物：Dubbo重启维护开发的刘军，主要负责人之一 刘军，阿里巴巴中间件高级研发工程师，主导了 Dubbo 重启维护以后的几个发版计划，专注于高性能 RPC 框架和微服务相关领域。曾负责网易考拉 RPC 框架的研发及指导在内部使用，参与了服务治理平台、分布式跟踪系统、分布式一致性框架等从无到有的设计与开发过程。 5、参考资料官网：Spring Cloud 参考书： Spring Cloud Netflix 中文文档 参考手册 中文版 springcloud中国社区：Spring Cloud中国社区 springcloud中文网：Spring Cloud中文网-官方文档中文版 三、SpringBoot和SpringCloud等其他技术的版本选择1、查看方式 官网查看 https://start.spring.io/actuator/info 2、确定版本老版本： 技术 版本 springcloud Hoxton.SR1 springboot 2.2.2.RELEASE cloud alibaba 2.1.0.RELEASE java java8 Maven 3.5及以上 MySQL 5.7及以上 新版本： 技术 版本 springcloud 2021.0.6 springboot 2.6.13 cloud alibaba 2021.0.4.0 java java8 Maven 3.5及以上 MySQL 5.7及以上 四、关于SpringCloud各种组件的停更&#x2F;升级&#x2F;替换 参考文档： https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md Spring Boot 中文文档 (springdoc.cn) Index of &#x2F;spring-boot&#x2F;docs Index of &#x2F;spring-cloud&#x2F;docs 五、微服务架构编码构建首先要明确一点：约定＞配置＞编码 1、idea新建父工程一系列操作说明1.1、idea新建父工程及其配置1.1、New Project 也可 1.1.2、创建名称名称：cloud2020 组：com.lxg.springcloud 1.1.3、Maven选版本 1.1.4、字符编码 1.1.5、注解生效激活 1.1.6、java编译版本选择8 1.2、父工程pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.13&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.18.20&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.20&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;2.1.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.6.13--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.6.13&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud 2021.0.6--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1.3、Maven工程落地细节1.3.1、dependencyManagementMaven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。 使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个dependencyManagement 元素中指定的版本号。 这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改 ；另外如果某个子项目需要另外的一个版本，只需要声明version就可。 dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本， 才会从父项目中继承该项，并且version和scope都读取自父pom; 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 1.3.2、跳过测试 1.4、父工程执行install操作 1.5、msql驱动说明123456com.mysql.jdbc.Driver和mysql-connector-java 5一起用。com.mysql.cj.jdbc.Driver和mysql-connector-java 6 一起用。com.mysql.cj.jdbc.Driver是mysql-connector-java 6 中的特性，相比mysql-connector-java 5 多了一个时区：serverTimezone，把数据源配置的驱动改一下就好了org.gjt.mm.mysql.Driver是当时最好的MySQL JDBC，但不是MySQL公司的，然后MySQL将MM的JDBC驱动 收为官方的JDBC驱动，所以将驱动的package也改了，但还保留了org.gjt.mm.mysql.Driver这个路径的引用，也就是你使用新版的JDBC驱动时还可以通过这个来引用，打开下载的新版JDBC驱动的jar文件可以看到，只有一个文件的目录是org.gjt.mm.mysql，就是为了兼容而设计的。 2、Rest微服务架构编码构建主要流程 123451、建module2、改pom3、写yml4、主启动5、业务类 2.1、cloud-provider-payment8001模块搭建2.1.1、创建模块 此时父工程的pom文件会多以下内容 123&lt;modules&gt; &lt;module&gt;cloud-provider-payment8001&lt;/module&gt;&lt;/modules&gt; 2.1.2、修改模块pom文件（不是父工程）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql-connector-java--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3、在resources下新建application.yml文件123456789101112131415161718server: port: 8001spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource #当前数据源操作类型 driver-class-name: com.mysql.jdbc.Driver #驱动名称 url: jdbc:mysql://localhost:3306/cloud2020?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false #数据库连接URL username: root #数据库连接用户名 password: 123456 #数据库连接密码mybatis: mapper-locations: classpath:mapper/*.xml #mybatis mapper文件路径 type-aliases-package: com.lxg.springcloud.entities #实体类所在的package 2.1.4、编写主启动类123456789101112package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class,args); &#125;&#125; 2.1.5、编写业务类1、建表 12345CREATE TABLE `payment` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;ID&#x27;, `serial` varchar(200) DEFAULT &#x27;&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 2、实体类enties 主实体： 1234567891011121314151617package com.lxg.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123; private Long id; private String serial;&#125; json封装体（返回给前端的） 12345678910111213141516171819202122package com.lxg.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; //处理没传数据的情况 public CommonResult(Integer code,String message)&#123; this(code,message,null); &#125;&#125; 3、dao PaymentDao： 123456789101112131415161718192021222324package com.lxg.springcloud.dao;import com.lxg.springcloud.entities.Payment;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;/** * @auther xiaolin * @creatr 2023/3/11 11:51 */@Mapperpublic interface PaymentDao &#123; public int create(Payment payment); public Payment getPaymentById(@Param(&quot;id&quot;) Long id); public int updatPayment(Payment payment); public int deletePaymentById(@Param(&quot;id&quot;) Long id);&#125; dao对应映射文件：(resources&#x2F;mapper&#x2F;xxx) 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.lxg.springcloud.dao.PaymentDao&quot;&gt; &lt;insert id=&quot;create&quot; parameterType=&quot;Payment&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into payment(serial) values(#&#123;serial&#125;) &lt;/insert&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lxg.springcloud.entities.Payment&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt; &lt;result column=&quot;serial&quot; property=&quot;serial&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getPaymentById&quot; parameterType=&quot;Long&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from payment where id=#&#123;id&#125; &lt;/select&gt; &lt;update id=&quot;updatPayment&quot; parameterType=&quot;Payment&quot;&gt; update payment set serial=#&#123;serial&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deletePaymentById&quot; parameterType=&quot;Long&quot;&gt; delete from payment where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 文件模板头： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt; &lt;mapper namespace=&quot;xxx&quot;&gt;。。。。。。&lt;/mapper&gt; 4、service 接口： 123456789101112131415161718192021package com.lxg.springcloud.service;import com.lxg.springcloud.entities.Payment;import org.apache.ibatis.annotations.Param;/** * @auther xiaolin * @creatr 2023/3/11 13:44 */public interface PaymentService &#123; public int create(Payment payment); public Payment getPaymentById(@Param(&quot;id&quot;) Long id); public int updatPayment(Payment payment); public int deletePaymentById(@Param(&quot;id&quot;) Long id);&#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940package com.lxg.springcloud.service.impl;import com.lxg.springcloud.dao.PaymentDao;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/11 13:45 */@Servicepublic class PaymentServiceImpl implements PaymentService &#123; @Resource private PaymentDao paymentDao; @Override public int create(Payment payment) &#123; return paymentDao.create(payment); &#125; @Override public Payment getPaymentById(Long id) &#123; return paymentDao.getPaymentById(id); &#125; @Override public int updatPayment(Payment payment) &#123; return paymentDao.updatPayment(payment); &#125; @Override public int deletePaymentById(Long id) &#123; return paymentDao.deletePaymentById(id); &#125;&#125; 5、controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.annotations.Param;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/11 14:10 */@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(Payment payment)&#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;插入成功！&quot;,result); &#125;else&#123; return new CommonResult(500,&quot;插入数据库失败！&quot;,null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;*****查询结果：&quot;+payment); if(payment!=null)&#123; return new CommonResult(200,&quot;查询成功！&quot;,payment); &#125;else&#123; return new CommonResult(404,&quot;查询失败，没有记录！&quot;,null); &#125; &#125; //正常要使用put请求，此处无前端页面简便处理 @PostMapping(value = &quot;/payment/update&quot;) public CommonResult updatPayment(Payment payment)&#123; int result = paymentService.updatPayment(payment); log.info(&quot;*****更新结果：&quot;+payment); if(result&gt;0)&#123; return new CommonResult(200,&quot;更新成功！&quot;,result); &#125;else&#123; return new CommonResult(500,&quot;更新失败！&quot;,null); &#125; &#125; @GetMapping(value = &quot;/payment/delete/&#123;id&#125;&quot;) public CommonResult deletePaymentById(@PathVariable(&quot;id&quot;)Long id)&#123; int result = paymentService.deletePaymentById(id); log.info(&quot;*****删除结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;删除成功！&quot;,result); &#125;else&#123; return new CommonResult(500,&quot;删除失败！&quot;,null); &#125; &#125;&#125; 2.1.6、测试查询： localhost:8001&#x2F;payment&#x2F;get&#x2F;1 添加：由于浏览器默认都是get请求，可使用apifox或postman等工具发送其他请求 http://localhost:8001/payment/create?serial=xiaolin002 修改： http://localhost:8001/payment/update/?id=1&amp;serial=xiaolin1 删除： localhost:8001&#x2F;payment&#x2F;delete&#x2F;5 运行： 现在还只是单个模块，所以只需要运行即可，到项目增多，会有一个Run DashBoard按钮出现统一管理运行 新版是服务按钮 正常情况会自动出现，如果有异常按以下操作： 123456789你自己路径：D:\\devSoft\\JetBrains\\IdeaProjects\\自己project名\\.idea&lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt;&lt;/option&gt; 2.2、热部署功能1、添加热部署依赖 1234567&lt;!--热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2、父工程pom文件加入插件 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3、开启自动编译 4、修改注册表内容 新版idea没有第一项，新的位置如下： 5、重启idea或不重启也可 2.3、cloud-consumer-order80模块2.3.1、创建maven模块2.3.2、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.3、编写application.yml12server: port: 80 2.3.4、编写主启动类12345678910111213141516package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @auther xiaolin * @creatr 2023/3/11 16:58 */@SpringBootApplicationpublic class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; 2.3.5、编写业务类1、实体类（直接copy） 主体实体类： 1234567891011121314151617package com.lxg.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123; private Long id; private String serial;&#125; json封装体 12345678910111213141516171819202122package com.lxg.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; //处理没传数据的情况 public CommonResult(Integer code,String message)&#123; this(code,message,null); &#125;&#125; 什么是RestTemplate？ 123456789RestTemplate提供了多种便捷访问远程Http服务的方法， 是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集官网地址：https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html使用：使用restTemplate访问restful接口非常的简单粗暴无脑。(url, requestMap, ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。 config配置类： 12345678910111213141516171819202122package com.lxg.springcloud.config;import org.springframework.boot.SpringBootConfiguration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/11 17:09 */@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; controller类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/11 17:00 */@RestController@Slf4jpublic class OrderController &#123; public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; @Resource private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/create&quot;) public CommonResult&lt;Payment&gt; create(Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL + &quot;/payment/create&quot;,payment,CommonResult.class); &#125; @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(PAYMENT_URL + &quot;/payment/get/&quot;+id,CommonResult.class); &#125; @GetMapping(&quot;/consumer/payment/update&quot;) public CommonResult&lt;Payment&gt; updatePayment(Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL + &quot;/payment/update&quot;,payment,CommonResult.class); &#125; @GetMapping(&quot;/consumer/payment/delete/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; deletePayment(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(PAYMENT_URL + &quot;/payment/delete&quot;+id,CommonResult.class); &#125;&#125; 2.3.6、测试查询： 添加： 这样添加的serial是null 给之前的PaymentController加上@RequestBody注解 12345678910@PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(@RequestBody Payment payment)&#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;插入成功！&quot;,result); &#125;else&#123; return new CommonResult(500,&quot;插入数据库失败！&quot;,null); &#125; &#125; 再次尝试：成功！ 1234567后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性。json字符串中，如果value为&quot;&quot;的话，后端对应属性如果是String类型的，那么接受到的就是&quot;&quot;，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。json字符串中，如果value为null的话，后端对应收到的就是null。如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或&quot;&quot;都行。千万不能有类似&quot;stature&quot;:，这样的写法，如: 12正常情况下不加@RequestBody，无论是get请求还是post请求都可以自动装配到实体类属性中，但是使用了restTemplate发起post请求，传递过去的是一个实体类对象，但是被封装成了RequestEntity对象（json格式），所以需要@RequestBody注解来获取参数 此时服务端（paymentController）需要传递json格式参数才可以正常插入 修改： 服务端应使用json格式发起请求： 删除： 2.4、工程重构2.4.1、观察问题系统中有重复部分，重构 2.4.2、新建cloud-api-commons模块2.4.3、修改pom文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.4.4、把之前两个模块中的实体类复制到该模块中2.4.5、使用maven命令打包 2.4.6、改造另外两个模块1、删除原先的实体类 2、在pom文件中新增以下内容 123456&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;&lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;&lt;/dependency&gt; 六、Eureka服务注册与发现1、Eureka基础知识1.1、什么是服务治理？1234什么是服务治理 Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理 在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。 1.2、什么是服务注册？123 什么是服务注册与发现Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址)) 下左图是Eureka系统架构，右图是Dubbo的架构，请对比 1.3、Eureka两个组件12345678Eureka包含两个组件：Eureka Server和Eureka Client Eureka Server提供服务注册服务各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。 EurekaClient通过注册中心进行访问是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒） 2、单机Eureka构建步骤2.1、IDEA生成eurekaServer端服务注册中心（类似物业公司）2.1.1、创建新模块 cloud-eureka-server70012.1.2、修改pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--boot web actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--监控用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般通用配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3、编写application.yml文件1234567891011121314server: port: 7001eureka: instance: hostname: localhost #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 2.1.4、编写主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * @auther xiaolin * @creatr 2023/3/11 23:26 */@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; 2.1.5、测试Eureka 此时 No application available 没有服务被发现 O(∩_∩)O因为没有注册服务进来当然不可能有服务被发现 2.2、EurekaClient端cloud-provider-payment8001将注册进EurekaServer 成为服务提供者provider，类似尚硅谷学校对外提供授课服务 2.2.1、修改cloud-provider-payment8001模块pom文件添加依赖 12345&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.2、编写yml，新增以下内容123456789eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 2.2.3、在主启动类上添加@EnableEurekaClient注解2.2.4、测试注意要先启动EurekaServer端 Eureka 服务名配置： 2.2.5、自我保护机制 2.3、EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer，类似来尚硅谷上课消费的各位同学 2.3.1、修改cloud-consumer-order80模块pom文件添加内容： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2.3.2、编写yml，新增以下内容123456789101112spring: application: name: cloud-order-serviceeureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 2.3.3、在主启动类上添加@EnableEurekaClient注解2.3.4、测试注意：先启动EurekaServer端，再启动其他端 Eureka localhost&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;12 3、集群Eureka构建3.1、Eureka集群原理说明 12345问题：微服务RPC远程服务调用最核心的是什么 高可用，试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)&quot;了，会导致整个为服务环境不可用，所以解决办法：搭建Eureka注册中心集群 ，实现负载均衡+故障容错 3.2、集群搭建步骤3.2.1、参考7001新建7002模块3.2.2、修改7002的pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;mscloud03&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-eureka-server7002&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--boot web actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般通用配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.3、修改映射配置C:\\Windows\\System32\\drivers\\etc\\hosts 12127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com 3.2.4、修改7001和7002的yml配置文件7001： 1234567891011121314server: port: 7001eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://eureka7002.com:7002/eureka/ 7002： 1234567891011121314server: port: 7002eureka: instance: hostname: eureka7002.com #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://eureka7001.com:7001/eureka/ 两者互相注册，相互守望 3.2.5、编写7002启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * @auther xiaolin * @creatr 2023/3/12 0:20 */@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7002 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7002.class,args); &#125;&#125; 3.2.6、测试 3.3、将8001服务发布到2台Eureka集群上修改yml文件 1234567891011121314151617181920212223242526server: port: 8001spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource #当前数据源操作类型 driver-class-name: com.mysql.jdbc.Driver #驱动名称 url: jdbc:mysql://localhost:3306/cloud2020?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false #数据库连接URL username: root #数据库连接用户名 password: 123456 #数据库连接密码eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url:# defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版mybatis: mapper-locations: classpath:mapper/*.xml #mybatis mapper文件路径 type-aliases-package: com.lxg.springcloud.entities #实体类所在的package 3.4、将80服务发布到2台Eureka集群上修改yml文件 12345678910111213141516server: port: 80spring: application: name: cloud-order-serviceeureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url:# defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 3.5、测试先启动7001,7002，2台Eureka集群 再启动提供者8001，再启动消费者80 3.6、支付提供者8001集群搭建3.6.1、新建8002支付提供者模块cloud-provider-payment80023.6.2、修改8002pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8002&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--eureka-client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql-connector-java--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3、编写8002yml文件1234567891011121314151617181920212223242526server: port: 8002spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource #当前数据源操作类型 driver-class-name: com.mysql.jdbc.Driver #驱动名称 url: jdbc:mysql://localhost:3306/cloud2020?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false #数据库连接URL username: root #数据库连接用户名 password: 123456 #数据库连接密码eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: # defaultZone: http://localhost:7001/eureka defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版mybatis: mapper-locations: classpath:mapper/*.xml #mybatis mapper文件路径 type-aliases-package: com.lxg.springcloud.entities #实体类所在的package 3.6.4、编写主启动类123456789101112131415package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class PaymentMain8002 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8002.class,args); &#125;&#125; 3.6.5、业务类直接从8001copy3.6.6、修改8001和8002的Controller8001: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/11 14:10 */@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(@RequestBody Payment payment)&#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;插入成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;插入数据库失败！serverport:&quot;+serverPort,null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;*****查询结果：&quot;+payment+&quot;哈哈哈哈成功了！&quot;); if(payment!=null)&#123; return new CommonResult(200,&quot;查询成功！serverport:&quot;+serverPort,payment); &#125;else&#123; return new CommonResult(404,&quot;查询失败，id&quot;+id+&quot;没有记录！serverport:&quot;+serverPort,null); &#125; &#125; //正常要使用put请求，此处无前端页面简便处理 @PostMapping(value = &quot;/payment/update&quot;) public CommonResult updatPayment(@RequestBody Payment payment)&#123; int result = paymentService.updatPayment(payment); log.info(&quot;*****更新结果：&quot;+payment); if(result&gt;0)&#123; return new CommonResult(200,&quot;更新成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;更新失败！serverport:&quot;+serverPort,null); &#125; &#125; @GetMapping(value = &quot;/payment/delete/&#123;id&#125;&quot;) public CommonResult deletePaymentById(@PathVariable(&quot;id&quot;)Long id)&#123; int result = paymentService.deletePaymentById(id); log.info(&quot;*****删除结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;删除成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;删除失败，id&quot;+id+&quot;没有记录！serverport:&quot;+serverPort,null); &#125; &#125;&#125; 8002： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/11 14:10 */@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @Resource private PaymentService paymentService; @PostMapping(value = &quot;/payment/create&quot;) public CommonResult create(@RequestBody Payment payment)&#123; int result = paymentService.create(payment); log.info(&quot;*****插入结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;插入成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;插入数据库失败！serverport:&quot;+serverPort,null); &#125; &#125; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;*****查询结果：&quot;+payment+&quot;哈哈哈哈成功了！&quot;); if(payment!=null)&#123; return new CommonResult(200,&quot;查询成功！serverport:&quot;+serverPort,payment); &#125;else&#123; return new CommonResult(404,&quot;查询失败，id&quot;+id+&quot;没有记录！serverport:&quot;+serverPort,null); &#125; &#125; //正常要使用put请求，此处无前端页面简便处理 @PostMapping(value = &quot;/payment/update&quot;) public CommonResult updatPayment(@RequestBody Payment payment)&#123; int result = paymentService.updatPayment(payment); log.info(&quot;*****更新结果：&quot;+payment); if(result&gt;0)&#123; return new CommonResult(200,&quot;更新成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;更新失败！serverport:&quot;+serverPort,null); &#125; &#125; @GetMapping(value = &quot;/payment/delete/&#123;id&#125;&quot;) public CommonResult deletePaymentById(@PathVariable(&quot;id&quot;)Long id)&#123; int result = paymentService.deletePaymentById(id); log.info(&quot;*****删除结果：&quot;+result); if(result&gt;0)&#123; return new CommonResult(200,&quot;删除成功！serverport:&quot;+serverPort,result); &#125;else&#123; return new CommonResult(500,&quot;删除失败,id&quot;+id+&quot;没有记录！serverport:&quot;+serverPort,null); &#125; &#125;&#125; 3.7、负载均衡3.7.1、bug1以上配置完，去访问会报错，无法访问到服务，因为它不知道选择8001还是8002 修改80模块controller 1234//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; // 通过在eureka上注册过的微服务名称调用public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;; 3.7.2、使用注解解决bug@LoadBalanced注解赋予RestTemplate负载均衡的能力 将注解加在80模块的RestTemplate配置类上 依赖于Ribbon的负载均衡功能 3.8、测试2先启动EurekaServer集群7001&#x2F;7002 再启动服务提供者集群8001&#x2F;8002 再启动消费者80 负载均衡效果达到，8001&#x2F;8002端口交替出现 Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能了。O(∩_∩)O 4、actuator微服务信息完善4.1、主机名称：服务名称修改当前问题 含有主机名称 修改8001、8002的yml文件： 12instance: instance-id: payment8002 12instance: instance-id: payment8001 修改之后： 4.2、访问信息有ip信息显示当前问题： 没有ip提示 修改8001、8002yml文件： 1prefer-ip-address: true #访问路径可以显示IP地址 修改之后： 5、服务发现Discovery5.1、对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息5.2、修改8001、8002的controller添加以下内容： 1234567891011121314151617@Resourceprivate DiscoveryClient discoveryClient;@GetMapping(value = &quot;/payment/discovery&quot;)public Object discovery()&#123; List&lt;String&gt; services = discoveryClient.getServices(); for (String element:services)&#123; log.info(&quot;*****element:&quot;+element); &#125; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); for (ServiceInstance instance : instances)&#123; log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri()); &#125; return this.discoveryClient;&#125; 5.3、修改8001、8002主启动类在启动类上添加@EnableDiscoveryClient注解 5.4、自测注意： 先启动EurekaServer 再启动8001、8002 6、Eureka自我保护6.1、故障现象概述保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。 如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE 6.2、原因12345为什么会产生Eureka自我保护机制？为了防止EurekaClient可以正常运行，但是 与 EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除什么是自我保护模式？默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。 在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着 综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。 一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存 属于CAP里面的AP分支 6.3、怎么禁止自我保护6.3.1、注册中心EurekaServer7001、7002配置1、默认保护模式是开启的 1eureka.server.enable-self-preservation=true 2、使用eureka.server.enable-self-preservation &#x3D; false 可以禁用自我保护模式 1234server: #关闭自我保护机制，保证不可用服务被及时踢除 enable-self-preservation: false eviction-interval-timer-in-ms: 2000 3、关闭效果 6.3.2、生产者客户端eureakeClient端8001配置1、默认 1234eureka.instance.lease-renewal-interval-in-seconds=30eureka.instance.lease-expiration-duration-in-seconds=90单位为秒 2、配置 123456#心跳检测与续约时间#开发时设置小些，保证服务关闭后注册中心能及时剔除服务#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)lease-renewal-interval-in-seconds: 1#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务lease-expiration-duration-in-seconds: 2 3、测试 关闭8001&#x2F;8002，服务立马被剔除 注意如果通过idea直接关闭，无论是否开启都会被剔除 正确测试方法：用命令查询所有端口：netstat -ano再用 ：taskkill &#x2F;pid pid号 &#x2F;f 强行关闭这个端口 七、Zookeeper服务注册与发现1、Eureka停止更新了你怎么办https://github.com/Netflix/eureka/wiki 找其他替代 2、SpringCloud整合Zookeeper替代Eureka2.1、安装注册中心zookeeperzookeeper是一个分布式协调工具，可以实现注册中心功能 关闭Linux服务器防火墙后启动zookeeper服务器 zookeeper服务器取代Eureka服务器，zk作为服务注册中心 使用版本：3.6.4(3.4.9版本一直报错) 2.2、服务提供者2.2.1、新建cloud-provider-payment8004模块同样可以多构建一个8005模块做集群配置 2.2.2、修改pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2.3、编写yml文件123456789101112#8004表示注册到zookeeper服务器的支付服务提供者端口号server: port: 8004#服务别名----注册zookeeper到注册中心名称spring: application: name: cloud-provider-payment cloud: zookeeper:# connect-string: 106.55.228.118:2181 connect-string: 192.168.131.101:2181 需要注册到几台zookeeper中，加,后面继续写即可 2.3.4、编写主启动类1234567891011121314151617181920package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/12 14:24 */@SpringBootApplication@EnableDiscoveryClient // 该注解用于向使用consul或者zookeeper作为注册中心时注册服务public class PaymentMain8004 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8004.class,args); &#125;&#125; 2.3.5、编写Controller12345678910111213141516171819202122232425package com.lxg.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;/** * @auther xiaolin * @creatr 2023/3/12 14:27 */@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @RequestMapping(value = &quot;/payment/zk&quot;) public String paymentzk() &#123; return &quot;springcloud with zookeeper: &quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; 2.3.6、启动8004进行注册启动报错： 原因：zookeeper版本jar包冲突问题 注意：根据zookeeper版本不同可能还会有其他版本依赖错误问题，自行判断解决 解决： 新版pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--先排除自带的zookeeper3.6--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper3.6.4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.4&lt;/version&gt; &lt;!--排除自带的slf4j-log4j12和log4j--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.7、测试 2.3.8、测试2 2.3.9、思考服务节点是临时节点还是持久节点 答案：临时 2.3、服务消费者2.3.1、新建cloud-consumerzk-order80模块2.3.2、修改pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--先排除自带的zookeeper--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper3.6.4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.4&lt;/version&gt; &lt;!--排除自带的slf4j-log4j12和log4j--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.3、编写yml文件12345678910server: port: 80spring: application: name: cloud-consumer-order cloud: #注册到zookeeper地址 zookeeper: connect-string: 192.168.131.101:2181,192.168.131.102:2181 2.3.4、编写主启动类123456789101112131415161718192021package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther zzyy * @create 2020-01-30 17:32 */@SpringBootApplication@EnableDiscoveryClientpublic class OrderZKMain80&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderZKMain80.class,args); &#125;&#125; 2.3.5、编写业务类1、配置Bean（RestTemplate） 123456789101112131415161718192021222324package com.lxg.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/12 22:57 */@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 2、编写Controller 123456789101112131415161718192021222324252627282930package com.lxg.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/12 22:59 */@RestController@Slf4jpublic class OrderZKController &#123; public static final String INVOKE_URL = &quot;http://cloud-provider-payment&quot;; @Resource private RestTemplate restTemplate; @GetMapping(value = &quot;/consumer/payment/zk&quot;) public String paymentInfo()&#123; String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/zk&quot;,String.class); return result; &#125;&#125; 2.3.6、测试 会在8004、8005之间切换 八、Consul服务注册与发现1、Consul简介1.1、是什么？What is Consul? | Consul | HashiCorp Developer 123456Consul 是一套开源的分布式服务发现和配置管理系统，由 HashiCorp 公司用 Go 语言开发。 提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。 它具有很多优点。包括： 基于 raft 协议，比较简洁； 支持健康检查, 同时支持 HTTP 和 DNS 协议 支持跨数据中心的 WAN 集群 提供图形界面 跨平台，支持 Linux、Mac、Windows 1.2、能干嘛Spring Cloud Consul 具有如下特性： 服务发现：提供HTTP和DNS两种发现方式。 健康监测：支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控 KV存储：Key、Value的存储方式 多数据中心：Consul支持多数据中心 可视化Web界面 1.3、去哪下载Install | Consul | HashiCorp Developer 1.4、怎么玩Spring Cloud Consul 中文文档 参考手册 中文版 2、安装并运行Consul2.1、官网安装说明：Install Consul | Consul | HashiCorp Developer 2.2、下载完成后只有一个consul.exe文件 2.3、使用开发模式启动命令：consul agent -dev 通过以下地址可以访问Consul的首页：http://localhost:8500 3、服务提供者3.1、新建Module支付服务provider8006：cloud-providerconsul-payment80063.2、修改pom文件1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!--SpringCloud consul-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.3、编写yml文件1234567891011121314server: port: 8006spring: application: name: consul-provider-payment cloud: consul: host: localhost port: 8500 discovery: #hostname: 127.0.0.1 servicename: $&#123;spring.application.name&#125; 3.4、编写主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/13 9:04 */@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8006 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8006.class,args); &#125;&#125; 3.5、编写业务类controller123456789101112131415161718192021222324252627282930package com.lxg.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.UUID;/** * @auther xiaolin * @creatr 2023/3/13 9:04 */@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;/payment/consul&quot;) public String paymentInfo() &#123; return &quot;springcloud with consul: &quot;+serverPort+&quot;\\t\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; 3.6、测试 根据以前，同样可以创建多一个8007服务者构成集群 4、服务消费者4.1、新建cloud-consumerconsul-order80模块4.2、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud consul-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.3、编写yml文件123456789101112131415server: port: 80spring: application: name: cloud-consumerconsul-order cloud: consul: host: localhost port: 8500 discovery: #hostname：localhost service-name: $&#123;spring.application.name&#125; 4.4、编写主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/13 11:29 */@SpringBootApplication@EnableDiscoveryClientpublic class OrderConsulMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderConsulMain80.class,args); &#125;&#125; 4.5、编写配置bean12345678910111213141516171819202122package com.lxg.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/13 11:31 */@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 4.6、编写controller123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/13 11:33 */@RestControllerpublic class OrderConsulController &#123; public static final String INVOKE_URL = &quot;http://consul-provider-payment&quot;; //consul-provider-payment @Autowired private RestTemplate restTemplate; @GetMapping(value = &quot;/consumer/payment/consul&quot;) public String paymentInfo() &#123; String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/consul&quot;, String.class); System.out.println(&quot;消费者调用支付服务(consule)---&gt;result:&quot; + result); return result; &#125;&#125; 4.7、测试Services - Consul 会在8006、8007切换 5、三个注册中心异同点 组件名 语言 CAP 服务健康检查 对外暴露接口 SpringCloud集成 Eureka Java AP 可配支持 HTTP 已集成 Consul Go CP 支持 HTTP&#x2F;DNS 已集成 Zookeeper Java CP 支持 客户端 已集成 5.1、CAP1234C:Consistency（强一致性）A:Availability（可用性）P:Partition tolerance（分区容错性）CAP理论关注粒度是数据，而不是整体系统设计的策略 5.2、经典CAP图AP架构（Eureka） 当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。结论：违背了一致性C的要求，只满足可用性和分区容错，即AP CP架构（consul、zookeeper） 当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性结论：违背了可用性A的要求，只满足一致性和分区容错，即CP 九、Ribbon负载均衡服务调用1、概述1.1、是什么？123Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。 1.2、官网资料https://github.com/Netflix/ribbon/wiki/Getting-Started Ribbon目前也进入维护模式 未来替换方案 1.3、能干嘛1.3.1、LB负载均衡12345678910LB负载均衡(Load Balance)是什么简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。常见的负载均衡有软件Nginx，LVS，硬件 F5等。 Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别 Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。 Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。 集中式LB 123集中式LB 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方； 进程内LB 12345 进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。 Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。 1.3.2、前面我们讲解过了80通过轮询负载访问8001&#x2F;8002一句话：负载均衡+RestTemplate调用 2、Ribbon负载均衡演示2.1、架构说明 Ribbon在工作时分成两步第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。 总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。 2.2、pom文件之前写样例时候没有引入spring-cloud-starter-ribbon也可以使用ribbon 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 猜测spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用，证明如下： 可以看到spring-cloud-starter-netflix-eureka-client 确实引入了Ribbon: 2.3、RestTemplate的使用2.3.1、官网https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html 2.3.2、getForObject方法&#x2F;getForEntity方法返回对象为响应体中数据转化成的对象，基本上可以理解为Json 返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等 2.3.3、postForObject方法&#x2F;postForEntity方法 2.3.4、GET请求方法1234567891011&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables); &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables); &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType); &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables); &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables); &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI var1, Class&lt;T&gt; responseType); 2.3.5、POST请求方法12345678910111213 &lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables); &lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables); &lt;T&gt; T postForObject(URI url, @Nullable Object request, Class&lt;T&gt; responseType); &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Object... uriVariables); &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables); &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, @Nullable Object request, Class&lt;T&gt; responseType); 3、Ribbon核心组件IRule3.1、IRule：根据特定算法中从服务列表中选取一个要访问的服务 1234567com.netflix.loadbalancer.RoundRobinRule:轮询com.netflix.loadbalancer.RandomRule:随机com.netflix.loadbalancer.RetryRule:先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务WeightedResponseTimeRule:对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择BestAvailableRule:会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务AvailabilityFilteringRule:先过滤掉故障实例，再选择并发较小的实例ZoneAvoidanceRule:默认规则,复合判断server所在区域的性能和server的可用性选择服务器 3.2、如何替换修改cloud-consumer-order80 3.2.1、配置细节官方文档明确给出了警告： 这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。 3.2.2、新建package 3.2.3、上面包下新建MySelfRule规则类1234567891011121314151617181920package com.lxg.myrule;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @auther zzyy * @create 2020-02-02 14:31 */@Configurationpublic class MySelfRule&#123; @Bean public IRule myRule() &#123; return new RandomRule();//定义为随机 &#125;&#125; 3.2.4、主启动类添加@RibbonClient123456789101112131415161718192021package com.lxg.springcloud;import com.lxg.myrule.MySelfRule;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;/** * @auther xiaolin * @creatr 2023/3/11 16:58 */@SpringBootApplication@EnableEurekaClient@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; 注意新版的Eureka已经没有ribbon了。使用的是loadbalancer 配置如下： 1、新建配置类，设置如下bean 1234567891011121314151617181920212223242526package com.lxg.springcloud.config;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;/** * @auther xiaolin * @creatr 2023/3/13 23:03 */@Configurationpublic class LoadBalanceConfig &#123; //将官方提供的 RandomLoadBalancer 注册为Bean @Bean public ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)&#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name); &#125;&#125; 2、在RestTemplate配置上加注解 @LoadBalancerClient(name &#x3D; “CLOUD-PAYMENT-SERVICE”,configuration &#x3D; LoadBalanceConfig.class)是关键 1234567891011121314151617181920212223242526272829303132package com.lxg.springcloud.config;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/11 17:09 */@LoadBalancerClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = LoadBalanceConfig.class)@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 也可以在主启动类上添加 1//@LoadBalancerClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = ApplicationContextConfig.class) 3.2.5、测试 在8001和8002中随机切换 4、Ribbon负载均衡算法4.1、原理1234567891011121314负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标 ，每次服务重启动后rest接口计数从1开始。 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); 如： List [0] instances = 127.0.0.1:8002 List [1] instances = 127.0.0.1:8001 8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理： 当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002如此类推...... 4.2、RoundRobinRule源码4.3、手写算法策略自己试着写一个本地负载均衡器试试 4.3.1、在8001和8002controller进行修改添加以下内容： 123456@GetMapping(value = &quot;/payment/lb&quot;) public String getPaymentLB() &#123; return serverPort; &#125; 4.3.2、去掉@LoadBalanced注解1234567891011121314151617181920212223242526272829303132package com.lxg.springcloud.config;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/11 17:09 */@LoadBalancerClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = LoadBalanceConfig.class)@Configurationpublic class ApplicationContextConfig &#123; @Bean// @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 4.3.3、编写一个LoadBalancer接口1234567891011121314package com.lxg.springcloud.lb;import org.springframework.cloud.client.ServiceInstance;import java.util.List;/** * @auther xiaolin * @creatr 2023/3/14 9:27 */public interface LoadBalancer &#123; ServiceInstance getMyInstances(List&lt;ServiceInstance&gt; serviceInstances);&#125; 4.3.4、编写接口实现类MyLB123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.springcloud.lb.impl;import com.lxg.springcloud.lb.LoadBalancer;import org.springframework.cloud.client.ServiceInstance;import org.springframework.stereotype.Component;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;/** * @auther xiaolin * @creatr 2023/3/14 9:29 */@Componentpublic class MyLB implements LoadBalancer &#123; private AtomicInteger atomicInteger = new AtomicInteger(0); public final int getAndIncrement()&#123; int current; int next; do&#123; current = this.atomicInteger.get(); //2147483647是整型的最大数，不超过就+1，超过置为0 next = current &gt;=2147483647 ? 0 : current + 1; &#125;while (!this.atomicInteger.compareAndSet(current,next)); //compareAndSet(expect, update)，这个函数会先将当前值和expect进行比较，如果相比较的两个值是相等的，那么就进行更新update操作。 System.out.println(&quot;*****第几次访问，次数next:&quot;+next); return next; &#125; @Override public ServiceInstance getMyInstances(List&lt;ServiceInstance&gt; serviceInstances) &#123; int index = getAndIncrement() % serviceInstances.size(); return serviceInstances.get(index); &#125;&#125; 4.3.5、修改80 OrderController新增以下内容： 12345678910@GetMapping(value = &quot;/consumer/payment/lb&quot;) public String getPaymentLB()&#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); if (instances==null || instances.size() &lt;=0)&#123; return null; &#125; ServiceInstance serviceInstance = loadBalancer.getMyInstances(instances); URI uri = serviceInstance.getUri(); return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class); &#125; 4.3.6、测试依次启动7001、7002、8001、8002 localhost&#x2F;consumer&#x2F;payment&#x2F;lb 会在8001和8002中交替更换 十、OpenFeign服务接口调用1、概述1.1、OpenFeign是什么官网解释：Spring Cloud OpenFeign 12Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡 总结： Feign是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 GitHub：https://github.com/spring-cloud/spring-cloud-openfeign 1.2、能干嘛？123456Feign能干什么Feign旨在使编写Java Http客户端变得更容易。前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。 Feign集成了Ribbon利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用 1.3、Feign和OpenFeign的区别 Feign OpenFeign Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务 OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。 org.springframework.cloud spring-cloud-starter-feign org.springframework.cloud spring-cloud-starter-openfeign 2、OpenFeign使用步骤接口+注解 微服务调用接口+@FeignClient 2.1、新建cloud-consumer-feign-order80Feign在消费端使用 2.2、pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--openfeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--eureka client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般基础通用配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3、编写yml文件12345678server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 2.4、编写主启动类123456789101112131415161718192021package com.lxg.springcloud;import com.lxg.springcloud.config.LoadBalanceConfig;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;import org.springframework.cloud.openfeign.EnableFeignClients;/** * @auther xiaolin * @creatr 2023/3/14 10:52 */@SpringBootApplication@EnableFeignClients@LoadBalancerClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = LoadBalanceConfig.class)public class OrderFeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderFeignMain80.class,args); &#125;&#125; 2.5、编写业务类2.5.1、业务逻辑接口加上@FeignClient注解配置调用provider服务 新增PaymentFeignService接口 12345678910111213141516171819202122package com.lxg.springcloud.service;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import feign.Param;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @auther xiaolin * @creatr 2023/3/14 10:58 */@Component@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123; @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; 2.5.2、编写控制层controller12345678910111213141516171819202122232425262728293031package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentFeignService;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/14 11:04 */@RestController@Slf4jpublic class OrderFeignController &#123; @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; return paymentFeignService.getPaymentById(id); &#125;&#125; 2.6、测试先启动7001、7002 再启动8001、8002 再启动OrderFeignMain80 Feign自带负载均衡配置项 2.7、小总结 若需要更改负载均衡策略，则按以下步骤进行： 编写一个配置类： 1234567891011121314151617181920212223242526package com.lxg.springcloud.config;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;/** * @auther xiaolin * @creatr 2023/3/13 23:03 */@Configurationpublic class LoadBalanceConfig &#123; //将官方提供的 RandomLoadBalancer 注册为Bean @Bean public ReactorLoadBalancer&lt;ServiceInstance&gt; randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)&#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name); &#125;&#125; 在启动类上添加注解 1@LoadBalancerClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = LoadBalanceConfig.class) 3、OpenFeign超时控制3.1、故意设置超时3.1.1、8001、8002写暂停程序在controller中添加以下内容： 123456@GetMapping(value = &quot;/payment/feign/timeout&quot;) public String PaymentFeignTimeOut()&#123; //暂停几秒钟线程 try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort; &#125; 3.1.2、消费方80在接口中新增超时方法12@GetMapping(value = &quot;/payment/feign/timeout&quot;) String paymentFeignTimeOut(); 3.1.3、消费方80在controller添加超时方法123456@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;) public String PaymentFeignTimeOut() &#123; //请求处理默认等待5秒 return paymentFeignService.PaymentFeignTimeOut(); &#125; 3.1.4、测试http://localhost/consumer/payment/feign/timeout OpenFeign默认等待5秒钟，超过后报错 3.2、超时配置默认Feign客户端只等待5秒钟，但是服务端处理需要超过5秒钟，导致Feign客户端不想等待了，直接返回报错。（老版本1秒）为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。 yml文件中开启配置 1234567891011121314151617#老版#ribbon:# ReadTimeout: 1000# ConnectTimeout: 1000#新版feign: client: config: default: # 连接超时时间，默认10s，设置单位为毫秒 connectTimeout: 2000 # 请求处理超时时间，默认60s，设置单位为毫秒 readTimeout: 5000 loggerLevel: FULL 4、OpenFeign日志打印功能4.1、是什么Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。说白了就是对Feign接口的调用情况进行监控和输出 4.2、日志级别NONE：默认的，不显示任何日志； BASIC：仅记录请求方法、URL、响应状态码及执行时间； HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息； FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。 4.3、配置日志级别配置类方式： 12345678910111213141516package com.lxg.springcloud.config;import feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FeignConfig&#123; @Bean Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125; yml文件配置方式： 12345feign: client: config: default: loggerLevel: FULL 4.4、开启日志1234logging: level: #feign日志已什么级别监控哪个接口 com.lxg.springcloud.service.PaymentFeignService: debug 4.5、查看日志 十一、Hystrix断路器1、概述1.1、分布式系统面临的问题分布式系统面临的问题复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。 服务雪崩 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”. 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。 1.2、是什么？Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 1.3、能干嘛 服务降级 服务熔断 接近实时的监控 …… 1.4、官网资料How To Use · Netflix&#x2F;Hystrix Wiki · GitHub 1.5、目前状态：停更https://github.com/Netflix/Hystrix 被动修复bugs 不再接受合并请求 不再发布新版本 2、Hystrix重要概念2.1、服务降级服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback 什么情况会出现触发服务降级？ 程序运行异常 超时 服务熔断触发服务降级 线程池&#x2F;信号量打满也会导致服务降级 仍然可以发起请求，但是当请求出现以上情况时就会触发服务降级fallback 2.2、服务熔断类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示 就是保险丝：服务的降级-&gt;进而熔断-&gt;恢复调用链路 不能继续发起请求，直接拒绝访问，并返回 2.3、服务限流秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行 3、hystrix案例3.1、构建3.1.1、新建cloud-provider-hystrix-payment80013.1.2、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 特别注意，hystrix在新版中需要指明版本号 3.1.3、编写yml文件1234567891011121314server: port: 8001spring: application: name: cloud-provider-hystrix-paymenteureka: client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka# defaultZone: http://eureka7001.com:7001/eureka 3.1.4、编写主启动类12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * @auther xiaolin * @creatr 2023/3/14 16:39 */@SpringBootApplication@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class,args); &#125;&#125; 3.1.5、编写业务类接口service： 12345678910111213package com.lxg.springcloud.service;/** * @auther xiaolin * @creatr 2023/3/14 16:41 */public interface PaymentService &#123; String paymentInfo_OK(Integer id); String paymentInfo_TimeOut(Integer id);&#125; 接口实现类： 123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.springcloud.service.Impl;import com.lxg.springcloud.service.PaymentService;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;/** * @auther xiaolin * @creatr 2023/3/14 16:41 */@Servicepublic class PaymentServiceImpl implements PaymentService &#123; /** * 正常访问，肯定ok * @param id * @return */ @Override public String paymentInfo_OK(Integer id) &#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id: &quot;+id+&quot;\\t&quot;+&quot;哈哈哈哈(●&#x27;◡&#x27;●)&quot;; &#125; @Override public String paymentInfo_TimeOut(Integer id) &#123; int timeNumber = 3; try&#123; //当需要将线程休眠一段时间的时候，可以使用Thread.sleep/TimeUnit.SECONDS.sleep的方式让当前线程暂停执行，二者都可以实现，并无差异。待休眠时间结束，线程可以继续执行。 //只是方便+其他时间单位 TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id: &quot;+id+&quot;\\t&quot;+&quot;哈哈哈哈(●&#x27;◡&#x27;●)&quot;+&quot; 耗时(秒）：&quot;+timeNumber; &#125;&#125; controller: 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lxg.springcloud.controller;import com.lxg.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/14 16:52 */@RestController@Slf4jpublic class PaymentHystrixController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String severPort; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_OK(id); log.info(&quot;*****result: &quot;+result); return result; &#125; @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String result = paymentService.paymentInfo_TimeOut(id); log.info(&quot;*****result: &quot;+result); return result; &#125;&#125; 3.1.6、正常测试启动7001 启动cloud-provider-hystrix-payment8001 访问： ok的方法：localhost:8001&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;10 timeout的方法：localhost:8001&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;10 上述module均OK 以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复 3.2、高并发测试上述在非高并发情形下，还能勉强满足 3.2.1、Jmeter压测测试开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务 此时再去访问： localhost:8001&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;10 会发现无论是ok还是timeout都被卡死 为什么：tomcat的默认的工作线程数被打满 了，没有多余的线程来分解压力和处理。 3.2.2、Jmeter压测结论上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死 3.2.3、加入80消费者1、新建cloud-consumer-feign-hystrix-order80 2、改pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--openfeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般基础通用配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、编写yml 1234567891011server: port: 80eureka: client: register-with-eureka: false service-url:# defaultZone: http://eureka7001.com:7001/eureka/ defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ 4、编写主启动类 12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;/** * @auther xiaolin * @creatr 2023/3/14 18:48 */@SpringBootApplication@EnableFeignClientspublic class OrderHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderHystrixMain80.class,args); &#125;&#125; 5、编写业务类 PaymentHystrixService： 1234567891011121314151617181920212223242526package com.lxg.springcloud.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @auther xiaolin * @creatr 2023/3/14 18:49 */@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)public interface PaymentHystrixService &#123; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125; OrderHystrixController: 12345678910111213141516171819202122232425262728293031323334353637package com.lxg.springcloud.controller;import com.lxg.springcloud.service.PaymentHystrixService;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/14 18:52 */@RestController@Slf4jpublic class OrderHystrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123; String s = paymentHystrixService.paymentInfo_OK(id); return s; &#125; @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123; String s = paymentHystrixService.paymentInfo_TimeOut(id); return s; &#125;&#125; 6、正常测试 7、高并发测试 2W个线程压8001 消费端80微服务再去访问正常的Ok微服务8001地址 http://localhost/consumer/payment/hystrix/ok/32 消费者80，o(╥﹏╥)o: 要么转圈圈等待 要么消费端报超时错误 3.3、故障现象和原因8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕 80此时调用8001，客户端访问响应缓慢，转圈圈 3.4、上述结论正因为有上述故障或不佳表现才有我们的降级&#x2F;容错&#x2F;限流等技术诞生 3.5、如何解决？解决的要求超时导致服务器变慢(转圈)：超时不再等待 出错(宕机或程序运行出错)：出错要有兜底 解决： 对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级 对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级 对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级 3.6、服务降级降级一般是客户端处理，熔断是在服务端处理的 3.6.1、降级配置@HystrixCommand 3.6.2、8001问题所在设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback 3.6.3、8001配置如下1、业务类启用@HystrixCommand报异常后如何处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lxg.springcloud.service.Impl;import com.lxg.springcloud.service.PaymentService;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;/** * @auther xiaolin * @creatr 2023/3/14 16:41 */@Servicepublic class PaymentServiceImpl implements PaymentService &#123; /** * 正常访问，肯定ok * @param id * @return */ @Override public String paymentInfo_OK(Integer id) &#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_OK,id: &quot;+id+&quot;\\t&quot;+&quot;哈哈哈哈(●&#x27;◡&#x27;●)&quot;; &#125; @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties =&#123; @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;) &#125;) @Override public String paymentInfo_TimeOut(Integer id) &#123; int timeNumber = 6; int age = 10/0;//报错// try&#123;// //当需要将线程休眠一段时间的时候，可以使用Thread.sleep/TimeUnit.SECONDS.sleep的方式让当前线程暂停执行，二者都可以实现，并无差异。待休眠时间结束，线程可以继续执行。// //只是方便+其他时间单位// TimeUnit.SECONDS.sleep(timeNumber);// &#125;catch (InterruptedException e) &#123;// throw new RuntimeException(e);// &#125; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; paymentInfo_TimeOut,id: &quot;+id+&quot;\\t&quot;+&quot;呜呜呜/(ㄒoㄒ)/~~&quot;+&quot; 耗时(秒）：&quot;+timeNumber; &#125; public String paymentInfo_TimeOutHandler(Integer id) &#123; return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot; 系统繁忙或者内部出错了，请稍后再试！,id: &quot;+id+&quot;\\t&quot;+&quot;哈哈哈哈(●&#x27;◡&#x27;●)&quot;; &#125;&#125; 一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法 上图故意制造两个异常： 1 int age &#x3D; 10&#x2F;0; 计算异常 2 我们能接受3秒钟，它运行5秒钟，超时异常。当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler 2、主启动类激活 添加新注解@EnableCircuitBreaker 3.6.4、80配置如下80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护 注意： 我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务 1、修改yml文件： 1234567891011121314151617181920212223242526272829303132333435server: port: 80eureka: client: register-with-eureka: false service-url:# defaultZone: http://eureka7001.com:7001/eureka/ defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/#新版feign:#老版# hystrix:# enabled: true #新版 circuitbreaker: enabled: true client: config: default: # 连接超时时间，默认10s，设置单位为毫秒 connectTimeout: 2000 # 请求处理超时时间，默认60s，设置单位为毫秒 readTimeout: 5000 loggerLevel: FULLhystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 5000 注意：此处必须设置hystrix的超时时间，否则默认为1秒 2、修改主启动类 1234567891011121314151617181920package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;/** * @auther xiaolin * @creatr 2023/3/14 18:48 */@SpringBootApplication@EnableFeignClients@EnableHystrixpublic class OrderHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderHystrixMain80.class,args); &#125;&#125; 3、修改业务类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lxg.springcloud.controller;import com.lxg.springcloud.service.PaymentHystrixService;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/14 18:52 */@RestController@Slf4jpublic class OrderHystrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123; String s = paymentHystrixService.paymentInfo_OK(id); return s; &#125; @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123; @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;) &#125;) @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123; int age = 10 / 0; String s = paymentHystrixService.paymentInfo_TimeOut(id); return s; &#125; @GetMapping(&quot;/consumer/payment/hystrix/test/&#123;id&#125;&quot;) public String paymentInfo_Test(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentHystrixService.paymentInfo_Test(id); &#125; public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;; &#125;&#125; 3.6.5、当前问题每个业务方法对应一个兜底的方法，代码膨胀 最好能把统一和自定义的东西分开 3.6.6、解决问题1、全局fallback(解决膨胀问题) @DefaultProperties(defaultFallback &#x3D; “”) 1：1 每个方法配置一个服务降级方法，技术上可以，实际上傻X 1：N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback &#x3D; “”) 统一跳转到统一处理结果页面 通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量，O(∩_∩)O哈哈~ controller配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.lxg.springcloud.controller;import com.lxg.springcloud.service.PaymentHystrixService;import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/14 18:52 */@RestController@Slf4j@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)public class OrderHystrixController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id) &#123; String s = paymentHystrixService.paymentInfo_OK(id); return s; &#125; @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)// @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;// @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)// &#125;) public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;// int age = 10 / 0; String s = paymentHystrixService.paymentInfo_TimeOut(id); return s; &#125; @GetMapping(&quot;/consumer/payment/hystrix/test/&#123;id&#125;&quot;) @HystrixCommand public String paymentInfo_Test(@PathVariable(&quot;id&quot;) Integer id) &#123; int age = 10/0; return paymentHystrixService.paymentInfo_Test(id); &#125; public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;我是controller中的处理方法,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;; &#125; //下面是全局fallback方法 public String payment_Global_FallbackMethod() &#123; return &quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;; &#125;&#125; 2、FeignClient （解决业务逻辑混乱） 另外：feign常用俩种降级方式Fallback和FallbackFactory。 功能：服务降级，客户端去调用服务端，碰上服务端宕机或关闭 fallbackFactory 推荐：可以捕获异常信息并返回默认降级结果。可以打印堆栈信息。 fallback 不推荐:不能捕获异常打印堆栈信息，不利于问题排查。 本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦 fallback: ①yml配置添加： 1234567891011121314151617181920212223242526272829303132333435server: port: 80eureka: client: register-with-eureka: false service-url:# defaultZone: http://eureka7001.com:7001/eureka/ defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/#新版feign:#老版# hystrix:# enabled: true #新版 circuitbreaker: enabled: true client: config: default: # 连接超时时间，默认10s，设置单位为毫秒 connectTimeout: 2000 # 请求处理超时时间，默认60s，设置单位为毫秒 readTimeout: 5000 loggerLevel: FULLhystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 5000 ②在需要被处理的类上添加以下配置 fallback指定进行处理的类 1@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = FallbackTest.class) 如： 123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.service;import org.springframework.cloud.openfeign.FallbackFactory;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @auther xiaolin * @creatr 2023/3/14 18:49 */@Component//@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)//@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = FallbackTest.class)@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallbackFactory = FallbackFactoryTest.class)public interface PaymentHystrixService &#123; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/test/&#123;id&#125;&quot;) public String paymentInfo_Test(@PathVariable(&quot;id&quot;) Integer id);&#125; ③创建FallbackTest去实现上述添加注解的类： 123456789101112131415161718192021222324252627package com.lxg.springcloud.service;import org.springframework.stereotype.Component;/** * @auther xiaolin * @creatr 2023/3/14 23:15 */@Componentpublic class FallbackTest implements PaymentHystrixService&#123; @Override public String paymentInfo_OK(Integer id) &#123; return null; &#125; @Override public String paymentInfo_TimeOut(Integer id) &#123; return &quot;我是fallback,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;; &#125; @Override public String paymentInfo_Test(Integer id) &#123; return null; &#125;&#125; fallbackfactory： 同理在被处理类上添加： 12@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallbackFactory = FallbackFactoryTest.class) 新建FallbackFactoryTest类： 123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.springcloud.service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.openfeign.FallbackFactory;import org.springframework.stereotype.Component;/** * @auther xiaolin * @creatr 2023/3/14 23:33 */@Componentpublic class FallbackFactoryTest implements FallbackFactory&lt;PaymentHystrixService&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(FallbackFactoryTest.class); @Override public PaymentHystrixService create(Throwable cause) &#123; //一进入异常就能知道什么异常 FallbackFactoryTest.logger.info(&quot;fallback; exception was: &#123;&#125;&quot;, cause.toString()); FallbackFactoryTest.logger.info(&quot;fallback; reason was: &#123;&#125;&quot;, cause.getMessage()); return new PaymentHystrixService() &#123; @Override public String paymentInfo_OK(Integer id) &#123; return null; &#125; @Override public String paymentInfo_TimeOut(Integer id) &#123; return &quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;; &#125; @Override public String paymentInfo_Test(Integer id) &#123; return null; &#125; &#125;; &#125;&#125; fallback和fallbackfactory本质没区别，fallbackfactory多了一些错误信息可以方便打印 注意这两种方式只能处理提供方出现错误或超时等情况，自身出现错误，无法处理 3.6.7、总结 使用OpenFeign的客户端在使用hystrix进行服务降级时，要注意在yml文件设置超时时间，feign默认的为连接10s和读60秒，hystrix默认为1s，在触发服务降级时会判断哪个超时时间最短，就会用最短的那个。 如果yml中设置了hystrix超时时间，而@HystrixProperty没设置，以yml的为准，如果yml没设置，默认1s，此时@HystrixProperty只有设置更低才生效，也就是这两个配置谁时间短谁生效 feignclient属性的fallback和fallbackfactory只能处理服务提供方发生的错误，无法处理自身错误 3.7、服务熔断3.7.1、断路器一句话就是家里的保险丝 3.7.2、熔断是什么熔断机制概述熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。 在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。 大神论文：https://martinfowler.com/bliki/CircuitBreaker.html 3.7.3、实操1、修改PaymentService和PaymentServiceImpl（8001） 新增： PaymentService: 12public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id); PaymentServiceImpl： 12345678910111213141516171819202122232425//====服务熔断 @Override @HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123; @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),//是否开启断路器 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),//请求次数 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),//时间窗口期 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少后跳闸 &#125;) public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123; if(id &lt; 0) &#123; throw new RuntimeException(&quot;******id 不能负数&quot;); &#125; //UUID.randomUUID().toString(); String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName()+&quot;\\t&quot;+&quot;调用成功，流水号: &quot; + serialNumber; &#125; public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~ id: &quot; +id; &#125; 可以上官网查看配置属性，也可以查看HystrixCommandProperties类 2、修改PaymentController 12345678//==服务熔断 @GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;) public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123; String result = paymentService.paymentCircuitBreaker(id); log.info(&quot;****result: &quot;+result); return result; &#125; 3、测试 localhost:8001&#x2F;payment&#x2F;circuit&#x2F;9 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行 3.7.4、原理（小总结）大神结论： 熔断类型： 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态 熔断关闭：熔断关闭不会对服务进行熔断 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断 官网断路器流程图： 官网步骤 123456789电路开合的准确发生方式如下:1.假设整个电路的容量满足一定的阈值HystrixCommandProperties.circuitBreakerRequestVolumeThreshold())…2.并且假设误差百分比超过阈值误差百分比HystrixCommandProperties.circuitBreakerErrorThresholdPercentage())…3.然后断路器从闭合转换为打开4.当它打开时，它会使所有针对该断路器的请求短路。5.一段时间后HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds())，下一个单一请求被允许通过(这是半开状态)。如果请求失败，断路器在睡眠窗口期间返回oPEN状态。如果请求成功，则断路器转换为闭合，逻辑在1。再次接管。 断路器在什么情况下开始起作用： 涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值。1：快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。 2：请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。 3：错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。 断路器开启或者关闭的条件： 123456当满足一定的阀值的时候（默认10秒内超过20个请求次数）当失败率达到一定的时候（默认10秒内超过50%的请求失败）到达以上阀值，断路器将会开启当开启的时候，所有请求都不会进行转发一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5 断路器打开之后： 1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。 2：原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 All配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//========================All@HystrixCommand(fallbackMethod = &quot;str_fallbackMethod&quot;, groupKey = &quot;strGroupCommand&quot;, commandKey = &quot;strCommand&quot;, threadPoolKey = &quot;strThreadPool&quot;, commandProperties = &#123; // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离 @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;), // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数） @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;), // 配置命令执行的超时时间 @HystrixProperty(name = &quot;execution.isolation.thread.timeoutinMilliseconds&quot;, value = &quot;10&quot;), // 是否启用超时时间 @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;), // 执行超时的时候是否中断 @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;), // 执行被取消的时候是否中断 @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnCancel&quot;, value = &quot;true&quot;), // 允许回调方法执行的最大并发数 @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;), // 服务降级是否启用，是否执行回调函数 @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;), // 是否启用断路器 @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候， // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;), // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, // 就把断路器设置为 &quot;打开&quot; 状态，否则就设置为 &quot;关闭&quot; 状态。 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;), // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后， // 会将断路器置为 &quot;半开&quot; 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 &quot;打开&quot; 状态， // 如果成功就设置为 &quot;关闭&quot; 状态。 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowinMilliseconds&quot;, value = &quot;5000&quot;), // 断路器强制打开 @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;), // 断路器强制关闭 @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;), // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间 @HystrixProperty(name = &quot;metrics.rollingStats.timeinMilliseconds&quot;, value = &quot;10000&quot;), // 该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候会根据 // 设置的时间窗长度拆分成多个 &quot;桶&quot; 来累计各度量值，每个&quot;桶&quot;记录了一段时间内的采集指标。 // 比如 10 秒内拆分成 10 个&quot;桶&quot;收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常 @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;), // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。 @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;), // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。 @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;), // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。 @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;), // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数， // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行， // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。 @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;), // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。 @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalinMilliseconds&quot;, value = &quot;500&quot;), // 是否开启请求缓存 @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;), // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中 @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;), &#125;, threadPoolProperties = &#123; // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量 @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;), // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列， // 否则将使用 LinkedBlockingQueue 实现的队列。 @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;-1&quot;), // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。 // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。 @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;5&quot;), &#125;)public String strConsumer() &#123; return &quot;hello 2020&quot;;&#125;public String str_fallbackMethod()&#123; return &quot;*****fall back str_fallbackMethod&quot;;&#125; 3.8、服务限流后面高级篇讲解alibaba的Sentinel说明 点击前往 4、hystrix工作流程4.1官网翻译阅读https://github.com/Netflix/Hystrix/wiki/How-it-Works 4.2、官网图例： 4.3、步骤说明： 1 创建 HystrixCommand（用在依赖的服务返回单个操作结果的时候） 或 HystrixObserableCommand（用在依赖的服务返回多个操作结果的时候） 对象。 2 命令执行。其中 HystrixComand 实现了下面前两种执行方式；而 HystrixObservableCommand 实现了后两种执行方式：execute()：同步执行，从依赖的服务返回一个单一的结果对象， 或是在发生错误的时候抛出异常。queue()：异步执行， 直接返回 一个Future对象， 其中包含了服务执行结束时要返回的单一结果对象。observe()：返回 Observable 对象，它代表了操作的多个结果，它是一个 Hot Obserable（不论 “事件源” 是否有 “订阅者”，都会在创建后对事件进行发布，所以对于 Hot Observable 的每一个 “订阅者” 都有可能是从 “事件源” 的中途开始的，并可能只是看到了整个操作的局部过程）。toObservable()： 同样会返回 Observable 对象，也代表了操作的多个结果，但它返回的是一个Cold Observable（没有 “订阅者” 的时候并不会发布事件，而是进行等待，直到有 “订阅者” 之后才发布事件，所以对于 Cold Observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）。 3 若当前命令的请求缓存功能是被启用的， 并且该命令缓存命中， 那么缓存的结果会立即以 Observable 对象的形式 返回。 4 检查断路器是否为打开状态。如果断路器是打开的，那么Hystrix不会执行命令，而是转接到 fallback 处理逻辑（第 8 步）；如果断路器是关闭的，检查是否有可用资源来执行命令（第 5 步）。 5 线程池&#x2F;请求队列&#x2F;信号量是否占满。如果命令依赖服务的专有线程池和请求队列，或者信号量（不使用线程池的时候）已经被占满， 那么 Hystrix 也不会执行命令， 而是转接到 fallback 处理逻辑（第8步）。 6 Hystrix 会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。HystrixCommand.run() ：返回一个单一的结果，或者抛出异常。HystrixObservableCommand.construct()： 返回一个Observable 对象来发射多个结果，或通过 onError 发送错误通知。 7 Hystrix会将 “成功”、”失败”、”拒绝”、”超时” 等信息报告给断路器， 而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行 “熔断&#x2F;短路”。 8 当命令执行失败的时候， Hystrix 会进入 fallback 尝试回退处理， 我们通常也称该操作为 “服务降级”。而能够引起服务降级处理的情况有下面几种：第4步： 当前命令处于”熔断&#x2F;短路”状态，断路器是打开的时候。第5步： 当前命令的线程池、 请求队列或 者信号量被占满的时候。第6步：HystrixObservableCommand.construct() 或 HystrixCommand.run() 抛出异常的时候。 9 当Hystrix命令执行成功之后， 它会将处理结果直接返回或是以Observable 的形式返回。 tips 如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常， Hystrix 依然会返回一个 Observable 对象， 但是它不会发射任何结果数据， 而是通过 onError 方法通知命令立即中断请求，并通过onError()方法将引起命令失败的异常发送给调用者。 5、服务监控HystrixDashboard5.1、概述除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。 5.2、仪表盘90015.2.1、新建cloud-consumer-hystrix-dashboard90015.2.2、修改pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5.2.3、修改yml文件1234567891011121314#端口号,自己定义的server: port: 9001#一定要加,不然还是会出现Unable to connect to Command Metric Stream,&quot;*&quot;,可以换成其他内容management: endpoints: web: exposure: include: &#x27;*&#x27;#最好添加,不然可能出现Origin parameter: http://localhost:8001/hystrix.stream is not in the allowed list of proxy host names. If it should be allowed add it to hystrix.dashboard.proxyStreamAllowList.hystrix: dashboard: proxy-stream-allow-list: localhost 5.3.4、在9001的主启动类上添加注解@EnableHystrixDashboard 5.3.5、在所有provider微服务提供者8001、8002上都需要添加监控依赖配置12345 &lt;!-- actuator监控信息完善 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 5.3.6、启动9001查看效果Hystrix Dashboard 5.3、断路器演示（服务监控HystrixDashboard)5.3.1、修改8001注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径 123456789101112131415/** *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑 *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;， *只要在自己的项目里配置上下面的servlet就可以了 */@Beanpublic ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean;&#125; 不然会报错404或Unable to connect to Command Metric Stream. 5.3.2、监控测试1、启动eureka集群 2、观察监控窗口 在9001监控页面添加监控地址： http://localhost:8001/hystrix.stream 先访问正常：localhost:8001&#x2F;payment&#x2F;circuit&#x2F;9 再访问错误：localhost:8001&#x2F;payment&#x2F;circuit&#x2F;-99 以上访问无误！ 打开监控面板： 面板如何看？ 7色： 1圈： 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例。 1线： 曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。 整体说明： 看懂一个再看复杂的： resilience4j在国内不常用，可以简单自己去了解 十二、zuul路由网关阅读脑图自行实践 十三、GateWay新一代网关1、概述简介1.1、官网上一代zuul 1.x：https://github.com/Netflix/zuul/wiki 当前gateway：Spring Cloud Gateway 1.2、是什么Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway一句话：gateway是原zuul1.x版的替代 1.2.1、概述Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等 123这个项目提供了一个建立在Spring生态系统之上的API网关，包括:Spring 5、Spring Boot 2和project Reactor 等技术。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到api，并提供横切关注点到它们,包括:安全性、监视/度量和弹性。SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。 一句话：SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。 1.2.2、能干嘛 反向代理 鉴权 流量控制 熔断 日志监控 ……. 1.2.3、微服务架构中网关所在位置 1.2.4、有zuul了怎么还要出gateway原因： neflix不太靠谱，zuul2.0一直跳票，迟迟不发布 1234567一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。 Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？ 多方面综合考虑Gateway是很理想的网关选择。 SpringCloud Gateway具有如下特性 12345678基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；动态路由：能够匹配任何请求属性；可以对路由指定 Predicate（断言）和 Filter（过滤器）；集成Hystrix的断路器功能；集成 Spring Cloud 服务发现功能；易于编写的 Predicate（断言）和 Filter（过滤器）；请求限流功能；支持路径重写。 SpringCloud Gateway 与 Zuul的区别 1234567891011在SpringCloud Finchley 正式版之前，Spring Cloud 推荐的网关是 Netflix 提供的Zuul： 1、Zuul 1.x，是一个基于阻塞 I/ O 的 API Gateway 2、Zuul 1.x 基于Servlet 2. 5使用阻塞架构它不支持任何长连接(如 WebSocket) Zuul 的设计模式和Nginx较像，每次 I/ O 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身会有第一次加载较慢的情况，使得Zuul 的性能相对较差。 3、Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。 Zuul 2.x的性能较 Zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试， Spring Cloud Gateway 的 RPS（每秒请求数）是Zuul 的 1. 6 倍。 4、Spring Cloud Gateway 建立 在 Spring Framework 5、 Project Reactor 和 Spring Boot 2 之上， 使用非阻塞 API。 5、Spring Cloud Gateway 还 支持 WebSocket， 并且与Spring紧密集成拥有更好的开发体验 zull1.x模型： 123456Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型。学过尚硅谷web中期课程都知道一个题目，Servlet的生命周期?servlet由servlet container进行生命周期管理。container启动时构造servlet对象并调用servlet init()进行初始化；container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。container关闭时调用servlet destory()销毁servlet； 上述模式的缺点： 123servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发(比如抽风用jemeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即spring实现了处理所有request请求的一个servlet（DispatcherServlet）并由该servlet阻塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型的弊端 GateWay模型： 1、WebFlux是什么 参考文档：https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-new-framework 说明： 12345传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的。但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用java8） Spring WebFlux 是 Spring 5.0 引入的新的响应式框架，区别于 Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于 Reactor 来实现响应式流规范。 2、三大核心概念2.1、Route（路由）路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由 2.2、Predicate（断言）参考的是Java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由 2.3、Filter（过滤）指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 2.4、总体 web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了 3、GateWay工作流程3.1、官网总结 1234567客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。 Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。 Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。 3.2、核心逻辑路由转发+执行过滤器链 4、入门配置4.1、新建cloud-gateway-gateway9527模块4.2、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-gateway-gateway9527&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--gateway--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--eureka-client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--一般基础配置类--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.3、配置yml文件12345678910111213141516171819202122232425262728293031server: port: 9527spring: application: name: cloud-gateway cloud: gateway: routes: #有个问题，这里配置了详细的地址，而不是服务名，那怎么做到负载均衡呢？ - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka# defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 4.4、编写主启动类12345678910111213141516package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class GateWayMain9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayMain9527.class, args); &#125;&#125; 4.5、如何才能做到路由映射呢？cloud-provider-payment8001看看controller的访问地址：get和lb 我们目前不想暴露8001端口，希望在8001外面套一层9527 4.6、yml新增网关配置12345678910111213141516171819202122232425262728 server: port: 9527spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 4.7、测试启动7001、8001（cloud-provider-payment8001） 启动9527 访问： 4.8、配置说明Gateway网关路由有两种配置方式： 在yml配置文件中配置（以上以演示过） 编写配置类进行注入Bean 官网案例： 自己写一个： 映射到bilibili热门页面 编码如下： 123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.config;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @auther xiaolin * @creatr 2023/3/15 17:44 */@Configurationpublic class GateWayConfig &#123; /** * 配置了一个id为path_route_xiaolin的路由规则 * 当访问http://localhost:9527/anime时会转发到地址：https://www.bilibili.com/anime/ * @param routeLocatorBuilder * @return */ @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); //https://www.bilibili.com/anime/ routes.route(&quot;path_route_xiaolin&quot;, r -&gt; r.path(&quot;/anime&quot;) .uri(&quot;https://www.bilibili.com/anime/&quot;)) .build(); return routes.build(); &#125;&#125; 5、通过服务名实现动态路由默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能 5.1、pom文件pom文件必须要有以下依赖：可以将9527注册进去 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 5.2、yml文件需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。 lb:&#x2F;&#x2F;serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri 12345678910111213141516171819202122232425262728293031323334server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 #uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka# defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 5.3、测试localhost:9527&#x2F;payment&#x2F;lb 会在8001和8002中进行轮询 5.4、如何更换负载均衡策略？xxx 5.5、网关、nginx、ribbon（loadbalancer）三个负载均衡的关系 123456789101112131415请求打到nginx 进行负载均衡 选择 网关服务器 然后 网关也会进行负载均衡 去注册中心找服务， 然会使用ribbon进行负载均衡 选择调用一个接口Nginx服务器端负载均衡：nginx是客户端所有请求统一交给nginx，由nginx进行实现负载均衡请求转发，属于服务器端负载均衡。既请求有nginx服务器端进行转发。Ribbon客户端负载均衡：Ribbon是从eureka注册中心服务器端上获取服务注册信息列表，缓存到本地，让后在本地实现轮训负载均衡策略。既在客户端实现负载均衡。应用场景的区别：Nginx适合于服务器端实现负载均衡 比如Tomcat ，Ribbon适合与在微服务中RPC远程调用实现本地服务负载均衡，比如Dubbo、SpringCloud中都是采用本地负载均衡。 gateway和nginx网关的区别 网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。 gateway 是前端工程 到 后台服务器之间的一个 对内网关 nginx是用户到 前端工程 的网关，对外网关 Nginx在其中扮演的角色是什么？ 反向代理 负载均衡 SpringGateway在其中扮演的角色是什么？ 统一鉴权 6、Predicate的使用6.1、是什么启动9527查看日志： Route Predicate Factories这个是什么东东? Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以进行组合 Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。 所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。 6.2、常用的Route Predicate6.2.1、After Route Predicate 上述这个After好懂，这个时间串串？？？怎么写 12345678910public class ZonedDateTimeDemo&#123; public static void main(String[] args) &#123; ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区 System.out.println(zbj);// ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;)); // 用指定时区获取当前时间// System.out.println(zny); &#125;&#125; 6.2.2、Before Route Predicate 6.2.3、Between Route Predicate6.2.4、Cookie Route Predicatecurl http://localhost:9527/payment/lb curl http://localhost:9527/payment/lb –cookie “username&#x3D;zzyy” curl乱码： https://blog.csdn.net/leedee/article/details/82685636 6.2.5、Header Route Predicate 两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。 6.2.6、Host Route Predicate Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。 6.2.7、Method Route Predicate 6.2.8、Path Route Predicate 6.2.9、Query Route Predicate 6.2.10、小总结1234567891011predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 - After=2020-02-05T15:10:03.685+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 #- Before=2020-02-05T15:10:03.685+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 #- Between=2020-02-02T17:45:06.206+08:00[Asia/Shanghai],2020-03-25T18:59:06.206+08:00[Asia/Shanghai] #- Cookie=username,zzyy #- Header=X-Request-Id, \\d+ # 请求头要有X-Request-Id属性并且值为整数的正则表达式 #- Host=**.atguigu.com - Method=GET - Query=username, \\d+ # 要有参数名username并且值还要是整数才能路由 说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。 目前新版的还有新的几个配置： RemoteAddr Route Predicate： Weight Route Predicate: XForwarded Remote Addr Route Predicate: 7、Filter的使用7.1、是什么 123路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。 Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生 7.2、Spring Cloud Gateway的Filter7.2.1、生命周期pre和post 7.2.2、种类（两种）GatewayFilter ： 34种之多 GlobalFilter： 使用方法和作用自行查看官网文档： Spring Cloud Gateway 7.3、常用的GateWayFilterAddRequestParameter： 12345678spring: cloud: gateway: routes: - id: add_request_parameter_route uri: https://example.org filters: - AddRequestParameter=red, blue 需要请求参数red&#x3D;blue才可以通过 7.4、自定义过滤器7.4.1、自定义全局GlobalFilter两个主要接口介绍：implements GlobalFilter,Ordered 7.4.2、能干嘛：全局日志记录 统一网关鉴权 ……. 7.4.3、案例代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lxg.springcloud.filter;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.web.servlet.filter.OrderedFilter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.Date;/** * @auther xiaolin * @creatr 2023/3/15 23:37 */@Component@Slf4jpublic class MyLogGateWayFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;******come in MyLogGateWayFilter&quot;+new Date()); String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;); if(uname==null)&#123; log.info(&quot;******用户名为null,非法用户,o(╥﹏╥)o&quot;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; 7.4.4、测试启动7001、8001、8002、9527 localhost:9527&#x2F;payment&#x2F;lb?uname&#x3D;xl localhost 十四、springcloud Config分布式配置中心1、概述1.1、当前分布式系统存在的配置问题微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。 SpringCloud提供了ConfigServer来解决这个问题（我们每一个微服务自己带着一个application.yml，上百个配置文件的管理……&#x2F;(ㄒoㄒ)&#x2F;~~） 1.2、是什么 1234567891011是什么 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。 怎么玩SpringCloud Config分为服务端和客户端两部分。 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。 1.3、能干嘛 集中管理配置文件 不同环境不同配置，动态化的配置更新，分环境部署比如dev&#x2F;test&#x2F;prod&#x2F;beta&#x2F;release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 post、curl访问刷新均可…… 1.4、与GitHub整合配置由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http&#x2F;https访问的形式 1.5、官网Spring Cloud Config 2、Config服务端配置与测试2.1、github上创建一个名为springcloud-config的仓库2.1.1、获取git地址&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;:linXiao01&#x2F;springcloud-config.git 2.2、在磁盘目录新建git仓库并clonegit clone &#103;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;:linXiao01&#x2F;springcloud-config.git 2.3、修改如果需要修改，此处模拟运维人员操作git和github： 123git add git commit -m &quot;init yml&quot;git push origin master 2.4、新建Module模块cloud-config-center-3344它即为Cloud的配置中心模块cloudConfig Center 2.5、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-center-3344&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.6、修改yml文件12345678910111213141516171819202122server: port: 3344spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: git@github.com:linXiao01/springcloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: main#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka 2.7、主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;/** * @auther xiaolin * @creatr 2023/3/16 9:14 */@SpringBootApplication@EnableConfigServerpublic class ConfigCenterMain3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigCenterMain3344.class, args); &#125;&#125; 2.8、windows下修改host文件，增加映射127.0.0.1 config-3344.com 2.9、测试启动3344 config-3344.com:3344&#x2F;main&#x2F;config-dev.yml 2.10、配置读取规则2.10.1、官网 2.10.2、&#x2F;{application}&#x2F;{profile}[&#x2F;{label}]config-3344.com:3344&#x2F;config&#x2F;dev&#x2F;main config-3344.com:3344&#x2F;config&#x2F;test&#x2F;main config-3344.com:3344&#x2F;config&#x2F;test&#x2F;dev 2.10.3、&#x2F;{application}-{profile}.ymlconfig-3344.com:3344&#x2F;config-prod.yml 访问不存在的配置： 2.10.4、&#x2F;{label}&#x2F;{application}-{profile}.ymlconfig-3344.com:3344&#x2F;main&#x2F;config-dev.yml config-3344.com:3344&#x2F;dev&#x2F;config-dev.yml 2.10.5、重要配置细节总结&#x2F;{name}-{profiles}.yml &#x2F;{label}&#x2F;{name}-{profiles}.yml label：分支(branch)name ：服务名profiles：环境(dev&#x2F;test&#x2F;prod) 以上成功实现了用SpringCloud Config通过GitHub获取配置信息，另外两个获取路径也是一样！ 3、Config客户端配置与测试3.1、新建cloud-config-client-33553.2、修改pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新版的SpringBoot一定要加上最后的bootstrap依赖，否则会报错！！！ 3.3、编写bootstrap.yml文件3.3.1、是什么12345678910applicaiton.yml是用户级的资源配置项bootstrap.yml是系统级的，优先级更加高 Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的`Application Context`的父上下文。初始化的时候，`Bootstrap Context`负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的`Environment`。 `Bootstrap`属性有高优先级，默认情况下，它们不会被本地配置覆盖。 `Bootstrap context`和`Application Context`有着不同的约定，所以新增了一个`bootstrap.yml`文件，保证`Bootstrap Context`和`Application Context`配置的分离。 要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml 3.3.2、内容1234567891011121314151617181920server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka 3.3.3、说明 3.4、编写主启动类1234567891011121314151617181920package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * @auther xiaolin * @creatr 2023/3/16 14:59 */@SpringBootApplication@EnableEurekaClientpublic class ConfigClientMain3355 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientMain3355.class,args); &#125;&#125; 3.5、编写业务类123456789101112131415161718192021222324package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @auther xiaolin * @creatr 2023/3/16 15:08 */@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; 3.6、测试config-3344.com:3344&#x2F;main&#x2F;config-dev.yml localhost:3355&#x2F;configInfo 成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息 3.7、问题123456789Linux运维修改GitHub上的配置文件内容做调整刷新3344，发现ConfigServer配置中心立刻响应刷新3355，发现ConfigClient客户端没有任何响应3355没有变化除非自己重启或者重新加载难到每次运维修改配置文件，客户端都需要重启？？噩梦 4、Config客户端之动态刷新避免每次更新配置都要重启客户端微服务3355 4.1、修改3355pom引入actutor监控 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 4.2、修改yml，暴露监控端口12345678910111213141516171819202122232425262728server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka#开启actuator监控#暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 4.3、@RefreshScope业务类Controller修改1234567891011121314151617181920212223242526package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @auther xiaolin * @creatr 2023/3/16 15:08 */@RestController@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; 4.4、访问3344可以正常更新 但是3355依然不能 4.5、怎么做需要运维人员发送Post请求刷新3355 必须是POST请求 curl -X POST “http://localhost:3355/actuator/refresh“ 4.6、再次访问 成功实现了客户端3355刷新到最新配置内容 4.7、还有什么问题 假如有多个微服务客户端3355&#x2F;3366&#x2F;3377 每个微服务都要执行一次post请求，手动刷新？ 可否广播，一次通知，处处生效？ 我们想大范围的自动刷新，求方法？ 十五、SpringCloud Bus 消息总线1、概述分布式自动刷新配置功能：Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。 1.1、是什么 Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。Spring Clud Bus目前支持RabbitMQ和Kafka。 1.2、能干嘛Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。 1.5、为何被称为总线12345什么是总线在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。 基本原理ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。 ActiveMQ 2、RabbitMQ环境配置2.1、windows安装方法2.1.1、查看RabbitMQ和Erlang版本关系RabbitMQ Erlang Version Requirements — RabbitMQ 2.1.2、安装Erlang环境Downloads - Erlang&#x2F;OTP github：Release 25.2.1 · rabbitmq&#x2F;erlang-rpm · GitHub 2.1.3、安装RabbitMQ历史版本：https://www.rabbitmq.com/news.html github：Releases · rabbitmq&#x2F;rabbitmq-server (github.com) 最新版本：Installing on Windows Manually — RabbitMQ 2.1.4、安装后进行rabbitMQ安装目录的sbin如：E:\\software\\RabbitMQ3.11.10\\rabbitmq_server-3.11.10\\sbin 2.1.5、命令cmd窗口打开，运行以下命令 执行完毕会开始菜单会有以下内容： 对应下载，启动，停止，删除。 2.1.6、访问查看是否安装成功http://localhost:15672/ 默认账号密码： guest guest 2.2、Linux系统安装2.2.1、安装Erlangrabbitmq&#x2F;erlang - Packages · packagecloud 使用wegt命令进行安装： 1wget --content-disposition &quot;https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.3.4.11-1.el7.x86_64.rpm/download.rpm?distro_version_id=140&quot; 2.2.2、安装RabbitMQhttps://packagecloud.io/rabbitmq/rabbitmq-server?page=23 2.2.3、具体教程https://blog.csdn.net/m0_67392182/article/details/126040124 3、SpringCloud Bus动态刷新全局广播以上配置完rabbitMQ环境后启动 3.1、以3355为模板新建一个3366模块3.1.1、修改pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-config-client-3366&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--添加消息总线RabbitMQ支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.1.2、修改yml文件（bootstrap）1234567891011121314151617181920212223242526272829303132333435363738server: port: 3366spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #集群化配置 #discovery: # service-id: CLOUD-CONFIG-SERVER #配置中心服务名 #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka#开启actuator监控#暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 3.1.3、主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * @auther xiaolin * @creatr 2023/3/17 11:01 */@SpringBootApplication@EnableEurekaClientpublic class ConfigClientMain3366 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientMain3366.class,args); &#125;&#125; 3.1.4、controller123456789101112131415161718192021222324252627282930package com.lxg.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @auther xiaolin * @creatr 2023/3/17 11:02 */@RestController@RefreshScopepublic class ConfigClientController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @Value(&quot;$&#123;config.info&#125;&quot;) public String configInfo; @GetMapping(&quot;/configInfo&quot;) public String configInfo() &#123; return &quot;serverPort: &quot;+serverPort+&quot;\\t\\n\\n configInfo: &quot;+configInfo; &#125;&#125; 特别注意@RefreshScope 3.2、设计思想 利用消息总线触发一个客户端&#x2F;bus&#x2F;refresh,而刷新所有客户端的配置 利用消息总线触发一个服务端ConfigServer的&#x2F;bus&#x2F;refresh端点，而刷新所有客户端的配置 图二的架构显然更加适合，图一不适合的原因如下： 123打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。破坏了微服务各节点的对等性。有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改 3.3、给config3344配置中心增加消息总线支持3.3.1、修改pom文件(添加)123456 &lt;!--添加消息总线RabbitMQ支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3.3.2、修改yml文件1234567891011121314151617181920212223242526272829303132333435363738server: port: 3344spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: git@github.com:linXiao01/springcloud-config.git #GitHub上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: main #rabbitmq相关配置 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka##rabbitmq相关配置,暴露bus刷新配置的端点management: endpoints: #暴露bus刷新配置的端点 web: exposure: include: &#x27;busrefresh&#x27; 3.4、修改33663.4.1、修改pom（添加）12345&lt;!--添加消息总线RabbitMQ支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3.4.2、修改yml1234567891011121314151617181920212223242526272829303132333435363738server: port: 3366spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #集群化配置 #discovery: # service-id: CLOUD-CONFIG-SERVER #配置中心服务名 #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka#开启actuator监控#暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 3.5、修改33553.5.1、修改pom（添加）12345&lt;!--添加消息总线RabbitMQ支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 3.5.2、修改yml12345678910111213141516171819202122232425262728293031323334server: port: 3355spring: application: name: config-client cloud: #Config客户端配置 config: label: main #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：main分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost port: 5672 username: guest password: guest#服务注册到eureka地址eureka: client: service-url: defaultZone: http://localhost:7001/eureka#开启actuator监控#暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; 3.6、测试依次启动7001、3344、3355、3366 3.6.1、修改github上的版本号3.6.2、发送post请求新版 1curl -X POST &quot;http://localhost:3344/actuator/busrefresh&quot; 老版 1curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot; 3.6.3、查看配置中心 3.6.4、查看3355、3366http://localhost:3355/configInfo http://localhost:3366/configInfo 版本由9转为10，没有重新启动过 一次修改，广播通知，处处生效 4、SpringCloud Bus动态刷新定点通知4.1、目的只通知3355，不通知3366 指定具体某一个实例生效而不是全部 4.2、如何做公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination} &#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例 4.3、刷新3355curl -X POST “http://localhost:3344/actuator/bus-refresh/config-client:3355“ 服务名:端口号 4.4、总结 十六、SpringCloud Stream消息驱动1、消息驱动概述1.1、是什么1.1.1、一句话1234567891011什么是SpringCloudStream官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。 应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。 通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。 目前仅支持RabbitMQ、Kafka。 1.1.2、官网https://spring.io/projects/spring-cloud-stream#overview Spring Cloud Stream是用于构建与共享消息传递系统连接的高度可伸缩的事件驱动微服务框架，该框架提供了一个灵活的编程模型，它建立在已经建立和熟悉的Spring熟语和最佳实践上，包括支持持久化的发布&#x2F;订阅、消费组以及消息分区这三个核心概念 Spring Cloud Stream Reference Documentation Spring Cloud Stream中文指导手册：https://m.wang1314.com/doc/webapp/topic/20971999.html 1.2、设计思想1.2.1、标准MQ 生产者&#x2F;消费者之间靠消息媒介传递信息内容（Message） 消息必须走特定的通道（消息通道MessageChannel） 消息通道里的消息如何被消费呢，谁负责收发处理：消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅 1.2.2、为什么用Could Stream比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区 这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候springcloud Stream给我们提供了一种解耦合的方式。 stream凭什么可以统一底层差异： 1234在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。 Binder: 在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。 Binder可以生成Binding，Binding用来绑定消息容器的生产者和消费者，它有两种类型，INPUT和OUTPUT，INPUT对应于消费者，OUTPUT对应于生产者。 1.2.3、Stream中的消息通信方式遵循了发布-订阅模式Topic主题进行广播： 在RabbitMQ就是Exchange，在Kakfa中就是Topic 1.3、Spring Cloud Stream标准流程套路 Binder：很方便的连接中间件，屏蔽差异 Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置 Source和Sink：简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。 1.4、编码API和常用注解 2、案例说明2.1、配置好RabbitMQ环境2.2、工程中新建三个子模块cloud-stream-rabbitmq-provider8801， 作为生产者进行发消息模块 cloud-stream-rabbitmq-consumer8802，作为消息接收模块 cloud-stream-rabbitmq-consumer8803 作为消息接收模块 3、消息驱动之生产者3.1、新建cloud-stream-rabbitmq-provider8801模块3.2、修改pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.3、创建主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @auther xiaolin * @creatr 2023/3/19 17:22 */@SpringBootApplicationpublic class StreamMQMain8801&#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8801.class,args); &#125;&#125; 3.4、第一种发送消息的方式（老版）3.4.1、修改yml文件1234567891011121314151617181920212223242526272829303132333435363738394041server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的名称，即上面的defaultRabbit# - $&#123;spring.cloud.stream.binders.defaultRabbit&#125; # 设置要绑定的消息服务的具体设置 rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 3.4.2、消息接口12345678910package com.lxg.springcloud.service;/** * @auther xiaolin * @creatr 2023/3/19 17:23 */public interface IMessageProvider &#123; String send();&#125; 3.4.3、实现类123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.service.impl;import com.lxg.springcloud.service.IMessageProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.function.StreamBridge;import org.springframework.cloud.stream.messaging.Source;import org.springframework.messaging.MessageChannel;import org.springframework.integration.support.MessageBuilder;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.UUID;/** * @auther xiaolin * @creatr 2023/3/19 17:24 */@EnableBinding(Source.class) //定义消息的推送管道（老版）public class IMessageProviderImpl implements IMessageProvider &#123; @Resource private MessageChannel output; //消息发送管道 @Override public String send() &#123; String serial = java.util.UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); System.out.println(&quot;********serial: &quot; + serial); return serial; &#125;&#125; 3.4.4、controller123456789101112131415161718192021222324252627package com.lxg.springcloud.controller;import com.lxg.springcloud.service.IMessageProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.function.Supplier;/** * @auther xiaolin * @creatr 2023/3/19 17:45 */@RestControllerpublic class SendMessageController &#123; @Autowired private IMessageProvider iMessageProvider; @GetMapping(value = &quot;/sendMessage&quot;) public String sendMessage()&#123; return iMessageProvider.send(); &#125;&#125; 3.4.5、测试启动RabbitMQ 启动7001 启动8801 访问http://localhost:8801/sendMessage 3.5、第二种发送消息的方式（streamBridge）3.5.1、修改yml文件（与第一种一致）3.5.2、消息接口（与第一种一致）3.5.3、实现类123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.service.impl;import com.lxg.springcloud.service.IMessageProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.stream.function.StreamBridge;import org.springframework.context.annotation.Bean;import org.springframework.messaging.MessageChannel;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.UUID;import java.util.function.Supplier;/** * @auther xiaolin * @creatr 2023/3/19 17:24 */@Service //新版public class IMessageProviderImpl implements IMessageProvider &#123; //新版 @Autowired StreamBridge streamBridge; @Override public String send() &#123; String message= UUID.randomUUID().toString(); streamBridge.send(&quot;output&quot;,message); System.out.println(&quot;********发送消息：&quot;+message); return message; &#125;&#125; 注意send方法中的output是通道名称，与yml文件配置一致 3.5.4、controller（与第一种一致）3.6、第三种发送方式(Supplier)使用Supplier接口发送消息： 新建一个bean返回type为Supplier，方法为hello()，会自动创建exchange&#x3D;hello-out-0 默认情况下每1秒钟由Spring框架触发1次。 修改默认值：spring.cloud.stream.poller.fixedDelay=5000 Reactive风格编程，Supplier&lt;Flux&lt;String&gt;&gt; hello()，Flux.just(String)，只会触发一次。 Reactive风格编程，配合Thread.sleep和Schedulers.elastic()，可实现每1秒发送1次消息。 Reactive风格编程，使用@PollableBean轻松实现每1秒发送1次消息。 3.6.1、修改yml123456789101112131415161718192021222324252627282930313233server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 3.6.2、消息接口123456789101112package com.lxg.springcloud.service;import java.util.function.Supplier;/** * @auther xiaolin * @creatr 2023/3/19 17:23 */public interface IMessageProvider &#123; public Supplier&lt;String&gt; hello();&#125; 3.6.3、实现类123456789101112131415161718192021222324252627package com.lxg.springcloud.service.impl;import com.lxg.springcloud.service.IMessageProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.stream.function.StreamBridge;import org.springframework.context.annotation.Bean;import org.springframework.messaging.MessageChannel;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.UUID;import java.util.function.Supplier;/** * @auther xiaolin * @creatr 2023/3/19 17:24 */@Service //新版public class IMessageProviderImpl implements IMessageProvider &#123; @Bean public Supplier&lt;String&gt; hello()&#123; String message= UUID.randomUUID().toString(); System.out.println(&quot;********发送消息：&quot;+message); return () -&gt; message; &#125;&#125; 3.6.4、controller12345678910111213141516171819202122package com.lxg.springcloud.controller;import com.lxg.springcloud.service.IMessageProvider;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.function.Supplier;/** * @auther xiaolin * @creatr 2023/3/19 17:45 */@Componentpublic class SendMessageController &#123; @Autowired private IMessageProvider iMessageProvider; public Supplier&lt;String&gt; sendMessage()&#123; return iMessageProvider.send(); &#125;&#125; 每个1秒自动触发发送一次消息，比如我们加上spring.cloud.stream.poller.fixedDelay=5000，那么Supplier消息就会每隔5秒发送一次。 4、消息驱动之消费者4.1、新建cloud-stream-rabbitmq-consumer8802模块4.2、修改pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8802&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.3、创建主启动类1234567891011121314151617package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @auther xiaolin * @creatr 2023/3/19 18:26 */@SpringBootApplicationpublic class StreamMQMain8802&#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8802.class,args); &#125;&#125; 4.4、第一种接收消息的方式（老版）4.4.1、修改yml123456789101112131415161718192021222324252627282930313233server: port: 8802spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 4.4.2、controller12345678910111213141516171819202122232425262728293031package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.context.annotation.Bean;import org.springframework.messaging.Message;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.function.Consumer;/** * @auther xiaolin * @creatr 2023/3/19 18:27 */@Component@EnableBinding(Sink.class)public class ReceiveMessageListenerController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message)&#123; System.out.println(&quot;消费者1号，-----&gt;接收到的消息：&quot;+message.getPayload()+&quot;\\t port:&quot;+serverPort); &#125;&#125; 4.5、第二种接收消息的方式（consumer）使用这个默认会自动生成一个方法名-in-0的exchange来接收，所以应该在发送端指定发送的exchange名字 4.5.1、修改yml12345678910111213141516171819202122232425262728server: port: 8802spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 4.5.2、controller1234567891011121314151617181920212223242526272829303132package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.context.annotation.Bean;import org.springframework.messaging.Message;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.function.Consumer;/** * @auther xiaolin * @creatr 2023/3/19 18:27 */@Componentpublic class ReceiveMessageListenerController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @Bean Consumer&lt;String&gt; receive()&#123; return message -&gt;&#123; System.out.println(&quot;消费者1号，-----&gt;接收到的消息：&quot;+message+&quot;\\t port:&quot;+serverPort); &#125;; &#125;&#125; 5、自定义消息通道（老版，新版不需要） 6、分组消费与持久化6.1、依照8802，新建一个88036.1.1、pom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8803&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 6.1.2、yml1234567891011121314151617181920212223242526272829303132server: port: 8803spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 receive-in-0: # 这个名字是一个通道的名称 destination: testExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8803.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 6.1.3、主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @auther xiaolin * @creatr 2023/3/19 18:26 */@SpringBootApplicationpublic class StreamMQMain8803&#123; public static void main(String[] args) &#123; SpringApplication.run(StreamMQMain8803.class,args); &#125;&#125; 6.1.4、controller123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;import java.util.function.Consumer;/** * @auther xiaolin * @creatr 2023/3/19 18:27 */@Component//@EnableBinding(Sink.class)public class ReceiveMessageListenerController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; /* @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message)&#123; System.out.println(&quot;消费者1号，-----&gt;接收到的消息：&quot;+message.getPayload()+&quot;\\t port:&quot;+serverPort); &#125;*/ @Bean Consumer&lt;String&gt; receive()&#123; return message -&gt;&#123; System.out.println(&quot;消费者2号，-----&gt;接收到的消息：&quot;+message+&quot;\\t port:&quot;+serverPort); &#125;; &#125;&#125; 6.2、启动启动RabbitMQ、7001、8801、8802、8803 运行后的问题： 8802和8803都能接收消息来处理 消息持久化 其实就是这个队列是topic模式，routing-key是#，即所有队列都能接收消费，而默认不同消费者使用的是不同队列 6.3、消费目前是8802&#x2F;8803同时都收到了，存在重复消费问题 http://localhost:8801/sendMessage 6.3.1、如何解决分组和持久化属性group 6.3.2、生产实际案例比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决 注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的(重复消费)，同一组内会发生竞争关系，只有其中一个可以消费。 使用后，即同一group的消费者使用同一个队列，竞争消费消息 6.4、分组6.4.1、原理微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。 6.4.2、8802&#x2F;8803都变成不同组，group两个相同分布式微服务应用为了实现高可用和负载均衡，实际上都会部署多个实例，本例阳哥启动了两个消费微服务(8802&#x2F;8803) 多数情况，生产者发送消息给某个具体微服务时只希望被消费一次，按照上面我们启动两个应用的例子，虽然它们同属一个应用，但是这个消息出现了被重复消费两次的情况。为了解决这个问题，在Spring Cloud Stream中提供了消费组的概念。 8802和8803修改yml: 123456bindings: # 服务的整合处理 receive-in-0: # 这个名字是一个通道的名称 destination: testExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 group: xiaolinA 8802&#x2F;8803实现了轮询分组，每次只有一个消费者8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。 同一个组的多个微服务实例，每次只会有一个拿到 6.5、持久化通过上述，解决了重复消费问题，再看看持久化 停止8802&#x2F;8803并去除掉8802的分组group:xiaolinA 8803的分组group: xiaolinA没有去掉 8801先发送4条消息到rabbitmq 先启动8802，无分组属性配置，后台没有打出来消息 再启动8803，有分组属性配置，后台打出来了MQ上的消息 十七、SpringCloud Sleuth分布式请求链路跟踪1、概述1.1、为什么会出现这个技术，解决什么问题？ 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。 1.2、是什么？https://github.com/spring-cloud/spring-cloud-sleuth Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案 在分布式系统中提供追踪解决方案并且兼容支持了zipkin 1.3、解决 2、搭建链路监控步骤2.1、zipkin2.1.1、下载SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可 项目地址：Central Repository: io&#x2F;zipkin&#x2F;zipkin-server (maven.org) 安装包：zipkin-server-2.23.9-exec.jar 官网：快速入门 ·OpenZipkin 2.1.2、运行jarjava -jar zipkin-server-2.23.9-exec.jar 2.1.3、运行控制台http://localhost:9411/zipkin/ 完整的调用链路： 表示一请求链路，一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来 术语： 一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来 名词解释： Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识 span:表示调用链路来源，通俗的理解span就是一次请求信息 2.2、服务提供者以cloud-provider-payment8001为例 2.2.1、修改pom文件(添加)1234567&lt;!--包含了sleuth+zipkin--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zipkin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.2.2、修改yml1234567891011121314server: port: 8001spring: application: name: cloud-payment-service zipkin: #zipkin server的请求地址 base-url: http://localhost:9411 sleuth: sampler: # 日志数据采样百分比，默认0.1(10%)，这里为了测试设置成了100%，生产环境只需要0.1即可 probability: 1.0 2.2.3、业务类PaymentController12345 @GetMapping(&quot;/payment/zipkin&quot;)public String paymentZipkin()&#123; return &quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to atguigu，O(∩_∩)O哈哈~&quot;;&#125; 2.3、服务消费者（调用方）以cloud-consumer-order80为例 2.3.1、修改pom文件1234567&lt;!--包含了sleuth+zipkin--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zipkin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.3.2、修改yml文件123456789101112spring: application: name: cloud-order-service zipkin: #zipkin server的请求地址 base-url: http://localhost:9411 sleuth: sampler: # 日志数据采样百分比，默认0.1(10%)，这里为了测试设置成了100%，生产环境只需要0.1即可 probability: 1.0 2.3.3、业务类OrderController1234567// ====================&gt; zipkin+sleuth @GetMapping(&quot;/consumer/payment/zipkin&quot;) public String paymentZipkin() &#123; String result = restTemplate.getForObject(&quot;http://localhost:8001&quot;+&quot;/payment/zipkin/&quot;, String.class); return result; &#125; 2.4、测试启动7001、8001、80 调用：localhost&#x2F;consumer&#x2F;payment&#x2F;zipkin 打开浏览器访问：http://localhost:9411/zipkin/ 查看依赖关系： 原理： 查看详情：","tags":"springcloud"},{"title":"SpringCloud Alibaba","url":"/2023/10/12/SpringCloud Alibaba/","text":"SpringCloud Alibaba一、入门简介1、why会出现SpringCloud alibaba1.1、Spring Cloud Netflix项目进入维护模式https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now 1.2、Spring Cloud Netflix Projects Entering Maintenance Mode1.2.1、什么是维护模式 将模块置于维护模式，意味着 Spring Cloud 团队将不会再向模块添加新功能。我们将修复 block 级别的 bug 以及安全问题，我们也会考虑并审查社区的小型 pull request。 1.2.2、进入维护模式意味着什么呢？进入维护模式意味着 Spring Cloud Netflix 将不再开发新的组件我们都知道Spring Cloud 版本迭代算是比较快的，因而出现了很多重大ISSUE都还来不及Fix就又推另一个Release了。进入维护模式意思就是目前一直以后一段时间Spring Cloud Netflix提供的服务和功能就这么多了，不在开发新的组件和功能了。以后将以维护和Merge分支Full Request为主 新组件功能将以其他替代平代替的方式实现 2、SpringCloud alibaba带来了什么2.1、是什么 官网： Spring Cloud Alibaba 参考文档 (spring-cloud-alibaba-group.github.io) spring-cloud-alibaba&#x2F;README-zh.md at 2021.x · alibaba&#x2F;spring-cloud-alibaba · GitHub 诞生：2018.10.31，Spring Cloud Alibaba 正式入驻了 Spring Cloud 官方孵化器，并在 Maven 中央库发布了第一个版本。 2.2、能干嘛 服务限流降级：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 2.3、去哪下载spring-cloud-alibaba&#x2F;README-zh.md at 2021.x · alibaba&#x2F;spring-cloud-alibaba · GitHub 2.4、怎么玩 3、SpringCloud alibaba学习资料获取3.1、官网 Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 SpringCloud Alibaba进入了SpringCloud官方孵化器，而且毕业了 https://spring.io/projects/spring-cloud-alibaba#overview 3.2、英文版https://github.com/alibaba/spring-cloud-alibaba https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html 3.3、中文版spring-cloud-alibaba&#x2F;README-zh.md at 2021.x · alibaba&#x2F;spring-cloud-alibaba · GitHub 二、SpringCloud Alibaba Nacos服务注册和配置中心1、Nacos简介1.1、为什么叫Nacos前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。 1.2、是什么一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos: Dynamic Naming and Configuration Service Nacos就是注册中心 + 配置中心的组合 等价于：Nacos &#x3D; Eureka+Config +Bus 1.3、能干嘛替代Eureka做服务注册中心 替代Config做服务配置中心 1.4、去哪下https://github.com/alibaba/Nacos 官网文档： home (nacos.io) https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery 1.5、各种注册中心比较 据说 Nacos 在阿里巴巴内部有超过 10 万的实例运行，已经过了类似双十一等各种大型流量的考验 2、安装运行Nacos本地Java8+Maven环境已经OK 2.1、先从官网下载Nacos：https://github.com/alibaba/nacos/releases 2.2、解压安装包，直接运行bin目录下的startup.cmdstartup.cmd -m standalone 新版的需要修改配置application.properties 使用以下程序生成秘钥： 123456789101112131415161718192021222324import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class SecretKeyGenerator &#123; public static SecretKey generate() &#123; try &#123; // 使用AES算法生成256位的SecretKey KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); keyGenerator.init(256); return keyGenerator.generateKey(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; SecretKey secretKey = generate(); System.out.println(Base64.getEncoder().encodeToString(secretKey.getEncoded())); &#125;&#125; 搜索并添加到配置文件中： nacos.core.auth.plugin.nacos.token.secret.key&#x3D; 2.3、登录localhost 默认账号密码都是：nacos 2.4、结果页面： 3、Nacos作为服务注册中心演示3.1、官网文档Spring Cloud Alibaba Reference Documentation (spring-cloud-alibaba-group.github.io) 3.2、基于Nacos的服务提供者3.2.1、新建cloudalibaba-provider-payment90013.2.2、改pom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-provider-payment9001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.3、改yml12345678910111213141516server: port: 9001spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &#x27;*&#x27; 3.2.4、主启动类12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/21 15:00 */@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain9001&#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9001.class, args); &#125;&#125; 3.2.5、业务类123456789101112131415161718192021222324package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * @auther xiaolin * @creatr 2023/3/21 15:00 */@RestControllerpublic class PaymentController&#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;) public String getPayment(@PathVariable(&quot;id&quot;) Integer id) &#123; return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\\t id&quot;+id; &#125;&#125; 3.2.6、测试http://localhost:9001/payment/nacos/1 http://localhost:8848/nacos nacos服务注册中心+服务提供者9001都OK了 3.2.7、新建9002新建cloudalibaba-provider-payment9002 与9001完全一致，只需要更改端口号即可 或者取巧不想新建重复体力劳动，直接拷贝虚拟端口映射： 3.3、基于Nacos的服务消费者3.3.1、新建cloudalibaba-consumer-nacos-order83模块3.3.2、pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-consumer-nacos-order83&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 注意：老版的nacos自带ribbon负载均衡，但是新版的已经没有，需要加入loadbalancer依赖 3.3.3、yml文件12345678910111213141516server: port: 83spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)service-url: nacos-user-service: http://nacos-payment-provider 3.3.4、主启动类12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/22 15:36 */@EnableDiscoveryClient@SpringBootApplicationpublic class OrderNacosMain83&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain83.class,args); &#125;&#125; 3.3.5、业务类ApplicationContextBean： 123456789101112131415161718192021package com.lxg.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * @auther xiaolin * @creatr 2023/3/22 15:38 */@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; OrderNacosController 123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/3/22 15:42 */@RestController@Slf4jpublic class OrderNacosController &#123; @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;) private String serverURL; @Resource private RestTemplate restTemplate; @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;) public String paymentInfo(@PathVariable(&quot;id&quot;) Long id)&#123; return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class); &#125;&#125; 3.3.6、测试Nacos localhost:83&#x2F;consumer&#x2F;payment&#x2F;nacos&#x2F;13 实现了负载均衡 3.4、服务注册中心对比3.4.1、各种注册中心的对比Nacos全景图所示 Nacos和CAP Nacos 支持AP和CP模式的切换: 123456789101112C是所有节点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。何时选择使用何种模式？一般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。curl -X PUT &#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27; 4、Nacos作为服务配置中心演示4.1、Nacos作为配置中心-基础配置4.1.1、新建cloudalibaba-config-nacos-client33774.1.2、pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-config-nacos-client3377&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--nacos-config--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos-discovery--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web + actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--一般基础配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 注意，使用了bootstrap.yml就别忘记引入bootstrap依赖 4.1.3、yml文件why配置两个： 123456Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application优先级高先加载，正常情况应该是被覆盖的，但是bootstrap是不会被application覆盖的 bootstrap.yml: 123456789101112131415161718# nacos配置server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 # $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125; # nacos-config-client-dev.yaml application.yml： 123spring: profiles: active: dev # 表示开发环境 4.1.4、主启动类123456789101112131415161718package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @auther xiaolin * @creatr 2023/3/22 23:05 */@EnableDiscoveryClient@SpringBootApplicationpublic class NacosConfigClientMain3377&#123; public static void main(String[] args) &#123; SpringApplication.run(NacosConfigClientMain3377.class, args); &#125;&#125; 4.1.5、业务类ConfigClientController: 1234567891011121314151617181920212223package com.lxg.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @auther xiaolin * @creatr 2023/3/22 23:05 */@RestController@RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。public class ConfigClientController&#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/config/info&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; @RefreshScope: 4.1.6、在nacos中添加配置信息Nacos中的匹配规则: Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则 官网： https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html 最后公式： 1$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125; 配置新增： nacos-config-dev.yaml Nacos界面配置对应 设置DataId 公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension} 123prefix 默认为 spring.application.name 的值spring.profile.active 即为当前环境对应的 profile，可以通过配置项 spring.profile.active 来配置。file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置 小总结说明: 历史配置: Nacos会记录配置文件的历史版本默认保留30天，此外还有一键回滚功能，回滚操作将会触发配置更新 回滚： 4.1.7、测试启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件 运行cloud-config-nacos-client3377的主启动类 调用接口查看配置信息：http://localhost:3377/config/info 自带动态刷新： 修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新 4.2、Nacos作为配置中心-分类配置4.2.1、问题多环境多项目管理 问题1：实际开发中，通常一个系统会准备dev开发环境test测试环境prod生产环境。如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？ 问题2：一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境……那怎么对这些微服务配置进行管理呢？ 4.2.2、Nacos的图形化管理界面配置管理 命名空间 Namespace+Group+Data ID三者关系？为什么这么设计？ 是什么 类似Java里面的package名和类名，最外层的namespace是可以用于区分部署环境的，Group和DataID逻辑上区分两个目标对象。 三者情况 默认情况：Namespace&#x3D;public，Group&#x3D;DEFAULT_GROUP, 默认Cluster是DEFAULT Nacos默认的命名空间是public，Namespace主要用来实现隔离。比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。 Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去 Service就是微服务；一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称（HZ），给广州机房的Service微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能。 最后是Instance，就是微服务的实例。 4.2.3、案例三种方案加载配置 DataID方案 指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置 默认空间+默认分组+新建dev和test两个DataID： 新建dev配置DataID： 新建test配置DataID： 通过spring.profile.active属性就能进行多环境下配置文件的读取： 测试： http://localhost:3377/config/info 配置是什么就加载什么 Group方案 通过Group实现环境区分 新建group 在nacos图形界面控制台上面新建配置文件DataID： bootstrap+application： 在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP Namespace方案 新建dev&#x2F;test的Namespace： 回到服务管理-服务列表查看： 按照域名配置填写： YML： bootstrap： 123456789101112131415161718# nacos配置server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 group: DEV_GROUP namespace: b4f3cb1a-30bc-4230-92a6-3c81497217f7 # $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125; # nacos-config-client-dev.yaml application: 123456# Nacos注册配置，application.ymlspring: profiles: #active: test active: dev #active: info 5、Nacos集群和持久化配置（重要）5.1、官网说明https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html 5.1.1、官网架构图 5.1.2、上图官网翻译，真实情况即VIP就是虚拟ip配置nginx进行访问 5.1.3、说明默认Nacos使用嵌入式数据库实现数据的存储。（如Nacos关掉后再打开，里面的配置依然存在）但是因为这样，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。 按照上述，我们需要mysql数据库 官网说明：https://nacos.io/zh-cn/docs/deployment.html 5.2、Nacos持久化配置解释5.2.1、Nacos默认自带的是嵌入式数据库derbyhttps://github.com/alibaba/nacos/blob/develop/config/pom.xml 观察到pom文件引入了derby 5.2.2、derby到mysql切换配置步骤 nacos安装目录conf目录下找到sql脚本 新版是mysql-schema.sql，执行脚本（新版需要自建数据库） nacos安装目录conf目录下找到application.properties 添加配置 123456spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=123456 5.2.3、启动启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby 5.2.4、新建配置文件 已经保存进mysql数据库 5.3、Linux版 Nacos+MySQL生产环境配置这个章节一堆坑！！！！！！ 若是三台机器搭建需要每一台都按照如下配置 5.3.1、首先安装好mysqlLinux 安装Mysql 详细教程（图文教程）-CSDN博客 5.3.2、安装jdk（1.8+）Linux 安装JDK详细步骤_linux 安装 jdk_Charge8的博客-CSDN博客 5.3.3、安装NacosRelease 2.2.1 (Mar 17th, 2023) · alibaba&#x2F;nacos · GitHub 5.3.4、Linux服务器上mysql数据库配置SQL脚本在哪里： 复制sql语句执行即可 5.3.5、application.properties 配置 更改数据存放位置： 123456spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=123456 新版的需要修改配置application.properties！！！！！！！！ nacos.core.auth.plugin.nacos.token.secret.key&#x3D; 报错改一下午！！！！ key可以通过以上的类进行生成：[tip](# 2.2、解压安装包，直接运行bin目录下的startup.cmd) 5.3.6、需要更改机器的hostnamehostname -i 查看主机名（不能是127.0.0.1） 如果是，需要修改： vi &#x2F;etc&#x2F;hostname 123直接写名字如：centos01 继续 vi &#x2F;etc&#x2F;hosts 主机映射： 1192.168.131.101(主机实际ip) centos01 然后重启才可以生效 5.3.7、Linux服务器上nacos的集群配置cluster.conf 如果是伪分布集群可以： 这个IP不能写127.0.0.1，必须是Linux命令hostname -i能够识别的IP 真实三台机器： 5.3.8、编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口新版已经自带这个功能了（不是伪分布式和新版的可以跳过） &#x2F;mynacos&#x2F;nacos&#x2F;bin 目录下有startup.sh 平时单机版的启动，都是.&#x2F;startup.sh即可。 但是 集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。命令：.&#x2F;startup.sh -p 3333 表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。 执行方式： 5.3.9、Nginx的配置，由它作为负载均衡器安装好nginx 修改配置文件： 老版： 123456789101112131415161718upstream cluster&#123; server 127.0.0.1:3333; server 127.0.0.1:4444; server 127.0.0.1:5555; &#125; server &#123; listen 1111; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; proxy_pass http://cluster; &#125;.......省略 新版有grpc，需要多以下配置，否则启动报错： 123456789101112# nacos服务器grpc相关地址和端口，需要nginx已经有stream模块stream &#123; upstream nacos-server-grpc &#123; server 192.168.131.101:9848; server 192.168.131.102:9848; server 192.168.131.103:9848; &#125; server &#123; listen 2111; proxy_pass nacos-server-grpc; &#125;&#125; 按照指定启动 5.3.10、截止到此处，1个Nginx+3个nacos注册中心+1个mysql测试通过nginx访问nacos http://192.168.131.101:1111/nacos/#/login 新建一个配置测试： linux服务器的mysql插入一条记录 如果想要三台机器的数据统一，则必须配置同一个数据库 5.3.11、微服务cloudalibaba-provider-payment9002启动注册进nacos集群 5.3.12、高可用小总结 三、SpringCloud Alibab Sentinel实现熔断与限流1、Sentinel1.1、官网https://github.com/alibaba/Sentinel 中文：introduction | Sentinel (sentinelguard.io) 1.2、是什么 一句话解释，之前我们学过的Hystrix 1.3、去哪下https://github.com/alibaba/Sentinel/releases 下载jar包 1.4、能干嘛 1.5、怎么玩https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel 服务使用中的各种问题： 服务雪崩 服务降级 服务熔断 服务限流 2、安装Sentinel控制台2.1、sentinel组件由2部分构成 后台 前台8080 2.2、安装步骤2.2.1、下载https://github.com/alibaba/Sentinel/releases 2.2.2、运行命令前提： java8环境ok 8080端口不能被占用 命令：java -jar sentinel-dashboard-1.8.6.jar 2.2.3、访问sentinel管理界面http://localhost:8080 登录账号密码均为sentinel 3、初始化演示工程3.1、启动Nacos8848成功http://localhost:8848/nacos/#/login 3.2、Module3.2.1、新建cloudalibaba-sentinel-service84013.2.2、改pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-sentinel-service8401&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--openfeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件+actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.6.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.3、改yml文件1234567891011121314151617181920212223server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: #Nacos服务注册中心地址 server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719management: endpoints: web: exposure: include: &#x27;*&#x27; 3.2.4、主启动类123456789101112131415package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401&#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp8401.class, args); &#125;&#125; 3.2.5、controller12345678910111213141516171819202122232425262728package com.lxg.springcloud.controller;import org.springframework.stereotype.Service;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther zzyy * @create 2020-01-09 16:34 */@RestControllerpublic class FlowLimitController&#123; @GetMapping(&quot;/testA&quot;) public String testA() &#123; return &quot;------testA&quot;; &#125; @GetMapping(&quot;/testB&quot;) public String testB() &#123; return &quot;------testB&quot;; &#125;&#125; 3.2.6、启动Sentinel8080java -jar sentinel-dashboard-1.8.6.jar 3.2.7、启动微服务84013.2.8、查看sentinel控制台发现现在空空如也 Sentinel采用的懒加载说明：需要执行访问 执行一次访问即可： http://localhost:8401/testA http://localhost:8401/testB 效果： 结论： sentinel8080正在监控微服务8401 4、流控规则4.1、基础介绍 进一步解释说明： 4.2、流控模式4.2.1、直接（默认）直接-&gt;快速失败：系统默认 配置及说明: 表示1秒钟内查询1次就是OK，若超过次数1，就直接-快速失败，报默认错误 测试: 快速点击访问http://localhost:8401/testA 结果:Blocked by Sentinel (flow limiting) 思考: 直接调用默认报错信息，技术方面OKbut,是否应该有我们自己的后续处理? 类似有个fallback的兜底方法？ 转到其他页面？ 4.2.2、关联模式是什么： 当关联的资源达到阈值时，就限流自己 当与A关联的资源B达到阀值后，就限流A自己 B惹事，A挂了 配置A： 设置效果当关联资源&#x2F;testB的qps阀值超过1时，就限流&#x2F;testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名 postman模拟并发密集访问testB 访问testB成功 postman里新建多线程集合组 将访问地址添加进新新线程组 Run 大批量线程高并发访问B，导致A失效了 运行后发现testA挂了 点击访问http://localhost:8401/testA Blocked by Sentinel (flow limiting) 4.2.3、链路模式多个请求调用了同一个微服务 针对上一级接口进行限流 可以对test1或test2进行限流 Sentinel-限流规则(流控模式：直接、关联、链路)_sentinel 关联 链路_其然乐衣的博客-CSDN博客 被调用的getorder服务达到阈值时，限制&#x2F;order&#x2F;test2,而&#x2F;order&#x2F;test1没事 5、流控效果5.1、直接-&gt;快速失败直接失败，抛出异常：Blocked by Sentinel (flow limiting) 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController 5.2、预热5.2.1、说明：公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值 5.2.2、官网：https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6 默认coldFactor为3，即请求 QPS 从 threshold &#x2F; 3 开始，经预热时长逐渐升至设定的 QPS 阈值。 限流 冷启动：限流 冷启动 · alibaba&#x2F;Sentinel Wiki · GitHub 5.2.3、源码com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController 5.2.4、warmup配置默认 coldFactor 为 3，即请求QPS从(threshold &#x2F; 3) 开始，经多少预热时长才逐渐升至设定的 QPS 阈值。案例，阀值为10+预热时长设置5秒。系统初始化的阀值为10 &#x2F; 3 约等于3,即阀值刚开始为3；然后过了5秒后阀值才慢慢升高恢复到10 多次点击http://localhost:8401/testB 刚开始不行，后续慢慢OK 5.2.5、应用场景如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。 5.3、排队等待匀速排队，阈值必须设置为QPS 5.3.1、官网 流量控制 匀速排队模式 · alibaba&#x2F;Sentinel Wiki · GitHub 5.3.2、源码com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController 5.3.3、测试 6、降级规则6.1、官网、熔断降级 · alibaba&#x2F;Sentinel Wiki · GitHub 6.2、基本介绍旧版： RT（平均响应时间，秒级） 平均响应时间 超出阈值 且 在时间窗口内通过的请求&gt;&#x3D;5，两个条件同时满足后触发降级 窗口期过后关闭断路器 RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效） 异常比列（秒级） QPS &gt;&#x3D; 5 且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级 异常数（分钟级） 异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级 新版 慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。 异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。 异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 6.2.1、进一步说明Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。 当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。 6.2.2、旧版Sentinel的断路器是没有半开状态的：半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。（这样再过窗口期设置时间过才能转到半开状态）具体可以参考Hystrix 复习Hystrix： 6.3、降级策略实战6.3.1、RT（老版）是什么： 测试： 代码： 1234567891011 @GetMapping(&quot;/testD&quot;)public String testD()&#123; //暂停几秒钟线程 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;testD 测试RT&quot;); return &quot;------testD&quot;;&#125; 配置： jmeter压测： 结论： 按照上述配置， 永远一秒钟打进来10个请求（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了 后续我停止jmeter，没有这么大的访问量了，断路器关闭(保险丝恢复)，微服务恢复OK 6.3.2、慢调用比例（新版）1.调用：一个请求发送到服务器，服务器给与响应，一个响应就是一个调用。2.RT：响应时间，指系统对请求作出响应的时间。3.慢调用：当调用的时间（响应的实际时间）&gt;设置的RT的时，这个调用叫做慢调用。4.慢调用比例：在所以调用中，慢调用占有实际的比例，&#x3D; 慢调用次数 &#x2F; 调用次数5.比例阈值：自己设定的 ， 慢调用次数 &#x2F; 调用次数&#x3D;比例阈值 统计时长：时间的判断依据最小请求数：设置的调用最小请求数 进入熔断状态判断依据：当统计时常内，实际请求数目大于最小请求数目，慢调用比例&gt; 比例阈值 ，进入熔断状态 熔断状态：在接下来的熔断时长内请求会自动被熔断 探测恢复状态：熔断时长结束后进入探测恢复状态 结束熔断：在探测恢复状态，如果接下来的一个请求响应时间小于设置的慢调用 RT，则结束熔断否则继续熔断。 sentinel降级策略：慢调用比例_海滩超人的博客-CSDN博客 Sentinel熔断策略-慢调用比例_紫荆之后-的博客-CSDN博客 6.3.3、异常比例是什么： 异常数是按照分钟统计的 测试： 代码： 1234567@GetMapping(&quot;/testException&quot;) public String testException() &#123; log.info(&quot;testD 测试RT&quot;); int age = 10/0; return &quot;------testException&quot;; &#125; 浏览器狂发请求，发现会进入熔断状态 由于每一次都是异常，半开尝试后仍然是异常，就继续熔断 6.3.3、异常数是什么： 异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 测试： 代码： 1234567@GetMapping(&quot;/testExceptionCount&quot;) public String testExceptionCount() &#123; log.info(&quot;testD 测试异常数&quot;); int age = 10/0; return &quot;------testExceptionCount&quot;; &#125; 配置： 10秒内请求数大于5，且这些请求中有5个是异常即会进入熔断状态，等3秒后进入半开状态，如果下一个请求还异常就继续熔断3秒，如果正常就取消熔断，重新判断 7、热点key限流7.1、基本介绍是什么： 何为热点热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作 7.2、官网：热点参数限流 · alibaba&#x2F;Sentinel Wiki (github.com) 7.3、承上启下复习start兜底方法分为系统默认和客户自定义，两种 之前的case，限流出问题后，都是用sentinel系统默认的提示：Blocked by Sentinel (flow limiting) 我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？ 结论 从HystrixCommand 到@SentinelResource 7.4、代码1234567891011121314@GetMapping(&quot;/testHotKey&quot;)@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;dealHandler_testHotKey&quot;)public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1, @RequestParam(value = &quot;p2&quot;,required = false) String p2)&#123; return &quot;------testHotKey&quot;;&#125;public String dealHandler_testHotKey(String p1,String p2,BlockException exception)&#123; return &quot;-----dealHandler_testHotKey&quot;;&#125; //sentinel系统默认的提示：Blocked by Sentinel (flow limiting) com.alibaba.csp.sentinel.slots.block.BlockException 7.5、配置 限流模式只支持QPS模式，固定写死了。（这才叫热点）@SentinelResource注解的方法参数索引，0代表第一个参数，1代表第二个参数，以此类推单机阀值以及统计窗口时长表示在此窗口时间超过阀值就限流。上面的抓图就是第一个参数有值的话，1秒的QPS为1，超过就限流，限流后调用dealHandler_testHotKey支持方法。 @SentinelResource(value &#x3D; “testHotKey”) 异常打到了前台用户界面看到，不友好 @SentinelResource(value &#x3D; “testHotKey”,blockHandler &#x3D; “dealHandler_testHotKey”) 方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理 用了我们自己定义的 7.6、测试error：http://localhost:8401/testHotKey?p1=abc error：http://localhost:8401/testHotKey?p1=abc&amp;p2=33 right：http://localhost:8401/testHotKey?p2=abc 7.7、参数例外项7.7.1、配置 添加按钮不能忘 7.7.2、测试right：http://localhost:8401/testHotKey?p1=5 error：http://localhost:8401/testHotKey?p1=3 当p1等于5的时候，阈值变为200 当p1不等于5的时候，阈值就是平常的1 前提条件：热点参数的注意点，参数必须是基本类型或者String 7.8、其他手贱添加异常看看……&#x2F;(ㄒoㄒ)&#x2F;~~ 12345678910@SentinelResource处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理； RuntimeExceptionint age = 10/0,这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管 总结 @SentinelResource主管配置出错，运行出错该走异常走异常 8、系统规则8.1、是什么系统自适应限流 · alibaba&#x2F;Sentinel Wiki (github.com) 8.2、各项配置参数说明 配置全局QPS 9、@SentinelResource9.1、按资源名称限流+后续处理启动Nacos成功：http://localhost:8848/nacos/#/login 启动Sentinel成功：java -jar sentinel-dashboard-1.8.6.jar 9.1.1、修改cloudalibaba-sentinel-service8401pom：（新增以下内容） 12345&lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; yml不变 controller： 123456789101112131415161718192021222324252627package com.lxg.springcloud.controller;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RateLimitController &#123; @GetMapping(&quot;/byResource&quot;) @SentinelResource(value = &quot;byResource&quot;, blockHandler = &quot;handleException&quot;) public CommonResult byResource() &#123; return new CommonResult(200, &quot;按资源名称限流测试OK&quot;, new Payment(2020L, &quot;serial001&quot;)); &#125; public CommonResult handleException(BlockException exception) &#123; return new CommonResult(444, exception.getClass().getCanonicalName() + &quot;\\t 服务不可用&quot;); &#125; @GetMapping(&quot;/rateLimit/byUrl&quot;) @SentinelResource(value = &quot;byUrl&quot;) public CommonResult byUrl() &#123; return new CommonResult(200, &quot;按url限流测试OK&quot;, new Payment(2020L, &quot;serial002&quot;)); &#125;&#125; 9.1.2、配置规则 图形配置和代码关系 表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流 9.1.3、测试1秒钟点击1下，OK 超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生 9.1.4、额外问题此时关闭问服务8401看看 Sentinel控制台，流控规则消失了？？？？？ 临时&#x2F;持久？ 9.2、按照Url地址限流+后续处理通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息 访问一次http://localhost:8401/rateLimit/byUrl sentinel配置： 测试： 疯狂点击http://localhost:8401/rateLimit/byUrl 9.3、上面兜底方案面临的问题 系统默认的，没有体现我们自己的业务要求。 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。 每个业务方法都添加一个兜底的，那代码膨胀加剧 全局统一的处理方法没有体现。 9.4、客户自定义限流处理逻辑9.4.1、创建CustomerBlockHandler类用于自定义限流处理逻辑1234567891011121314151617181920package com.lxg.springcloud.handler;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.lxg.springcloud.entities.CommonResult;/** * @auther xiaolin * @creatr 2023/3/28 22:10 */public class CustomerBlockHandler &#123; public static CommonResult handleException(BlockException exception) &#123; return new CommonResult(4444, &quot;按客户自定义,global handlerException----1&quot;); &#125; public static CommonResult handleException2(BlockException exception) &#123; return new CommonResult(4444, &quot;按客户自定义,global handlerException----2&quot;); &#125;&#125; 9.4.2、RateLimitController12345678910111213141516/** * 自定义通用的限流处理逻辑， blockHandlerClass = CustomerBlockHandler.class blockHandler = handleException2 上述配置：找CustomerBlockHandler类里的handleException2方法进行兜底处理 */ /** * 自定义通用的限流处理逻辑 */ @GetMapping(&quot;/rateLimit/customerBlockHandler&quot;) @SentinelResource(value = &quot;customerBlockHandler&quot;, blockHandlerClass = CustomerBlockHandler.class, blockHandler = &quot;handleException2&quot;) public CommonResult customerBlockHandler() &#123; return new CommonResult(200,&quot;按客户自定义限流处理逻辑&quot;,new Payment(2020L,&quot;serial003&quot;)); &#125; 9.4.3、启动微服务后先调用一次9.4.4、配置 9.4.5、狂刷 9.4.6、进一步说明 9.5、更多注解属性说明 所有的代码都要用try-catch-finally方式进行处理，o(╥﹏╥)o Sentinel主要有三个核心Api： SphU定义资源 Tracer定义统计 ContextUtil定义了上下文 10、服务熔断功能10.1、sentinel整合ribbon+openFeign+fallback10.2、Ribbon系列10.2.1、启动nacos和sentinel10.2.2、新建9003&#x2F;9004模块新建cloudalibaba-provider-payment9003&#x2F;9004两个一样的做法 1、pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-provider-payment9003&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、application.yml 123456789101112131415161718server: port: 9003/9004spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址management: endpoints: web: exposure: include: &#x27;*&#x27; 3、主启动类 1234567891011121314package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain9004/9003&#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain9004/9003.class, args); &#125;&#125; 4、业务类 12345678910111213141516171819202122232425262728293031package com.lxg.springcloud.controller;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestControllerpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;(); static &#123; hashMap.put(1L, new Payment(1L, &quot;28a8c1e3bc2742d8848569891fb42181&quot;)); hashMap.put(2L, new Payment(2L, &quot;bba8c1e3bc2742d8848569891ac32182&quot;)); hashMap.put(3L, new Payment(3L, &quot;6ua8c1e3bc2742d8848569891xt92183&quot;)); &#125; @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123; Payment payment = hashMap.get(id); CommonResult&lt;Payment&gt; result = new CommonResult(200, &quot;from mysql,serverPort: &quot; + serverPort, payment); return result; &#125;&#125; 5、测试地址 http://localhost:9003/paymentSQL/1 10.2.3、新建消费者84模块新建cloudalibaba-consumer-nacos-order84 1、pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloudalibaba-consumer-nacos-order84&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringCloud ailibaba sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、application.yml 12345678910111213141516171819202122232425server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 filter: enabled: false# web-context-unify: false #关闭将Controller方法做context整合#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)service-url: nacos-user-service: http://nacos-payment-provider 3、主启动类 1234567891011121314package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class OrderNacosMain84&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; 4、业务类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.lxg.springcloud.controller;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;import java.sql.SQLException;import java.util.concurrent.Executors;/** * @auther zzyy * @create 2020-02-13 20:24 */@RestController@Slf4jpublic class CircleBreakerController&#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) // @SentinelResource(value = &quot;fallback&quot;)// @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback负责业务异常// @SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler负责在sentinel里面配置的降级限流 @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot; ,exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;) public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id,CommonResult.class,id); if (id == 4) &#123; throw new IllegalArgumentException (&quot;非法参数异常....&quot;); &#125;else if (result.getData() == null) &#123; throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录&quot;); &#125; return result; &#125; public CommonResult handlerFallback(@PathVariable Long id,Throwable e) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(444,&quot;fallback,无此流水,exception &quot;+e.getMessage(),payment); &#125; public CommonResult blockHandler(@PathVariable Long id,BlockException blockException) &#123; Payment payment = new Payment(id,&quot;null&quot;); return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel限流,无此流水: blockException &quot;+blockException.getMessage(),payment); &#125;&#125; 5、ApplicationContextConfig 123456789101112131415161718package com.lxg.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig&#123; @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 6、修改后重启微服务 热部署对java代码级生效及时 对@SentinelResource注解内属性，有时效果不好 7、目的 fallback管运行异常 blockHandler管配置违规 8、测试地址 http://localhost:84/consumer/fallback/1 9、无任何配置情况 给客户error页面，不友好 10、只配置fallback 本例sentinel无配置 11、只配置blockHandler 本例sentinel需配置： 12、fallback和blockHandler都配置 本例sentinel需配置 13、忽略属性……. 本例sentinel无配置 程序异常打到前台了，对用户不友好 10.3、Feign系列10.3.1、修改84模块84消费者调用提供者9003 Feign组件一般是消费侧 1、pom文件新增 12345&lt;!--SpringCloud openfeign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、yml修改 123456789101112131415161718192021222324252627282930313233343536server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8179 filter: enabled: false# web-context-unify: false #关闭将Controller方法做context整合management: endpoints: web: exposure: include: &#x27;*&#x27;# 激活Sentinel对Feign的支持feign: sentinel: enabled: true#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)#service-url:# nacos-user-service: http://nacos-payment-provider 激活Sentinel对Feign的支持 3、主启动添加注解 123456789@EnableDiscoveryClient@SpringBootApplication@EnableFeignClientspublic class OrderNacosMain84&#123; public static void main(String[] args) &#123; SpringApplication.run(OrderNacosMain84.class, args); &#125;&#125; 添加@EnableFeignClients启动Feign的功能 4、业务类 PaymentService 1234567891011121314151617181920package com.lxg.springcloud.service;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * @auther xiaolin * @creatr 2023/4/4 11:33 */@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)public interface PaymentService &#123; @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);&#125; PaymentFallbackService 12345678910111213141516171819package com.lxg.springcloud.service;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import org.springframework.stereotype.Component;/** * @auther xiaolin * @creatr 2023/4/4 12:25 */@Componentpublic class PaymentFallbackService implements PaymentService&#123; @Override public CommonResult&lt;Payment&gt; paymentSQL(Long id) &#123; return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;)); &#125;&#125; Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.lxg.springcloud.controller;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.lxg.springcloud.entities.CommonResult;import com.lxg.springcloud.entities.Payment;import com.lxg.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;import java.sql.SQLException;import java.util.concurrent.Executors;/** * @auther zzyy * @create 2020-02-13 20:24 */@RestController@Slf4jpublic class CircleBreakerController &#123; public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;; @Resource private RestTemplate restTemplate; @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;) @SentinelResource(value = &quot;fallback&quot;)// @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback负责业务异常// @SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler负责在sentinel里面配置的降级限流// @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;// ,exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;) public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123; CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot; + id, CommonResult.class, id); if (id == 4) &#123; throw new IllegalArgumentException(&quot;非法参数异常....&quot;); &#125; else if (result.getData() == null) &#123; throw new NullPointerException(&quot;NullPointerException,该ID没有对应记录&quot;); &#125; return result; &#125; public CommonResult handlerFallback(@PathVariable Long id, Throwable e) &#123; Payment payment = new Payment(id, &quot;null&quot;); return new CommonResult&lt;&gt;(444, &quot;fallback,无此流水,exception &quot; + e.getMessage(), payment); &#125; public CommonResult blockHandler(@PathVariable Long id, BlockException blockException) &#123; Payment payment = new Payment(id, &quot;null&quot;); return new CommonResult&lt;&gt;(445, &quot;blockHandler-sentinel限流,无此流水: blockException &quot; + blockException.getMessage(), payment); &#125; //==================OpenFeign @Resource private PaymentService paymentService; @GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123; return paymentService.paymentSQL(id); &#125;&#125; 5、访问 http://localhost:84/consumer/paymentSQL/1 测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级，不会被耗死 10.3.2、熔断框架比较 11、规则持久化11.1、是什么一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化 11.2、怎么玩将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效 11.3、步骤11.3.1、修改cloudalibaba-sentinel-service84011、pom文件 12345&lt;!--SpringCloud ailibaba sentinel-datasource-nacos --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt; 2、yml 12345678910111213141516171819202122232425262728293031323334server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: #Nacos服务注册中心地址 server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719# web-context-unify: false #关闭将Controller方法做context整合 datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flowmanagement: endpoints: web: exposure: include: &#x27;*&#x27; 11.3.2、添加Nacos业务规则配置 123456789101112131415161718192021 [ &#123; &quot;resource&quot;: &quot;/rateLimit/byUrl&quot;, &quot;limitApp&quot;: &quot;default&quot;, &quot;grade&quot;: 1, &quot;count&quot;: 1, &quot;strategy&quot;: 0, &quot;controlBehavior&quot;: 0, &quot;clusterMode&quot;: false &#125;] resource：资源名称；limitApp：来源应用；grade：阈值类型，0表示线程数，1表示QPS；count：单机阈值；strategy：流控模式，0表示直接，1表示关联，2表示链路；controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；clusterMode：是否集群。 11.3.3、启动8401后刷新sentinel发现业务规则有了 11.3.4、快速访问测试接口http://localhost:8401/rateLimit/byUrl 11.3.5、停止8401再看sentinel 11.3.6、重新启动8401再看sentinel乍一看还是没有，稍等一会儿 多次调用：http://localhost:8401/rateLimit/byUrl 配置重新出现了，持久化验证通过 四、SpringCloud Alibaba1、分布式事务问题\\1.1、分布式前单机单库没这个问题 从1：1 -&gt; 1：N -&gt; N：N 1.2、分布式之后单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。 一句话：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题 2、Seata简介2.1、是什么Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。 官网地址：http://seata.io/zh-cn/ 2.2、能干嘛一个典型的分布式事务过程： 2.2.1、分布式事务处理过程的一ID+三组件模型： Transaction ID XID：全局唯一的事务ID 3组件概念： Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚 2.2.2、处理过程123451、TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；2、XID 在微服务调用链路的上下文中传播；3、RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；4、TM 向 TC 发起针对 XID 的全局提交或回滚决议；5、TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。 2.3、去哪下发布说明: https://github.com/seata/seata/releases 2.4、怎么玩本地@Transactional 全局@GlobalTransactional SEATA 的分布式交易解决方案： 3、Seata-Server安装3.1、官网地址http://seata.io/zh-cn/ 3.2、下载版本https://github.com/seata/seata/releases 下载的是seata-server-1.6.0.zip 3.3、seata-server-1.6.0.zip解压到指定目录并修改conf目录下的application.yml配置文件先备份application.yml 主要修改：事务日志存储模式为db+数据库连接信息 application.yml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081server: port: 7091spring: application: name: seata-serverlogging: config: classpath:logback-spring.xml file: path: $&#123;user.home&#125;/logs/seata extend: logstash-appender: destination: 127.0.0.1:4560 kafka-appender: bootstrap-servers: 127.0.0.1:9092 topic: logback_to_logstashconsole: user: username: seata password: seataseata: config: # support: nacos, consul, apollo, zk, etcd3 type: file registry: # support: nacos, eureka, redis, zk, consul, etcd3, sofa #type: file type: nacos preferred-networks: 30.240.* nacos: #application: seata-server server-addr: 127.0.0.1:8848 #group: SEATA_GROUP namespace: cluster: default #username: #password: #context-path: ##if use MSE Nacos with auth, mutex with username/password attribute #access-key: &quot;&quot; #secret-key: &quot;&quot; store: # support: file 、 db 、 redis #mode: file mode: db #session: # mode: file #lock: # mode: file file: dir: sessionStore max-branch-session-size: 16384 max-global-session-size: 512 file-write-buffer-cache-size: 16384 session-reload-read-size: 100 flush-disk-mode: async db: datasource: druid db-type: mysql driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true user: root password: 123456 min-conn: 5 max-conn: 100 global-table: global_table branch-table: branch_table lock-table: lock_table distributed-lock-table: distributed_lock query-limit: 100 max-wait: 5000# server:# service-port: 8091 #If not configured, the default is &#x27;$&#123;server.port&#125; + 1000&#x27; security: secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017 tokenValidityInMilliseconds: 1800000 ignore: urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login 3.4、mysql5.7数据库新建库seata3.5、在seata库里建表建表sql在&#x2F;seata&#x2F;script&#x2F;server&#x2F;db&#x2F;mysql.sql 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- -------------------------------- The script used when storeMode is &#x27;db&#x27; ---------------------------------- the table to store GlobalSession dataCREATE TABLE IF NOT EXISTS `global_table`( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store BranchSession dataCREATE TABLE IF NOT EXISTS `branch_table`( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;-- the table to store lock dataCREATE TABLE IF NOT EXISTS `lock_table`( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0:locked ,1:rollbacking&#x27;, `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid` (`xid`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `distributed_lock`( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`)) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4;INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;AsyncCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryRollbacking&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;TxTimeoutCheck&#x27;, &#x27; &#x27;, 0); 3.6、启动nacos端口号8848http://localhost:8848/nacos/ 3.7、启动seata-server双击即可 Seata 3.8、以上配置可参考Seata部署指南 4、订单&#x2F;库存&#x2F;账户业务数据库准备以下演示都需要先启动Nacos后启动Seata，保证两个都OK Seata没启动报错:no available server to connect 4.1、分布式事务业务说明4.1.1、业务说明这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。 当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，最后在订单服务中修改订单状态为已完成。 该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。 下订单—&gt;扣库存—&gt;减账户(余额) 4.2、创建业务数据库seata_order：存储订单的数据库； seata_storage：存储库存的数据库； seata_account：存储账户信息的数据库。 建库SQL： 123456 CREATE DATABASE seata_order; CREATE DATABASE seata_storage; CREATE DATABASE seata_account; 4.3、按照上述3库分别建对应业务表seata_order库下建t_order表： 1234567891011 CREATE TABLE t_order ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `user_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;用户id&#x27;, `product_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;产品id&#x27;, `count` INT(11) DEFAULT NULL COMMENT &#x27;数量&#x27;, `money` DECIMAL(11,0) DEFAULT NULL COMMENT &#x27;金额&#x27;, `status` INT(1) DEFAULT NULL COMMENT &#x27;订单状态：0：创建中；1：已完结&#x27; ) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; SELECT * FROM t_order; seata_storage库下建t_storage 表: 1234567891011121314 CREATE TABLE t_storage ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `product_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;产品id&#x27;, `total` INT(11) DEFAULT NULL COMMENT &#x27;总库存&#x27;, `used` INT(11) DEFAULT NULL COMMENT &#x27;已用库存&#x27;, `residue` INT(11) DEFAULT NULL COMMENT &#x27;剩余库存&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`)VALUES (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;100&#x27;, &#x27;0&#x27;, &#x27;100&#x27;); SELECT * FROM t_storage; seata_account库下建t_account 表: 123456789101112 CREATE TABLE t_account ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;id&#x27;, `user_id` BIGINT(11) DEFAULT NULL COMMENT &#x27;用户id&#x27;, `total` DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;总额度&#x27;, `used` DECIMAL(10,0) DEFAULT NULL COMMENT &#x27;已用余额&#x27;, `residue` DECIMAL(10,0) DEFAULT &#x27;0&#x27; COMMENT &#x27;剩余可用额度&#x27;) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`) VALUES (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;1000&#x27;, &#x27;0&#x27;, &#x27;1000&#x27;); SELECT * FROM t_account; 4.4、按照上述3库分别建对应的回滚日志表订单-库存-账户3个库下都需要建各自的回滚日志表 建表sql：seata&#x2F;script&#x2F;client&#x2F;at&#x2F;db at master · seata&#x2F;seata · GitHub 1234567891011121314-- for AT mode you must to init this sql for you business database. the seata server not need it.CREATE TABLE IF NOT EXISTS `undo_log`( `branch_id` BIGINT NOT NULL COMMENT &#x27;branch transaction id&#x27;, `xid` VARCHAR(128) NOT NULL COMMENT &#x27;global transaction id&#x27;, `context` VARCHAR(128) NOT NULL COMMENT &#x27;undo_log context,such as serialization&#x27;, `rollback_info` LONGBLOB NOT NULL COMMENT &#x27;rollback info&#x27;, `log_status` INT(11) NOT NULL COMMENT &#x27;0:normal status,1:defense status&#x27;, `log_created` DATETIME(6) NOT NULL COMMENT &#x27;create datetime&#x27;, `log_modified` DATETIME(6) NOT NULL COMMENT &#x27;modify datetime&#x27;, UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;AT transaction mode undo table&#x27;; 4.5、最终效果 5、订单&#x2F;库存&#x2F;账户业务微服务准备5.1、业务需求下订单-&gt;减库存-&gt;扣余额-&gt;改(订单)状态 5.2、新建订单seata-order-service20015.2.1、pom1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.lxg.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;seata-order-service2001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--seata--&gt; &lt;!-- 注意一定要引入对版本，要引入spring-cloud版本seata，而不是springboot版本的seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;!-- 排除掉springcloud默认的seata版本，以免版本不一致出现问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 上面排除掉了springcloud默认色seata版本，此处引入和seata-server版本对应的seata包--&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web-actuator--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql-druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--loadbalancer--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5.2.2、yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server: port: 2001spring: application: name: seata-order-service cloud: nacos: discovery: server-addr: localhost:8848 alibaba: seata: tx-service-group: default_tx_group datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_order username: root password: 123456feign: hystrix: enabled: false client: config: default: # 连接超时时间，默认10s，设置单位为毫秒 connectTimeout: 2000 # 请求处理超时时间，默认60s，设置单位为毫秒 readTimeout: 5000 loggerLevel: FULLlogging: level: io: seata: infomybatis: mapper-locations: classpath:mapper/*.xml# seata配置seata: enabled: true # Seata 应用编号，默认为 $&#123;spring.application.name&#125; #application-id: $&#123;spring.application.name&#125; # Seata 事务组编号，用于 TC 集群名 tx-service-group: default_tx_group # 开启自动代理 enable-auto-data-source-proxy: true # 服务配置项 #service: # 虚拟组和分组的映射 # vgroup-mapping: # gulimall-order-group: default #config: # type: nacos #nacos:# serverAddr: 127.0.0.1:8848# group: SEATA_GROUP# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b 5.2.3、file.conf（可能是没有配置nacos配置中心）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140transport &#123; # tcp udt unix-domain-socket type = &quot;TCP&quot; #NIO NATIVE server = &quot;NIO&quot; #enable heartbeat heartbeat = true #thread factory for netty thread-factory &#123; boss-thread-prefix = &quot;NettyBoss&quot; worker-thread-prefix = &quot;NettyServerNIOWorker&quot; server-executor-thread-prefix = &quot;NettyServerBizHandler&quot; share-boss-worker = false client-selector-thread-prefix = &quot;NettyClientSelector&quot; client-selector-thread-size = 1 client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot; # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = &quot;seata&quot; compressor = &quot;none&quot;&#125;service &#123; vgroup_mapping.default_tx_group = &quot;default&quot; #修改自定义事务组名称 default.grouplist = &quot;127.0.0.1:8091&quot; enableDegrade = false disable = false max.commit.retry.timeout = &quot;-1&quot; max.rollback.retry.timeout = &quot;-1&quot; disableGlobalTransaction = false&#125;client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125; report.retry.count = 5 tm.commit.retry.count = 1 tm.rollback.retry.count = 1&#125;## transaction log storestore &#123; ## store mode: file、db mode = &quot;db&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = &quot;dbcp&quot; ## mysql/oracle/h2/oceanbase etc. db-type = &quot;mysql&quot; driver-class-name = &quot;com.mysql.jdbc.Driver&quot; url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot; user = &quot;root&quot; password = &quot;123456&quot; min-conn = 1 max-conn = 3 global.table = &quot;global_table&quot; branch.table = &quot;branch_table&quot; lock-table = &quot;lock_table&quot; query-limit = 100 &#125;&#125;lock &#123; ## the lock store mode: local、remote mode = &quot;remote&quot; local &#123; ## store locks in user&#x27;s database &#125; remote &#123; ## store locks in the seata&#x27;s server &#125;&#125;recovery &#123; #schedule committing retry period in milliseconds committing-retry-period = 1000 #schedule asyn committing retry period in milliseconds asyn-committing-retry-period = 1000 #schedule rollbacking retry period in milliseconds rollbacking-retry-period = 1000 #schedule timeout retry period in milliseconds timeout-retry-period = 1000&#125;transaction &#123; undo.data.validation = true undo.log.serialization = &quot;jackson&quot; undo.log.save.days = 7 #schedule delete expired undo_log in milliseconds undo.log.delete.period = 86400000 undo.log.table = &quot;undo_log&quot;&#125;## metrics settingsmetrics &#123; enabled = false registry-type = &quot;compact&quot; # multi exporters use comma divided exporter-list = &quot;prometheus&quot; exporter-prometheus-port = 9898&#125;support &#123; ## spring spring &#123; # auto proxy the DataSource bean datasource.autoproxy = false &#125;&#125; 5.2.4、registry.conf（可在yml直接配置）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# registry &#123;# # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa# type = &quot;nacos&quot;## nacos &#123;# serverAddr = &quot;localhost:8848&quot;# namespace = &quot;&quot;# cluster = &quot;default&quot;# &#125;# eureka &#123;# serviceUrl = &quot;http://localhost:8761/eureka&quot;# application = &quot;default&quot;# weight = &quot;1&quot;# &#125;# redis &#123;# serverAddr = &quot;localhost:6379&quot;# db = &quot;0&quot;# &#125;# zk &#123;# cluster = &quot;default&quot;# serverAddr = &quot;127.0.0.1:2181&quot;# session.timeout = 6000# connect.timeout = 2000# &#125;# consul &#123;# cluster = &quot;default&quot;# serverAddr = &quot;127.0.0.1:8500&quot;# &#125;# etcd3 &#123;# cluster = &quot;default&quot;# serverAddr = &quot;http://localhost:2379&quot;# &#125;# sofa &#123;# serverAddr = &quot;127.0.0.1:9603&quot;# application = &quot;default&quot;# region = &quot;DEFAULT_ZONE&quot;# datacenter = &quot;DefaultDataCenter&quot;# cluster = &quot;default&quot;# group = &quot;SEATA_GROUP&quot;# addressWaitTime = &quot;3000&quot;# &#125;# file &#123;# name = &quot;file.conf&quot;# &#125;# &#125;## config &#123;# # file、nacos 、apollo、zk、consul、etcd3# type = &quot;file&quot;## nacos &#123;# serverAddr = &quot;localhost&quot;# namespace = &quot;&quot;# &#125;# consul &#123;# serverAddr = &quot;127.0.0.1:8500&quot;# &#125;# apollo &#123;# app.id = &quot;seata-server&quot;# apollo.meta = &quot;http://192.168.1.204:8801&quot;# &#125;# zk &#123;# serverAddr = &quot;127.0.0.1:2181&quot;# session.timeout = 6000# connect.timeout = 2000# &#125;# etcd3 &#123;# serverAddr = &quot;http://localhost:2379&quot;# &#125;# file &#123;# name = &quot;file.conf&quot;# &#125;# &#125;# yml配置 123456 registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b 5.2.5、domain1、CommonResult 1234567891011121314151617181920package com.lxg.springcloud.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; 2、Order 12345678910111213141516171819202122232425262728package com.lxg.springcloud.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.math.BigDecimal;@Data@AllArgsConstructor@NoArgsConstructorpublic class Order&#123; private Long id; private Long userId; private Long productId; private Integer count; private BigDecimal money; /** * 订单状态：0：创建中；1：已完结 */ private Integer status;&#125; 5.2.6、Dao接口1234567891011121314151617181920package com.lxg.springcloud.dao;import com.lxg.springcloud.domain.Order;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;/** * @auther xiaolin * @creatr 2023/4/4 22:00 */@Mapperpublic interface OrderDao &#123; //1、新建订单 void create(Order order); //2、修改订单状态，从0改为1 void update(@Param(&quot;userId&quot;) Long userId,@Param(&quot;status&quot;) Integer status);&#125; OrderMapper: 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.lxg.springcloud.dao.OrderDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lxg.springcloud.domain.Order&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;count&quot; property=&quot;count&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;money&quot; property=&quot;money&quot; jdbcType=&quot;DECIMAL&quot;/&gt; &lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;insert id=&quot;create&quot;&gt; insert into t_order (id,user_id,product_id,count,money,status) values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0); &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; update t_order set status = 1 where user_id = #&#123;userId&#125; and status = #&#123;status&#125;; &lt;/update&gt;&lt;/mapper&gt; 5.2.7、ServiceAccountService接口： 12345678910111213141516171819202122package com.lxg.springcloud.service;import com.lxg.springcloud.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import java.math.BigDecimal;/** * @auther xiaolin * @creatr 2023/4/4 22:14 */@FeignClient(value = &quot;seata-account-service&quot;)public interface AccountService &#123; @PostMapping(value = &quot;/account/decrease&quot;) CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; OrderService： 12345678910111213141516package com.lxg.springcloud.service;import com.lxg.springcloud.domain.Order;/** * @auther xiaolin * @creatr 2023/4/4 22:14 */public interface OrderService &#123; void create(Order order);&#125; StorageService: 123456789101112131415161718192021package com.lxg.springcloud.service;import com.lxg.springcloud.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;/** * @auther xiaolin * @creatr 2023/4/4 22:14 */@FeignClient(value = &quot;seata-storage-service&quot;)public interface StorageService &#123; @PostMapping(value = &quot;/storage/decrease&quot;) CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId,@RequestParam(&quot;count&quot;) Integer count);&#125; OrderServiceImpl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.lxg.springcloud.service.impl;import com.lxg.springcloud.dao.OrderDao;import com.lxg.springcloud.domain.Order;import com.lxg.springcloud.service.AccountService;import com.lxg.springcloud.service.OrderService;import com.lxg.springcloud.service.StorageService;import io.seata.core.context.RootContext;import io.seata.spring.annotation.GlobalTransactional;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/4/4 22:14 */@Service@Slf4jpublic class OrderServiceImpl implements OrderService &#123; @Resource private OrderDao orderDao; @Resource private StorageService storageService; @Resource private AccountService accountService; /** * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态 * 简单说： * 下订单-&gt;减库存-&gt;减余额-&gt;改状态 */ @Override @GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class) public void create(Order order) &#123; log.info(&quot;Seata全局事务id=================&gt;&#123;&#125;&quot;, RootContext.getXID()); log.info(&quot;---&gt;开始新建订单&quot;); //1、新建订单 orderDao.create(order); log.info(&quot;---&gt;订单微服务开始调用库存，做扣减count&quot;); //2、扣减库存 storageService.decrease(order.getProductId(),order.getCount()); log.info(&quot;---&gt;订单微服务开始调用库存，做扣减end&quot;); //3、扣减账户 log.info(&quot;---&gt;订单微服务开始调用账号，做扣减money&quot;); accountService.decrease(order.getUserId(),order.getMoney()); log.info(&quot;---&gt;订单微服务开始调用账号，做扣减end&quot;); //4、修改订单状态，从0-&gt;1,1代表已经完成 log.info(&quot;---&gt;修改订单状态开始&quot;); orderDao.update(order.getUserId(),0); log.info(&quot;---&gt;修改订单状态结束&quot;); log.info(&quot;下订单结束了，O(∩_∩)O哈哈~&quot;); &#125;&#125; 5.2.8、controller12345678910111213141516171819202122232425262728293031package com.lxg.springcloud.controller;import com.lxg.springcloud.domain.CommonResult;import com.lxg.springcloud.domain.Order;import com.lxg.springcloud.service.OrderService;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @auther xiaolin * @creatr 2023/4/4 22:30 */@RestControllerpublic class OrderController &#123; @Resource private OrderService orderService; @GetMapping(&quot;/order/create&quot;) public CommonResult create(Order order)&#123; orderService.create(order); return new CommonResult(200,&quot;订单创建成功！&quot;); &#125;&#125; 5.2.9、configMyBatisConfig 123456789package com.lxg.springcloud.config;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&#123;&quot;com.lxg.springcloud.dao&quot;&#125;)public class MyBatisConfig &#123;&#125; DataSourceProxyConfig：新版配置就启动报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lxg.springcloud.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;//@Configurationpublic class DataSourceProxyConfig &#123; @Value(&quot;$&#123;mybatis.mapper-locations&#125;&quot;) private String mapperLocations; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 5.2.10、主启动类12345678910111213141516171819202122package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;/** * @auther xiaolin * @creatr 2023/4/4 22:35 */@EnableFeignClients@EnableDiscoveryClient//@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@SpringBootApplicationpublic class SeataOrderMainApp2001 &#123; public static void main(String[] args) &#123; SpringApplication.run(SeataOrderMainApp2001.class,args); &#125;&#125; 如果数据源配置有效就要@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class) 5.3、seata-order-service20015.3.1、pom文件与以上模块一致 5.3.2、yml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859server: port: 2002spring: application: name: seata-storage-service cloud: nacos: discovery: server-addr: localhost:8848 alibaba: seata: tx-service-group: default_tx_group datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_storage username: root password: 123456feign: hystrix: enabled: falselogging: level: io: seata: infomybatis: mapper-locations: classpath:mapper/*.xml# seata配置seata: enabled: true # Seata 应用编号，默认为 $&#123;spring.application.name&#125; #application-id: $&#123;spring.application.name&#125; # Seata 事务组编号，用于 TC 集群名 tx-service-group: default_tx_group # 开启自动代理 enable-auto-data-source-proxy: true # 服务配置项 #service: # 虚拟组和分组的映射 # vgroup-mapping: # gulimall-order-group: default #config: # type: nacos #nacos: # serverAddr: 127.0.0.1:8848 # group: SEATA_GROUP # namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848 cluster: &quot;default&quot;# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b 5.3.3、domain1234567891011121314151617181920package com.lxg.springcloud.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.lxg.springcloud.domain;import lombok.Data;/** * @auther xiaolin * @creatr 2023/4/4 23:54 */@Datapublic class Storage &#123; private Long id; /** * 产品id */ private Long productId; /** * 总库存 */ private Integer total; /** * 已用库存 */ private Integer used; /** * 剩余库存 */ private Integer residue;&#125; 5.3.4、dao1234567891011121314151617package com.lxg.springcloud.dao;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;/** * @auther xiaolin * @creatr 2023/4/4 23:55 */@Mapperpublic interface StorageDao &#123; /** * 扣减库存 */ void decrease(@Param(&quot;productId&quot;) Long productId, @Param(&quot;count&quot;) Integer count);&#125; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.lxg.springcloud.dao.StorageDao&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lxg.springcloud.domain.Storage&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;result column=&quot;total&quot; property=&quot;total&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;used&quot; property=&quot;used&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;residue&quot; property=&quot;residue&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;decrease&quot;&gt; UPDATE t_storage SET used = used + #&#123;count&#125;, residue = residue - #&#123;count&#125; WHERE product_id = #&#123;productId&#125; &lt;/update&gt;&lt;/mapper&gt; 5.3.5、service12345678package com.lxg.springcloud.service;public interface StorageService &#123; /** * 扣减库存 */ void decrease(Long productId, Integer count);&#125; 1234567891011121314151617181920212223242526272829303132package com.lxg.springcloud.service.Impl;import com.lxg.springcloud.dao.StorageDao;import com.lxg.springcloud.service.StorageService;import io.seata.core.context.RootContext;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service@Slf4jpublic class StorageServiceImpl implements StorageService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class); @Resource private StorageDao storageDao; /** * 扣减库存 */ @Override public void decrease(Long productId, Integer count) &#123; log.info(&quot;Seata全局事务id=================&gt;&#123;&#125;&quot;,RootContext.getXID()); LOGGER.info(&quot;-------&gt;storage-service中扣减库存开始&quot;); storageDao.decrease(productId,count); LOGGER.info(&quot;-------&gt;storage-service中扣减库存结束&quot;); &#125;&#125; 5.3.6、controller1234567891011121314151617181920212223package com.lxg.springcloud.controller;import com.lxg.springcloud.domain.CommonResult;import com.lxg.springcloud.service.StorageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class StorageController &#123; @Autowired private StorageService storageService; /** * 扣减库存 */ @RequestMapping(&quot;/storage/decrease&quot;) public CommonResult decrease(Long productId, Integer count) &#123; storageService.decrease(productId, count); return new CommonResult(200,&quot;扣减库存成功！&quot;); &#125;&#125; 5.3.7、file.conf与上模块一致 5.3.8、registry.conf与上模块一致 5.3.9、config与上模块一致 5.3.10、主启动类12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;//@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableDiscoveryClient@EnableFeignClients@SpringBootApplicationpublic class SeataStorageServiceApplication2002 &#123; public static void main(String[] args) &#123; SpringApplication.run(SeataStorageServiceApplication2002.class, args); &#125;&#125; 5.4、seata-account-service20035.4.1、pom与以上一致 5.4.2、yml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758server: port: 2003spring: application: name: seata-account-service cloud: nacos: discovery: server-addr: localhost:8848 alibaba: seata: tx-service-group: default_tx_group datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_account username: root password: 123456feign: hystrix: enabled: falselogging: level: io: seata: infomybatis: mapper-locations: classpath:mapper/*.xml# seata配置seata: enabled: true # Seata 应用编号，默认为 $&#123;spring.application.name&#125; #application-id: $&#123;spring.application.name&#125; # Seata 事务组编号，用于 TC 集群名 tx-service-group: default_tx_group # 开启自动代理 enable-auto-data-source-proxy: true # 服务配置项 #service: # 虚拟组和分组的映射 # vgroup-mapping: # gulimall-order-group: default #config: # type: nacos #nacos:# serverAddr: 127.0.0.1:8848# group: SEATA_GROUP# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848# namespace: 86ab3ca5-81db-4efb-ae22-7b4a2980a96b 5.4.3、domain1234567891011121314151617181920212223242526272829303132333435package com.lxg.springcloud.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.math.BigDecimal;@Data@AllArgsConstructor@NoArgsConstructorpublic class Account &#123; private Long id; /** * 用户id */ private Long userId; /** * 总额度 */ private BigDecimal total; /** * 已用额度 */ private BigDecimal used; /** * 剩余额度 */ private BigDecimal residue;&#125; 1234567891011121314151617181920package com.lxg.springcloud.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt;&#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code,message,null); &#125;&#125; 5.4.4、file.conf与以上一致 5.4.5、registry.conf与以上一致 5.4.6、dao123456789101112131415package com.lxg.springcloud.dao;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import java.math.BigDecimal;@Mapperpublic interface AccountDao &#123; /** * 扣减账户余额 */ void decrease(@Param(&quot;userId&quot;) Long userId, @Param(&quot;money&quot;) BigDecimal money);&#125; 5.4.7、service123456789101112131415package com.lxg.springcloud.service;import org.springframework.web.bind.annotation.RequestParam;import java.math.BigDecimal;public interface AccountService &#123; /** * 扣减账户余额 * @param userId 用户id * @param money 金额 */ void decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.springcloud.service.impl;import com.lxg.springcloud.dao.AccountDao;import com.lxg.springcloud.service.AccountService;import io.seata.core.context.RootContext;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.math.BigDecimal;import java.util.concurrent.TimeUnit;@Service@Slf4jpublic class AccountServiceImpl implements AccountService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl.class); @Resource AccountDao accountDao; /** * 扣减账户余额 */ @Override public void decrease(Long userId, BigDecimal money) &#123; log.info(&quot;Seata全局事务id=================&gt;&#123;&#125;&quot;, RootContext.getXID()); LOGGER.info(&quot;-------&gt;account-service中扣减账户余额开始&quot;); //模拟超时异常，全局事务回滚 //暂停几秒钟线程 try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; accountDao.decrease(userId,money); LOGGER.info(&quot;-------&gt;account-service中扣减账户余额结束&quot;); &#125;&#125; 5.4.8、controller1234567891011121314151617181920212223242526package com.lxg.springcloud.controller;import com.lxg.springcloud.domain.CommonResult;import com.lxg.springcloud.service.AccountService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.math.BigDecimal;@RestControllerpublic class AccountController &#123; @Resource AccountService accountService; /** * 扣减账户余额 */ @RequestMapping(&quot;/account/decrease&quot;) public CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money)&#123; accountService.decrease(userId,money); return new CommonResult(200,&quot;扣减账户余额成功！&quot;); &#125;&#125; 5.4.9、config与以上一致 5.4.10、主启动类12345678910111213141516171819package com.lxg.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;//@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)@EnableDiscoveryClient@EnableFeignClients@SpringBootApplicationpublic class SeataAccountMainApp2003&#123; public static void main(String[] args) &#123; SpringApplication.run(SeataAccountMainApp2003.class, args); &#125;&#125; 6、Test下订单-&gt;减库存-&gt;扣余额-&gt;改(订单)状态 数据库初始情况： 6.1、正常下单http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100 数据库情况： 6.2、超时异常，没加@GlobalTransactionalhttp://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100 AccountServiceImpl添加超时 故障情况： 当库存和账户金额扣减后，订单状态并没有设置为已经完成，没有从零改为1 而且由于feign的重试机制，账户余额还有可能被多次扣减 6.3、超时异常，添加@GlobalTransactionalAccountServiceImpl添加超时 OrderServiceImpl@GlobalTransactional 12345@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)public void create(Order order)&#123;。。。。。。&#125; 下单后数据库数据并没有任何改变 记录都添加不进来 7、一部分补充7.1、Seata2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案 Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架 2020起始，参加工作后用1.0以后的版本 7.2、再看TC&#x2F;TM&#x2F;RM三大组件 分布式事务的执行流程： TM 开启分布式事务（TM 向 TC 注册全局事务记录）； 按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）； TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交&#x2F;回滚分布式事务）； TC 汇总事务信息，决定分布式事务是提交还是回滚； TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。 7.3、AT模式如何做到对业务的无侵入7.3.1、是什么 7.3.2、一阶段加载在一阶段，Seata 会拦截“业务 SQL”，1 解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，2 执行“业务 SQL”更新业务数据，在业务数据更新之后，3 其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。 7.3.3、二阶段提交二阶段如是顺利提交的话，因为“业务 SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。 7.3.4、二阶段回滚二阶段回滚：二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。 7.4、自己debug会发现seata数据库的表数据和undo.log表的数据有变化 7.5、补充 具体其他内容可以阅读官网文档： Seata 是什么","tags":"springcloud"},{"title":"SpringBoot-02","url":"/2023/10/12/springboot02/","text":"tags:45、web实验-抽取公共页面官方文档 - Template Layout 公共页面/templates/common.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;!--注意要添加xmlns:th才能添加thymeleaf的标签--&gt;&lt;head th:fragment=&quot;commonheader&quot;&gt; &lt;!--common--&gt; &lt;link href=&quot;css/style.css&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;css/style-responsive.css&quot; th:href=&quot;@&#123;/css/style-responsive.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; ...&lt;/head&gt;&lt;body&gt;&lt;!-- left side start--&gt;&lt;div id=&quot;leftmenu&quot; class=&quot;left-side sticky-left-side&quot;&gt; ... &lt;div class=&quot;left-side-inner&quot;&gt; ... &lt;!--sidebar nav start--&gt; &lt;ul class=&quot;nav nav-pills nav-stacked custom-nav&quot;&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/main.html&#125;&quot;&gt;&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; &lt;span&gt;Dashboard&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; ... &lt;li class=&quot;menu-list nav-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-th-list&quot;&gt;&lt;/i&gt; &lt;span&gt;Data Tables&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;sub-menu-list&quot;&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/basic_table&#125;&quot;&gt; Basic Table&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/dynamic_table&#125;&quot;&gt; Advanced Table&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/responsive_table&#125;&quot;&gt; Responsive Table&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;/editable_table&#125;&quot;&gt; Edit Table&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; ... &lt;/ul&gt; &lt;!--sidebar nav end--&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- left side end--&gt;&lt;!-- header section start--&gt;&lt;div th:fragment=&quot;headermenu&quot; class=&quot;header-section&quot;&gt; &lt;!--toggle button start--&gt; &lt;a class=&quot;toggle-btn&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;!--toggle button end--&gt; ...&lt;/div&gt;&lt;!-- header section end--&gt;&lt;div id=&quot;commonscript&quot;&gt; &lt;!-- Placed js at the end of the document so the pages load faster --&gt; &lt;script th:src=&quot;@&#123;/js/jquery-1.10.2.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/jquery-ui-1.9.2.custom.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/jquery-migrate-1.2.1.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/bootstrap.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/modernizr.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/js/jquery.nicescroll.js&#125;&quot;&gt;&lt;/script&gt; &lt;!--common scripts for all pages--&gt; &lt;script th:src=&quot;@&#123;/js/scripts.js&#125;&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /templates/table/basic_table.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;ThemeBucket&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;#&quot; type=&quot;image/png&quot;&gt; &lt;title&gt;Basic Table&lt;/title&gt; &lt;div th:include=&quot;common :: commonheader&quot;&gt; &lt;/div&gt;&lt;!--将common.html的代码段 插进来--&gt;&lt;/head&gt;&lt;body class=&quot;sticky-header&quot;&gt;&lt;section&gt;&lt;div th:replace=&quot;common :: #leftmenu&quot;&gt;&lt;/div&gt; &lt;!-- main content start--&gt; &lt;div class=&quot;main-content&quot; &gt; &lt;div th:replace=&quot;common :: headermenu&quot;&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;!-- main content end--&gt;&lt;/section&gt;&lt;!-- Placed js at the end of the document so the pages load faster --&gt;&lt;div th:replace=&quot;common :: #commonscript&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Difference between th:insert and th:replace (and th:include) 46、web实验-遍历数据与页面bug修改控制层代码： 1234567891011@GetMapping(&quot;/dynamic_table&quot;)public String dynamic_table(Model model)&#123; //表格内容的遍历 List&lt;User&gt; users = Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;), new User(&quot;lisi&quot;, &quot;123444&quot;), new User(&quot;haha&quot;, &quot;aaaaa&quot;), new User(&quot;hehe &quot;, &quot;aaddd&quot;)); model.addAttribute(&quot;users&quot;,users); return &quot;table/dynamic_table&quot;;&#125; 页面代码： 12345678910111213141516&lt;table class=&quot;display table table-bordered&quot; id=&quot;hidden-table-info&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,stats:$&#123;users&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;stats.count&#125;&quot;&gt;Trident&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;Internet&lt;/td&gt; &lt;td &gt;[[$&#123;user.password&#125;]]&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 47、视图解析-【源码分析】-视图解析器与视图视图解析原理流程： 目标方法处理的过程中（阅读DispatcherServlet源码），所有数据都会被放在 ModelAndViewContainer 里面，其中包括数据和视图地址。 方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer 。 任何目标方法执行完成以后都会返回ModelAndView（数据和视图地址）。 processDispatchResult()处理派发结果（页面改如何响应） render(mv, request, response); 进行页面渲染逻辑 根据方法的String返回值得到 View 对象【定义了页面的渲染逻辑】 所有的视图解析器尝试是否能根据当前返回值得到View对象 得到了 redirect:/main.html --&gt; Thymeleaf new RedirectView()。 ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。 view.render(mv.getModelInternal(), request, response); 视图对象调用自定义的render进行页面渲染工作。 RedirectView 如何渲染【重定向到一个页面】 获取目标url地址 response.sendRedirect(encodedURL); 视图解析： - 返回值以 forward: 开始： new InternalResourceView(forwardUrl); –&gt; 转发request.getRequestDispatcher(path).forward(request, response); - 返回值以 redirect: 开始： new RedirectView() –&gt; render就是重定向 - 返回值是普通字符串：new ThymeleafView()—&gt; 阅读源码：最好自己在IDE，打断点，且Debug模式运行实例，这样比较没那么沉闷。 48、拦截器-登录检查与静态资源放行 编写一个拦截器实现HandlerInterceptor接口 拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors()） 指定拦截规则（注意，如果是拦截所有，静态资源也会被拦截】 编写一个实现HandlerInterceptor接口的拦截器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Slf4jpublic class LoginInterceptor implements HandlerInterceptor &#123; /** * 目标方法执行之前 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestURI = request.getRequestURI(); log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI); //登录检查逻辑 HttpSession session = request.getSession(); Object loginUser = session.getAttribute(&quot;loginUser&quot;); if(loginUser != null)&#123; //放行 return true; &#125; //拦截住。未登录。跳转到登录页 request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);// re.sendRedirect(&quot;/&quot;); request.getRequestDispatcher(&quot;/&quot;).forward(request,response); return false; &#125; /** * 目标方法执行完成以后 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView); &#125; /** * 页面渲染以后 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex); &#125;&#125; 拦截器注册到容器中 &amp;&amp; 指定拦截规则： 123456789@Configurationpublic class AdminWebConfig implements WebMvcConfigurer&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor())//拦截器注册到容器中 .addPathPatterns(&quot;/**&quot;) //所有请求都被拦截包括静态资源 .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;, &quot;/js/**&quot;,&quot;/aa/**&quot;); //放行的请求&#125; 49、拦截器-【源码分析】-拦截器的执行时机和原理 根据当前请求，找到HandlerExecutionChain（可以处理请求的handler以及handler的所有 拦截器） 先来顺序执行 所有拦截器的 preHandle()方法。 如果当前拦截器preHandle()返回为true。则执行下一个拦截器的preHandle() 如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的 afterCompletion();。 如果任何一个拦截器返回false，直接跳出不执行目标方法。 所有拦截器都返回true，才执行目标方法。 倒序执行所有拦截器的postHandle()方法。 前面的步骤有任何异常都会直接倒序触发 afterCompletion()。 页面成功渲染完成以后，也会倒序触发 afterCompletion()。 DispatcherServlet中涉及到HandlerInterceptor的地方： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DispatcherServlet extends FrameworkServlet &#123; ... protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; ... //该方法内调用HandlerInterceptor的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... //该方法内调用HandlerInterceptor的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; //该方法内调用HandlerInterceptor接口的afterCompletion方法 triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; //该方法内调用HandlerInterceptor接口的afterCompletion方法 triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; ... &#125; &#125; private void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, Exception ex) throws Exception &#123; if (mappedHandler != null) &#123; //该方法内调用HandlerInterceptor接口的afterCompletion方法 mappedHandler.triggerAfterCompletion(request, response, ex); &#125; throw ex; &#125; private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; ... if (mappedHandler != null) &#123; //该方法内调用HandlerInterceptor接口的afterCompletion方法 // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HandlerExecutionChain &#123; ... boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; for (int i = 0; i &lt; this.interceptorList.size(); i++) &#123; HandlerInterceptor interceptor = this.interceptorList.get(i); //HandlerInterceptor的preHandle方法 if (!interceptor.preHandle(request, response, this.handler)) &#123; triggerAfterCompletion(request, response, null); return false; &#125; this.interceptorIndex = i; &#125; return true; &#125; void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123; for (int i = this.interceptorList.size() - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = this.interceptorList.get(i); //HandlerInterceptor接口的postHandle方法 interceptor.postHandle(request, response, this.handler, mv); &#125; &#125; void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) &#123; for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = this.interceptorList.get(i); try &#123; //HandlerInterceptor接口的afterCompletion方法 interceptor.afterCompletion(request, response, this.handler, ex); &#125; catch (Throwable ex2) &#123; logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2); &#125; &#125; &#125; &#125; 50、文件上传-单文件与多文件上传的使用 页面代码/static/form/form_layouts.html 12345678910111213141516171819202122232425262728&lt;form role=&quot;form&quot; th:action=&quot;@&#123;/upload&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot;&gt;邮箱&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; placeholder=&quot;Enter email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;名字&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;头像&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;headerImg&quot; id=&quot;exampleInputFile&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputFile&quot;&gt;生活照&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;photos&quot; multiple&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 控制层代码 12345678910111213141516171819202122232425262728293031323334353637@Slf4j@Controllerpublic class FormTestController &#123; @GetMapping(&quot;/form_layouts&quot;) public String form_layouts()&#123; return &quot;form/form_layouts&quot;; &#125; @PostMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;email&quot;) String email, @RequestParam(&quot;username&quot;) String username, @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123; log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;, email,username,headerImg.getSize(),photos.length); if(!headerImg.isEmpty())&#123; //保存到文件服务器，OSS服务器 String originalFilename = headerImg.getOriginalFilename(); headerImg.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; if(photos.length &gt; 0)&#123; for (MultipartFile photo : photos) &#123; if(!photo.isEmpty())&#123; String originalFilename = photo.getOriginalFilename(); photo.transferTo(new File(&quot;H:\\\\cache\\\\&quot;+originalFilename)); &#125; &#125; &#125; return &quot;main&quot;; &#125;&#125; 文件上传相关的配置类： org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration org.springframework.boot.autoconfigure.web.servlet.MultipartProperties 文件大小相关配置项： 12spring.servlet.multipart.max-file-size=10MBspring.servlet.multipart.max-request-size=100MB 51、文件上传-【源码流程】文件上传参数解析器文件上传相关的自动配置类MultipartAutoConfiguration有创建文件上传参数解析器StandardServletMultipartResolver。 1234567891011121314151617181920212223242526272829@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class &#125;)@ConditionalOnProperty(prefix = &quot;spring.servlet.multipart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(MultipartProperties.class)public class MultipartAutoConfiguration &#123; private final MultipartProperties multipartProperties; public MultipartAutoConfiguration(MultipartProperties multipartProperties) &#123; this.multipartProperties = multipartProperties; &#125; @Bean @ConditionalOnMissingBean(&#123; MultipartConfigElement.class, CommonsMultipartResolver.class &#125;) public MultipartConfigElement multipartConfigElement() &#123; return this.multipartProperties.createMultipartConfig(); &#125; @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) @ConditionalOnMissingBean(MultipartResolver.class) public StandardServletMultipartResolver multipartResolver() &#123; //配置好文件上传解析器 StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver(); multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily()); return multipartResolver; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//文件上传解析器public class StandardServletMultipartResolver implements MultipartResolver &#123; private boolean resolveLazily = false; public void setResolveLazily(boolean resolveLazily) &#123; this.resolveLazily = resolveLazily; &#125; @Override public boolean isMultipart(HttpServletRequest request) &#123; return StringUtils.startsWithIgnoreCase(request.getContentType(), &quot;multipart/&quot;); &#125; @Override public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException &#123; return new StandardMultipartHttpServletRequest(request, this.resolveLazily); &#125; @Override public void cleanupMultipart(MultipartHttpServletRequest request) &#123; if (!(request instanceof AbstractMultipartHttpServletRequest) || ((AbstractMultipartHttpServletRequest) request).isResolved()) &#123; // To be on the safe side: explicitly delete the parts, // but only actual file parts (for Resin compatibility) try &#123; for (Part part : request.getParts()) &#123; if (request.getFile(part.getName()) != null) &#123; part.delete(); &#125; &#125; &#125; catch (Throwable ex) &#123; LogFactory.getLog(getClass()).warn(&quot;Failed to perform cleanup of multipart items&quot;, ex); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DispatcherServlet extends FrameworkServlet &#123; @Nullable private MultipartResolver multipartResolver; private void initMultipartResolver(ApplicationContext context) &#123; ... //这个就是配置类配置的StandardServletMultipartResolver文件上传解析器 this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class); ... &#125; protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false;//最后finally的回收flag ... try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //做预处理,如果有上传文件 就new StandardMultipartHttpServletRequest包装类 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); ... // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); ... // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); &#125; .... finally &#123; ... if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException &#123; if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request)) &#123; ... return this.multipartResolver.resolveMultipart(request); ... &#125; &#125; protected void cleanupMultipart(HttpServletRequest request) &#123; if (this.multipartResolver != null) &#123; MultipartHttpServletRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class); if (multipartRequest != null) &#123; this.multipartResolver.cleanupMultipart(multipartRequest); &#125; &#125; &#125;&#125; mv = ha.handle(processedRequest, response, mappedHandler.getHandler());跳到以下的类 12345678910111213141516171819202122232425262728293031323334353637public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; @Override protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; ... mav = invokeHandlerMethod(request, response, handlerMethod); ... return mav; &#125; @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123;//关注点 invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; ... invocableMethod.invokeAndHandle(webRequest, mavContainer); ... return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125; &#125; &#125; this.argumentResolvers其中主角类RequestPartMethodArgumentResolver用来生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123; ... public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); ... &#125; @Nullable public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); ... return doInvoke(args);//反射调用 &#125; @Nullable protected Object doInvoke(Object... args) throws Exception &#123; Method method = getBridgedMethod(); ReflectionUtils.makeAccessible(method); return method.invoke(getBean(), args); ... &#125; //处理得出multipart参数，准备稍后的反射调用（@PostMapping标记的上传方法） protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; MethodParameter[] parameters = getMethodParameters(); ... Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; //关注点1 if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; //关注点2 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; ... &#125; &#125; return args; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RequestPartMethodArgumentResolver extends AbstractMessageConverterMethodArgumentResolver &#123; //对应上面代码关注点1 @Override public boolean supportsParameter(MethodParameter parameter) &#123; //标注@RequestPart的参数 if (parameter.hasParameterAnnotation(RequestPart.class)) &#123; return true; &#125; else &#123; if (parameter.hasParameterAnnotation(RequestParam.class)) &#123; return false; &#125; return MultipartResolutionDelegate.isMultipartArgument(parameter.nestedIfOptional()); &#125; &#125; //对应上面代码关注点2 @Override @Nullable public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest request, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class); Assert.state(servletRequest != null, &quot;No HttpServletRequest&quot;); RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class); boolean isRequired = ((requestPart == null || requestPart.required()) &amp;&amp; !parameter.isOptional()); String name = getPartName(parameter, requestPart); parameter = parameter.nestedIfOptional(); Object arg = null; //封装成MultipartFile类型的对象作参数 Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest); if (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123; arg = mpArg; &#125; ... return adaptArgumentIfNecessary(arg, parameter); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public final class MultipartResolutionDelegate &#123; ... @Nullable public static Object resolveMultipartArgument(String name, MethodParameter parameter, HttpServletRequest request) throws Exception &#123; MultipartHttpServletRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class); boolean isMultipart = (multipartRequest != null || isMultipartContent(request)); if (MultipartFile.class == parameter.getNestedParameterType()) &#123; if (!isMultipart) &#123; return null; &#125; if (multipartRequest == null) &#123; multipartRequest = new StandardMultipartHttpServletRequest(request); &#125; return multipartRequest.getFile(name); &#125; else if (isMultipartFileCollection(parameter)) &#123; if (!isMultipart) &#123; return null; &#125; if (multipartRequest == null) &#123; multipartRequest = new StandardMultipartHttpServletRequest(request); &#125; List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name); return (!files.isEmpty() ? files : null); &#125; else if (isMultipartFileArray(parameter)) &#123; if (!isMultipart) &#123; return null; &#125; if (multipartRequest == null) &#123; multipartRequest = new StandardMultipartHttpServletRequest(request); &#125; List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name); return (!files.isEmpty() ? files.toArray(new MultipartFile[0]) : null); &#125; else if (Part.class == parameter.getNestedParameterType()) &#123; if (!isMultipart) &#123; return null; &#125; return request.getPart(name); &#125; else if (isPartCollection(parameter)) &#123; if (!isMultipart) &#123; return null; &#125; List&lt;Part&gt; parts = resolvePartList(request, name); return (!parts.isEmpty() ? parts : null); &#125; else if (isPartArray(parameter)) &#123; if (!isMultipart) &#123; return null; &#125; List&lt;Part&gt; parts = resolvePartList(request, name); return (!parts.isEmpty() ? parts.toArray(new Part[0]) : null); &#125; else &#123; return UNRESOLVABLE; &#125; &#125; ... &#125; 52、错误处理-SpringBoot默认错误处理机制Spring Boot官方文档 - Error Handling 默认规则： 默认情况下，Spring Boot提供/error处理所有错误的映射 机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据 1234567&#123; &quot;timestamp&quot;: &quot;2020-11-22T05:53:28.416+00:00&quot;, &quot;status&quot;: 404, &quot;error&quot;: &quot;Not Found&quot;, &quot;message&quot;: &quot;No message available&quot;, &quot;path&quot;: &quot;/asadada&quot;&#125; 要对其进行自定义，添加View解析为error 要完全替换默认行为，可以实现 ErrorController 并注册该类型的Bean定义，或添加ErrorAttributes类型的组件以使用现有机制但替换其内容。 /templates/error/下的4xx，5xx页面会被自动解析 53、错误处理-【源码分析】底层组件功能分析 ErrorMvcAutoConfiguration 自动配置异常处理规则 容器中的组件：类型：DefaultErrorAttributes -&gt; id：errorAttributes public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver DefaultErrorAttributes：定义错误页面中可以包含数据（异常明细，堆栈信息等）。 容器中的组件：类型：BasicErrorController –&gt; id：basicErrorController（json+白页 适配响应） 处理默认 /error 路径的请求，页面响应 new ModelAndView(&quot;error&quot;, model); 容器中有组件 View-&gt;id是error；（响应默认错误页） 容器中放组件 BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。 容器中的组件：类型：DefaultErrorViewResolver -&gt; id：conventionErrorViewResolver 如果发生异常错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面（主要作用）。 error&#x2F;404、5xx.html 如果想要返回页面，就会找error视图（StaticView默认是一个白页）。 54、错误处理-【源码流程】异常处理流程譬如写一个会抛出异常的控制层： 12345678910111213@Slf4j@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01()&#123; int i = 1 / 0;//将会抛出ArithmeticException log.info(&quot;Hello, Spring Boot 2!&quot;); return &quot;Hello, Spring Boot 2!&quot;; &#125;&#125; 当浏览器发出/hello请求，DispatcherServlet的doDispatch()的mv = ha.handle(processedRequest, response, mappedHandler.getHandler());将会抛出ArithmeticException。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class DispatcherServlet extends FrameworkServlet &#123; ... protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... // Actually invoke the handler. //将会抛出ArithmeticException mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; //将会捕捉ArithmeticException dispatchException = ex; &#125; catch (Throwable err) &#123; ... &#125; //捕捉后，继续运行 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; ... &#125; &#125; private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; ... &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); //ArithmeticException将在这处理 mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; ... &#125; protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception &#123; // Success and error responses may use different content types request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE); // Check registered HandlerExceptionResolvers... ModelAndView exMv = null; if (this.handlerExceptionResolvers != null) &#123; //遍历所有的 handlerExceptionResolvers，看谁能处理当前异常HandlerExceptionResolver处理器异常解析器 for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) &#123; exMv = resolver.resolveException(request, response, handler, ex); if (exMv != null) &#123; break; &#125; &#125; &#125; ... //若只有系统的自带的异常解析器（没有自定义的），异常还是会抛出 throw ex; &#125;&#125; 系统自带的异常解析器： DefaultErrorAttributes先来处理异常，它主要功能把异常信息保存到request域，并且返回null。 12345678910111213public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123; ... public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; this.storeErrorAttributes(request, ex); return null; &#125; private void storeErrorAttributes(HttpServletRequest request, Exception ex) &#123; request.setAttribute(ERROR_ATTRIBUTE, ex);//把异常信息保存到request域 &#125; ... &#125; 默认没有任何解析器（上图的HandlerExceptionResolverComposite）能处理异常，所以最后异常会被抛出。 最终底层就会转发/error 请求。会被底层的BasicErrorController处理。 123456789101112131415161718@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); //如果/template/error内没有4**.html或5**.html， //modelAndView为空，最终还是返回viewName为error的modelAndView return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model); &#125; ...&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... //渲染页面 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); ... &#125; private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; ... // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; ... &#125; protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. //找出合适error的View，如果/template/error内没有4**.html或5**.html， //将会返回默认异常页面ErrorMvcAutoConfiguration.StaticView //这里按需深究代码吧！ view = resolveViewName(viewName, mv.getModelInternal(), locale, request); ... &#125; ... try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; //看下面代码块的StaticView的render块 view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; ... &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class &#125;)// Load before the main WebMvcAutoConfiguration so that the error View is available@AutoConfigureBefore(WebMvcAutoConfiguration.class)@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class, WebMvcProperties.class &#125;)public class ErrorMvcAutoConfiguration &#123; ... @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true) @Conditional(ErrorTemplateMissingCondition.class) protected static class WhitelabelErrorViewConfiguration &#123; //将创建一个名为error的系统默认异常页面View的Bean private final StaticView defaultErrorView = new StaticView(); @Bean(name = &quot;error&quot;) @ConditionalOnMissingBean(name = &quot;error&quot;) public View defaultErrorView() &#123; return this.defaultErrorView; &#125; // If the user adds @EnableWebMvc then the bean name view resolver from // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment. @Bean @ConditionalOnMissingBean public BeanNameViewResolver beanNameViewResolver() &#123; BeanNameViewResolver resolver = new BeanNameViewResolver(); resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; &#125; &#125; private static class StaticView implements View &#123; private static final MediaType TEXT_HTML_UTF8 = new MediaType(&quot;text&quot;, &quot;html&quot;, StandardCharsets.UTF_8); private static final Log logger = LogFactory.getLog(StaticView.class); @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (response.isCommitted()) &#123; String message = getMessage(model); logger.error(message); return; &#125; response.setContentType(TEXT_HTML_UTF8.toString()); StringBuilder builder = new StringBuilder(); Object timestamp = model.get(&quot;timestamp&quot;); Object message = model.get(&quot;message&quot;); Object trace = model.get(&quot;trace&quot;); if (response.getContentType() == null) &#123; response.setContentType(getContentType()); &#125; //系统默认异常页面html代码 builder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;).append( &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;) .append(&quot;&lt;div id=&#x27;created&#x27;&gt;&quot;).append(timestamp).append(&quot;&lt;/div&gt;&quot;) .append(&quot;&lt;div&gt;There was an unexpected error (type=&quot;).append(htmlEscape(model.get(&quot;error&quot;))) .append(&quot;, status=&quot;).append(htmlEscape(model.get(&quot;status&quot;))).append(&quot;).&lt;/div&gt;&quot;); if (message != null) &#123; builder.append(&quot;&lt;div&gt;&quot;).append(htmlEscape(message)).append(&quot;&lt;/div&gt;&quot;); &#125; if (trace != null) &#123; builder.append(&quot;&lt;div style=&#x27;white-space:pre-wrap;&#x27;&gt;&quot;).append(htmlEscape(trace)).append(&quot;&lt;/div&gt;&quot;); &#125; builder.append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); response.getWriter().append(builder.toString()); &#125; private String htmlEscape(Object input) &#123; return (input != null) ? HtmlUtils.htmlEscape(input.toString()) : null; &#125; private String getMessage(Map&lt;String, ?&gt; model) &#123; Object path = model.get(&quot;path&quot;); String message = &quot;Cannot render error page for request [&quot; + path + &quot;]&quot;; if (model.get(&quot;message&quot;) != null) &#123; message += &quot; and exception [&quot; + model.get(&quot;message&quot;) + &quot;]&quot;; &#125; message += &quot; as the response has already been committed.&quot;; message += &quot; As a result, the response may have the wrong status code.&quot;; return message; &#125; @Override public String getContentType() &#123; return &quot;text/html&quot;; &#125; &#125;&#125; 55、错误处理-【源码流程】几种异常处理原理 自定义错误页 error&#x2F;404.html error&#x2F;5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页 @ControllerAdvice+@ExceptionHandler处理全局异常；底层是 ExceptionHandlerExceptionResolver 支持的 1234567891011@Slf4j@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;) //处理异常 public String handleArithException(Exception e)&#123; log.error(&quot;异常是：&#123;&#125;&quot;,e); return &quot;login&quot;; //视图地址 &#125;&#125; @ResponseStatus+自定义异常 ；底层是 ResponseStatusExceptionResolver ，把responseStatus注解的信息底层调用 response.sendError(statusCode, resolvedReason)，tomcat发送的/error 12345678910@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = &quot;用户数量太多&quot;)public class UserTooManyException extends RuntimeException &#123; public UserTooManyException()&#123; &#125; public UserTooManyException(String message)&#123; super(message); &#125;&#125; 12345678910111213141516171819@Controllerpublic class TableController &#123; @GetMapping(&quot;/dynamic_table&quot;) public String dynamic_table(@RequestParam(value=&quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn,Model model)&#123; //表格内容的遍历 List&lt;User&gt; users = Arrays.asList(new User(&quot;zhangsan&quot;, &quot;123456&quot;), new User(&quot;lisi&quot;, &quot;123444&quot;), new User(&quot;haha&quot;, &quot;aaaaa&quot;), new User(&quot;hehe &quot;, &quot;aaddd&quot;)); model.addAttribute(&quot;users&quot;,users); if(users.size()&gt;3)&#123; throw new UserTooManyException();//抛出自定义异常 &#125; return &quot;table/dynamic_table&quot;; &#125; &#125; Spring自家异常如 org.springframework.web.bind.MissingServletRequestParameterException，DefaultHandlerExceptionResolver 处理Spring自家异常。 response.sendError(HttpServletResponse.SC_BAD_REQUEST/*400*/, ex.getMessage()); 自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则 12345678910111213141516@Order(value= Ordered.HIGHEST_PRECEDENCE) //优先级，数字越小优先级越高@Componentpublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; try &#123; response.sendError(511,&quot;我喜欢的错误&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ModelAndView(); &#125;&#125; ErrorViewResolver 实现自定义处理异常 response.sendError()，error请求就会转给controller。 你的异常没有任何人能处理，tomcat底层调用response.sendError()，error请求就会转给controller。 basicErrorController 要去的页面地址是 ErrorViewResolver 。 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)public class BasicErrorController extends AbstractErrorController &#123; ... @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model); &#125; protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //这里用到ErrorViewResolver接口 for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null; &#125; ... &#125; 123456@FunctionalInterfacepublic interface ErrorViewResolver &#123; ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model);&#125; 56、原生组件注入-原生注解与Spring方式注入官方文档 - Servlets, Filters, and listeners 使用原生的注解12345678@WebServlet(urlPatterns = &quot;/my&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;66666&quot;); &#125;&#125; 12345678910111213141516171819@Slf4j@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;) //mypublic class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info(&quot;MyFilter初始化完成&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; log.info(&quot;MyFilter工作&quot;); chain.doFilter(request,response); &#125; @Override public void destroy() &#123; log.info(&quot;MyFilter销毁&quot;); &#125;&#125; 123456789101112131415@Slf4j@WebListenerpublic class MyServletContextListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; log.info(&quot;MySwervletContextListener监听到项目初始化完成&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; log.info(&quot;MySwervletContextListener监听到项目销毁&quot;); &#125;&#125; 最后还要在主启动类添加注解@ServletComponentScan 12345678@ServletComponentScan(basePackages = &quot;com.lun&quot;)//@SpringBootApplication(exclude = RedisAutoConfiguration.class)public class Boot05WebAdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Boot05WebAdminApplication.class, args); &#125;&#125; Spring方式注入ServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean 123456789101112131415161718192021222324252627@Configuration(proxyBeanMethods = true)public class MyRegistConfig &#123; @Bean public ServletRegistrationBean myServlet()&#123; MyServlet myServlet = new MyServlet(); return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;); &#125; @Bean public FilterRegistrationBean myFilter()&#123; MyFilter myFilter = new MyFilter();// return new FilterRegistrationBean(myFilter,myServlet()); FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;)); return filterRegistrationBean; &#125; @Bean public ServletListenerRegistrationBean myListener()&#123; MySwervletContextListener mySwervletContextListener = new MySwervletContextListener(); return new ServletListenerRegistrationBean(mySwervletContextListener); &#125;&#125; 57、原生组件注入-【源码分析】DispatcherServlet注入原理org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(DispatcherServlet.class)@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)public class DispatcherServletAutoConfiguration &#123; /* * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;; /* * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot; */ public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = &quot;dispatcherServletRegistration&quot;; @Configuration(proxyBeanMethods = false) @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class) @EnableConfigurationProperties(WebMvcProperties.class) protected static class DispatcherServletConfiguration &#123; //创建DispatcherServlet类的Bean @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) &#123; DispatcherServlet dispatcherServlet = new DispatcherServlet(); dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest()); dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest()); dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound()); dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents()); dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails()); return dispatcherServlet; &#125; @Bean @ConditionalOnBean(MultipartResolver.class) @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) &#123; // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; &#125; &#125; @Configuration(proxyBeanMethods = false) @Conditional(DispatcherServletRegistrationCondition.class) @ConditionalOnClass(ServletRegistration.class) @EnableConfigurationProperties(WebMvcProperties.class) @Import(DispatcherServletConfiguration.class) protected static class DispatcherServletRegistrationConfiguration &#123; //注册DispatcherServlet类 @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME) @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) &#123; DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath()); registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup()); multipartConfig.ifAvailable(registration::setMultipartConfig); return registration; &#125; &#125; ... &#125; DispatcherServlet默认映射的是 / 路径，可以通过在配置文件修改spring.mvc.servlet.path=/mvc。 58、嵌入式Servlet容器-【源码分析】切换web服务器与定制化 默认支持的WebServer Tomcat, Jetty, or Undertow。 ServletWebServerApplicationContext 容器启动寻找ServletWebServerFactory 并引导创建服务器。 原理 SpringBoot应用启动发现当前是Web应用，web场景包-导入tomcat。 web应用会创建一个web版的IOC容器 ServletWebServerApplicationContext 。 ServletWebServerApplicationContext 启动的时候寻找 ServletWebServerFactory （Servlet 的web服务器工厂——&gt;Servlet 的web服务器）。 SpringBoot底层默认有很多的WebServer工厂（ServletWebServerFactoryConfiguration内创建Bean），如： TomcatServletWebServerFactory JettyServletWebServerFactory UndertowServletWebServerFactory 底层直接会有一个自动配置类ServletWebServerFactoryAutoConfiguration。 ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）。 ServletWebServerFactoryConfiguration 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 TomcatServletWebServerFactory TomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize——this.tomcat.start(); 内嵌服务器，与以前手动把启动服务器相比，改成现在使用代码启动（tomcat核心jar包存在）。 Spring Boot默认使用Tomcat服务器，若需更改其他服务器，则修改工程pom.xml： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 官方文档 - Use Another Web Server 定制Servlet容器 实现WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; 把配置文件的值和ServletWebServerFactory进行绑定 修改配置文件 server.xxx 直接自定义 ConfigurableServletWebServerFactory xxxxxCustomizer：定制化器，可以改变xxxx的默认规则 12345678910111213import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;import org.springframework.stereotype.Component;@Componentpublic class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123; @Override public void customize(ConfigurableServletWebServerFactory server) &#123; server.setPort(9000); &#125;&#125; 59、定制化原理-SpringBoot定制化组件的几种方式（小结）定制化的常见方式 修改配置文件 xxxxxCustomizer 编写自定义的配置类 xxxConfiguration + @Bean替换、增加容器中默认组件，视图解析器 Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能 + @Bean给容器中再扩展一些组件 123@Configurationpublic class AdminWebConfig implements WebMvcConfigurer&#123;&#125; @EnableWebMvc + WebMvcConfigurer — @Bean 可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能（高级功能，初学者退避三舍）。 原理： WebMvcAutoConfiguration默认的SpringMVC的自动配置功能类，如静态资源、欢迎页等。 一旦使用 @EnableWebMvc ，会@Import(DelegatingWebMvcConfiguration.class)。 DelegatingWebMvcConfiguration的作用，只保证SpringMVC最基本的使用 把所有系统中的WebMvcConfigurer拿过来，所有功能的定制都是这些WebMvcConfigurer合起来一起生效。 自动配置了一些非常底层的组件，如RequestMappingHandlerMapping，这些组件依赖的组件都是从容器中获取如。 public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport。 WebMvcAutoConfiguration里面的配置要能生效必须 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)。 @EnableWebMvc 导致了WebMvcAutoConfiguration 没有生效。 原理分析套路场景starter - xxxxAutoConfiguration - 导入xxx组件 - 绑定xxxProperties - 绑定配置文件项。 60、数据访问-数据库场景的自动配置分析与整合测试导入JDBC场景1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 接着导入数据库驱动包（MySQL为例）。 123456789101112131415161718&lt;!--默认版本：--&gt;&lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--&lt;version&gt;5.1.49&lt;/version&gt;--&gt;&lt;/dependency&gt;&lt;!--想要修改版本1、直接依赖引入具体版本（maven的就近依赖原则）2、重新声明版本（maven的属性的就近优先原则）--&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt;&lt;/properties&gt; 相关数据源配置类 DataSourceAutoConfiguration ： 数据源的自动配置。 修改数据源相关的配置：spring.datasource。 数据库连接池的配置，是自己容器中没有DataSource才自动配置的。 底层配置好的连接池是：HikariDataSource。 DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置。 JdbcTemplateAutoConfiguration： JdbcTemplate的自动配置，可以来对数据库进行CRUD。 可以修改前缀为spring.jdbc的配置项来修改JdbcTemplate。 @Bean @Primary JdbcTemplate：Spring容器中有这个JdbcTemplate组件，使用@Autowired。 JndiDataSourceAutoConfiguration： JNDI的自动配置。 XADataSourceAutoConfiguration： 分布式事务相关的。 修改配置项123456spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 单元测试数据源1234567891011121314151617181920import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test//用@org.junit.Test会报空指针异常，可能跟JUnit新版本有关 void contextLoads() &#123;// jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)// jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,) Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class); log.info(&quot;记录总数：&#123;&#125;&quot;,aLong); &#125;&#125; 61、数据访问-自定义方式整合druid数据源Druid官网 Druid是什么？它是数据库连接池，它能够提供强大的监控和扩展功能。 官方文档 - Druid连接池介绍 Spring Boot整合第三方技术的两种方式： 自定义 找starter场景 自定义方式添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 配置Druid数据源： 123456789101112131415@Configurationpublic class MyConfig &#123; @Bean @ConfigurationProperties(&quot;spring.datasource&quot;)//复用配置文件的数据源配置 public DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource();// druidDataSource.setUrl();// druidDataSource.setUsername();// druidDataSource.setPassword(); return druidDataSource; &#125;&#125; 更多配置项 配置Druid的监控页功能： Druid内置提供了一个StatViewServlet用于展示Druid的统计信息。官方文档 - 配置_StatViewServlet配置。这个StatViewServlet的用途包括： 提供监控信息展示的html页面 提供监控信息的JSON API Druid内置提供一个StatFilter，用于统计监控信息。官方文档 - 配置_StatFilter WebStatFilter用于采集web-jdbc关联监控的数据，如SQL监控、URI监控。官方文档 - 配置_配置WebStatFilter Druid提供了WallFilter，它是基于SQL语义分析来实现防御SQL注入攻击的。官方文档 - 配置 wallfilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class MyConfig &#123; @Bean @ConfigurationProperties(&quot;spring.datasource&quot;) public DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource(); //加入监控和防火墙功能功能 druidDataSource.setFilters(&quot;stat,wall&quot;); return druidDataSource; &#125; /** * 配置 druid的监控页功能 * @return */ @Bean public ServletRegistrationBean statViewServlet()&#123; StatViewServlet statViewServlet = new StatViewServlet(); ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(statViewServlet, &quot;/druid/*&quot;); //监控页账号密码： registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;); registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;); return registrationBean; &#125; /** * WebStatFilter 用于采集web-jdbc关联监控的数据。 */ @Bean public FilterRegistrationBean webStatFilter()&#123; WebStatFilter webStatFilter = new WebStatFilter(); FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(webStatFilter); filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;); return filterRegistrationBean; &#125; &#125; 62、数据访问-druid数据源starter整合方式官方文档 - Druid Spring Boot Starter 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 分析自动配置： 扩展配置项 spring.datasource.druid 自动配置类DruidDataSourceAutoConfigure DruidSpringAopConfiguration.class, 监控SpringBean的；配置项：spring.datasource.druid.aop-patterns DruidStatViewServletConfiguration.class, 监控页的配置。spring.datasource.druid.stat-view-servlet默认开启。 DruidWebStatFilterConfiguration.class，web监控配置。spring.datasource.druid.web-stat-filter默认开启。 DruidFilterConfiguration.class所有Druid的filter的配置： 12345678private static final String FILTER_STAT_PREFIX = &quot;spring.datasource.druid.filter.stat&quot;;private static final String FILTER_CONFIG_PREFIX = &quot;spring.datasource.druid.filter.config&quot;;private static final String FILTER_ENCODING_PREFIX = &quot;spring.datasource.druid.filter.encoding&quot;;private static final String FILTER_SLF4J_PREFIX = &quot;spring.datasource.druid.filter.slf4j&quot;;private static final String FILTER_LOG4J_PREFIX = &quot;spring.datasource.druid.filter.log4j&quot;;private static final String FILTER_LOG4J2_PREFIX = &quot;spring.datasource.druid.filter.log4j2&quot;;private static final String FILTER_COMMONS_LOG_PREFIX = &quot;spring.datasource.druid.filter.commons-log&quot;;private static final String FILTER_WALL_PREFIX = &quot;spring.datasource.druid.filter.wall&quot;; 配置示例： 1234567891011121314151617181920212223242526272829303132spring: datasource: url: jdbc:mysql://localhost:3306/db_account username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver druid: aop-patterns: com.atguigu.admin.* #监控SpringBean filters: stat,wall # 底层开启功能，stat（sql监控），wall（防火墙） stat-view-servlet: # 配置监控页功能 enabled: true login-username: admin login-password: admin resetEnable: false web-stat-filter: # 监控web enabled: true urlPattern: /* exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27; filter: stat: # 对上面filters里面的stat的详细配置 slow-sql-millis: 1000 logSlowSql: true enabled: true wall: enabled: true config: drop-table-allow: false 63、数据访问-整合MyBatis-配置版MyBatis的GitHub仓库 MyBatis官方 starter的命名方式： SpringBoot官方的Starter：spring-boot-starter-* 第三方的： *-spring-boot-starter 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt; 配置模式: 全局配置文件 SqlSessionFactory：自动配置好了 SqlSession：自动配置了SqlSessionTemplate 组合了SqlSession @Import(AutoConfiguredMapperScannerRegistrar.class) Mapper： 只要我们写的操作MyBatis的接口标准了@Mapper就会被自动扫描进来 12345678910@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)public class MybatisAutoConfiguration&#123; ...&#125;@ConfigurationProperties(prefix = &quot;mybatis&quot;)public class MybatisProperties&#123; ...&#125; 配置文件： 1234567891011spring: datasource: username: root password: 1234 url: jdbc:mysql://localhost:3306/my driver-class-name: com.mysql.jdbc.Driver# 配置mybatis规则mybatis: config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/*.xml #sql映射文件位置 mybatis-config.xml: 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 由于Spring Boot自动配置缘故，此处不必配置，只用来做做样。--&gt;&lt;/configuration&gt; Mapper接口： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lun.boot.mapper.UserMapper&quot;&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;com.lun.boot.bean.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567import com.lun.boot.bean.User;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface UserMapper &#123; public User getUser(Integer id);&#125; POJO： 123456public class User &#123; private Integer id; private String name; //getters and setters...&#125; DB： 12345CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(45) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; Controller and Service： 1234567891011121314@Controllerpublic class UserController &#123; @Autowired private UserService userService; @ResponseBody @GetMapping(&quot;/user/&#123;id&#125;&quot;) public User getUser(@PathVariable(&quot;id&quot;) Integer id)&#123; return userService.getUser(id); &#125;&#125; 1234567891011@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper;//IDEA下标红线，可忽视这红线 public User getUser(Integer id)&#123; return userMapper.getUser(id); &#125;&#125; 配置private Configuration configuration; 也就是配置mybatis.configuration相关的，就是相当于改mybatis全局配置文件中的值。（也就是说配置了mybatis.configuration，就不需配置mybatis全局配置文件了） 1234567# 配置mybatis规则mybatis: mapper-locations: classpath:mybatis/mapper/*.xml # 可以不写全局配置文件，所有全局配置文件的配置都放在configuration配置项中了。 # config-location: classpath:mybatis/mybatis-config.xml configuration: map-underscore-to-camel-case: true 小结 导入MyBatis官方Starter。 编写Mapper接口，需@Mapper注解。 编写SQL映射文件并绑定Mapper接口。 在application.yaml中指定Mapper配置文件的所处位置，以及指定全局配置文件的信息 （建议：**配置在mybatis.configuration**）。 64、数据访问-整合MyBatis-注解配置混合版你可以通过Spring Initializr添加MyBatis的Starer。 注解与配置混合搭配，干活不累： 123456789101112131415@Mapperpublic interface UserMapper &#123; public User getUser(Integer id); @Select(&quot;select * from user where id=#&#123;id&#125;&quot;) public User getUser2(Integer id); public void saveUser(User user); @Insert(&quot;insert into user(`name`) values(#&#123;name&#125;)&quot;) @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;) public void saveUser2(User user);&#125; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lun.boot.mapper.UserMapper&quot;&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;com.lun.boot.bean.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;saveUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user(`name`) values(#&#123;name&#125;) &lt;/insert&gt;&lt;/mapper&gt; 简单DAO方法就写在注解上。复杂的就写在配置文件里。 使用@MapperScan(&quot;com.lun.boot.mapper&quot;) 简化，Mapper接口就可以不用标注@Mapper注解。 123456789@MapperScan(&quot;com.lun.boot.mapper&quot;)@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125;&#125; 65、数据访问-整合MyBatisPlus操作数据库IDEA的MyBatis的插件 - MyBatisX MyBatisPlus官网 MyBatisPlus官方文档 MyBatisPlus是什么MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; MybatisPlusAutoConfiguration配置类，MybatisPlusProperties配置项绑定。 SqlSessionFactory自动配置好，底层是容器中默认的数据源。 mapperLocations自动配置好的，有默认值classpath*:/mapper/**/*.xml，这表示任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。 建议以后sql映射文件放在 mapper下。 容器中也自动配置好了SqlSessionTemplate。 @Mapper 标注的接口也会被自动扫描，建议直接 @MapperScan(&quot;com.lun.boot.mapper&quot;)批量扫描。 MyBatisPlus优点之一：只需要我们的Mapper继承MyBatisPlus的BaseMapper 就可以拥有CRUD能力，减轻开发工作。 123456import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.lun.hellomybatisplus.model.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 66、数据访问-CRUD实验-数据列表展示官方文档 - CRUD接口 使用MyBatis Plus提供的IService，ServiceImpl，减轻Service层开发工作。 1234567891011import com.lun.hellomybatisplus.model.User;import com.baomidou.mybatisplus.extension.service.IService;import java.util.List;/** * Service 的CRUD也不用写了 */public interface UserService extends IService&lt;User&gt; &#123; //此处故意为空&#125; 12345678910111213import com.lun.hellomybatisplus.model.User;import com.lun.hellomybatisplus.mapper.UserMapper;import com.lun.hellomybatisplus.service.UserService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123; //此处故意为空&#125; 与下一节联合在一起 67、数据访问-CRUD实验-分页数据展示与下一节联合在一起 68、数据访问-CRUD实验-删除用户完成添加分页插件： 1234567891011121314151617181920212223242526@Configurationpublic class MyBatisConfig &#123; /** * MybatisPlusInterceptor * @return */ @Bean public MybatisPlusInterceptor paginationInterceptor() &#123; MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 // paginationInterceptor.setLimit(500); // 开启 count 的 join 优化,只针对部分 left join //这是分页拦截器 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(); paginationInnerInterceptor.setOverflow(true); paginationInnerInterceptor.setMaxLimit(500L); mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor); return mybatisPlusInterceptor; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;table class=&quot;display table table-bordered table-striped&quot; id=&quot;dynamic-table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=&quot;gradeX&quot; th:each=&quot;user: $&#123;users.records&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;user.name&#125;]]&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;4&lt;/td&gt; &lt;td&gt; &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;users.current&#125;)&#125;&quot; class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;div class=&quot;row-fluid&quot;&gt; &lt;div class=&quot;span6&quot;&gt; &lt;div class=&quot;dataTables_info&quot; id=&quot;dynamic-table_info&quot;&gt; 当前第[[$&#123;users.current&#125;]]页 总计 [[$&#123;users.pages&#125;]]页 共[[$&#123;users.total&#125;]]条记录 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;span6&quot;&gt; &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt; &lt;ul&gt; &lt;li class=&quot;prev disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;← 前一页&lt;/a&gt;&lt;/li&gt; &lt;li th:class=&quot;$&#123;num == users.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,users.pages)&#125;&quot; &gt; &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;下一页 → &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; #numbers表示methods for formatting numeric objects.link 1234567891011121314151617181920212223242526@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)public String deleteUser(@PathVariable(&quot;id&quot;) Long id, @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn, RedirectAttributes ra)&#123; userService.removeById(id); ra.addAttribute(&quot;pn&quot;,pn); return &quot;redirect:/dynamic_table&quot;;&#125;@GetMapping(&quot;/dynamic_table&quot;)public String dynamic_table(@RequestParam(value=&quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn,Model model)&#123; //表格内容的遍历 //从数据库中查出user表中的用户进行展示 //构造分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(pn, 2); //调用page进行分页 Page&lt;User&gt; userPage = userService.page(page, null); model.addAttribute(&quot;users&quot;,userPage); return &quot;table/dynamic_table&quot;;&#125; 69、数据访问-准备阿里云Redis环境添加依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--导入jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; RedisAutoConfiguration自动配置类，RedisProperties 属性类 –&gt; spring.redis.xxx是对redis的配置。 连接工厂LettuceConnectionConfiguration、JedisConnectionConfiguration是准备好的。 自动注入了RedisTemplate&lt;Object, Object&gt;，xxxTemplate。 自动注入了StringRedisTemplate，key，value都是String 底层只要我们使用StringRedisTemplate、RedisTemplate就可以操作Redis。 外网Redis环境搭建： 阿里云按量付费Redis，其中选择经典网络。 申请Redis的公网连接地址。 修改白名单，允许0.0.0.0/0访问。 70、数据访问-Redis操作与统计小实验相关Redis配置： 1234567891011121314spring: redis:# url: redis://lfy:Lfy123456@r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com:6379 host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com port: 6379 password: lfy:Lfy123456 client-type: jedis jedis: pool: max-active: 10# lettuce:# 另一个用来连接redis的java框架# pool:# max-active: 10# min-idle: 5 测试Redis连接： 1234567891011121314151617181920212223@SpringBootTestpublic class Boot05WebAdminApplicationTests &#123; @Autowired StringRedisTemplate redisTemplate; @Autowired RedisConnectionFactory redisConnectionFactory; @Test void testRedis()&#123; ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue(); operations.set(&quot;hello&quot;,&quot;world&quot;); String hello = operations.get(&quot;hello&quot;); System.out.println(hello); System.out.println(redisConnectionFactory.getClass()); &#125;&#125; Redis Desktop Manager：可视化Redis管理软件。 URL统计拦截器： 12345678910111213141516@Componentpublic class RedisUrlCountInterceptor implements HandlerInterceptor &#123; @Autowired StringRedisTemplate redisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri = request.getRequestURI(); //默认每次访问当前uri就会计数+1 redisTemplate.opsForValue().increment(uri); return true; &#125;&#125; 注册URL统计拦截器： 12345678910111213141516@Configurationpublic class AdminWebConfig implements WebMvcConfigurer&#123; @Autowired RedisUrlCountInterceptor redisUrlCountInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(redisUrlCountInterceptor) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;, &quot;/js/**&quot;,&quot;/aa/**&quot;); &#125;&#125; Filter、Interceptor 几乎拥有相同的功能？ Filter是Servlet定义的原生组件，它的好处是脱离Spring应用也能使用。 Interceptor是Spring定义的接口，可以使用Spring的自动装配等功能。 调用Redis内的统计数据： 123456789101112131415161718192021222324@Slf4j@Controllerpublic class IndexController &#123; @Autowired StringRedisTemplate redisTemplate; @GetMapping(&quot;/main.html&quot;) public String mainPage(HttpSession session,Model model)&#123; log.info(&quot;当前方法是：&#123;&#125;&quot;,&quot;mainPage&quot;); ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue(); String s = opsForValue.get(&quot;/main.html&quot;); String s1 = opsForValue.get(&quot;/sql&quot;); model.addAttribute(&quot;mainCount&quot;,s); model.addAttribute(&quot;sqlCount&quot;,s1); return &quot;main&quot;; &#125;&#125; 71、单元测试-JUnit5简介Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库 JUnit 5官方文档 作为最新版本的JUnit框架，JUnit5与之前版本的JUnit框架有很大的不同。由三个不同子项目的几个不同模块组成。 JUnit 5 &#x3D; JUnit Platform + JUnit Jupiter + JUnit Vintage JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。 JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部包含了一个测试引擎，用于在Junit Platform上运行。 JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x，JUnit3.x的测试引擎。 注意： SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容JUnit4需要自行引入（不能使用JUnit4的功能 @Test） JUnit 5’s Vintage已经从spring-boot-starter-test从移除。如果需要继续兼容Junit4需要自行引入Vintage依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 使用添加JUnit 5，添加对应的starter： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Spring的JUnit 5的基本单元测试模板（Spring的JUnit4的是@SpringBootTest+@RunWith(SpringRunner.class)）： 1234567891011121314151617import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;//注意不是org.junit.Test（这是JUnit4版本的）import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass SpringBootApplicationTests &#123; @Autowired private Component component; @Test //@Transactional 标注后连接数据库有回滚功能 public void contextLoads() &#123; Assertions.assertEquals(5, component.getFive()); &#125;&#125; Jupiter 英 [ˈdʒuːpɪtə(r)] 美 [ˈdʒuːpɪtər] n. 木星(太阳系中最大的行星) vintage 英 [ˈvɪntɪdʒ] 美 [ˈvɪntɪdʒ] n. 特定年份(或地方)酿制的酒;酿造年份;采摘葡萄酿酒的期间(或季节);葡萄收获期(或季节) adj. (指葡萄酒)优质的，上等的，佳酿的;古色古香的(指1917–1930年间制造，车型和品味受人青睐的);(过去某个时期)典型的，优质的;(某人的)最佳作品的 72、单元测试-常用测试注解官方文档 - Annotations @Test：表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest：表示方法是参数化测试。 @RepeatedTest：表示方法可重复执行。 @DisplayName：为测试类或者测试方法设置展示名称。 @BeforeEach：表示在每个单元测试之前执行。 @AfterEach：表示在每个单元测试之后执行。 @BeforeAll：表示在所有单元测试之前执行。 @AfterAll：表示在所有单元测试之后执行。 @Tag：表示单元测试类别，类似于JUnit4中的@Categories。 @Disabled：表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。 @Timeout：表示测试方法运行如果超过了指定时间将会返回错误。 @ExtendWith：为测试类或测试方法提供扩展类引用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.junit.jupiter.api.*;@DisplayName(&quot;junit5功能测试类&quot;)public class Junit5Test &#123; @DisplayName(&quot;测试displayname注解&quot;) @Test void testDisplayName() &#123; System.out.println(1); System.out.println(jdbcTemplate); &#125; @ParameterizedTest @ValueSource(strings = &#123; &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; &#125;) void palindromes(String candidate) &#123; assertTrue(StringUtils.isPalindrome(candidate)); &#125; @Disabled @DisplayName(&quot;测试方法2&quot;) @Test void test2() &#123; System.out.println(2); &#125; @RepeatedTest(5) @Test void test3() &#123; System.out.println(5); &#125; /** * 规定方法超时时间。超出时间测试出异常 * * @throws InterruptedException */ @Timeout(value = 500, unit = TimeUnit.MILLISECONDS) @Test void testTimeout() throws InterruptedException &#123; Thread.sleep(600); &#125; @BeforeEach void testBeforeEach() &#123; System.out.println(&quot;测试就要开始了...&quot;); &#125; @AfterEach void testAfterEach() &#123; System.out.println(&quot;测试结束了...&quot;); &#125; @BeforeAll static void testBeforeAll() &#123; System.out.println(&quot;所有测试就要开始了...&quot;); &#125; @AfterAll static void testAfterAll() &#123; System.out.println(&quot;所有测试以及结束了...&quot;); &#125;&#125; 73、单元测试-断言机制断言Assertion是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是org.junit.jupiter.api.Assertions的静态方法。检查业务逻辑返回的数据是否合理。所有的测试运行结束以后，会有一个详细的测试报告。 JUnit 5 内置的断言可以分成如下几个类别： 简单断言用来对单个值进行简单的验证。如： 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 12345678910111213141516@Test@DisplayName(&quot;simple assertion&quot;)public void simple() &#123; assertEquals(3, 1 + 2, &quot;simple math&quot;); assertNotEquals(3, 1 + 1); assertNotSame(new Object(), new Object()); Object obj = new Object(); assertSame(obj, obj); assertFalse(1 &gt; 2); assertTrue(1 &lt; 2); assertNull(null); assertNotNull(new Object());&#125; 数组断言通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。 12345@Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 组合断言assertAll()方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。 12345678@Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 异常断言在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows()，配合函数式编程就可以进行使用。 1234567@Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 超时断言JUnit5还提供了Assertions.assertTimeout()为测试方法设置了超时时间。 123456@Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 快速失败通过 fail 方法直接使得测试失败。 12345@Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125; 74、单元测试-前置条件Unit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言assertions会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。 前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;; @Test @DisplayName(&quot;simple&quot;) public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;)); assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125; @Test @DisplayName(&quot;assume then do&quot;) public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, &quot;DEV&quot;), () -&gt; System.out.println(&quot;In DEV&quot;) ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。 assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 75、单元测试-嵌套测试官方文档 - Nested Tests JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach注解，而且嵌套的层次没有限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@DisplayName(&quot;A stack&quot;)class TestingAStackDemo &#123; Stack&lt;Object&gt; stack; @Test @DisplayName(&quot;is instantiated with new Stack()&quot;) void isInstantiatedWithNew() &#123; new Stack&lt;&gt;(); &#125; @Nested @DisplayName(&quot;when new&quot;) class WhenNew &#123; @BeforeEach void createNewStack() &#123; stack = new Stack&lt;&gt;(); &#125; @Test @DisplayName(&quot;is empty&quot;) void isEmpty() &#123; assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;throws EmptyStackException when popped&quot;) void throwsExceptionWhenPopped() &#123; assertThrows(EmptyStackException.class, stack::pop); &#125; @Test @DisplayName(&quot;throws EmptyStackException when peeked&quot;) void throwsExceptionWhenPeeked() &#123; assertThrows(EmptyStackException.class, stack::peek); &#125; @Nested @DisplayName(&quot;after pushing an element&quot;) class AfterPushing &#123; String anElement = &quot;an element&quot;; @BeforeEach void pushAnElement() &#123; stack.push(anElement); &#125; @Test @DisplayName(&quot;it is no longer empty&quot;) void isNotEmpty() &#123; assertFalse(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when popped and is empty&quot;) void returnElementWhenPopped() &#123; assertEquals(anElement, stack.pop()); assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when peeked but remains not empty&quot;) void returnElementWhenPeeked() &#123; assertEquals(anElement, stack.peek()); assertFalse(stack.isEmpty()); &#125; &#125; &#125;&#125; 76、单元测试-参数化测试官方文档 - Parameterized Tests 参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。 利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 @ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型 @NullSource: 表示为参数化测试提供一个null的入参 @EnumSource: 表示为参数化测试提供一个枚举入参 @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流) 当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现**ArgumentsProvider**接口，任何外部文件都可以作为它的入参。 1234567891011121314151617181920@ParameterizedTest@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)@DisplayName(&quot;参数化测试1&quot;)public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;) //指定方法名@DisplayName(&quot;方法来源参数&quot;)public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name); Assertions.assertNotNull(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(&quot;apple&quot;, &quot;banana&quot;);&#125; 迁移指南官方文档 - Migrating from JUnit 4 在进行迁移的时候需要注意如下的变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 77、指标监控-SpringBoot Actuator与Endpoint未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。 官方文档 - Spring Boot Actuator: Production-ready Features 1.x与2.x的不同： SpringBoot Actuator 1.x 支持SpringMVC 基于继承方式进行扩展 层级Metrics配置 自定义Metrics收集 默认较少的安全策略 SpringBoot Actuator 2.x 支持SpringMVC、JAX-RS以及Webflux 注解驱动进行扩展 层级&amp;名称空间Metrics 底层使用MicroMeter，强大、便捷默认丰富的安全策略 如何使用 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 访问http://localhost:8080/actuator/**。 暴露所有监控信息为HTTP。 123456management: endpoints: enabled-by-default: true #暴露所有端点信息 web: exposure: include: &#x27;*&#x27; #以web方式暴露 测试例子 http://localhost:8080/actuator/beans http://localhost:8080/actuator/configprops http://localhost:8080/actuator/metrics http://localhost:8080/actuator/metrics/jvm.gc.pause http://localhost:8080/actuator/metrics/endpointName/detailPath actuator 英 [ˈæktjʊeɪtə] 美 [ˈæktjuˌeɪtər] n. 致动（促动，激励，调节）器；传动（装置，机构）；拖动装置；马达；操作机构；执行机构（元件）；（电磁铁）螺线管；操纵装置（阀门）；调速控制器；往复运动油（气）缸；作动筒 metric 英 [ˈmetrɪk] 美 [ˈmetrɪk] adj. 米制的;公制的;按公制制作的;用公制测量的 n. 度量标准;[数学]度量;诗体;韵文;诗韵 78、指标监控-常使用的端点及开启与禁用常使用的端点 ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 其中最常用的Endpoint： Health：监控状况 Metrics：运行时指标 Loggers：日志记录 Health Endpoint健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。 重要的几点： health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告。 很多的健康检查默认已经自动配置好了，比如：数据库、redis等。 可以很容易的添加自定义的健康检查机制。 Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到： 通过Metrics对接多种监控系统。 简化核心Metrics开发。 添加自定义Metrics或者扩展已有Metrics。 开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint。配置模式为management.endpoint.&lt;endpointName&gt;.enabled = true 1234management: endpoint: beans: enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint。 12345678management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 暴露Endpoints支持的暴露方式 HTTP：默认只暴露health和info。 JMX：默认暴露所有Endpoint。 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入Spring Security，则会默认配置安全访问规则。 ID JMX Web auditevents Yes No beans Yes No caches Yes No conditions Yes No configprops Yes No env Yes No flyway Yes No health Yes Yes heapdump N&#x2F;A No httptrace Yes No info Yes Yes integrationgraph Yes No jolokia N&#x2F;A No logfile N&#x2F;A No loggers Yes No liquibase Yes No metrics Yes No mappings Yes No prometheus N&#x2F;A No scheduledtasks Yes No sessions Yes No shutdown Yes No startup Yes No threaddump Yes No 若要更改公开的Endpoint，请配置以下的包含和排除属性： Property Default management.endpoints.jmx.exposure.exclude management.endpoints.jmx.exposure.include * management.endpoints.web.exposure.exclude management.endpoints.web.exposure.include info, health 官方文档 - Exposing Endpoints 79、指标监控-定制Endpoint定制 Health 信息1234management: health: enabled: true show-details: always #总是显示详细信息。可显示每个模块的状态信息 通过实现HealthIndicator 接口，或继承MyComHealthIndicator 类。 1234567891011121314151617181920212223242526import org.springframework.boot.actuate.health.Health;import org.springframework.boot.actuate.health.HealthIndicator;import org.springframework.stereotype.Component;@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; int errorCode = check(); // perform some specific health check if (errorCode != 0) &#123; return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build(); &#125; return Health.up().build(); &#125;&#125;/*构建HealthHealth build = Health.down() .withDetail(&quot;msg&quot;, &quot;error service&quot;) .withDetail(&quot;code&quot;, &quot;500&quot;) .withException(new RuntimeException()) .build();*/ 12345678910111213141516171819202122232425262728293031@Componentpublic class MyComHealthIndicator extends AbstractHealthIndicator &#123; /** * 真实的检查方法 * @param builder * @throws Exception */ @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; //mongodb。 获取连接进行测试 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 检查完成 if(1 == 2)&#123;// builder.up(); //健康 builder.status(Status.UP); map.put(&quot;count&quot;,1); map.put(&quot;ms&quot;,100); &#125;else &#123;// builder.down(); builder.status(Status.OUT_OF_SERVICE); map.put(&quot;err&quot;,&quot;连接超时&quot;); map.put(&quot;ms&quot;,3000); &#125; builder.withDetail(&quot;code&quot;,100) .withDetails(map); &#125;&#125; 定制info信息常用两种方式： 编写配置文件 12345info: appName: boot-admin version: 2.0.1 mavenProjectName: @project.artifactId@ #使用@@可以获取maven的pom文件值 mavenProjectVersion: @project.version@ 编写InfoContributor 12345678910111213141516import java.util.Collections;import org.springframework.boot.actuate.info.Info;import org.springframework.boot.actuate.info.InfoContributor;import org.springframework.stereotype.Component;@Componentpublic class ExampleInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(&quot;example&quot;, Collections.singletonMap(&quot;key&quot;, &quot;value&quot;)); &#125;&#125; http://localhost:8080/actuator/info 会输出以上方式返回的所有info信息 定制Metrics信息Spring Boot支持的metrics 增加定制Metrics： 12345678910class MyService&#123; Counter counter; public MyService(MeterRegistry meterRegistry)&#123; counter = meterRegistry.counter(&quot;myservice.method.running.counter&quot;); &#125; public void hello() &#123; counter.increment(); &#125;&#125; 12345//也可以使用下面的方式@BeanMeterBinder queueSize(Queue queue) &#123; return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);&#125; 定制Endpoint123456789101112131415@Component@Endpoint(id = &quot;container&quot;)public class DockerEndpoint &#123; @ReadOperation public Map getDockerInfo()&#123; return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;); &#125; @WriteOperation private void restartDocker()&#123; System.out.println(&quot;docker restarted....&quot;); &#125;&#125; 场景： 开发ReadinessEndpoint来管理程序是否就绪。 开发LivenessEndpoint来管理程序是否存活。 80、指标监控-Boot Admin Server官方Github 官方文档 可视化指标监控 What is Spring Boot Admin? codecentric’s Spring Boot Admin is a community project to manage and monitor your Spring Boot ® applications. The applications register with our Spring Boot Admin Client (via HTTP) or are discovered using Spring Cloud ® (e.g. Eureka, Consul). The UI is just a Vue.js application on top of the Spring Boot Actuator endpoints. 开始使用方法 81、高级特性-Profile环境切换为了方便多环境适配，Spring Boot简化了profile功能。 默认配置文件application.yaml任何时候都会加载。 指定环境配置文件application-&#123;env&#125;.yaml，env通常替代为test， 激活指定环境 配置文件激活：spring.profiles.active=prod 命令行激活：java -jar xxx.jar --spring.profiles.active=prod --person.name=haha（修改配置文件的任意值，命令行优先） 默认配置与环境配置同时生效 同名配置项，profile配置优先 @Profile条件装配功能1234567@Data@Component@ConfigurationProperties(&quot;person&quot;)//在配置文件中配置public class Person&#123; private String name; private Integer age;&#125; application.properties 123person: name: lun age: 8 1234567891011121314151617181920212223242526public interface Person &#123; String getName(); Integer getAge();&#125;@Profile(&quot;test&quot;)//加载application-test.yaml里的@Component@ConfigurationProperties(&quot;person&quot;)@Datapublic class Worker implements Person &#123; private String name; private Integer age;&#125;@Profile(value = &#123;&quot;prod&quot;,&quot;default&quot;&#125;)//加载application-prod.yaml里的@Component@ConfigurationProperties(&quot;person&quot;)@Datapublic class Boss implements Person &#123; private String name; private Integer age;&#125; application-test.yaml 12345person: name: test-张三server: port: 7000 application-prod.yaml 12345person: name: prod-张三server: port: 8000 application.properties 12# 激活prod配置文件spring.profiles.active=prod 12345678@Autowiredprivate Person person;@GetMapping(&quot;/&quot;)public String hello()&#123; //激活了prod，则返回Boss；激活了test，则返回Worker return person.getClass().toString();&#125; @Profile还可以修饰在方法上： 123456789101112131415161718class Color &#123;&#125;@Configurationpublic class MyConfig &#123; @Profile(&quot;prod&quot;) @Bean public Color red()&#123; return new Color(); &#125; @Profile(&quot;test&quot;) @Bean public Color green()&#123; return new Color(); &#125;&#125; 可以激活一组： 1234spring.profiles.active=productionspring.profiles.group.production[0]=proddbspring.profiles.group.production[1]=prodmq 82、高级特性-配置加载优先级外部化配置官方文档 - Externalized Configuration Spring Boot uses a very particular PropertySource order that is designed to allow sensible overriding of values. Properties are considered in the following order (with values from lower items overriding earlier ones)（1优先级最低，14优先级最高）: Default properties (specified by setting SpringApplication.setDefaultProperties). @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Config data (such as application.properties files) A RandomValuePropertySource that has properties only in random.*. OS environment variables. Java System properties (System.getProperties()). JNDI attributes from java:comp/env. ServletContext init parameters. ServletConfig init parameters. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). Command line arguments. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application. @TestPropertySource annotations on your tests. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active. 123456789101112import org.springframework.stereotype.*;import org.springframework.beans.factory.annotation.*;@Componentpublic class MyBean &#123; @Value(&quot;$&#123;name&#125;&quot;)//以这种方式可以获得配置值 private String name; // ...&#125; 外部配置源 Java属性文件。 YAML文件。 环境变量。 命令行参数。 配置文件查找位置 classpath 根路径。 classpath 根路径下config目录。 jar包当前目录。 jar包当前目录的config目录。 &#x2F;config子目录的直接子目录。 配置文件加载顺序： 当前jar包内部的application.properties和application.yml。 当前jar包内部的application-&#123;profile&#125;.properties 和 application-&#123;profile&#125;.yml。 引用的外部jar包的application.properties和application.yml。 引用的外部jar包的application-&#123;profile&#125;.properties和application-&#123;profile&#125;.yml。 指定环境优先，外部优先，后面的可以覆盖前面的同名配置项。 83、高级特性-自定义starter细节starter启动原理 starter的pom.xml引入autoconfigure依赖 1234graph LRA[starter] --&gt;B[autoconfigure]B --&gt; C[spring-boot-starter] autoconfigure包中配置使用META-INF/spring.factories中EnableAutoConfiguration的值，使得项目启动加载指定的自动配置类 编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties @Configuration @Conditional @EnableConfigurationProperties @Bean …… 引入starter — xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —- 配置项 自定义starter 目标：创建HelloService的自定义starter。 创建两个工程，分别命名为hello-spring-boot-starter（普通Maven工程），hello-spring-boot-starter-autoconfigure（需用用到Spring Initializr创建的Maven工程）。 hello-spring-boot-starter无需编写什么代码，只需让该工程引入hello-spring-boot-starter-autoconfigure依赖： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lun&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.lun&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; hello-spring-boot-starter-autoconfigure的pom.xml如下： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lun&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-spring-boot-starter-autoconfigure&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建4个文件： com/lun/hello/auto/HelloServiceAutoConfiguration com/lun/hello/bean/HelloProperties com/lun/hello/service/HelloService src/main/resources/META-INF/spring.factories 123456789101112131415161718import com.lun.hello.bean.HelloProperties;import com.lun.hello.service.HelloService;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnMissingBean(HelloService.class)@EnableConfigurationProperties(HelloProperties.class)//默认HelloProperties放在容器中public class HelloServiceAutoConfiguration &#123; @Bean public HelloService helloService()&#123; return new HelloService(); &#125;&#125; 123456789101112131415161718192021222324import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(&quot;hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 12345678910111213141516import com.lun.hello.bean.HelloProperties;import org.springframework.beans.factory.annotation.Autowired;/** * 默认不要放在容器中 */public class HelloService &#123; @Autowired private HelloProperties helloProperties; public String sayHello(String userName)&#123; return helloProperties.getPrefix() + &quot;: &quot; + userName + &quot; &gt; &quot; + helloProperties.getSuffix(); &#125;&#125; 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.lun.hello.auto.HelloServiceAutoConfiguration 用maven插件，将两工程install到本地。 接下来，测试使用自定义starter，用Spring Initializr创建名为hello-spring-boot-starter-test工程，引入hello-spring-boot-starter依赖，其pom.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lun&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-spring-boot-starter-test&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入`hello-spring-boot-starter`依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lun&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 添加配置文件application.properties： 12hello.prefix=hellohello.suffix=666 添加单元测试类： 12345678910111213141516171819import com.lun.hello.service.HelloService;//来自自定义starterimport org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass HelloSpringBootStarterTestApplicationTests &#123; @Autowired private HelloService helloService; @Test void contextLoads() &#123; // System.out.println(helloService.sayHello(&quot;lun&quot;)); Assertions.assertEquals(&quot;hello: lun &gt; 666&quot;, helloService.sayHello(&quot;lun&quot;)); &#125;&#125; 84、原理解析-SpringApplication创建初始化流程SpringBoot启动过程Spring Boot应用的启动类： 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class HelloSpringBootStarterTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloSpringBootStarterTestApplication.class, args); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SpringApplication &#123; ... public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args); &#125; public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args); &#125; //先看看new SpringApplication(primarySources)，下一节再看看run() public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this(null, primarySources); &#125; public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //WebApplicationType是枚举类，有NONE,SERVLET,REACTIVE,下行webApplicationType是SERVLET this.webApplicationType = WebApplicationType.deduceFromClasspath(); //初始启动引导器，去spring.factories文件中找org.springframework.boot.Bootstrapper，但我找不到实现Bootstrapper接口的类 this.bootstrappers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class)); //去spring.factories找 ApplicationContextInitializer setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //去spring.factories找 ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); &#125; private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null; &#125; ... &#125; spring.factories： 1234567891011121314151617181920212223...# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\org.springframework.boot.context.ContextIdApplicationContextInitializer,\\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.ClearCachesApplicationListener,\\org.springframework.boot.builder.ParentContextCloserApplicationListener,\\org.springframework.boot.context.FileEncodingApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.context.logging.LoggingApplicationListener,\\org.springframework.boot.env.EnvironmentPostProcessorApplicationListener,\\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener... 85、原理解析-SpringBoot完整启动过程继续上一节，接着讨论return new SpringApplication(primarySources).run(args)的run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218public class SpringApplication &#123; ... public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch();//开始计时器 stopWatch.start();//开始计时 //1. //创建引导上下文（Context环境）createBootstrapContext() //获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置 DefaultBootstrapContext bootstrapContext = createBootstrapContext(); //2.到最后该方法会返回这context ConfigurableApplicationContext context = null; //3.让当前应用进入headless模式 configureHeadlessProperty(); //4.获取所有 RunListener（运行监听器）,为了方便所有Listener进行事件感知 SpringApplicationRunListeners listeners = getRunListeners(args); //5. 遍历 SpringApplicationRunListener 调用 starting 方法； // 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。 listeners.starting(bootstrapContext, this.mainApplicationClass); try &#123; //6.保存命令行参数 ApplicationArguments ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //7.准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); configureIgnoreBeanInfo(environment); /*打印标志 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.2) */ Banner printedBanner = printBanner(environment); // 创建IOC容器（createApplicationContext（）） // 根据项目类型webApplicationType（NONE,SERVLET,REACTIVE）创建容器， // 当前会创建 AnnotationConfigServletWebServerApplicationContext context = createApplicationContext(); context.setApplicationStartup(this.applicationStartup); //8.准备ApplicationContext IOC容器的基本信息 prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); //9.刷新IOC容器,创建容器中的所有组件,Spring框架的内容 refreshContext(context); //该方法没内容，大概为将来填入 afterRefresh(context, applicationArguments); stopWatch.stop();//停止计时 if (this.logStartupInfo) &#123;//this.logStartupInfo默认是true new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; //10. listeners.started(context); //11.调用所有runners callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; //13. handleRunFailure(context, ex, listeners); throw new IllegalStateException(ex); &#125; try &#123; //12. listeners.running(context); &#125; catch (Throwable ex) &#123; //13. handleRunFailure(context, ex, null); throw new IllegalStateException(ex); &#125; return context; &#125; //1. private DefaultBootstrapContext createBootstrapContext() &#123; DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext(); this.bootstrappers.forEach((initializer) -&gt; initializer.intitialize(bootstrapContext)); return bootstrapContext; &#125; //3. private void configureHeadlessProperty() &#123; //this.headless默认为true System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless))); &#125; private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;; //4. private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; //getSpringFactoriesInstances 去 spring.factories 找 SpringApplicationRunListener return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args), this.applicationStartup); &#125; //7.准备环境 private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123; // Create and configure the environment //返回或者创建基础环境信息对象，如：StandardServletEnvironment, StandardReactiveWebEnvironment ConfigurableEnvironment environment = getOrCreateEnvironment(); //配置环境信息对象,读取所有的配置源的配置属性值。 configureEnvironment(environment, applicationArguments.getSourceArgs()); //绑定环境信息 ConfigurationPropertySources.attach(environment); //7.1 通知所有的监听器当前环境准备完成 listeners.environmentPrepared(bootstrapContext, environment); DefaultPropertiesPropertySource.moveToEnd(environment); configureAdditionalProfiles(environment); bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment; &#125; //8. private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; //保存环境信息 context.setEnvironment(environment); //IOC容器的后置处理流程 postProcessApplicationContext(context); //应用初始化器 applyInitializers(context); //8.1 遍历所有的 listener 调用 contextPrepared。 //EventPublishRunListenr通知所有的监听器contextPrepared listeners.contextPrepared(context); bootstrapContext.close(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); //8.2 listeners.contextLoaded(context); &#125; //11.调用所有runners private void callRunners(ApplicationContext context, ApplicationArguments args) &#123; List&lt;Object&gt; runners = new ArrayList&lt;&gt;(); //获取容器中的 ApplicationRunner runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); //获取容器中的 CommandLineRunner runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); //合并所有runner并且按照@Order进行排序 AnnotationAwareOrderComparator.sort(runners); //遍历所有的runner。调用 run 方法 for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123; if (runner instanceof ApplicationRunner) &#123; callRunner((ApplicationRunner) runner, args); &#125; if (runner instanceof CommandLineRunner) &#123; callRunner((CommandLineRunner) runner, args); &#125; &#125; &#125; //13. private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception, SpringApplicationRunListeners listeners) &#123; try &#123; try &#123; handleExitCode(context, exception); if (listeners != null) &#123; //14. listeners.failed(context, exception); &#125; &#125; finally &#123; reportFailure(getExceptionReporters(context), exception); if (context != null) &#123; context.close(); &#125; &#125; &#125; catch (Exception ex) &#123; logger.warn(&quot;Unable to close ApplicationContext&quot;, ex); &#125; ReflectionUtils.rethrowRuntimeException(exception); &#125; ...&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041//2. new SpringApplication(primarySources).run(args) 最后返回的接口类型public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable &#123; String CONFIG_LOCATION_DELIMITERS = &quot;,; \\t\\n&quot;; String CONVERSION_SERVICE_BEAN_NAME = &quot;conversionService&quot;; String LOAD_TIME_WEAVER_BEAN_NAME = &quot;loadTimeWeaver&quot;; String ENVIRONMENT_BEAN_NAME = &quot;environment&quot;; String SYSTEM_PROPERTIES_BEAN_NAME = &quot;systemProperties&quot;; String SYSTEM_ENVIRONMENT_BEAN_NAME = &quot;systemEnvironment&quot;; String APPLICATION_STARTUP_BEAN_NAME = &quot;applicationStartup&quot;; String SHUTDOWN_HOOK_THREAD_NAME = &quot;SpringContextShutdownHook&quot;; void setId(String var1); void setParent(@Nullable ApplicationContext var1); void setEnvironment(ConfigurableEnvironment var1); ConfigurableEnvironment getEnvironment(); void setApplicationStartup(ApplicationStartup var1); ApplicationStartup getApplicationStartup(); void addBeanFactoryPostProcessor(BeanFactoryPostProcessor var1); void addApplicationListener(ApplicationListener&lt;?&gt; var1); void setClassLoader(ClassLoader var1); void addProtocolResolver(ProtocolResolver var1); void refresh() throws BeansException, IllegalStateException; void registerShutdownHook(); void close(); boolean isActive(); ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;&#125; 12345#4.#spring.factories# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class SpringApplicationRunListeners &#123; private final Log log; private final List&lt;SpringApplicationRunListener&gt; listeners; private final ApplicationStartup applicationStartup; SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners, ApplicationStartup applicationStartup) &#123; this.log = log; this.listeners = new ArrayList&lt;&gt;(listeners); this.applicationStartup = applicationStartup; &#125; //5.遍历 SpringApplicationRunListener 调用 starting 方法； //相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。 void starting(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass) &#123; doWithListeners(&quot;spring.boot.application.starting&quot;, (listener) -&gt; listener.starting(bootstrapContext), (step) -&gt; &#123; if (mainApplicationClass != null) &#123; step.tag(&quot;mainApplicationClass&quot;, mainApplicationClass.getName()); &#125; &#125;); &#125; //7.1 void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123; doWithListeners(&quot;spring.boot.application.environment-prepared&quot;, (listener) -&gt; listener.environmentPrepared(bootstrapContext, environment)); &#125; //8.1 void contextPrepared(ConfigurableApplicationContext context) &#123; doWithListeners(&quot;spring.boot.application.context-prepared&quot;, (listener) -&gt; listener.contextPrepared(context)); &#125; //8.2 void contextLoaded(ConfigurableApplicationContext context) &#123; doWithListeners(&quot;spring.boot.application.context-loaded&quot;, (listener) -&gt; listener.contextLoaded(context)); &#125; //10. void started(ConfigurableApplicationContext context) &#123; doWithListeners(&quot;spring.boot.application.started&quot;, (listener) -&gt; listener.started(context)); &#125; //12. void running(ConfigurableApplicationContext context) &#123; doWithListeners(&quot;spring.boot.application.running&quot;, (listener) -&gt; listener.running(context)); &#125; //14. void failed(ConfigurableApplicationContext context, Throwable exception) &#123; doWithListeners(&quot;spring.boot.application.failed&quot;, (listener) -&gt; callFailedListener(listener, context, exception), (step) -&gt; &#123; step.tag(&quot;exception&quot;, exception.getClass().toString()); step.tag(&quot;message&quot;, exception.getMessage()); &#125;); &#125; private void doWithListeners(String stepName, Consumer&lt;SpringApplicationRunListener&gt; listenerAction, Consumer&lt;StartupStep&gt; stepAction) &#123; StartupStep step = this.applicationStartup.start(stepName); this.listeners.forEach(listenerAction); if (stepAction != null) &#123; stepAction.accept(step); &#125; step.end(); &#125; ... &#125; 86、原理解析-自定义事件监听组件MyApplicationContextInitializer.java 123456789import org.springframework.context.ApplicationContextInitializer;import org.springframework.context.ConfigurableApplicationContext;public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(&quot;MyApplicationContextInitializer ....initialize.... &quot;); &#125;&#125; MyApplicationListener.java 123456789import org.springframework.context.ApplicationEvent;import org.springframework.context.ApplicationListener;public class MyApplicationListener implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; System.out.println(&quot;MyApplicationListener.....onApplicationEvent...&quot;); &#125;&#125; MyApplicationRunner.java 1234567891011121314import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Order(1)@Component//放入容器public class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;MyApplicationRunner...run...&quot;); &#125;&#125; MyCommandLineRunner.java 1234567891011121314import org.springframework.boot.CommandLineRunner;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;/** * 应用启动做一个一次性事情 */@Order(2)@Component//放入容器public class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(&quot;MyCommandLineRunner....run....&quot;); &#125;&#125; MySpringApplicationRunListener.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.boot.ConfigurableBootstrapContext;import org.springframework.boot.SpringApplication;import org.springframework.boot.SpringApplicationRunListener;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.core.env.ConfigurableEnvironment;public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123; private SpringApplication application; public MySpringApplicationRunListener(SpringApplication application, String[] args)&#123; this.application = application; &#125; @Override public void starting(ConfigurableBootstrapContext bootstrapContext) &#123; System.out.println(&quot;MySpringApplicationRunListener....starting....&quot;); &#125; @Override public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123; System.out.println(&quot;MySpringApplicationRunListener....environmentPrepared....&quot;); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(&quot;MySpringApplicationRunListener....contextPrepared....&quot;); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(&quot;MySpringApplicationRunListener....contextLoaded....&quot;); &#125; @Override public void started(ConfigurableApplicationContext context) &#123; System.out.println(&quot;MySpringApplicationRunListener....started....&quot;); &#125; @Override public void running(ConfigurableApplicationContext context) &#123; System.out.println(&quot;MySpringApplicationRunListener....running....&quot;); &#125; @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(&quot;MySpringApplicationRunListener....failed....&quot;); &#125;&#125; 注册MyApplicationContextInitializer，MyApplicationListener，MySpringApplicationRunListener: resources / META-INF / spring.factories: 12345678org.springframework.context.ApplicationContextInitializer=\\ com.lun.boot.listener.MyApplicationContextInitializerorg.springframework.context.ApplicationListener=\\ com.lun.boot.listener.MyApplicationListenerorg.springframework.boot.SpringApplicationRunListener=\\ com.lun.boot.listener.MySpringApplicationRunListener 87、后会有期 路漫漫其修远兮，吾将上下而求索。 纸上得来终觉浅，绝知此事要躬行。 Spring Boot 2 场景整合篇 虚拟化技术 安全控制 缓存技术 消息中间件 对象存储 定时调度 异步任务 分布式系统 Spring Boot 2 响应式编程 响应式编程基础 Webflux开发Web应用 响应式访问持久化层 响应式安全开发 响应式原理","tags":"springboot"},{"title":"SpringBoot-01","url":"/2023/10/12/springboot01/","text":"01、基础入门-SpringBoot2课程介绍SpringBoot2核心技术与响应式编程 · 语雀 (yuque.com) Spring Boot 2核心技术 Spring Boot 2响应式编程 学习要求 -熟悉Spring基础 -熟悉Maven使用 环境要求 Java8及以上 Maven 3.3及以上 学习资料 Spring Boot官网 Spring Boot官方文档 本课程文档地址 视频地址1、视频地址2 源码地址 02、基础入门-Spring生态圈Spring官网 Spring能做什么Spring的能力 Spring的生态覆盖了： web开发 数据访问 安全控制 分布式 消息服务 移动开发 批处理 …… Spring5重大升级 响应式编程 内部源码设计 基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。 为什么用SpringBoot Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.link 能快速创建出生产级别的Spring应用。 SpringBoot优点 Create stand-alone Spring applications 创建独立Spring应用 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌web服务器 Provide opinionated ‘starter’ dependencies to simplify your build configuration 自动starter依赖，简化构建配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring以及第三方功能 Provide production-ready features such as metrics, health checks, and externalized configuration 提供生产级别的监控、健康检查及外部化配置 Absolutely no code generation and no requirement for XML configuration 无代码生成、无需编写XML SpringBoot是整合Spring技术栈的一站式框架 SpringBoot是简化Spring技术栈的快速开发脚手架 SpringBoot缺点 人称版本帝，迭代快，需要时刻关注变化 封装太深，内部原理复杂，不容易精通 03、基础入门-SpringBoot的大时代背景微服务 In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.——James Lewis and Martin Fowler (2014) 微服务是一种架构风格 一个应用拆分为一组小型服务 每个服务运行在自己的进程内，也就是可独立部署和升级 服务之间使用轻量级HTTP交互 服务围绕业务功能拆分 可以由全自动部署机制独立部署 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术 分布式 分布式的困难 远程调用 服务发现 负载均衡 服务容错 配置管理 服务监控 链路追踪 日志管理 任务调度 …… 分布式的解决 SpringBoot + SpringCloud 云原生原生应用如何上云。 Cloud Native 上云的困难 服务自愈 弹性伸缩 服务隔离 自动化部署 灰度发布 流量治理 …… 上云的解决 04、基础入门-SpringBoot官方文档架构 Spring Boot官网 Spring Boot官方文档 官网文档架构 查看版本新特性 05、基础入门-SpringBoot-HelloWorld系统要求 Java 8 Maven 3.3+ IntelliJ IDEA 2019.1.2 Maven配置文件新添内容： 12345678910111213141516171819202122232425&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; HelloWorld项目需求：浏览发送&#x2F;hello请求，响应 “Hello，Spring Boot 2” 创建maven工程引入依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建主程序1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125;&#125; 编写业务12345678910import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01()&#123; return &quot;Hello, Spring Boot 2!&quot;; &#125;&#125; 运行&amp;测试 运行MainApplication类 浏览器输入http://localhost:8888/hello，将会输出Hello, Spring Boot 2!。 设置配置maven工程的resource文件夹中创建application.properties文件。 12# 设置端口号server.port=8888 更多配置信息 打包部署在pom.xml添加 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包， 打包好的jar包被生成在helloworld工程项目的target文件夹内。 用cmd运行java -jar boot-01-helloworld-1.0-SNAPSHOT.jar，既可以运行helloworld工程项目。 将jar包直接在目标服务器执行即可。 出现卡顿–&gt;cmd属性关闭快速编辑模式 06、基础入门-SpringBoot-依赖管理特性 父项目做依赖管理 123456789101112131415依赖管理&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;上面项目的父项目如下：&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt;它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制 开发导入starter场景启动器 见到很多 spring-boot-starter-* ： *代表就某种场景 只要引入starter，这个场景的所有常规需要的依赖我们都会自动引入 更多SpringBoot所有支持的场景 见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。 1234567所有场景启动器最底层的依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 无需关注版本号，自动版本仲裁 引入依赖默认都可以不写版本 引入非版本仲裁的jar，要写版本号。 可以修改默认版本号 查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。 在当前项目里面重写配置，如下面的代码。 123456&lt;properties&gt; &lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;&lt;/properties&gt;或直接使用&lt;version&gt;&lt;/version&gt; IDEA快捷键： ctrl + shift + alt + U：以图的方式显示项目中依赖之间的关系。 alt + ins：相当于Eclipse的 Ctrl + N，创建新类，新包等。 ctrl+f查找 ctrl+R替换 shift两下查找 07、基础入门-SpringBoot-自动配置特性 自动配好Tomcat 引入Tomcat依赖。 配置Tomcat 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 自动配好SpringMVC 引入SpringMVC全套组件 自动配好SpringMVC常用组件（功能） 自动配好Web常见功能，如：字符编码问题 SpringBoot帮我们配置好了所有web开发的常见场景 12345678910public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125;&#125; 默认的包结构 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来 无需以前的包扫描配置 想要改变扫描路径 @SpringBootApplication(scanBasePackages&#x3D;”com.lun”) @ComponentScan 指定扫描路径 1234567@SpringBootApplication等同于 @SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.lun&quot;) 各种配置拥有默认值 默认配置最终都是映射到某个类上，如：MultipartProperties 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象 按需加载所有自动配置项 - 非常多的starter - 引入了哪些场景这个场景的自动配置才会开启 - SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面 …… 08、底层注解-@Configuration详解 基本使用 Full模式与Lite模式 示例 123456789101112131415161718192021222324252627/** * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的 * 2、配置类本身也是组件 * 3、proxyBeanMethods：代理bean的方法 * Full(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认） * Lite(proxyBeanMethods = false)（每个@Bean方法被调用多少次返回的组件都是新创建的） */@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123; /** * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象 * @return */ @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例 public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); //user组件依赖了Pet组件 zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125;&#125; @Configuration测试代码如下: 123456789101112131415161718192021222324252627282930313233343536@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&quot;com.atguigu.boot&quot;)public class MainApplication &#123; public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; //3、从容器中获取组件 Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class); Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。 //保持组件单实例 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); User user01 = run.getBean(&quot;user01&quot;, User.class); Pet tom = run.getBean(&quot;tom&quot;, Pet.class); System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom)); &#125;&#125; 最佳实战 配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置 类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式（默认） lite 英 [laɪt] 美 [laɪt]adj. 低热量的，清淡的(light的一种拼写方法);类似…的劣质品 IDEA快捷键： Alt + Ins:生成getter，setter、构造器等代码。 Ctrl + Alt + B:查看类的具体实现代码。 09、底层注解-@Import导入组件@Bean、@Component、@Controller、@Service、@Repository，它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能。 @ComponentScan 在07、基础入门-SpringBoot-自动配置特性有用例。 @Import({User.class, DBHelper.class})给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名 1234@Import(&#123;User.class, DBHelper.class&#125;)@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123;&#125; 测试类： 123456789101112131415//1、返回我们IOC容器ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);//...//5、获取组件String[] beanNamesForType = run.getBeanNamesForType(User.class);for (String s : beanNamesForType) &#123; System.out.println(s);&#125;DBHelper bean1 = run.getBean(DBHelper.class);System.out.println(bean1); 10、底层注解-@Conditional条件装配条件装配：满足Conditional指定的条件，则进行组件注入 用@ConditionalOnMissingBean举例说明 12345678910111213141516171819202122232425262728293031323334353637@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(name = &quot;tom&quot;)//没有tom名字的Bean时，MyConfig类的Bean才能生效。public class MyConfig &#123; @Bean public User user01()&#123; User zhangsan = new User(&quot;zhangsan&quot;, 18); zhangsan.setPet(tomcatPet()); return zhangsan; &#125; @Bean(&quot;tom22&quot;) public Pet tomcatPet()&#123; return new Pet(&quot;tomcat&quot;); &#125;&#125;public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); //2、查看容器里面的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; boolean tom = run.containsBean(&quot;tom&quot;); System.out.println(&quot;容器中Tom组件：&quot;+tom);//false boolean user01 = run.containsBean(&quot;user01&quot;); System.out.println(&quot;容器中user01组件：&quot;+user01);//true boolean tom22 = run.containsBean(&quot;tom22&quot;); System.out.println(&quot;容器中tom22组件：&quot;+tom22);//true&#125; 11、底层注解-@ImportResource导入Spring配置文件比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。 bean.xml： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans ...&quot;&gt; &lt;bean id=&quot;haha&quot; class=&quot;com.lun.boot.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;hehe&quot; class=&quot;com.lun.boot.bean.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 使用方法： 1234@ImportResource(&quot;classpath:beans.xml&quot;)public class MyConfig &#123;...&#125; 测试类： 123456789public static void main(String[] args) &#123; //1、返回我们IOC容器 ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args); boolean haha = run.containsBean(&quot;haha&quot;); boolean hehe = run.containsBean(&quot;hehe&quot;); System.out.println(&quot;haha：&quot;+haha);//true System.out.println(&quot;hehe：&quot;+hehe);//true&#125; 12、底层注解-@ConfigurationProperties配置绑定如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用 传统方法： 12345678910111213public class getProperties &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Properties pps = new Properties(); pps.load(new FileInputStream(&quot;a.properties&quot;)); Enumeration enum1 = pps.propertyNames();//得到配置文件的名字 while(enum1.hasMoreElements()) &#123; String strKey = (String) enum1.nextElement(); String strValue = pps.getProperty(strKey); System.out.println(strKey + &quot;=&quot; + strValue); //封装到JavaBean。 &#125; &#125; &#125; Spring Boot一种配置配置绑定： @ConfigurationProperties + @Component 假设有配置文件application.properties 12mycar.brand=BYDmycar.price=100000 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 12345@Component@ConfigurationProperties(prefix = &quot;mycar&quot;)public class Car &#123;...&#125; Spring Boot另一种配置配置绑定： @EnableConfigurationProperties + @ConfigurationProperties 开启Car配置绑定功能 把这个Car这个组件自动注册到容器中 1234@EnableConfigurationProperties(Car.class)public class MyConfig &#123;...&#125; 1234@ConfigurationProperties(prefix = &quot;mycar&quot;)public class Car &#123;...&#125; 13、自动配置【源码分析】-自动包规则原理Spring Boot应用的启动类： 12345678@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125;&#125; 分析下@SpringBootApplication 123456789101112131415161718@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; ...&#125; 重点分析@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan。 @SpringBootConfiguration12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; @Configuration代表当前是一个配置类。 @ComponentScan指定扫描哪些Spring注解。 @ComponentScan 在07、基础入门-SpringBoot-自动配置特性有用例。 @EnableAutoConfiguration12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 重点分析@AutoConfigurationPackage，@Import(AutoConfigurationImportSelector.class)。 @AutoConfigurationPackage标签名直译为：自动配置包，指定了默认的包规则。 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)//给容器中导入一个组件public @interface AutoConfigurationPackage &#123; String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; 利用Registrar给容器中导入一系列组件 得到主启动类所在包名，并将该指定的一个包下的所有组件导入进MainApplication所在包下。 14、自动配置【源码分析】-初始加载自动配置类@Import(AutoConfigurationImportSelector.class) 在AutoConfigurationImportSelector类中利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件 调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类 利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader);得到所有的组件 从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 1234567# 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类# spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\... 虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是xxxxAutoConfiguration按照条件装配规则（@Conditional），最终会按需配置。 如AopAutoConfiguration类： 1234567891011121314@Configuration( proxyBeanMethods = false)@ConditionalOnProperty( prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)public class AopAutoConfiguration &#123; public AopAutoConfiguration() &#123; &#125; ...&#125; 15、自动配置【源码分析】-自动配置流程以DispatcherServletAutoConfiguration的内部类DispatcherServletConfiguration为例子: 123456789@Bean@ConditionalOnBean(MultipartResolver.class) //容器中有这个类型组件@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件public MultipartResolver multipartResolver(MultipartResolver resolver) &#123; //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver;//给容器中加入了文件上传解析器；&#125; SpringBoot默认会在底层配好所有的组件，但是如果用户自己配置了以用户的优先。 总结： SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定） 生效的配置类就会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能就有了 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改。 xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值 —-&gt; application.properties 16、最佳实践-SpringBoot应用如何编写 引入场景依赖 官方文档 查看自动配置了哪些（选做） 自己分析，引入场景对应的自动配置一般都生效了 配置文件中debug&#x3D;true开启自动配置报告。 Negative（不生效） Positive（生效） 是否需要修改 参照文档修改配置项 官方文档 自己分析。xxxxProperties绑定了配置文件的哪些。 自定义加入或者替换组件 @Bean、@Component… 自定义器 XXXXXCustomizer； …… 17、最佳实践-Lombok简化开发Lombok用标签方式代替构造器、getter&#x2F;setter、toString()等鸡肋代码。 spring boot已经管理Lombok。引入依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; IDEA中File-&gt;Settings-&gt;Plugins，搜索安装Lombok插件。 1234567891011121314151617@NoArgsConstructor//@AllArgsConstructor@Data@ToString@EqualsAndHashCodepublic class User &#123; private String name; private Integer age; private Pet pet; public User(String name,Integer age)&#123; this.name = name; this.age = age; &#125;&#125; 简化日志开发 123456789@Slf4j@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String handle01(@RequestParam(&quot;name&quot;) String name)&#123; log.info(&quot;请求进来了....&quot;); return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name; &#125;&#125; 18、最佳实践-dev-tools Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The spring-boot-devtools module can be included in any project to provide additional development-time features.——link Applications that use spring-boot-devtools automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, do not need to restart the application.——link Triggering a restart As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using: In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project (Build -&gt; Build Project)(shortcut: Ctrl+F9) has the same effect. 添加依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在IDEA中，项目或者页面修改以后：Ctrl+F9。 19、最佳实践-Spring InitailizrSpring Initailizr是创建Spring Boot工程向导。 在IDEA中，菜单栏New -&gt; Project -&gt; Spring Initailizr。 已经帮助我们引入了依赖，创建好了项目结构 20、配置文件-yaml的用法同以前的properties用法 YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。 非常适合用来做以数据为中心的配置文件。 基本语法 key: value；kv之间有空格 大小写敏感 使用缩进表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 ‘#’表示注释 字符串无需加引号，如果要加，单引号’’、双引号””表示字符串内容会被 转义、不转义 数据类型 字面量：单个的、不可再分的值。date、boolean、string、number、null 1k: v 对象：键值对的集合。map、hash、set、object 12345678910#行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;#或k: k1: v1 k2: v2 k3: v3 数组：一组按次序排列的值。array、list、queue 12345678910#行内写法： k: [v1,v2,v3]#或者k: - v1 - v2 - v3 实例12345678910111213141516171819@Datapublic class Person &#123; private String userName; private Boolean boss; private Date birth; private Integer age; private Pet pet; private String[] interests; private List&lt;String&gt; animal; private Map&lt;String, Object&gt; score; private Set&lt;Double&gt; salarys; private Map&lt;String, List&lt;Pet&gt;&gt; allPets;&#125;@Datapublic class Pet &#123; private String name; private Double weight;&#125; 用yaml表示以上对象 12345678910111213141516171819202122232425person: userName: zhangsan boss: false birth: 2019/12/12 20:12:33 age: 18 pet: name: tomcat weight: 23.4 interests: [篮球,游泳] animal: - jerry - mario score: english: first: 30 second: 40 third: 50 math: [131,140,148] chinese: &#123;first: 128,second: 136&#125; salarys: [3999,4999.98,5999.99] allPets: sick: - &#123;name: tom&#125; - &#123;name: jerry,weight: 47&#125; health: [&#123;name: mario,weight: 47&#125;] 21、配置文件-自定义类绑定的配置提示 You can easily generate your own configuration metadata file from items annotated with @ConfigurationProperties by using the spring-boot-configuration-processor jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——link 自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖： 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 22、web场景-web开发简介springMVC自动配置概览 Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 WebMvcRegistrations 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC 23、web场景-静态资源规则与定制化静态资源目录只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources 访问 ： 当前项目根路径&#x2F; + 静态资源名 原理： 静态映射&#x2F;**。 请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。 也可以改变默认的静态资源路径，/static，/public,/resources, /META-INF/resources失效 12resources: static-locations: [classpath:/haha/] 静态资源访问前缀123spring: mvc: static-path-pattern: /res/** 当前项目 + static-path-pattern + 静态资源名 &#x3D; 静态资源文件夹下找 webjar可用jar方式添加css，js等资源文件， https://www.webjars.org/ 例如，添加jquery 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 访问地址：http://localhost:8080/webjars/jquery&#x2F;3.5.1&#x2F;jquery.js 后面地址要按照依赖里面的包路径。 24、web场景-welcome与favicon功能官方文档 欢迎页支持 静态资源路径下 index.html。 可以配置静态资源路径 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问 12345spring:# mvc:# static-path-pattern: /res/** 这个会导致welcome page功能失效 resources: static-locations: [classpath:/haha/] controller能处理&#x2F;index。 自定义Favicon指网页标签上的小图标。 favicon.ico 放在静态资源目录下即可。 123spring:# mvc:# static-path-pattern: /res/** 这个会导致 Favicon 功能失效 25、web场景-【源码分析】-静态资源原理 SpringBoot启动默认加载 xxxAutoConfiguration 类（自动配置类） SpringMVC功能的自动配置类WebMvcAutoConfiguration，生效 12345678910@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; ...&#125; 给容器中配置的内容： 配置文件的相关属性的绑定：WebMvcProperties&#x3D;&#x3D;spring.mvc、ResourceProperties&#x3D;&#x3D;spring.resources 1234567@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123; ...&#125; 配置类只有一个有参构造器1234567891011121314////有参构造器所有参数的值都会从容器中确定public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123; this.resourceProperties = resourceProperties; this.mvcProperties = mvcProperties; this.beanFactory = beanFactory; this.messageConvertersProvider = messageConvertersProvider; this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable(); this.dispatcherServletPath = dispatcherServletPath; this.servletRegistrations = servletRegistrations; &#125; ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象 WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象 ListableBeanFactory beanFactory Spring的beanFactory HttpMessageConverters 找到所有的HttpMessageConverters ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。 DispatcherServletPath ServletRegistrationBean 给应用注册Servlet、Filter…. 资源处理的默认规则123456789101112131415161718192021222324252627282930...public class WebMvcAutoConfiguration &#123; ... public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; ... @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); //wevjars的规则 if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; 根据上述代码，我们可以同过配置禁止所有静态资源规则。 123spring: resources: add-mappings: false #禁用所有静态资源规则 静态资源规则： 1234567891011121314@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; ...&#125; 欢迎页的处理规则12345678910111213141516...public class WebMvcAutoConfiguration &#123; ... public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; ... @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping; &#125; WelcomePageHandlerMapping的构造方法如下： 12345678910111213WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123; if (welcomePage != null &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123; //要用欢迎页功能，必须是/** logger.info(&quot;Adding welcome page: &quot; + welcomePage); setRootViewName(&quot;forward:index.html&quot;); &#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; //调用Controller /index logger.info(&quot;Adding welcome page template: index&quot;); setRootViewName(&quot;index&quot;); &#125;&#125; 这构造方法内的代码也解释了web场景-welcome与favicon功能中配置static-path-pattern了，welcome页面和小图标失效的问题。 26、请求处理-【源码分析】-Rest映射及源码解析请求映射 @xxxMapping; @GetMapping @PostMapping @PutMapping @DeleteMapping Rest风格支持（使用HTTP请求方式动词来表示对资源的操作） 以前： &#x2F;getUser 获取用户 &#x2F;deleteUser 删除用户 &#x2F;editUser 修改用户 &#x2F;saveUser保存用户 现在： &#x2F;user GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户 核心Filter；HiddenHttpMethodFilter 用法 开启页面表单的Rest功能 页面 form的属性method&#x3D;post，隐藏域 _method&#x3D;put、delete等（如果直接get或post，无需隐藏域） 编写请求映射 12345678spring: mvc: hiddenmethod: filter: enabled: true #开启页面表单的Rest功能 相当于之前springMVC在web.xml注册HiddenHttpMethodFilter过滤器 1234567891011121314151617&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt; &lt;input value=&quot;REST-GET提交&quot; type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input value=&quot;REST-POST提交&quot; type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;/&gt; &lt;input value=&quot;REST-DELETE 提交&quot; type=&quot;submit&quot;/&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot; /&gt; &lt;input value=&quot;REST-PUT提交&quot;type=&quot;submit&quot; /&gt;&lt;/form&gt; 1234567891011121314151617181920212223@GetMapping(&quot;/user&quot;)//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)public String getUser()&#123; return &quot;GET-张三&quot;;&#125;@PostMapping(&quot;/user&quot;)//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)public String saveUser()&#123; return &quot;POST-张三&quot;;&#125;@PutMapping(&quot;/user&quot;)//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)public String putUser()&#123; return &quot;PUT-张三&quot;;&#125;@DeleteMapping(&quot;/user&quot;)//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)public String deleteUser()&#123; return &quot;DELETE-张三&quot;;&#125; Rest原理（表单提交要使用REST的时候） 表单提交会带上\\_method=PUT 请求过来被HiddenHttpMethodFilter拦截 请求是否正常，并且是POST 获取到\\_method的值。 兼容以下请求；PUT.DELETE.PATCH 原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class HiddenHttpMethodFilter extends OncePerRequestFilter &#123; private static final List&lt;String&gt; ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name())); /** Default method parameter: &#123;@code _method&#125;. */ public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;; private String methodParam = DEFAULT_METHOD_PARAM; /** * Set the parameter name to look for HTTP methods. * @see #DEFAULT_METHOD_PARAM */ public void setMethodParam(String methodParam) &#123; Assert.hasText(methodParam, &quot;&#x27;methodParam&#x27; must not be empty&quot;); this.methodParam = methodParam; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; HttpServletRequest requestToUse = request; if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; String method = paramValue.toUpperCase(Locale.ENGLISH); if (ALLOWED_METHODS.contains(method)) &#123; requestToUse = new HttpMethodRequestWrapper(request, method); &#125; &#125; &#125; filterChain.doFilter(requestToUse, response); &#125; /** * Simple &#123;@link HttpServletRequest&#125; wrapper that returns the supplied method for * &#123;@link HttpServletRequest#getMethod()&#125;. */ private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123; private final String method; public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123; super(request); this.method = method; &#125; @Override public String getMethod() &#123; return this.method; &#125; &#125;&#125; Rest使用客户端工具。 如PostMan可直接发送put、delete等方式请求。 27、请求处理-【源码分析】-怎么改变默认的_method123456789101112131415161718192021@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; ... @Bean @ConditionalOnMissingBean(HiddenHttpMethodFilter.class) @ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false) public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123; return new OrderedHiddenHttpMethodFilter(); &#125; ...&#125; @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)意味着在没有HiddenHttpMethodFilter时，才执行hiddenHttpMethodFilter()。因此，我们可以自定义filter，改变默认的\\_method。例如： 12345678910@Configuration(proxyBeanMethods = false)public class WebConfig&#123; //自定义filter @Bean public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123; HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter(); methodFilter.setMethodParam(&quot;_m&quot;); return methodFilter; &#125; &#125; 将\\_method改成_m。 1234&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_m&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;/&gt; &lt;input value=&quot;REST-DELETE 提交&quot; type=&quot;submit&quot;/&gt;&lt;/form&gt; 28、请求处理-【源码分析】-请求映射原理SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet -&gt; doDispatch() 123456789101112131415161718192021protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 找到当前请求使用哪个Handler（Controller的方法）处理 mappedHandler = getHandler(processedRequest); //HandlerMapping：处理器映射。/xxx-&gt;&gt;xxxx ...&#125; getHandler()方法如下： 123456789101112@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; this.handlerMappings在Debug模式下展现的内容： 其中，RequestMappingHandlerMapping保存了所有@RequestMapping 和handler的映射规则。 所有的请求映射都在HandlerMapping中： SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 &#x2F;能访问到index.html； SpringBoot自动配置了默认 的 RequestMappingHandlerMapping 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。 如果有就找到这个请求对应的handler 如果没有就是下一个 HandlerMapping 我们需要一些自定义的映射处理，我们也可以自己给容器中放HandlerMapping。自定义 HandlerMapping IDEA快捷键： Ctrl + Alt + U : 以UML的类图展现类有哪些继承类，派生类以及实现哪些接口。 Crtl + Alt + Shift + U : 同上，区别在于上条快捷键结果在新页展现，而本条快捷键结果在弹窗展现。 Ctrl + H : 以树形方式展现类层次结构图。 29、请求处理-常用参数注解使用注解： @PathVariable 路径变量 @RequestHeader 获取请求头 @RequestParam 获取请求参数（指问号后的参数，url?a&#x3D;1&amp;b&#x3D;2） @CookieValue 获取Cookie值 @RequestAttribute 获取request域属性 @RequestBody 获取请求体[POST] @MatrixVariable 矩阵变量 @ModelAttribute 使用用例： 12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class ParameterTestController &#123; // car/2/owner/zhangsan @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;) public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String name, @PathVariable Map&lt;String,String&gt; pv, @RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader Map&lt;String,String&gt; header, @RequestParam(&quot;age&quot;) Integer age, @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters, @RequestParam Map&lt;String,String&gt; params, @CookieValue(&quot;_ga&quot;) String _ga, @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();// map.put(&quot;id&quot;,id);// map.put(&quot;name&quot;,name);// map.put(&quot;pv&quot;,pv);// map.put(&quot;userAgent&quot;,userAgent);// map.put(&quot;headers&quot;,header); map.put(&quot;age&quot;,age); map.put(&quot;inters&quot;,inters); map.put(&quot;params&quot;,params); map.put(&quot;_ga&quot;,_ga); System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue()); return map; &#125; @PostMapping(&quot;/save&quot;) public Map postMethod(@RequestBody String content)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;,content); return map; &#125;&#125; 30、请求处理-@RequestAttribute用例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Controllerpublic class RequestController &#123; @GetMapping(&quot;/goto&quot;) public String goToPage(HttpServletRequest request)&#123; request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;); request.setAttribute(&quot;code&quot;,200); return &quot;forward:/success&quot;; //转发到 /success请求 &#125; @GetMapping(&quot;/params&quot;) public String testParam(Map&lt;String,Object&gt; map, Model model, HttpServletRequest request, HttpServletResponse response)&#123; map.put(&quot;hello&quot;,&quot;world666&quot;); model.addAttribute(&quot;world&quot;,&quot;hello666&quot;); request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;); Cookie cookie = new Cookie(&quot;c1&quot;,&quot;v1&quot;); response.addCookie(cookie); return &quot;forward:/success&quot;; &#125; ///&lt;-----------------主角@RequestAttribute在这个方法 @ResponseBody @GetMapping(&quot;/success&quot;) public Map success(@RequestAttribute(value = &quot;msg&quot;,required = false) String msg, @RequestAttribute(value = &quot;code&quot;,required = false)Integer code, HttpServletRequest request)&#123; Object msg1 = request.getAttribute(&quot;msg&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); Object hello = request.getAttribute(&quot;hello&quot;); Object world = request.getAttribute(&quot;world&quot;); Object message = request.getAttribute(&quot;message&quot;); map.put(&quot;reqMethod_msg&quot;,msg1); map.put(&quot;annotation_msg&quot;,msg); map.put(&quot;hello&quot;,hello); map.put(&quot;world&quot;,world); map.put(&quot;message&quot;,message); return map; &#125;&#125; 31、请求处理-@MatrixVariable与UrlPathHelper 语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd SpringBoot默认是禁用了矩阵变量的功能 手动开启：原理。对于路径的处理。UrlPathHelper的removeSemicolonContent设置为false，让其支持矩阵变量的。 矩阵变量必须有url路径变量才能被解析 手动开启矩阵变量： 实现WebMvcConfigurer接口： 1234567891011@Configuration(proxyBeanMethods = false)public class WebConfig implements WebMvcConfigurer &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 不移除；后面的内容。矩阵变量功能就可以生效 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125;&#125; 创建返回WebMvcConfigurerBean： 123456789101112131415@Configuration(proxyBeanMethods = false)public class WebConfig&#123; @Bean public WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper = new UrlPathHelper(); // 不移除；后面的内容。矩阵变量功能就可以生效 urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125; &#125; &#125;&#125; @MatrixVariable的用例 123456789101112131415161718192021222324252627282930@RestControllerpublic class ParameterTestController &#123; ///cars/sell;low=34;brand=byd,audi,yd @GetMapping(&quot;/cars/&#123;path&#125;&quot;) public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low, @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand, @PathVariable(&quot;path&quot;) String path)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;low&quot;,low); map.put(&quot;brand&quot;,brand); map.put(&quot;path&quot;,path); return map; &#125; // /boss/1;age=20/2;age=10 @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;) public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge, @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;bossAge&quot;,bossAge); map.put(&quot;empAge&quot;,empAge); return map; &#125;&#125; 32、请求处理-【源码分析】-各种类型参数解析原理这要从DispatcherServlet开始说起： 123456789101112131415161718192021222324252627public class DispatcherServlet extends FrameworkServlet &#123; protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); ... HandlerMapping中找到能处理请求的Handler（Controller.method()）。 为当前Handler 找一个适配器 HandlerAdapter，用的最多的是RequestMappingHandlerAdapter。 适配器执行目标方法并确定方法参数的每一个值。 HandlerAdapter默认会加载所有HandlerAdapter 123456789101112131415161718192021public class DispatcherServlet extends FrameworkServlet &#123; /** Detect all HandlerAdapters or just expect &quot;handlerAdapter&quot; bean?. */ private boolean detectAllHandlerAdapters = true; ... private void initHandlerAdapters(ApplicationContext context) &#123; this.handlerAdapters = null; if (this.detectAllHandlerAdapters) &#123; // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values()); // We keep HandlerAdapters in sorted order. AnnotationAwareOrderComparator.sort(this.handlerAdapters); &#125; &#125; ... 有这些HandlerAdapter： 支持方法上标注@RequestMapping 支持函数式编程的 … … 执行目标方法123456789101112131415161718192021public class DispatcherServlet extends FrameworkServlet &#123; protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = null; ... // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); ... //本节重点 // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); HandlerAdapter接口实现类RequestMappingHandlerAdapter（主要用来处理@RequestMapping） 12345678910111213141516171819202122public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ... //AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; @Override protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; //handleInternal的核心 mav = invokeHandlerMethod(request, response, handlerMethod);//解释看下节 //... return mav; &#125;&#125; 参数解析器确定将要执行的目标方法的每一个参数的值是什么; SpringMVC目标方法能写多少种参数类型。取决于参数解析器argumentResolvers。 123456789101112131415@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123;//&lt;-----关注点 invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; ... this.argumentResolvers在afterPropertiesSet()方法内初始化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; @Nullable private HandlerMethodArgumentResolverComposite argumentResolvers; @Override public void afterPropertiesSet() &#123; ... if (this.argumentResolvers == null) &#123;//初始化argumentResolvers List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; ... &#125; //初始化了一堆的实现HandlerMethodArgumentResolver接口的 private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;&gt;(30); // Annotation-based argument resolution resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); // Type-based argument resolution resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); if (KotlinDetector.isKotlinPresent()) &#123; resolvers.add(new ContinuationHandlerMethodArgumentResolver()); &#125; // Custom arguments if (getCustomArgumentResolvers() != null) &#123; resolvers.addAll(getCustomArgumentResolvers()); &#125; // Catch-all resolvers.add(new PrincipalMethodArgumentResolver()); resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers; &#125; &#125; HandlerMethodArgumentResolverComposite类如下：（众多参数解析器argumentResolvers的包装类）。 1234567891011121314151617public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123; private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = new ArrayList&lt;&gt;(); ... public HandlerMethodArgumentResolverComposite addResolvers( @Nullable HandlerMethodArgumentResolver... resolvers) &#123; if (resolvers != null) &#123; Collections.addAll(this.argumentResolvers, resolvers); &#125; return this; &#125; ...&#125; 我们看看HandlerMethodArgumentResolver的源码： 1234567891011public interface HandlerMethodArgumentResolver &#123; //当前解析器是否支持解析这种参数 boolean supportsParameter(MethodParameter parameter); @Nullable//如果支持，就调用 resolveArgument Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;&#125; 返回值处理器ValueHandler 123456789101112131415161718@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123;//&lt;---关注点 invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; ... this.returnValueHandlers在afterPropertiesSet()方法内初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; @Nullable private HandlerMethodReturnValueHandlerComposite returnValueHandlers; @Override public void afterPropertiesSet() &#123; ... if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125; &#125; //初始化了一堆的实现HandlerMethodReturnValueHandler接口的 private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList&lt;&gt;(20); // Single-purpose return value types handlers.add(new ModelAndViewMethodReturnValueHandler()); handlers.add(new ModelMethodProcessor()); handlers.add(new ViewMethodReturnValueHandler()); handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(), this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager)); handlers.add(new StreamingResponseBodyReturnValueHandler()); handlers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new HttpHeadersReturnValueHandler()); handlers.add(new CallableMethodReturnValueHandler()); handlers.add(new DeferredResultMethodReturnValueHandler()); handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory)); // Annotation-based return value types handlers.add(new ServletModelAttributeMethodProcessor(false)); handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); // Multi-purpose return value types handlers.add(new ViewNameMethodReturnValueHandler()); handlers.add(new MapMethodProcessor()); // Custom return value types if (getCustomReturnValueHandlers() != null) &#123; handlers.addAll(getCustomReturnValueHandlers()); &#125; // Catch-all if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123; handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers())); &#125; else &#123; handlers.add(new ServletModelAttributeMethodProcessor(true)); &#125; return handlers; &#125;&#125; HandlerMethodReturnValueHandlerComposite类如下： 12345678910111213141516public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler &#123; private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;&gt;(); ... public HandlerMethodReturnValueHandlerComposite addHandlers( @Nullable List&lt;? extends HandlerMethodReturnValueHandler&gt; handlers) &#123; if (handlers != null) &#123; this.returnValueHandlers.addAll(handlers); &#125; return this; &#125;&#125; HandlerMethodReturnValueHandler接口： 12345678public interface HandlerMethodReturnValueHandler &#123; boolean supportsReturnType(MethodParameter returnType); void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125; 回顾执行目标方法123456public class DispatcherServlet extends FrameworkServlet &#123; ... protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = null; ... mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); RequestMappingHandlerAdapter的handle()方法： 12345678910111213141516171819202122public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ... //AbstractHandlerMethodAdapter类的方法，RequestMappingHandlerAdapter继承AbstractHandlerMethodAdapter public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; @Override protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; //handleInternal的核心 mav = invokeHandlerMethod(request, response, handlerMethod);//解释看下节 //... return mav; &#125;&#125; RequestMappingHandlerAdapter的invokeHandlerMethod()方法： 12345678910111213141516171819202122232425262728293031public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; ... ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; ... //关注点：执行目标方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125; &#125; invokeAndHandle()方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123; public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); ... try &#123; //returnValue存储起来 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; ... &#125; &#125; @Nullable//InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类 public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; ////获取方法的参数值 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); ... return doInvoke(args); &#125; @Nullable protected Object doInvoke(Object... args) throws Exception &#123; Method method = getBridgedMethod();//@RequestMapping的方法 ReflectionUtils.makeAccessible(method); try &#123; if (KotlinDetector.isSuspendingFunction(method)) &#123; return CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args); &#125; //通过反射调用 return method.invoke(getBean(), args);//getBean()指@RequestMapping的方法所在类的对象。 &#125; catch (IllegalArgumentException ex) &#123; ... &#125; catch (InvocationTargetException ex) &#123; ... &#125; &#125; &#125; 如何确定目标方法每一个参数的值重点分析ServletInvocableHandlerMethod的getMethodArgumentValues方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123; ... @Nullable//InvocableHandlerMethod类的，ServletInvocableHandlerMethod类继承InvocableHandlerMethod类 public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; ////获取方法的参数值 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); ... return doInvoke(args); &#125; //本节重点，获取方法的参数值 protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; //查看resolvers是否有支持 if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; //支持的话就开始解析吧 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; .... &#125; &#125; return args; &#125; &#125; this.resolvers的类型为HandlerMethodArgumentResolverComposite（在参数解析器章节提及） 12345678910111213141516171819202122232425262728293031323334353637public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; return getArgumentResolver(parameter) != null; &#125; @Override @Nullable public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) &#123; throw new IllegalArgumentException(&quot;Unsupported parameter type [&quot; + parameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;); &#125; return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory); &#125; @Nullable private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; //挨个判断所有参数解析器那个支持解析这个参数 for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123; if (resolver.supportsParameter(parameter)) &#123; result = resolver; this.argumentResolverCache.put(parameter, result);//找到了，resolver就缓存起来，方便稍后resolveArgument()方法使用 break; &#125; &#125; &#125; return result; &#125;&#125; 小结本节描述，一个请求发送到DispatcherServlet后的具体处理流程，也就是SpringMVC的主要原理。 本节内容较多且硬核，对日后编程很有帮助，需耐心对待。 可以运行一个示例，打断点，在Debug模式下，查看程序流程。 33、请求处理-【源码分析】-Servlet API参数解析原理 WebRequest ServletRequest MultipartRequest HttpSession javax.servlet.http.PushBuilder Principal InputStream Reader HttpMethod Locale TimeZone ZoneId ServletRequestMethodArgumentResolver用来处理以上的参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class ServletRequestMethodArgumentResolver implements HandlerMethodArgumentResolver &#123; @Nullable private static Class&lt;?&gt; pushBuilder; static &#123; try &#123; pushBuilder = ClassUtils.forName(&quot;javax.servlet.http.PushBuilder&quot;, ServletRequestMethodArgumentResolver.class.getClassLoader()); &#125; catch (ClassNotFoundException ex) &#123; // Servlet 4.0 PushBuilder not found - not supported for injection pushBuilder = null; &#125; &#125; @Override public boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; paramType = parameter.getParameterType(); return (WebRequest.class.isAssignableFrom(paramType) || ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType) || HttpSession.class.isAssignableFrom(paramType) || (pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) || (Principal.class.isAssignableFrom(paramType) &amp;&amp; !parameter.hasParameterAnnotations()) || InputStream.class.isAssignableFrom(paramType) || Reader.class.isAssignableFrom(paramType) || HttpMethod.class == paramType || Locale.class == paramType || TimeZone.class == paramType || ZoneId.class == paramType); &#125; @Override public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Class&lt;?&gt; paramType = parameter.getParameterType(); // WebRequest / NativeWebRequest / ServletWebRequest if (WebRequest.class.isAssignableFrom(paramType)) &#123; if (!paramType.isInstance(webRequest)) &#123; throw new IllegalStateException( &quot;Current request is not of type [&quot; + paramType.getName() + &quot;]: &quot; + webRequest); &#125; return webRequest; &#125; // ServletRequest / HttpServletRequest / MultipartRequest / MultipartHttpServletRequest if (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) &#123; return resolveNativeRequest(webRequest, paramType); &#125; // HttpServletRequest required for all further argument types return resolveArgument(paramType, resolveNativeRequest(webRequest, HttpServletRequest.class)); &#125; private &lt;T&gt; T resolveNativeRequest(NativeWebRequest webRequest, Class&lt;T&gt; requiredType) &#123; T nativeRequest = webRequest.getNativeRequest(requiredType); if (nativeRequest == null) &#123; throw new IllegalStateException( &quot;Current request is not of type [&quot; + requiredType.getName() + &quot;]: &quot; + webRequest); &#125; return nativeRequest; &#125; @Nullable private Object resolveArgument(Class&lt;?&gt; paramType, HttpServletRequest request) throws IOException &#123; if (HttpSession.class.isAssignableFrom(paramType)) &#123; HttpSession session = request.getSession(); if (session != null &amp;&amp; !paramType.isInstance(session)) &#123; throw new IllegalStateException( &quot;Current session is not of type [&quot; + paramType.getName() + &quot;]: &quot; + session); &#125; return session; &#125; else if (pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) &#123; return PushBuilderDelegate.resolvePushBuilder(request, paramType); &#125; else if (InputStream.class.isAssignableFrom(paramType)) &#123; InputStream inputStream = request.getInputStream(); if (inputStream != null &amp;&amp; !paramType.isInstance(inputStream)) &#123; throw new IllegalStateException( &quot;Request input stream is not of type [&quot; + paramType.getName() + &quot;]: &quot; + inputStream); &#125; return inputStream; &#125; else if (Reader.class.isAssignableFrom(paramType)) &#123; Reader reader = request.getReader(); if (reader != null &amp;&amp; !paramType.isInstance(reader)) &#123; throw new IllegalStateException( &quot;Request body reader is not of type [&quot; + paramType.getName() + &quot;]: &quot; + reader); &#125; return reader; &#125; else if (Principal.class.isAssignableFrom(paramType)) &#123; Principal userPrincipal = request.getUserPrincipal(); if (userPrincipal != null &amp;&amp; !paramType.isInstance(userPrincipal)) &#123; throw new IllegalStateException( &quot;Current user principal is not of type [&quot; + paramType.getName() + &quot;]: &quot; + userPrincipal); &#125; return userPrincipal; &#125; else if (HttpMethod.class == paramType) &#123; return HttpMethod.resolve(request.getMethod()); &#125; else if (Locale.class == paramType) &#123; return RequestContextUtils.getLocale(request); &#125; else if (TimeZone.class == paramType) &#123; TimeZone timeZone = RequestContextUtils.getTimeZone(request); return (timeZone != null ? timeZone : TimeZone.getDefault()); &#125; else if (ZoneId.class == paramType) &#123; TimeZone timeZone = RequestContextUtils.getTimeZone(request); return (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault()); &#125; // Should never happen... throw new UnsupportedOperationException(&quot;Unknown parameter type: &quot; + paramType.getName()); &#125; /** * Inner class to avoid a hard dependency on Servlet API 4.0 at runtime. */ private static class PushBuilderDelegate &#123; @Nullable public static Object resolvePushBuilder(HttpServletRequest request, Class&lt;?&gt; paramType) &#123; PushBuilder pushBuilder = request.newPushBuilder(); if (pushBuilder != null &amp;&amp; !paramType.isInstance(pushBuilder)) &#123; throw new IllegalStateException( &quot;Current push builder is not of type [&quot; + paramType.getName() + &quot;]: &quot; + pushBuilder); &#125; return pushBuilder; &#125; &#125;&#125; 用例： 1234567891011@Controllerpublic class RequestController &#123; @GetMapping(&quot;/goto&quot;) public String goToPage(HttpServletRequest request)&#123; request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;); request.setAttribute(&quot;code&quot;,200); return &quot;forward:/success&quot;; //转发到 /success请求 &#125;&#125; 34、请求处理-【源码分析】-Model、Map原理复杂参数： Map Model（map、model里面的数据会被放在request的请求域 request.setAttribute） Errors&#x2F;BindingResult RedirectAttributes（ 重定向携带数据） ServletResponse（response） SessionStatus UriComponentsBuilder ServletUriComponentsBuilder 用例： 1234567891011121314151617181920212223242526272829303132333435@GetMapping(&quot;/params&quot;)public String testParam(Map&lt;String,Object&gt; map, Model model, HttpServletRequest request, HttpServletResponse response)&#123; //下面三位都是可以给request域中放数据 map.put(&quot;hello&quot;,&quot;world666&quot;); model.addAttribute(&quot;world&quot;,&quot;hello666&quot;); request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;); Cookie cookie = new Cookie(&quot;c1&quot;,&quot;v1&quot;); response.addCookie(cookie); return &quot;forward:/success&quot;;&#125;@ResponseBody@GetMapping(&quot;/success&quot;)public Map success(@RequestAttribute(value = &quot;msg&quot;,required = false) String msg, @RequestAttribute(value = &quot;code&quot;,required = false)Integer code, HttpServletRequest request)&#123; Object msg1 = request.getAttribute(&quot;msg&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); Object hello = request.getAttribute(&quot;hello&quot;);//得出testParam方法赋予的值 world666 Object world = request.getAttribute(&quot;world&quot;);//得出testParam方法赋予的值 hello666 Object message = request.getAttribute(&quot;message&quot;);//得出testParam方法赋予的值 HelloWorld map.put(&quot;reqMethod_msg&quot;,msg1); map.put(&quot;annotation_msg&quot;,msg); map.put(&quot;hello&quot;,hello); map.put(&quot;world&quot;,world); map.put(&quot;message&quot;,message); return map;&#125; Map&lt;String,Object&gt; map Model model HttpServletRequest request 上面三位都是可以给request域中放数据，用request.getAttribute()获取 接下来我们看看，Map&lt;String,Object&gt; map与Model model用什么参数处理器。 Map&lt;String,Object&gt; map参数用MapMethodProcessor处理： 1234567891011121314151617181920public class MapMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; return (Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp; parameter.getParameterAnnotations().length == 0); &#125; @Override @Nullable public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Assert.state(mavContainer != null, &quot;ModelAndViewContainer is required for model exposure&quot;); return mavContainer.getModel(); &#125; ... &#125; mavContainer.getModel()如下： 1234567891011121314151617181920212223242526272829public class ModelAndViewContainer &#123; ... private final ModelMap defaultModel = new BindingAwareModelMap(); @Nullable private ModelMap redirectModel; ... public ModelMap getModel() &#123; if (useDefaultModel()) &#123; return this.defaultModel; &#125; else &#123; if (this.redirectModel == null) &#123; this.redirectModel = new ModelMap(); &#125; return this.redirectModel; &#125; &#125; private boolean useDefaultModel() &#123; return (!this.redirectModelScenario || (this.redirectModel == null &amp;&amp; !this.ignoreDefaultModelOnRedirect)); &#125; ... &#125; Model model用ModelMethodProcessor处理： 1234567891011121314151617public class ModelMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; return Model.class.isAssignableFrom(parameter.getParameterType()); &#125; @Override @Nullable public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; Assert.state(mavContainer != null, &quot;ModelAndViewContainer is required for model exposure&quot;); return mavContainer.getModel(); &#125; ...&#125; return mavContainer.getModel();这跟MapMethodProcessor的一致 Model也是另一种意义的Map。 接下来看看Map&lt;String,Object&gt; map与Model model值是如何做到用request.getAttribute()获取的。 众所周知，所有的数据都放在 ModelAndView包含要去的页面地址View，还包含Model数据。 先看ModelAndView接下来是如何处理的？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class DispatcherServlet extends FrameworkServlet &#123; ... protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... try &#123; ModelAndView mv = null; ... // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); ... &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; //处理分发结果 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; ... &#125; private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; ... // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); ... &#125; ... &#125; protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(&quot;Could not resolve view with name &#x27;&quot; + mv.getViewName() + &quot;&#x27; in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; &#125; view.render(mv.getModelInternal(), request, response); ... &#125;&#125; 在Debug模式下，view属为InternalResourceView类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class InternalResourceView extends AbstractUrlBasedView &#123; @Override//该方法在AbstractView，AbstractUrlBasedView继承了AbstractView public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); //看下一个方法实现 renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); &#125; @Override protected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. // 暴露模型作为请求域属性 exposeModelAsRequestAttributes(model, request);//&lt;---重点 // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); ... &#125; //该方法在AbstractView，AbstractUrlBasedView继承了AbstractView protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123; model.forEach((name, value) -&gt; &#123; if (value != null) &#123; request.setAttribute(name, value); &#125; else &#123; request.removeAttribute(name); &#125; &#125;); &#125; &#125; exposeModelAsRequestAttributes方法看出，Map&lt;String,Object&gt; map，Model model这两种类型数据可以给request域中放数据，用request.getAttribute()获取。 35、请求处理-【源码分析】-自定义参数绑定原理12345678910111213@RestControllerpublic class ParameterTestController &#123; /** * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定 * @param person * @return */ @PostMapping(&quot;/saveuser&quot;) public Person saveuser(Person person)&#123; return person; &#125;&#125; 123456789101112131415161718192021222324/** * 姓名： &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt; * 年龄： &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt; * 生日： &lt;input name=&quot;birth&quot;/&gt; &lt;br/&gt; * 宠物姓名：&lt;input name=&quot;pet.name&quot;/&gt;&lt;br/&gt; * 宠物年龄：&lt;input name=&quot;pet.age&quot;/&gt; */@Datapublic class Person &#123; private String userName; private Integer age; private Date birth; private Pet pet; &#125;@Datapublic class Pet &#123; private String name; private String age;&#125; 封装过程用到ServletModelAttributeMethodProcessor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ServletModelAttributeMethodProcessor extends ModelAttributeMethodProcessor &#123; @Override//本方法在ModelAttributeMethodProcessor类， public boolean supportsParameter(MethodParameter parameter) &#123; return (parameter.hasParameterAnnotation(ModelAttribute.class) || (this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType()))); &#125; @Override @Nullable//本方法在ModelAttributeMethodProcessor类， public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; ... String name = ModelFactory.getNameForParameter(parameter); ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class); if (ann != null) &#123; mavContainer.setBinding(name, ann.binding()); &#125; Object attribute = null; BindingResult bindingResult = null; if (mavContainer.containsAttribute(name)) &#123; attribute = mavContainer.getModel().get(name); &#125; else &#123; // Create attribute instance try &#123; attribute = createAttribute(name, parameter, binderFactory, webRequest); &#125; catch (BindException ex) &#123; ... &#125; &#125; if (bindingResult == null) &#123; // Bean property binding and validation; // skipped in case of binding failure on construction. WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); if (binder.getTarget() != null) &#123; if (!mavContainer.isBindingDisabled(name)) &#123; //web数据绑定器，将请求参数的值绑定到指定的JavaBean里面** bindRequestParameters(binder, webRequest); &#125; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new BindException(binder.getBindingResult()); &#125; &#125; // Value type adaptation, also covering java.util.Optional if (!parameter.getParameterType().isInstance(attribute)) &#123; attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter); &#125; bindingResult = binder.getBindingResult(); &#125; // Add resolved attribute and BindingResult at the end of the model Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel(); mavContainer.removeAttributes(bindingResultModel); mavContainer.addAllAttributes(bindingResultModel); return attribute; &#125;&#125; WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中 在过程当中，用到GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型 36、请求处理-【源码分析】-自定义Converter原理未来我们可以给WebDataBinder里面放自己的Converter； 下面演示将字符串“啊猫,3”转换成Pet对象。 12345678910111213141516171819202122232425//1、WebMvcConfigurer定制化SpringMVC的功能@Beanpublic WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new Converter&lt;String, Pet&gt;() &#123; @Override public Pet convert(String source) &#123; // 啊猫,3 if(!StringUtils.isEmpty(source))&#123; Pet pet = new Pet(); String[] split = source.split(&quot;,&quot;); pet.setName(split[0]); pet.setAge(Integer.parseInt(split[1])); return pet; &#125; return null; &#125; &#125;); &#125; &#125;;&#125; 37、响应处理-【源码分析】-ReturnValueHandler原理 假设给前端自动返回json数据，需要引入相关的依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web场景自动引入了json场景 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 控制层代码如下： 1234567891011121314@Controllerpublic class ResponseTestController &#123; @ResponseBody //利用返回值处理器里面的消息转换器进行处理 @GetMapping(value = &quot;/test/person&quot;) public Person getPerson()&#123; Person person = new Person(); person.setAge(28); person.setBirth(new Date()); person.setUserName(&quot;zhangsan&quot;); return person; &#125;&#125; 32、请求处理-【源码分析】-各种类型参数解析原理 - 返回值处理器有讨论ReturnValueHandler。现在直接看看重点： 123456789101112131415161718192021222324252627282930313233343536public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ... @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; ... ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123;//&lt;----关注点 invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; ... invocableMethod.invokeAndHandle(webRequest, mavContainer);//看下块代码 if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125; &#125; 123456789101112131415161718public class ServletInvocableHandlerMethod extends InvocableHandlerMethod &#123; public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); ... try &#123; //看下块代码 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; ... &#125; &#125; 123456789101112131415161718192021222324252627282930313233public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler &#123; ... @Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; //selectHandler()实现在下面 HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName()); &#125; //开始处理 handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); &#125; @Nullable private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) &#123; boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123; if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123; continue; &#125; if (handler.supportsReturnType(returnType)) &#123; return handler; &#125; &#125; return null; &#125; @ResponseBody 注解，即RequestResponseBodyMethodProcessor，它实现HandlerMethodReturnValueHandler接口 1234567891011121314151617181920public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor &#123; ... @Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // 使用消息转换器进行写出操作，本方法下一章节介绍： // Try even with null return value. ResponseBodyAdvice could get involved. writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage); &#125;&#125; 38、响应处理-【源码分析】-HTTPMessageConverter原理返回值处理器ReturnValueHandler原理： 返回值处理器判断是否支持这种类型返回值 supportsReturnType 返回值处理器调用 handleReturnValue 进行处理 RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的。 利用 MessageConverters 进行处理 将数据写为json 内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型） 服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据， SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理？ 得到MappingJackson2HttpMessageConverter可以将对象写为json 利用MappingJackson2HttpMessageConverter将对象转为json再写出去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//RequestResponseBodyMethodProcessor继承这类public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver implements HandlerMethodReturnValueHandler &#123; ... //承接上一节内容 protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; Object body; Class&lt;?&gt; valueType; Type targetType; if (value instanceof CharSequence) &#123; body = value.toString(); valueType = String.class; targetType = String.class; &#125; else &#123; body = value; valueType = getReturnValueType(body, returnType); targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass()); &#125; ... //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型） MediaType selectedMediaType = null; MediaType contentType = outputMessage.getHeaders().getContentType(); boolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete(); if (isContentTypePreset) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found &#x27;Content-Type:&quot; + contentType + &quot;&#x27; in response&quot;); &#125; selectedMediaType = contentType; &#125; else &#123; HttpServletRequest request = inputMessage.getServletRequest(); List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request); //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据 List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType); if (body != null &amp;&amp; producibleTypes.isEmpty()) &#123; throw new HttpMessageNotWritableException( &quot;No converter found for return value of type: &quot; + valueType); &#125; List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;(); for (MediaType requestedType : acceptableTypes) &#123; for (MediaType producibleType : producibleTypes) &#123; if (requestedType.isCompatibleWith(producibleType)) &#123; mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType)); &#125; &#125; &#125; if (mediaTypesToUse.isEmpty()) &#123; if (body != null) &#123; throw new HttpMediaTypeNotAcceptableException(producibleTypes); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes); &#125; return; &#125; MediaType.sortBySpecificityAndQuality(mediaTypesToUse); //选择一个MediaType for (MediaType mediaType : mediaTypesToUse) &#123; if (mediaType.isConcrete()) &#123; selectedMediaType = mediaType; break; &#125; else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123; selectedMediaType = MediaType.APPLICATION_OCTET_STREAM; break; &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Using &#x27;&quot; + selectedMediaType + &quot;&#x27;, given &quot; + acceptableTypes + &quot; and supported &quot; + producibleTypes); &#125; &#125; if (selectedMediaType != null) &#123; selectedMediaType = selectedMediaType.removeQualityValue(); //本节主角：HttpMessageConverter for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null); //判断是否可写 if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) &#123; body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(), inputMessage, outputMessage); if (body != null) &#123; Object theBody = body; LogFormatUtils.traceDebug(logger, traceOn -&gt; &quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;); addContentDispositionHeader(inputMessage, outputMessage); //开始写入 if (genericConverter != null) &#123; genericConverter.write(body, targetType, selectedMediaType, outputMessage); &#125; else &#123; ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Nothing to write: null body&quot;); &#125; &#125; return; &#125; &#125; &#125; ... &#125; HTTPMessageConverter接口： 12345678910111213141516171819202122232425262728293031323334/** * Strategy interface for converting from and to HTTP requests and responses. */public interface HttpMessageConverter&lt;T&gt; &#123; /** * Indicates whether the given class can be read by this converter. */ boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); /** * Indicates whether the given class can be written by this converter. */ boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); /** * Return the list of &#123;@link MediaType&#125; objects supported by this converter. */ List&lt;MediaType&gt; getSupportedMediaTypes(); /** * Read an object of the given type from the given input message, and returns it. */ T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; /** * Write an given object to the given output message. */ void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;&#125; HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。 例子：Person对象转为JSON，或者 JSON转为Person，这将用到MappingJackson2HttpMessageConverter 123public class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter &#123; ...&#125; 关于MappingJackson2HttpMessageConverter的实例化请看下节。 关于HttpMessageConverters的初始化DispatcherServlet的初始化时会调用initHandlerAdapters(ApplicationContext context) 123456789101112131415161718public class DispatcherServlet extends FrameworkServlet &#123; ... private void initHandlerAdapters(ApplicationContext context) &#123; this.handlerAdapters = null; if (this.detectAllHandlerAdapters) &#123; // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values()); // We keep HandlerAdapters in sorted order. AnnotationAwareOrderComparator.sort(this.handlerAdapters); &#125; &#125; ... 上述代码会加载ApplicationContext的所有HandlerAdapter，用来处理@RequestMapping的RequestMappingHandlerAdapter实现HandlerAdapter接口，RequestMappingHandlerAdapter也被实例化。 1234567891011121314151617181920212223public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ... private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters; ... public RequestMappingHandlerAdapter() &#123; this.messageConverters = new ArrayList&lt;&gt;(4); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); if (!shouldIgnoreXml) &#123; try &#123; this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;()); &#125; catch (Error err) &#123; // Ignore when no TransformerFactory implementation is available &#125; &#125; this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; 在构造器中看到一堆HttpMessageConverter。接着，重点查看AllEncompassingFormHttpMessageConverter类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class AllEncompassingFormHttpMessageConverter extends FormHttpMessageConverter &#123; /** * Boolean flag controlled by a &#123;@code spring.xml.ignore&#125; system property that instructs Spring to * ignore XML, i.e. to not initialize the XML-related infrastructure. * &lt;p&gt;The default is &quot;false&quot;. */ private static final boolean shouldIgnoreXml = SpringProperties.getFlag(&quot;spring.xml.ignore&quot;); private static final boolean jaxb2Present; private static final boolean jackson2Present; private static final boolean jackson2XmlPresent; private static final boolean jackson2SmilePresent; private static final boolean gsonPresent; private static final boolean jsonbPresent; private static final boolean kotlinSerializationJsonPresent; static &#123; ClassLoader classLoader = AllEncompassingFormHttpMessageConverter.class.getClassLoader(); jaxb2Present = ClassUtils.isPresent(&quot;javax.xml.bind.Binder&quot;, classLoader); jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp; ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader); jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader); jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader); gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader); jsonbPresent = ClassUtils.isPresent(&quot;javax.json.bind.Jsonb&quot;, classLoader); kotlinSerializationJsonPresent = ClassUtils.isPresent(&quot;kotlinx.serialization.json.Json&quot;, classLoader); &#125; public AllEncompassingFormHttpMessageConverter() &#123; if (!shouldIgnoreXml) &#123; try &#123; addPartConverter(new SourceHttpMessageConverter&lt;&gt;()); &#125; catch (Error err) &#123; // Ignore when no TransformerFactory implementation is available &#125; if (jaxb2Present &amp;&amp; !jackson2XmlPresent) &#123; addPartConverter(new Jaxb2RootElementHttpMessageConverter()); &#125; &#125; if (jackson2Present) &#123; addPartConverter(new MappingJackson2HttpMessageConverter());//&lt;----重点看这里 &#125; else if (gsonPresent) &#123; addPartConverter(new GsonHttpMessageConverter()); &#125; else if (jsonbPresent) &#123; addPartConverter(new JsonbHttpMessageConverter()); &#125; else if (kotlinSerializationJsonPresent) &#123; addPartConverter(new KotlinSerializationJsonHttpMessageConverter()); &#125; if (jackson2XmlPresent &amp;&amp; !shouldIgnoreXml) &#123; addPartConverter(new MappingJackson2XmlHttpMessageConverter()); &#125; if (jackson2SmilePresent) &#123; addPartConverter(new MappingJackson2SmileHttpMessageConverter()); &#125; &#125;&#125;public class FormHttpMessageConverter implements HttpMessageConverter&lt;MultiValueMap&lt;String, ?&gt;&gt; &#123; ... private List&lt;HttpMessageConverter&lt;?&gt;&gt; partConverters = new ArrayList&lt;&gt;(); ... public void addPartConverter(HttpMessageConverter&lt;?&gt; partConverter) &#123; Assert.notNull(partConverter, &quot;&#x27;partConverter&#x27; must not be null&quot;); this.partConverters.add(partConverter); &#125; ...&#125; 在AllEncompassingFormHttpMessageConverter类构造器看到MappingJackson2HttpMessageConverter类的实例化，AllEncompassingFormHttpMessageConverter包含MappingJackson2HttpMessageConverter。 ReturnValueHandler是怎么与MappingJackson2HttpMessageConverter关联起来？请看下节。 ReturnValueHandler与MappingJackson2HttpMessageConverter关联再次回顾RequestMappingHandlerAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; ... @Nullable private HandlerMethodReturnValueHandlerComposite returnValueHandlers;//我们关注的returnValueHandlers @Override @Nullable//本方法在AbstractHandlerMethodAdapter public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; @Override protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; ... mav = invokeHandlerMethod(request, response, handlerMethod); ... return mav; &#125; @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123;//&lt;---我们关注的returnValueHandlers invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; ... invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125; &#125; @Override public void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans ... if (this.returnValueHandlers == null) &#123;//赋值returnValueHandlers List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125; &#125; private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList&lt;&gt;(20); ... // Annotation-based return value types //这里就是 ReturnValueHandler与 MappingJackson2HttpMessageConverter关联 的关键点 handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),//&lt;---MessageConverters也就传参传进来的 this.contentNegotiationManager, this.requestResponseBodyAdvice));// ... return handlers; &#125; //------ public List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; return this.messageConverters; &#125; //RequestMappingHandlerAdapter构造器已初始化部分messageConverters public RequestMappingHandlerAdapter() &#123; this.messageConverters = new ArrayList&lt;&gt;(4); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); if (!shouldIgnoreXml) &#123; try &#123; this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;()); &#125; catch (Error err) &#123; // Ignore when no TransformerFactory implementation is available &#125; &#125; this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; ... &#125; 应用中WebMvcAutoConfiguration（底层是WebMvcConfigurationSupport实现）传入更多messageConverters，其中就包含MappingJackson2HttpMessageConverter。 39、响应处理-【源码分析】-内容协商原理根据客户端接收能力不同，返回不同媒体类型的数据。 引入XML依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 可用Postman软件分别测试返回json和xml：只需要改变请求头中Accept字段（application&#x2F;json、application&#x2F;xml）。 Http协议中规定的，Accept字段告诉服务器本客户端可以接收的数据类型。 内容协商原理： 判断当前响应头中是否已经有确定的媒体类型MediaType。 获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application&#x2F;xml）（这一步在下一节有详细介绍） contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略 HeaderContentNegotiationStrategy 确定客户端可以接收的内容类型 遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象（Person） 找到支持操作Person的converter，把converter支持的媒体类型统计出来。 客户端需要application&#x2F;xml，服务端有10种MediaType。 进行内容协商的最佳匹配媒体类型 用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//RequestResponseBodyMethodProcessor继承这类public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver implements HandlerMethodReturnValueHandler &#123; ... //跟上一节的代码一致 protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; Object body; Class&lt;?&gt; valueType; Type targetType; if (value instanceof CharSequence) &#123; body = value.toString(); valueType = String.class; targetType = String.class; &#125; else &#123; body = value; valueType = getReturnValueType(body, returnType); targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass()); &#125; ... //本节重点 //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型） MediaType selectedMediaType = null; MediaType contentType = outputMessage.getHeaders().getContentType(); boolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete(); if (isContentTypePreset) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found &#x27;Content-Type:&quot; + contentType + &quot;&#x27; in response&quot;); &#125; selectedMediaType = contentType; &#125; else &#123; HttpServletRequest request = inputMessage.getServletRequest(); List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request); //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据 List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType); if (body != null &amp;&amp; producibleTypes.isEmpty()) &#123; throw new HttpMessageNotWritableException( &quot;No converter found for return value of type: &quot; + valueType); &#125; List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;(); for (MediaType requestedType : acceptableTypes) &#123; for (MediaType producibleType : producibleTypes) &#123; if (requestedType.isCompatibleWith(producibleType)) &#123; mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType)); &#125; &#125; &#125; if (mediaTypesToUse.isEmpty()) &#123; if (body != null) &#123; throw new HttpMediaTypeNotAcceptableException(producibleTypes); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes); &#125; return; &#125; MediaType.sortBySpecificityAndQuality(mediaTypesToUse); //选择一个MediaType for (MediaType mediaType : mediaTypesToUse) &#123; if (mediaType.isConcrete()) &#123; selectedMediaType = mediaType; break; &#125; else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123; selectedMediaType = MediaType.APPLICATION_OCTET_STREAM; break; &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Using &#x27;&quot; + selectedMediaType + &quot;&#x27;, given &quot; + acceptableTypes + &quot; and supported &quot; + producibleTypes); &#125; &#125; if (selectedMediaType != null) &#123; selectedMediaType = selectedMediaType.removeQualityValue(); //本节主角：HttpMessageConverter for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null); //判断是否可写 if (genericConverter != null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) &#123; body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(), inputMessage, outputMessage); if (body != null) &#123; Object theBody = body; LogFormatUtils.traceDebug(logger, traceOn -&gt; &quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;); addContentDispositionHeader(inputMessage, outputMessage); //开始写入 if (genericConverter != null) &#123; genericConverter.write(body, targetType, selectedMediaType, outputMessage); &#125; else &#123; ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Nothing to write: null body&quot;); &#125; &#125; return; &#125; &#125; &#125; ... &#125; 40、响应处理-【源码分析】-基于请求参数的内容协商原理上一节内容协商原理的第二步： 获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application&#x2F;xml） contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略 HeaderContentNegotiationStrategy 确定客户端可以接收的内容类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//RequestResponseBodyMethodProcessor继承这类public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver implements HandlerMethodReturnValueHandler &#123; ... //跟上一节的代码一致 protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; Object body; Class&lt;?&gt; valueType; Type targetType; ... //本节重点 //内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型） MediaType selectedMediaType = null; MediaType contentType = outputMessage.getHeaders().getContentType(); boolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete(); if (isContentTypePreset) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found &#x27;Content-Type:&quot; + contentType + &quot;&#x27; in response&quot;); &#125; selectedMediaType = contentType; &#125; else &#123; HttpServletRequest request = inputMessage.getServletRequest(); List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request); //服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据 List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType); ... &#125; //在AbstractMessageConverterMethodArgumentResolver类内 private List&lt;MediaType&gt; getAcceptableMediaTypes(HttpServletRequest request) throws HttpMediaTypeNotAcceptableException &#123; //内容协商管理器 默认使用基于请求头的策略 return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request)); &#125; &#125; 12345678910111213141516171819202122public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver &#123; ... public ContentNegotiationManager() &#123; this(new HeaderContentNegotiationStrategy());//内容协商管理器 默认使用基于请求头的策略 &#125; @Override public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123; for (ContentNegotiationStrategy strategy : this.strategies) &#123; List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request); if (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) &#123; continue; &#125; return mediaTypes; &#125; return MEDIA_TYPE_ALL_LIST; &#125; ... &#125; 1234567891011121314151617181920212223242526272829//基于请求头的策略public class HeaderContentNegotiationStrategy implements ContentNegotiationStrategy &#123; /** * &#123;@inheritDoc&#125; * @throws HttpMediaTypeNotAcceptableException if the &#x27;Accept&#x27; header cannot be parsed */ @Override public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123; String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT); if (headerValueArray == null) &#123; return MEDIA_TYPE_ALL_LIST; &#125; List&lt;String&gt; headerValues = Arrays.asList(headerValueArray); try &#123; List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues); MediaType.sortBySpecificityAndQuality(mediaTypes); return !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST; &#125; catch (InvalidMediaTypeException ex) &#123; throw new HttpMediaTypeNotAcceptableException( &quot;Could not parse &#x27;Accept&#x27; header &quot; + headerValues + &quot;: &quot; + ex.getMessage()); &#125; &#125;&#125; 开启浏览器参数方式内容协商功能为了方便内容协商，开启基于请求参数的内容协商功能。 1234spring: mvc: contentnegotiation: favor-parameter: true #开启请求参数内容协商模式 内容协商管理器，就会多了一个ParameterContentNegotiationStrategy（由Spring容器注入） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ParameterContentNegotiationStrategy extends AbstractMappingContentNegotiationStrategy &#123; private String parameterName = &quot;format&quot;;// /** * Create an instance with the given map of file extensions and media types. */ public ParameterContentNegotiationStrategy(Map&lt;String, MediaType&gt; mediaTypes) &#123; super(mediaTypes); &#125; /** * Set the name of the parameter to use to determine requested media types. * &lt;p&gt;By default this is set to &#123;@code &quot;format&quot;&#125;. */ public void setParameterName(String parameterName) &#123; Assert.notNull(parameterName, &quot;&#x27;parameterName&#x27; is required&quot;); this.parameterName = parameterName; &#125; public String getParameterName() &#123; return this.parameterName; &#125; @Override @Nullable protected String getMediaTypeKey(NativeWebRequest request) &#123; return request.getParameter(getParameterName()); &#125; //---以下方法在AbstractMappingContentNegotiationStrategy类 @Override public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest webRequest) throws HttpMediaTypeNotAcceptableException &#123; return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest)); &#125; /** * An alternative to &#123;@link #resolveMediaTypes(NativeWebRequest)&#125; that accepts * an already extracted key. * @since 3.2.16 */ public List&lt;MediaType&gt; resolveMediaTypeKey(NativeWebRequest webRequest, @Nullable String key) throws HttpMediaTypeNotAcceptableException &#123; if (StringUtils.hasText(key)) &#123; MediaType mediaType = lookupMediaType(key); if (mediaType != null) &#123; handleMatch(key, mediaType); return Collections.singletonList(mediaType); &#125; mediaType = handleNoMatch(webRequest, key); if (mediaType != null) &#123; addMapping(key, mediaType); return Collections.singletonList(mediaType); &#125; &#125; return MEDIA_TYPE_ALL_LIST; &#125; &#125; 然后，浏览器地址输入带format参数的URL： 123http://localhost:8080/test/person?format=json或http://localhost:8080/test/person?format=xml 这样，后端会根据参数format的值，返回对应json或xml格式的数据。 41、响应处理-【源码分析】-自定义MessageConverter实现多协议数据兼容。json、xml、x-guigu（这个是自创的） @ResponseBody 响应数据出去 调用 RequestResponseBodyMethodProcessor 处理 Processor 处理方法返回值。通过 MessageConverter处理 所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写） 内容协商找到最终的 messageConverter SpringMVC的什么功能，一个入口给容器中添加一个 WebMvcConfigurer 12345678910111213@Configuration(proxyBeanMethods = false)public class WebConfig &#123; @Bean public WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; converters.add(new GuiguMessageConverter()); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 自定义的Converter */public class GuiguMessageConverter implements HttpMessageConverter&lt;Person&gt; &#123; @Override public boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType) &#123; return false; &#125; @Override public boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) &#123; return clazz.isAssignableFrom(Person.class); &#125; /** * 服务器要统计所有MessageConverter都能写出哪些内容类型 * * application/x-guigu * @return */ @Override public List&lt;MediaType&gt; getSupportedMediaTypes() &#123; return MediaType.parseMediaTypes(&quot;application/x-guigu&quot;); &#125; @Override public Person read(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; return null; &#125; @Override public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; //自定义协议数据的写出 String data = person.getUserName()+&quot;;&quot;+person.getAge()+&quot;;&quot;+person.getBirth(); //写出去 OutputStream body = outputMessage.getBody(); body.write(data.getBytes()); &#125;&#125; 123456789101112131415161718192021222324252627282930import java.util.Date;@Controllerpublic class ResponseTestController &#123; /** * 1、浏览器发请求直接返回 xml [application/xml] jacksonXmlConverter * 2、如果是ajax请求 返回 json [application/json] jacksonJsonConverter * 3、如果硅谷app发请求，返回自定义协议数据 [appliaction/x-guigu] xxxxConverter * 属性值1;属性值2; * * 步骤： * 1、添加自定义的MessageConverter进系统底层 * 2、系统底层就会统计出所有MessageConverter能操作哪些类型 * 3、客户端内容协商 [guigu---&gt;guigu] * * 作业：如何以参数的方式进行内容协商 * @return */ @ResponseBody //利用返回值处理器里面的消息转换器进行处理 @GetMapping(value = &quot;/test/person&quot;) public Person getPerson()&#123; Person person = new Person(); person.setAge(28); person.setBirth(new Date()); person.setUserName(&quot;zhangsan&quot;); return person; &#125;&#125; 用Postman发送/test/person（请求头Accept:application/x-guigu)，将返回自定义协议数据的写出。 42、响应处理-【源码分析】-浏览器与PostMan内容协商完全适配假设你想基于自定义请求参数的自定义内容协商功能。 换句话，在地址栏输入http://localhost:8080/test/person?format=gg返回数据，跟http://localhost:8080/test/person且请求头参数Accept:application/x-guigu的返回自定义协议数据的一致。 1234567891011121314151617181920212223242526272829303132333435@Configuration(proxyBeanMethods = false)public class WebConfig /*implements WebMvcConfigurer*/ &#123; //1、WebMvcConfigurer定制化SpringMVC的功能 @Bean public WebMvcConfigurer webMvcConfigurer()&#123; return new WebMvcConfigurer() &#123; /** * 自定义内容协商策略 * @param configurer */ @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; //Map&lt;String, MediaType&gt; mediaTypes Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;&gt;(); mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON); mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML); //自定义媒体类型 mediaTypes.put(&quot;gg&quot;,MediaType.parseMediaType(&quot;application/x-guigu&quot;)); //指定支持解析哪些参数对应的哪些媒体类型 ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);// parameterStrategy.setParameterName(&quot;ff&quot;); //还需添加请求头处理策略，否则accept:application/json、application/xml则会失效 HeaderContentNegotiationStrategy headeStrategy = new HeaderContentNegotiationStrategy(); configurer.strategies(Arrays.asList(parameterStrategy, headeStrategy)); &#125; &#125; &#125; ... &#125; 日后开发要注意，有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。 43、视图解析-Thymeleaf初体验 Thymeleaf is a modern server-side Java template engine for both web and standalone environments. Thymeleaf’s main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams. With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.——Link Thymeleaf官方文档 thymeleaf使用引入Starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 自动配置好了thymeleaf1234567@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(ThymeleafProperties.class)@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)public class ThymeleafAutoConfiguration &#123; ...&#125; 自动配好的策略 所有thymeleaf的配置值都在 ThymeleafProperties 配置好了 SpringTemplateEngine 配好了 ThymeleafViewResolver 我们只需要直接开发页面 12public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;//模板放置处public static final String DEFAULT_SUFFIX = &quot;.html&quot;;//文件的后缀名 编写一个控制层： 12345678910@Controllerpublic class ViewTestController &#123; @GetMapping(&quot;/hello&quot;) public String hello(Model model)&#123; //model中的数据会被放在请求域中 request.setAttribute(&quot;a&quot;,aa) model.addAttribute(&quot;msg&quot;,&quot;一定要大力发展工业文化&quot;); model.addAttribute(&quot;link&quot;,&quot;http://www.baidu.com&quot;); return &quot;success&quot;; &#125;&#125; /templates/success.html： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;nice&lt;/h1&gt;&lt;h2&gt; &lt;a href=&quot;www.baidu.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;去百度&lt;/a&gt; &lt;br/&gt; &lt;a href=&quot;www.google.com&quot; th:href=&quot;@&#123;/link&#125;&quot;&gt;去百度&lt;/a&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 123server: servlet: context-path: /app #设置应用名 这个设置后，URL要插入/app, 如http://localhost:8080/app/hello.html。 基本语法表达式 表达式名字 语法 用途 变量取值 ${…} 获取请求域、session域、对象等值 选择变量 *{…} 获取上下文对象值 消息 #{…} 获取国际化等值 链接 @{…} 生成链接 片段表达式 ~{…} jsp:include 作用，引入公共页面片段 字面量 文本值: ‘one text’ , ‘Another one!’ ,… 数字: 0 , 34 , 3.0 , 12.3 ,… 布尔值: true , false 空值: null 变量： one，two，…. 变量不能有空格 文本操作 字符串拼接: + 变量替换: |The name is ${name}| 数学运算 运算符: + , - , * , &#x2F; , % 布尔运算 运算符: and , or 一元运算: ! , not 比较运算 比较: &gt; , &lt;** **,** **&gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le ) 等式: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) 条件运算 If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 特殊操作 无操作： _ 设置属性值-th:attr 设置单个值 123456&lt;form action=&quot;subscribe.html&quot; th:attr=&quot;action=@&#123;/subscribe&#125;&quot;&gt; &lt;fieldset&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Subscribe!&quot; th:attr=&quot;value=#&#123;subscribe.submit&#125;&quot;/&gt; &lt;/fieldset&gt;&lt;/form&gt; 设置多个值 12&lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt; 官方文档 - 5 Setting Attribute Values 迭代12345&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt; 12345&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt; 条件运算123&lt;a href=&quot;comments.html&quot; th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot; th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;/a&gt; 12345&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;&#x27;admin&#x27;&quot;&gt;User is an administrator&lt;/p&gt; &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 属性优先级 Order Feature Attributes 1 Fragment inclusion th:insert th:replace 2 Fragment iteration th:each 3 Conditional evaluation th:if th:unless th:switch th:case 4 Local variable definition th:object th:with 5 General attribute modification th:attr th:attrprepend th:attrappend 6 Specific attribute modification th:value th:href th:src ... 7 Text (tag body modification) th:text th:utext 8 Fragment specification th:fragment 9 Fragment removal th:remove 官方文档 - 10 Attribute Precedence 44、web实验-后台管理系统基本功能项目创建使用IDEA的Spring Initializr。 thymeleaf、 web-starter、 devtools、 lombok 登陆页面 /static 放置 css，js等静态资源 /templates/login.html 登录页 12345678910111213141516171819&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;!-- 要加这玩意thymeleaf才能用 --&gt;&lt;form class=&quot;form-signin&quot; action=&quot;index.html&quot; method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt; ... &lt;!-- 消息提醒 --&gt; &lt;label style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; class=&quot;form-control&quot; placeholder=&quot;User ID&quot; autofocus&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;&gt; &lt;button class=&quot;btn btn-lg btn-login btn-block&quot; type=&quot;submit&quot;&gt; &lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt; &lt;/button&gt; ... &lt;/form&gt; /templates/main.html 主页 thymeleaf内联写法： 1&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt; 登录控制层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Controllerpublic class IndexController &#123; /** * 来登录页 * @return */ @GetMapping(value = &#123;&quot;/&quot;,&quot;/login&quot;&#125;) public String loginPage()&#123; return &quot;login&quot;; &#125; @PostMapping(&quot;/login&quot;) public String main(User user, HttpSession session, Model model)&#123; //RedirectAttributes if(StringUtils.hasLength(user.getUserName()) &amp;&amp; &quot;123456&quot;.equals(user.getPassword()))&#123; //把登陆成功的用户保存起来 session.setAttribute(&quot;loginUser&quot;,user); //登录成功重定向到main.html; 重定向防止表单重复提交 return &quot;redirect:/main.html&quot;; &#125;else &#123; model.addAttribute(&quot;msg&quot;,&quot;账号密码错误&quot;); //回到登录页面 return &quot;login&quot;; &#125; &#125; /** * 去main页面 * @return */ @GetMapping(&quot;/main.html&quot;) public String mainPage(HttpSession session, Model model)&#123; //最好用拦截器,过滤器 Object loginUser = session.getAttribute(&quot;loginUser&quot;); if(loginUser != null)&#123; return &quot;main&quot;; &#125;else &#123; //session过期，没有登陆过 //回到登录页面 model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;); return &quot;login&quot;; &#125; &#125; &#125; 模型1234567@AllArgsConstructor@NoArgsConstructor@Datapublic class User &#123; private String userName; private String password;&#125;","tags":"springboot"},{"title":"Redis","url":"/2023/10/12/Redis/","text":"Redis一、NoSQL数据库1、技术发展 解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、MyBatis 解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch 1.1、Web1.0时代Web1.0时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。 1.2、Web2.0时代随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。 1.3、解决CPU及内存压力 1.4、解决IO压力 2、NoSQL数据库2.1、NoSQL数据库概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准。 不支持ACID。 远超于SQL的性能。 2.2、NoSQL适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 2.3、NoSQL不使用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 （用不着sql****的和用了sql也不行的情况，请考虑用NoSql） 2.4、Memcache 很早出现的NoSql数据库 数据都在内存中，一般不持久化 支持简单的key-value模式，支持类型单一 一般是作为缓存数据库辅助持久化的数据库 2.5、Redis 几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。 一般是作为缓存数据库辅助持久化的数据库 2.6、MongoDB 高性能、开源、模式自由(schema free)的文档型数据库 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘 虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能 支持二进制数据及大型对象 可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据。 3、行式存储数据库（大数据时代）3.1、行式数据库 3.2、列式数据库 3.2.1、Hbase HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。 HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10****亿行数据，还可处理有数百万列元素的数据表。 3.2.2、Cassandra【ke’saendre】 Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的**海量数据集(数据量通常达到PB级别)**。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。 12345678910111213计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。字节 byte：8个二进制位为一个字节(B)，最常用的单位。1KB (Kilobyte 千字节)=1024B，1MB (Megabyte 兆字节 简称“兆”)=1024KB，1GB (Gigabyte 吉字节 又称“千兆”)=1024MB，1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)，1PB（Petabyte 千万亿字节 拍字节）=1024TB，1EB（Exabyte 百亿亿字节 艾字节）=1024PB，1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,1YB (Jottabyte 一亿亿亿字节 尧字节)= 1024 ZB,1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.注：“兆”为百万级数量单位。 4、图关系型数据库 主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)&#x2F;2) 5、DB-Engines数据库排名http://db-engines.com/en/ranking 二、Redis概述及安装 Redis是一个开源的key-value存储系统。 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上，Redis支持各种不同方式的排序。 与memcached一样，为了保证效率，数据都是缓存在内存中。 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 并且在此基础上实现了master-slave(主从)同步。 1、应用场景1.1、配合关系型数据库做高速缓存 高频次，热门访问的数据，降低数据库IO 分布式架构，做session共享 1.2、多样的数据结构存储持久化数据 2、Redis安装Redis官方网站：http://redis.io Redis中文官方网站：http://redis.cn/ 2.1、安装版本 6.2.1 for Linux（redis-6.2.1.tar.gz） 不用考虑在windows环境下对Redis的支持 2.2、安装步骤2.2.1、准备工作：下载安装最新版的gcc编译器安装C 语言的编译环境 yum install centos-release-scl scl-utils-build yum install -y devtoolset-8-toolchain scl enable devtoolset-8 bash 测试 gcc版本 gcc –version 2.2.2、下载redis-6.2.1.tar.gz放&#x2F;opt目录2.2.3、解压命令：tar -zxvf redis-6.2.1.tar.gz2.2.4、解压完成后进入目录：cd redis-6.2.12.2.5、在redis-6.2.1目录下再次执行make命令(只是编译好)2.2.6、如果没有准备好C语言编译环境，make会报错 ——Jemalloc&#x2F;jemalloc.h：没有那个文件 2.2.7、解决方案：运行 make distclean2.2.8、在redis-6.2.1目录下再次执行make 命令（只是编译好）2.2.9、跳过make test 继续执行：make install2.3、安装目录:&#x2F;usr&#x2F;local&#x2F;bin查看默认安装目录： redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何 redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲 redis-check-dump：修复有问题的dump.rdb文件 redis-sentinel：Redis集群使用 redis-server：Redis服务器启动命令 redis-cli：客户端，操作入口 2.4、前台启动（不推荐）前台启动，命令行窗口不能关闭，否则服务器停止 2.5、后台启动（推荐）2.5.1、备份redis.conf拷贝一份redis.conf到其他目录 cp &#x2F;opt&#x2F;redis-7.0.5&#x2F;redis.conf &#x2F;myredis 2.5.2、后台启动设置daemonize no改成yes修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动 2.5.3、Redis启动redis-server&#x2F;myredis&#x2F;redis.conf 2.5.4、用客户端访问：redis-cli 2.5.5、多个端口可以：redis-cli -p63792.5.6、测试验证：ping 2.5.7、Redis关闭单实例关闭：redis-cli shutdown 进入终端后再关闭 多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown 2.6、Redis介绍相关知识121、端口号6379从何而来？（Alessia Merz）merz在九键的对应数字 123456默认16个数据库，类似数组下标从0开始，初始默认使用0号库使用命令 select &lt;dbid&gt;来切换数据库。如: select 8 统一密码管理，所有库同样密码。dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库 1234Redis是单线程+多路IO复用技术多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）串行 vs 多线程+锁（memcached） vs 单线程+多路IO复用(Redis)（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用） 三、常用五大数据类型1、Redis键12345678910111213keys *查看当前库所有key (匹配：keys *1)exists key判断某个key是否存在type key 查看你的key是什么类型del key 删除指定的key数据unlink key 根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。expire key 10 10秒钟：为给定的key设置过期时间ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期select命令切换数据库dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库 2、Redis字符串2.1、简介String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M 2.2、常用命令1234567891011121314151617181920set &lt;key&gt;&lt;value&gt;添加键值对 *NX：当数据库中key不存在时，可以将key-value添加数据库*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥*EX：key的超时秒数*PX：key的超时毫秒数，与EX互斥get &lt;key&gt;查询对应键值append &lt;key&gt;&lt;value&gt;将给定的&lt;value&gt; 追加到原值的末尾strlen &lt;key&gt;获得值的长度setnx &lt;key&gt;&lt;value&gt;只有在 key 不存在时 设置key 的值incr &lt;key&gt;将 key 中储存的数字值增1只能对数字值操作，如果为空，新增值为1decr &lt;key&gt;将 key 中储存的数字值减1只能对数字值操作，如果为空，新增值为-1incrby / decrby &lt;key&gt;&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。 原子性： 12345所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。（1）在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。Redis单命令的原子性主要得益于Redis的单线程。 案例： java中的i++是否是原子操作？不是i&#x3D;0;两个线程分别对i进行++100次,值是多少？ 2~200 123456789101112第一个线程 第二个线程i=0 i=0（已经取值）i++ i=99 i++ i=1i=1（取值时，i已经变成1） i++ i=100i++i=2 1234567891011121314151617mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ..... 同时设置一个或多个 key-value对 mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....同时获取一个或多个 value msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ..... 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;获得值的范围，类似java中的substring，前包，后包setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;用 &lt;value&gt; 覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;设置键值的同时，设置过期时间，单位秒。getset &lt;key&gt;&lt;value&gt;以新换旧，设置了新值同时获得旧值。 2.3、数据结构String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配. 如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。 3、Redis列表3.1、简介单键多值 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 3.2、常用命令123456789101112131415lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... 从左边/右边插入一个或多个值。lpop/rpop &lt;key&gt;从左边/右边吐出一个值。值在键在，值光键亡。rpoplpush &lt;key1&gt;&lt;key2&gt;从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;按照索引下标获得元素(从左到右)lrange mylist 0 -1 0左边第一个，-1右边第一个，（0-1表示获取所有）lindex &lt;key&gt;&lt;index&gt;按照索引下标获得元素(从左到右)llen &lt;key&gt;获得列表长度 linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;从左边删除n个value(从左到右)lset&lt;key&gt;&lt;index&gt;&lt;value&gt;将列表key下标为index的值替换成value 3.3、数据结构123456List的数据结构为快速链表quickList。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。 Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 4、Redis集合（Set）4.1、简介Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的*复杂度都是***O(1)**。 一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。 4.2、常用命令123456789101112sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略smembers &lt;key&gt;取出该集合的所有值。sismember &lt;key&gt;&lt;value&gt;判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0scard&lt;key&gt;返回该集合的元素个数。srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... 删除集合中的某个元素。spop &lt;key&gt;随机从该集合中吐出一个值。srandmember &lt;key&gt;&lt;n&gt;随机从该集合中取出n个值。不会从集合中删除 。smove &lt;source&gt;&lt;destination&gt;value把集合中一个值从一个集合移动到另一个集合sinter &lt;key1&gt;&lt;key2&gt;返回两个集合的交集元素。sunion &lt;key1&gt;&lt;key2&gt;返回两个集合的并集元素。sdiff &lt;key1&gt;&lt;key2&gt;返回两个集合的差集元素(key1中的，不包含key2中的) 4.3、数据结构Set数据结构是dict字典，字典是用哈希表实现的。 Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。 5、Redis哈希5.1、简介Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; 用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储 主要有以下2种存储方式： 5.2、常用命令12345678hset &lt;key&gt;&lt;field&gt;&lt;value&gt;给&lt;key&gt;集合中的 &lt;field&gt;键赋值&lt;value&gt;hget &lt;key1&gt;&lt;field&gt;从&lt;key1&gt;集合&lt;field&gt;取出 value hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... 批量设置hash的值hexists&lt;key1&gt;&lt;field&gt;查看哈希表 key 中，给定域 field 是否存在。 hkeys &lt;key&gt;列出该hash集合的所有fieldhvals &lt;key&gt;列出该hash集合的所有valuehincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;为哈希表 key 中的域 field 的值加上增量 1 -1hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 . 5.3、数据结构Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。 6、Redis有序集合6.1、简介Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 6.2、常用命令12345678910111213zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…将一个或多个 member 元素及其 score 值加入到有序集 key 当中。zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES] 返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。zrangebyscore key minmax [withscores] [limit offset count]返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列。 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt; 为元素的score加上增量zrem &lt;key&gt;&lt;value&gt;删除该集合下，指定值的元素 zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;返回该值在集合中的排名，从0开始。 案例：如何利用zset实现一个文章访问量的排行榜？ 6.3、数据结构12345SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。zset底层使用了两个数据结构（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。 6.4、跳跃表（跳表） 简介 有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。 实例 对比有序链表和跳跃表，从链表中查询出51 有序列表 要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。 跳跃表 从第2层开始，1节点比51节点小，向后比较。 21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层 在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下 在第0层，51节点为要查找的节点，节点被找到，共查找4次。 从此可以看出跳跃表比有序链表效率要高 四、Redis配置文件介绍自定义目录：&#x2F;etc&#x2F;redis.conf 1、Units单位配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit 大小写不敏感 2、INCLUDES包含 类似jsp中的include，多实例的情况可以把公用的配置文件提取出来 3、网络相关配置3.1、bind1234默认情况bind=127.0.0.1只能接受本机的访问请求不写的情况下，无限制接受任何ip地址的访问生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应 保存配置，停止服务，重启启动查看进程，不再是本机访问了。 3.2、protected-mode将本机访问保护模式设置no 3.3、Port端口号：默认为6379 3.4、tcp-backlog123设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果 3.5、timeout一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。 3.6、tcp-keepalive对访问客户端的一种心跳检测，每个n秒检测一次。 单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 4、GENERAL通用4.1、daemonize是否为后台进程，设置为yes守护进程，后台启动 4.2、pidfile存放pid文件的位置，每个实例会产生一个不同的pid文件 4.3、loglevel指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice 四个级别根据使用阶段来选择，生产环境选择notice 或者warning 4.4、logfile日志文件名称 4.5、databases 16设定库的数量 默认16，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id 5、SECURITY安全5.1设置密码 访问密码的查看、设置和取消 在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。 永久设置，需要再配置文件中进行设置。 6、LIMITS限制6.1、maxclients 设置redis同时可以与多少个客户端进行连接。 默认情况下为10000个客户端。 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。 6.2、maxmemory 建议必须设置，否则，将内存占满，造成服务器宕机 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。 6.3、maxmemory-policy volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用） allkeys-lru：在所有集合key中，使用LRU算法移除key volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键 allkeys-random：在所有集合key中，移除随机的key volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key noeviction：不进行移除。针对写操作，只是返回错误信息 6.4、maxmemory-samples 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。 五、Redis的发布和订阅1、什么是发布和订阅Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 2、Redis的发布和订阅 客户端可以订阅频道如下图 当给这个频道发布消息后，消息就会发送给订阅的客户端 3、发布订阅命令行实现 打开一个客户端订阅channel1 SUBSCRIBE channel1 打开另一个客户端，给channel1发布消息hello publish channel1 hello 返回的1是订阅者数量 打开第一个客户端可以看到发送的消息 、 注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息 六、Redis新数据类型1、Bitmaps1.1、简介现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图 1234合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。 1.2、命令 setbit （1）格式 setbit设置Bitmaps中某个偏移量的值（0或1） *offset:偏移量从0开始 （2）实例 每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。 设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图 unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps 123注：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。 getbit （1）格式 getbit获取Bitmaps中某个偏移量的值 获取键的第offset位的值（从0开始算） （2）实例 获取id&#x3D;8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过： 注：因为100根本不存在，所以也是返回0 bitcount 统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。 （1）格式 bitcount[start end] 统计字符串从start字节到end字节比特值为1的数量 （2）实例 计算2022-11-06这天的独立访问用户数量 start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。 1234567891011举例： K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】bitcount K1 1 2 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000--》bitcount K1 1 2 --》1bitcount K1 1 3 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000 00100001--》bitcount K1 1 3 --》3bitcount K1 0 -2 ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001 01000000 00000000--》bitcount K1 0 -2 --》3 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。 bitop （1）格式 bitop and(or&#x2F;not&#x2F;xor) [key…] bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。 （2）实例 12345678910111213141516172020-11-04 日访问网站的userid=1,2,5,9。setbit unique:users:20201104 1 1setbit unique:users:20201104 2 1setbit unique:users:20201104 5 1setbit unique:users:20201104 9 12020-11-03 日访问网站的userid=0,1,4,9。setbit unique:users:20201103 0 1setbit unique:users:20201103 1 1setbit unique:users:20201103 4 1setbit unique:users:20201103 9 1计算出两天都访问过网站的用户数量bitop and unique:users:and:20201104_03 unique:users:20201103unique:users:20201104 计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集 1.3、Bitmaps与set对比假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表 很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的 但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。 2、HyperLogLog2.1、简介12345678910111213在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。解决基数问题有很多种方案：（1）数据存储在MySQL表中，使用distinct count计算不重复个数（2）使用Redis提供的hash、set、bitmaps等数据结构来处理以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLogRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。什么是基数?比如数据集 &#123;1, 3, 5, 7, 5, 7, 8&#125;， 那么这个数据集的基数集为 &#123;1, 3, 5 ,7, 8&#125;, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 2.2命令 pfadd （1）格式 pfadd &lt; element&gt; [element …] 添加指定元素到 HyperLogLog 中 （2）实例 将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。 pfcount （1）格式 pfcount [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可 （2）实例 pfmerge （1）格式 pfmerge [sourcekey …] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得 （2）实例 3、Geospatial3.1、简介Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。 3.2、命令 geoadd (1)格式 geoadd&lt; longitude&gt; [longitude latitude member…] 添加地理位置（经度，纬度，名称） （2）实例 geoadd china:city 121.47 31.23 shanghai geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing 1234两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。 geopos （1）格式 geopos [member…] 获得指定地区的坐标值 （2）实例 geodist （1）格式 geodist [m|km|ft|mi ] 获取两个位置之间的直线距离 （2）实例 获取两个位置之间的直线距离 单位： m 表示单位为米[默认值]。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位 georadius （1）格式 georadius&lt; longitude&gt;radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素 经度 纬度 距离 单位 （2）实例 七、Redis_Jedis_测试1、Jedis所需要的jar包12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 2、连接Redis注意事项禁用Linux的防火墙：Linux(CentOS7)里执行命令 systemctl stop&#x2F;disable firewalld.service redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no 3、Jedis常用操作3.1、创建动态的工程3.2、创建测试程序12345678910111213141516171819package com.lxg.jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.Tuple;import java.util.List;import java.util.Set;public class JedisDemo1 &#123; public static void main(String[] args) &#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); //测试 String value = jedis.ping(); System.out.println(value); &#125;&#125; 4、测试相关数据类型4.1、Jedis-API：Key123456789101112131415161718192021222324252627// 操作key @Test public void demo1()&#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); //添加 jedis.set(&quot;name&quot;,&quot;lucy&quot;); //获取 String name = jedis.get(&quot;name&quot;); System.out.println(name); //设置多个key-value jedis.mset(&quot;k1&quot;,&quot;v1&quot;,&quot;k2&quot;,&quot;v2&quot;); List&lt;String&gt; mget = jedis.mget(&quot;k1&quot;, &quot;k2&quot;); System.out.println(mget); Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); for(String key : keys)&#123; System.out.println(key); &#125; &#125; 4.2、Jedis-API：List12345678910111213// 操作list @Test public void demo2()&#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); jedis.lpush(&quot;key1&quot;,&quot;lucy&quot;,&quot;marry&quot;,&quot;jack&quot;); List&lt;String&gt; values = jedis.lrange(&quot;key1&quot;, 0, -1); System.out.println(values); &#125; 4.3、Jedis-API：set123456789101112// 操作set @Test public void demo3()&#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); jedis.sadd(&quot;names&quot;,&quot;lucy&quot;,&quot;jack&quot;); Set&lt;String&gt; names = jedis.smembers(&quot;names&quot;); System.out.println(names); &#125; 4.4、Jedis-API：hash123456789101112// 操作哈希 @Test public void demo4()&#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); jedis.hset(&quot;users&quot;,&quot;age&quot;,&quot;20&quot;); String hget = jedis.hget(&quot;users&quot;, &quot;age&quot;); System.out.println(hget); &#125; 4.5、Jedis-API:zset1234567891011// 操作有序列表 @Test public void demo5()&#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); jedis.zadd(&quot;china&quot;,100d,&quot;shanghai&quot;); Set&lt;Tuple&gt; china = jedis.zrangeWithScores(&quot;china&quot;, 0, -1); System.out.println(china); &#125; 八、Redis实例1、完成一个手机验证码功能1234567要求：1、输入手机号，点击发送后随机生成6位数字码，2分钟有效2、输入验证码，点击验证，返回成功或失败3、每个手机号每天只能输入3次 源代码创建SpringBoot项目，引入Redis依赖 index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;手机验证码&lt;/title&gt; &lt;style&gt; div&#123; width: 400px; height: 200px; margin: 0 auto; &#125; &lt;/style&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot;/&gt; &lt;button id=&quot;send&quot;&gt;发送验证码&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;code&quot;/&gt; &lt;button id=&quot;sure&quot;&gt;确定&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; const btn01 = document.getElementById(&quot;send&quot;); const btn02 = document.getElementById(&quot;sure&quot;); const Inputcode = document.getElementsByName(&quot;code&quot;)[0]; const Inputphone = document.getElementsByName(&quot;phone&quot;)[0]; var getcode; btn01.addEventListener(&quot;click&quot;,()=&gt;&#123; axios.get(&quot;/createCode?phone=&quot;+Inputphone.value).then(code=&gt;&#123; console.log(Inputphone.value+&quot;请求服务器得到的验证码是：&quot;+code.data); getcode=code.data; &#125;) &#125;) btn02.addEventListener(&quot;click&quot;,()=&gt;&#123; console.log(&quot;test&quot;); axios.get(`/verifyCode?phone=$&#123;Inputphone.value&#125;&amp;icode=$&#123;Inputcode.value&#125;`).then(status=&gt;&#123; console.log(&quot;请求服务器得到的验证码是：&quot;+getcode); console.log(&quot;用户输入的验证码是：&quot;+Inputcode.value); if(status.data)&#123; alert(&quot;验证成功&quot;); &#125;else&#123; alert(&quot;验证失败&quot;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lxg.jediscode.jedis.controller;import org.springframework.boot.autoconfigure.data.redis.RedisProperties;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import redis.clients.jedis.Jedis;import java.util.Random;@RestControllerpublic class CodeController &#123; @GetMapping(&quot;/createCode&quot;) //1、生成6位验证码 public String createCode(@RequestParam(value = &quot;phone&quot;) String phone)&#123; Random random = new Random();// String code = &quot;&quot;; StringBuilder code = new StringBuilder(); for (int i = 0; i &lt; 6; i++) &#123; int rand = random.nextInt(10);// code+=rand; code.append(rand); &#125; //将验证码存入redis setCode(String.valueOf(code),phone); //获取redis中的验证码 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); String codeKey = &quot;VerifyCode&quot;+phone+&quot;:code&quot;; String redisCode = jedis.get(codeKey); return redisCode; &#125; //2、每个手机每天只能发送三次，验证码放到redis中，设置过期时间为120秒 public void setCode(String ccode,String phone)&#123; //连接redis Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); //拼接key //手机发送次数key String countKey = &quot;VerifyCode&quot;+phone+&quot;:count&quot;; //验证码key String codeKey = &quot;VerifyCode&quot;+phone+&quot;:code&quot;; //每个手机每天只能发送三次 String count = jedis.get(countKey); if(count==null)&#123; //没有发送过，第一次 //设置发送次数为1 jedis.setex(countKey,24*60*60,&quot;1&quot;); &#125; else if (Integer.parseInt(count)&lt;=2) &#123; //发送次数+1 jedis.incr(countKey); &#125;else if(Integer.parseInt(count)&gt;2)&#123; //发送三次，不能再发送 System.out.println(&quot;今天发送次数已经超过三次&quot;); jedis.close(); return; &#125; //把验证码放到redis里去 jedis.setex(codeKey,120,ccode); jedis.close(); &#125; @GetMapping(&quot;/verifyCode&quot;) //3、验证码校验 public Boolean verifyCode(@RequestParam(value = &quot;phone&quot;) String phone,@RequestParam(value = &quot;icode&quot;) String icode)&#123; //从redis获取验证码 Jedis jedis = new Jedis(&quot;106.55.228.118&quot;,6379); //验证码key String codeKey = &quot;VerifyCode&quot;+phone+&quot;:code&quot;; String redisCode = jedis.get(codeKey); //判断 if(redisCode.equals(icode))&#123; System.out.println(&quot;成功&quot;); jedis.close(); return true; &#125;else&#123; System.out.println(&quot;失败&quot;); jedis.close(); return false; &#125; &#125;&#125; 九、Redis与SpringBoot整合1、整合步骤1.1、引入依赖123456789101112131415161718192021222324252627&lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jackson 2.x 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; 1.2、application.properties配置redis配置12345678910111213141516#Redis服务器地址spring.redis.host=106.55.228.118#Redis服务器连接端口spring.redis.port=6379#Redis数据库索引（默认为0）spring.redis.database= 0#连接超时时间（毫秒）spring.redis.timeout=1800000#连接池最大连接数（使用负值表示没有限制）spring.redis.lettuce.pool.max-active=20#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-wait=-1#连接池中的最大空闲连接spring.redis.lettuce.pool.max-idle=5#连接池中的最小空闲连接spring.redis.lettuce.pool.min-idle=0 1.3、添加redis配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.lxg.redis_springboot.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory);//key序列化方式 template.setKeySerializer(redisSerializer);//value序列化 template.setValueSerializer(jackson2JsonRedisSerializer);//value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);//解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om);// 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; 1.4、测试1234567891011121314151617181920212223242526package com.lxg.redis_springboot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/redisTest&quot;)public class RedisTestController &#123; @Autowired private RedisTemplate redisTemplate; @GetMapping public String testRedis() &#123; //设置值到redis redisTemplate.opsForValue().set(&quot;name&quot;,&quot;lucy&quot;); //从redis获取值 String name = (String) redisTemplate.opsForValue().get(&quot;name&quot;); return name; &#125;&#125; 十、Redis中的事务操作1、Redis中的事务定义 Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队 2、Multi、Exec、discard从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。 组队的过程中可以通过discard来放弃组队。 案例： 组队成功，提交成功 组队阶段报错，提交失败 组队成功，提交有成功有失败情况 3、事务的错误处理组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。 4、为什么要做成事务想想一个场景：有很多人有你的账户,同时去参加双十一抢购 5、事务冲突的问题5.1、例子一个请求想给金额减8000 一个请求想给金额减5000 一个请求想给金额减1000 5.2、悲观锁与乐观锁 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。 5.3、WATCH key [key …]在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 5.4、unwatch取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。 http://doc.redisfans.com/transaction/exec.html 6、Redis事务三大特性123456781、单独的隔离操作 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其 他客户端发送来的命令请求所打断。 2、没有隔离级别的概念 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行3、保证原子性 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 十一、Redis——事务——秒杀案例1、解决计数器和人员记录的事务操作 2、Redis事务—秒杀并发模拟使用工具ab模拟测试 CentOS6 默认安装 CentOS7需要手动安装 2.1、联网：yum install httpd-tools（centos）ubuntu：sudo apt-get install apache2-utils 2.2 、无网络（1） 进入cd &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x86_64&#x2F;Packages（路径跟centos6不同） （2） 顺序安装 apr-1.4.8-3.el7.x86_64.rpm apr-util-1.5.2-6.el7.x86_64.rpm httpd-tools-2.4.6-67.el7.centos.x86_64.rpm 2.3、测试及结果2.3.1、通过ab测试vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。 内容：prodid&#x3D;0101&amp; 执行命令： ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded http://192.168.2.115:8081/Seckill/doseckill 2.3.2、超卖 3、超卖问题 4、利用乐观锁淘汰用户，解决超卖问题 1234567891011121314151617//增加乐观锁jedis.watch(qtkey); //3.判断库存String qtkeystr = jedis.get(qtkey);if(qtkeystr==null || &quot;&quot;.equals(qtkeystr.trim())) &#123;System.out.println(&quot;未初始化库存&quot;);jedis.close();return false ;&#125; int qt = Integer.parseInt(qtkeystr);if(qt&lt;=0) &#123;System.err.println(&quot;已经秒光&quot;);jedis.close();return false;&#125; 12345678910111213141516171819202122//增加事务Transaction multi = jedis.multi(); //4.减少库存//jedis.decr(qtkey);multi.decr(qtkey); //5.加人//jedis.sadd(usrkey, uid);multi.sadd(usrkey, uid); //执行事务List&lt;Object&gt; list = multi.exec(); //判断事务提交是否失败if(list==null || list.size()==0) &#123;System.out.println(&quot;秒杀失败&quot;);jedis.close();return false;&#125;System.err.println(&quot;秒杀成功&quot;);jedis.close(); 5、继续增加并发测试5.1、连接有限制ab -n 2000 -c 200 -k -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ http://192.168.140.1:8080/seckill/doseckill 增加-r参数，-r Don’t exit on socket receive errors. ab -n 2000 -c 100 -r -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ http://192.168.140.1:8080/seckill/doseckill 5.2、已经秒光，但是还有库存ab -n 2000 -c 100 -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ http://192.168.137.1:8080/seckill/doseckill 已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。 5.3、连接超时，通过连接池解决 5.4、连接池12345678910节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为代码见项目中 链接池参数 MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。 maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例； MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException； testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的； 6、解决库存遗留问题6.1、LUA脚本 1234Lua 是一个小巧的脚本语言，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。https://www.w3cschool.cn/lua/ 6.2、LUA脚本在Redis中的优势12345将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。利用lua脚本淘汰用户，解决超卖问题。redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。 7、Redis_事务_秒杀案例_代码7.1、项目结构 7.2、第一版：简单版老师点10次，正常秒杀 同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。 使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。 7.3、第二版：加事务-乐观锁（解决超卖），但出现遗留库存和超时7.4、第三版：连接池解决超时问题7.5、第四版：解决库存遗留问题，LUA脚本1234567891011121314151617local userid=KEYS[1]; local prodid=KEYS[2];local qtkey=&quot;sk:&quot;..prodid..&quot;:qt&quot;;local usersKey=&quot;sk:&quot;..prodid.&quot;:usr&#x27;; local userExists=redis.call(&quot;sismember&quot;,usersKey,userid);if tonumber(userExists)==1 then return 2;endlocal num= redis.call(&quot;get&quot; ,qtkey);if tonumber(num)&lt;=0 then return 0; else redis.call(&quot;decr&quot;,qtkey); redis.call(&quot;sadd&quot;,usersKey,userid);endreturn 1; 十二、Redis持久化之RDB1、总体介绍官网介绍：http://www.redis.io Redis 提供了2个不同形式的持久化方式。 RDB（Redis DataBase） AOF（Append Of File） 2、RDB（Redis DataBase）2.1、官网介绍 2.2、是什么在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 2.3、备份是如何执行的Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 2.4、Fork Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术” 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 2.5、RDB持久化流程 2.6、dump.rdb文件在redis.conf中配置文件名称，默认为dump.rdb 2.7、配置位置rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 dir “&#x2F;myredis&#x2F;“ 2.8、如何触发RDB快照；保持策略2.8.1、配置文件中默认的快照配置 2.8.2、命令save VS bgsave（手动触发）save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。 bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。 可以通过lastsave 命令获取最后一次成功执行快照的时间 2.8.3、flushall命令执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 2.8.4、SNAPSHOTTING快照2.8.5、Save（配置自动触发）格式：save 秒钟 写操作次数 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件， 默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。 禁用 不设置save指令，或者给save传入空字符串 2.8.6、stop-writes-on-bgsave-error 当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes. 2.8.7、rdbcompression 压缩文件 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。 如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes. 2.8.8、rdbchecksum 检查完整性 在存储快照后，还可以让redis使用CRC64算法来进行数据校验， 但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能 推荐yes. 2.8.9、rdb的备份123456先通过config get dir 查询rdb文件的目录 将*.rdb的文件拷贝到别的地方rdb的恢复 关闭Redis 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb 启动Redis, 备份数据会直接加载 2.9、优势 适合大规模的数据恢复 对数据完整性和一致性要求不高更适合使用 节省磁盘空间 恢复速度快 2.10、劣势 lFork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。 2.11、如何停止动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略 2.11、小结 十三、Redis持久化之AOF1、AOF（Append Only File）1.1、是什么以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 1.2、AOF持久化流程（1）客户端的请求写命令会被append追加到AOF缓冲区内； （2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中； （3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量； （4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的； 1.3、AOF默认不开启可以在redis.conf中配置文件名称，默认为 appendonly.aof AOF文件的保存路径，同RDB的路径一致。 1.4、AOF和RDB同时开启，reids听谁的？AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） 1.5、AOF启动&#x2F;修复&#x2F;恢复 AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。 正常恢复 修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir) 恢复：重启redis然后重新加载 异常恢复 修改默认的appendonly no，改为yes、 如遇到AOF文件损坏，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof–fix appendonly.aof进行恢复 备份被写坏的AOF文件 恢复：重启redis，然后重新加载 1.6、AOF同步频率设置appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好 appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 appendfsync no redis不主动进行同步，把同步时机交给操作系统。 1.7、Rewrite压缩1、是什么： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 2、重写原理，如何实现重写 AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 no-appendfsync-on-rewrite： 如果 no-appendfsync-on-rewrite&#x3D;yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能） 如果 no-appendfsync-on-rewrite&#x3D;no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低） 触发机制，何时重写 Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发 重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发） auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。 例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB 系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size, 如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 3、重写流程 （1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。 （2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。 （3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。 （4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。 （5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。 1.8、优势 备份机制更稳健，丢失数据概率更低。 可读的日志文本，通过操作AOF稳健，可以处理误操作。 1.9、劣势 比起RDB占用更多的磁盘空间。 恢复备份速度要慢。 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成恢复不能。 1.10、小总结 2、总结2.1、用哪个好官方推荐两个都启用。 如果对数据不敏感，可以选单独用RDB。 不建议单独用 AOF，因为可能会出现Bug。 如果只是做纯内存缓存，可以都不用。 2.2、官网建议 RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储 AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 同时开启两种持久化方式 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。 性能建议 123456因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。 如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。 十四、Redis_主从复制1、是什么主机数据更新后根据配置和策略， 自动同步到备机的master&#x2F;slaver机制，Master****以写为主，Slave以读为主** 2、能干嘛读写分离，性能扩展 容灾快速恢复 3、怎么玩：主从复制拷贝多个redis.conf文件include(写绝对路径) 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 dump.rdb名字dbfilename Appendonly 关掉或者换名字 3.1、新建redis6379.conf，填写以下内容include &#x2F;myredis&#x2F;redis.conf pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid port 6379 dbfilename dump6379.rdb 3.2、新建redis6380.conf，填写以下内容 3.3、新建redis6381.conf，填写以下内容 slave-priority 10 设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100 3.4、启动三台redis服务器 3.5、查看系统进程，看看三台服务器是否启动 3.6、查看三台主机运行情况info replication 打印主从复制的相关信息 3.7、配从（库）不配主（库）slaveof 成为某个实例的从服务器 在6380和6381上执行: slaveof 127.0.0.1 6379 在主机上写，在从机上可以读取数据 在从机上写数据报错 主机挂掉，重启就行，一切如初 从机重启需重设：slaveof 127.0.0.1 6379 可以将配置增加到文件中。永久生效。 4、常用三招4.1、一主二仆切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？ 从机是否可以写？set可否？ 主机shutdown后情况如何？从机是上位还是原地待命？ 主机又回来了后，主机新增记录，从机还能否顺利复制？ 其中一台从机down后情况如何？依照原有它能跟上大部队吗？ 4.2、薪火相传上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。 用 slaveof 中途变更转向:会清除之前的数据，重新建立拷贝最新的 风险是一旦某个slave宕机，后面的slave都没法备份 主机挂了，从机还是从机，无法写数据了 4.3、反客为主当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。 用 slaveof no one 将从机变为主机。 5、复制原理 Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行 ![image-20221129122104811]( 6、哨兵模式6.1、是什么反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 6.2、怎么玩（使用步骤）6.2.1、调整为一主二仆模式，6379带着6380、6381 6.2.2、自定义的&#x2F;myredis 目录下新建sentinel.conf文件，名字绝不能错6.2.3、配置哨兵，填写内容sentinel monitor mymaster 127.0.0.1 6379 1 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 6.2.4、启动哨兵&#x2F;usr&#x2F;local&#x2F;bin redis做压测可以用自带的redis-benchmark工具 执行redis-sentinel &#x2F;myredis&#x2F;sentinel.conf 6.2.5、当主机挂掉，从机选举中产生新的主机(大概10秒左右可以看到哨兵窗口日志，切换了新的主机) 哪个从机会被选举为主机呢？根据优先级别：slave-priority 原主机重启后会变为从机。 6.2.6、复制延时由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 6.3、故障恢复 优先级在redis.conf中默认：slave-priority 100，值越小优先级越高 偏移量是指获得原主机数据最全的 每个redis实例启动后都会随机生成一个40位的runid 6.4、主从复制123456789101112131415161718192021private static JedisSentinelPool jedisSentinelPool=null;public static Jedis getJedisFromSentinel()&#123;if(jedisSentinelPool==null)&#123; Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;(); sentinelSet.add(&quot;192.168.11.103:26379&quot;); JedisPoolConfig jedisPoolConfig =new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(10); //最大可用连接数jedisPoolConfig.setMaxIdle(5); //最大闲置连接数jedisPoolConfig.setMinIdle(5); //最小闲置连接数jedisPoolConfig.setBlockWhenExhausted(true); //连接耗尽是否等待jedisPoolConfig.setMaxWaitMillis(2000); //等待时间jedisPoolConfig.setTestOnBorrow(true); //取连接的时候进行一下测试 ping pongjedisSentinelPool=new JedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig);return jedisSentinelPool.getResource(); &#125;else&#123;return jedisSentinelPool.getResource(); &#125;&#125; 十五、Redis集群1、问题容量不够，redis如何进行扩容？ 并发写操作， redis如何分摊？ 另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。 之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。 2、什么是集群Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 3、删除持久化数据将rdb,aof文件都删除掉。 4、制作6个实例：6379、6380、6381、6389、6390、63914.1、配置基本信息开启daemonize yes Pid文件名字 指定端口 Log文件名字 Dump.rdb名字 Appendonly 关掉或者换名字 4.2、redis cluster 配置修改cluster-enabled yes 打开集群模式 cluster-config-file nodes-6379.conf 设定节点配置文件名 cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。 123456789include /home/bigdata/redis.confport 6379pidfile &quot;/var/run/redis_6379.pid&quot;dbfilename &quot;dump6379.rdb&quot;dir &quot;/home/bigdata/redis_cluster&quot;logfile &quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 15000 4.3、修改好redis6379.conf文件，拷贝多个redis.conf文件 4.4、使用查找替换修改另外五个文件例如：:%s&#x2F;6379&#x2F;6380 4.5、启动6个redis服务 5、将六个节点合成一个集群组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。 合体： cd &#x2F;opt&#x2F;redis-6.2.1&#x2F;src 1redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391 此处不要用127.0.0.1，请用真实IP地址 –replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。 普通方式登录 可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。 6、-c 采用集群策略连接，设置数据会自动切换到相应的写主机 7、通过cluster nodes 命令查看集群信息 8、redis cluster 如何分配六个节点一个集群至少要有三个主节点。 选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。 9、什么是slots[OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots… &gt;&gt;&gt; Check slots coverage… [OK] All 16384 slots covered. 一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中： 节点 A 负责处理 0 号至 5460 号插槽。 节点 B 负责处理 5461 号至 10922 号插槽。 节点 C 负责处理 10923 号至 16383 号插槽。 10、在集群中录入值在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。 redis-cli客户端提供了 –c 参数实现自动重定向。 如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。 不在一个slot下的键值，是不能使用mget,mset等多键操作。 可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。 11、查询集群中的值CLUSTER GETKEYSINSLOT 返回 count 个 slot 槽中的键。 12、故障恢复如果主节点下线？从节点能否自动升为主节点？注意：15秒超时 主节点恢复后，主从关系会如何？主节点回来变成从机。 如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续? 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。 redis.conf中的参数 cluster-require-full-coverage 13、集群的Jedis开发即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。 无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。 123456789public class JedisClusterTest &#123; public static void main(String[] args) &#123; Set&lt;HostAndPort&gt;set =new HashSet&lt;HostAndPort&gt;(); set.add(new HostAndPort(&quot;192.168.31.211&quot;,6379)); JedisCluster jedisCluster=new JedisCluster(set); jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;); System.out.println(jedisCluster.get(&quot;k1&quot;)); &#125;&#125; 14、Redis集群提供了以下好处实现扩容 分摊压力 无中心配置相对简单 15、Redis集群的不足多键操作是不被支持的 多键的Redis事务是不被支持的。lua脚本不被支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。 十六、Redis应用问题解决1、缓存穿透1.1、问题描述key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 1.2、解决方案一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 解决方案： （1） 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟 （2） 设置可访问的名单（白名单）： 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 （3） 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。 布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。) 将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。 （4） 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务 2、缓存击穿2,1、问题描述key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 2.2、解决方案key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。 解决问题： （1）预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 （2）实时调整：现场监控哪些数据热门，实时调整key的过期时长 （3）使用锁： （1） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。 （2） 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key （3） 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key； （4） 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。 3、缓存雪崩3.1、问题描述key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问 缓存失效瞬间 3.2、解决方案缓存失效时的雪崩效应对底层系统的冲击非常可怕！ 解决方案： （1） 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等） （2） 使用锁或队列： 用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况 （3） 设置过期标志更新缓存： 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。 （4） 将缓存失效时间分散开： 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 4、分布式锁4.1、问题描述随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 分布式锁主流的实现方案： 基于数据库实现分布式锁 基于缓存（Redis等） 基于Zookeeper 每一种分布式锁解决方案都有各自的优缺点： 性能：redis最高 可靠性：zookeeper最高 这里，我们就基于redis实现分布式锁。 4.2、解决方案：使用redis实现分布式锁redis:命令 # set sku:1:info “OK” NX PX 10000 EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。 PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 XX ：只在键已经存在时，才对键进行设置操作。 多个客户端同时获取锁（setnx） 获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del） 其他客户端等待重试 4.3、编写代码Redis: set num 0 12345678910111213141516171819202122232425262728@GetMapping(&quot;testLock&quot;)public void testLock()&#123; //1获取锁，setne Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;); //2获取锁成功、查询num的值 if(lock)&#123; Object value = redisTemplate.opsForValue().get(&quot;num&quot;); //2.1判断num为空return if(StringUtils.isEmpty(value))&#123; return; &#125; //2.2有值就转成成int int num = Integer.parseInt(value+&quot;&quot;); //2.3把redis的num加1 redisTemplate.opsForValue().set(&quot;num&quot;, ++num); //2.4释放锁，del redisTemplate.delete(&quot;lock&quot;); &#125;else&#123; //3获取锁失败、每隔0.1秒再获取 try &#123; Thread.sleep(100); testLock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 重启，服务集群，通过网关压力测试： ab -n 1000 -c 100 http://192.168.140.1:8080/test/testLock 查看redis中num的值： 4.4、优化之设置锁的过期时间设置过期时间有两种方式： 首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放） 在set时指定过期时间（推荐） 设置过期时间： 压力测试肯定也没有问题。自行测试 问题：可能会释放其他服务器的锁。 场景：如果业务逻辑的执行时间是7s。执行流程如下 index1业务逻辑没执行完，3秒后锁被自动释放。 index2获取到锁，执行业务逻辑，3秒后锁被自动释放。 index3获取到锁，执行业务逻辑 index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。 最终等于没锁的情况。 解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁 4.5、优化之UUID防误删 123456789101112131415161718192021222324252627问题：删除操作缺乏原子性。场景：1. index1执行删除时，查询到的lock值确实和uuid相等uuid=v1set(lock,uuid)； 2. index1执行删除前，lock刚好过期时间已到，被redis自动释放在redis中没有了lock，没有了锁。3. index2获取了lockindex2线程获取到了cpu的资源，开始执行方法uuid=v2set(lock,uuid)；4. index1执行删除，此时会把index2的lock删除index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行删除的index2的锁！ 4.6、优化之LUA脚本保证删除的原子性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@GetMapping(&quot;testLockLua&quot;)public void testLockLua() &#123; //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中 String uuid = UUID.randomUUID().toString(); //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！ String skuId = &quot;25&quot;; // 访问skuId 为25号的商品 100008348542 String locKey = &quot;lock:&quot; + skuId; // 锁住的是每个商品的数据 // 3 获取锁 Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS); // 第一种： lock 与过期时间中间不写任何的代码。 // redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间 // 如果true if (lock) &#123; // 执行的业务逻辑开始 // 获取缓存中的num 数据 Object value = redisTemplate.opsForValue().get(&quot;num&quot;); // 如果是空直接返回 if (StringUtils.isEmpty(value)) &#123; return; &#125; // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！ int num = Integer.parseInt(value + &quot;&quot;); // 使num 每次+1 放入缓存 redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num)); /*使用lua脚本来锁*/ // 定义lua 脚本 String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; // 使用redis执行lua执行 DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setScriptText(script); // 设置一下返回值类型 为Long // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型， // 那么返回字符串与0 会有发生错误。 redisScript.setResultType(Long.class); // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。 redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid); &#125; else &#123; // 其他线程等待 try &#123; // 睡眠 Thread.sleep(1000); // 睡醒了之后，调用方法。 testLockLua(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Lua 脚本详解： 项目中正确使用： 12341. 定义key，key应该是为每个sku定义的，也就是每个sku有一把锁。String locKey =&quot;lock:&quot;+skuId; // 锁住的是每个商品的数据Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid,3,TimeUnit.SECONDS); 4.7、总结1、加锁 1234// 1. 从redis中获取锁,set k1 v1 px 20000 nxString uuid = UUID.randomUUID().toString();Boolean lock = this.redisTemplate.opsForValue() .setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS); 2、使用LUA释放锁 12345678// 2. 释放锁 delString script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;// 设置lua脚本返回的数据类型DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();// 设置lua脚本返回类型为LongredisScript.setResultType(Long.class);redisScript.setScriptText(script);redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid); 3、重试 12Thread.sleep(500);testLock(); 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： - 互斥性。在任意时刻，只有一个客户端能持有锁。 - 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 - 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 - 加锁和解锁必须具有原子性。 十七、Redis6.0新功能1、ACL1.1、简介Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。 在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ： （1）接入权限:用户名和密码 （2）可以执行的命令 （3）可以操作的 KEY 参考官网：https://redis.io/topics/acl 1.2、命令1、使用acl list命令展现用户权限列表 （1）数据说明 2、使用acl cat命令 （1）查看添加权限指令类别 （2）加参数类型名可以查看类型下具体命令 3、使用acl whoami命令查看当前用户 4、使用aclsetuser命令创建和编辑用户ACL （1）ACL规则 下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。 （2）通过命令创建新用户默认权限 acl setuser user1 在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。 （3）设置有用户名、密码、ACL权限、并启用的用户 acl setuser user2 on &gt;password ~cached:* +get (4)切换用户，验证权限 2、IO多线程2.1、简介Redis6终于支撑多线程了，告别单线程了吗？ IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。Redis6执行命令依然是单线程。 2.2、原理架构Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下: 另外，多线程IO默认也是不开启的，需要再配置文件中配置 io-threads-do-reads yes io-threads 4 3、工具支持Cluster之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。 4、Redis新功能持续关注Redis6新功能还有： 1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信 2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。 3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。 4、Modules API Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。","tags":"redis"},{"title":"RabbitMQ","url":"/2023/10/12/RabbitMQ/","text":"RabbitMQ[Toc] 一、消息队列1、MQ的相关概念1.1、什么是MQ1MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。 1.2、为什么要用MQ12341.流量消峰举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。2.应用解耦以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。 123.异步处理有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。 1.3、MQ的分类1、ActiveMQ 优点：单击吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据 缺点：官方社区现在对ActiveMQ5.x的维护越来越少，高吞吐量场景较少使用 尚硅谷官网视频：https://www.gulixueyuan.com/course/322 2、Kafka 大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件，以其百万级TPS的的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。 优点: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢； 3、RocketMQ RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。 优点:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ 缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码 4、RabbitMQ 2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一。 优点:由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高https://www.rabbitmq.com/news.html 缺点：商业版需要收费,学习成本较高 1.4、MQ的选择1.Kafka Kafka主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。尚硅谷官网 kafka 视频连接 http://www.gulixueyuan.com/course/330/tasks 2.RocketMQ 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。 3.RabbitMQ 结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。 2、RabbitMQ2.1、RabbitMQ的概念1RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。 2.2、四大核心概念1234567891011生产者 产生数据发送消息的程序是生产者交换机 交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定队列 队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式消费者 消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。 2.3、RabbitMQ核心部分 2.4、各个名词介绍 12345678910111213Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message BrokerVirtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等Connection：publisher／consumer 和 broker 之间的 TCP 连接Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销 Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)Queue：消息最终被送到这里等待 consumer 取走Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据 2.5、安装1、官网地址https://www.rabbitmq.com/download.html RabbitMQ安装教程（最新RabbitMQ安装，通用教程）_普通网友的博客-CSDN博客_rabbitmq安装 2、文件上传上传到&#x2F;usr&#x2F;local&#x2F;software 目录下(如果没有 software 需要自己创建) 3、安装文件（分别安装以下顺序安装） 123rpm -ivh erlang-21.3-1.el7.x86_64.rpmyum install socat -yrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm 4、常用命令（按照以下顺序执行） 添加开机启动 RabbitMQ 服务chkconfig rabbitmq-server on 启动服务&#x2F;sbin&#x2F;service rabbitmq-server start 查看服务状态&#x2F;sbin&#x2F;service rabbitmq-server status 停止服务(选择执行)&#x2F;sbin&#x2F;service rabbitmq-server stop 开启 web 管理插件rabbitmq-plugins enable rabbitmq_management 关闭防火墙systemctl stop firewalld 用默认账号密码(guest)访问地址 http://ip:15672/出现权限问题 5、添加一个新的用户 创建账号rabbitmqctl add_user admin 123 设置用户角色rabbitmqctl set_user_tags admin administrator 设置用户权限 123set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限 当前用户和角色rabbitmqctl list_user 6、再次利用admin用户登录 7、重置命令 123456关闭应用的命令为rabbitmqctl stop_app清除的命令为rabbitmqctl reset重新启动命令为rabbitmqctl start_app 二、Hello World在本教程的这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印 出来的消费者。我们将介绍 Java API 中的一些细节。 在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区 1、依赖12345678910111213141516171819202122232425262728&lt;!--指定 jdk 编译版本--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;dependencies&gt; &lt;!--rabbitmq 依赖客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--操作文件流的一个依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、消息生产者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.lxg.rabbitmq.one;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * 生产者：发消息 */public class Producer &#123; //队列名称 public static final String QUEUE_NAME = &quot;hello&quot;; //发消息 public static void main(String[] args) throws IOException, TimeoutException &#123; //创建一个连接工厂 ConnectionFactory factory = new ConnectionFactory(); //工厂IP 连接RabbitMQ的队列 factory.setHost(&quot;106.55.228.118&quot;); //用户名 factory.setUsername(&quot;admin&quot;); //密码 factory.setPassword(&quot;123&quot;); //创建连接 Connection connection = factory.newConnection(); //获取信道 Channel channel = connection.createChannel(); /** * 生成一个队列 * 1、队列名称 * 2、队列里面的消息是否持久化（存储在磁盘） 默认情况消息存储在内存中 * 3、该队列是否只供一个消费者进行消费 是否不进行消息的共享，true：只能一个消费者消费 false：可以多个消费者消费 * 4、是否自动删除，最后一个消费者端开连接后，该队列是否自动删除 true自动删除 false不自动删除 * 5、其他参数 */ channel.queueDeclare(QUEUE_NAME, false, false, false, null); //发消息 String message = &quot;hello world!&quot;; /** * 发送一个消息 * 1、发送到哪个交换机 * 2、路由的Key值是哪个，本次是队列的名称 * 3、其他参数信息 * 4、发送消息的消息体 */ channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes()); System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; 3、消息消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lxg.rabbitmq.one;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * 消费者 * 接收消息 */public class Consumer &#123; //队列名称 public static final String QUEUE_NAME = &quot;hello&quot;; //接收消息 public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;106.55.228.118&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;123&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明 接收消息 DeliverCallback deliverCallback = (consumerTag,message) -&gt; &#123; System.out.println(new String(message.getBody())); &#125;; //取消消息时的回调 CancelCallback cancelCallback = consumerTag -&gt; &#123; System.out.println(&quot;消费消息被中断了&quot;); &#125;; /** * 消费者消费消息 * 1、消费哪个队列 * 2、消费之后是否要自动应答 true代表的是自动应答 false代表手动应答 * 3、消费者未成功消费的回调 * 4、消费者取消消费的回调 */ channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback); &#125;&#125; 三、Work Queues工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。 1、轮训分发消息在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程 是如何工作的。 1.1、抽取工具类123456789101112131415161718192021222324package com.lxg.rabbitmq.utils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * 此类为连接工厂创建信道的工具类 */public class RabbitMqUtils &#123; //得到一个连接的 channel public static Channel getChannel() throws Exception&#123; //创建一个连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;106.55.228.118&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;123&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); return channel; &#125;&#125; 1.2、启动两个工作线程12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lxg.rabbitmq.two;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.CancelCallback;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 这是一个工作线程（相当于之前的消费者） * */public class Worker01 &#123; //队列的名称 public static final String QUEUE_NAME = &quot;hello&quot;; //接收消息 public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //消息的接收 DeliverCallback deliverCallback = (consumerTag,message) -&gt; &#123; System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody())); &#125;; //取消消费的回调 CancelCallback cancelCallback = consumerTag -&gt; &#123; System.out.println(consumerTag+&quot;消费者取消消费接口回调逻辑！&quot;); &#125;; //消息的接收 /** * 消费者消费消息 * 1、消费哪个队列 * 2、消费之后是否要自动应答 true代表的是自动应答 false代表手动应答 * 3、消费者成功消费的回调 * 4、消费者取消消费的回调 */ channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback); &#125;&#125; 1.3、启动一个发送线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.lxg.rabbitmq.two;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import java.io.IOException;import java.util.Scanner;/** * 生产者：发送大量消息 */public class Task01 &#123; //队列名称 public static final String QUEUE_NAME = &quot;hello&quot;; //发送大量消息 public static void main(String[] args) throws Exception &#123; //创建信道 Channel channel = RabbitMqUtils.getChannel(); //队列的声明 /** * 生成一个队列 * 1、队列名称 * 2、队列里面的消息是否持久化（存储在磁盘） 默认情况消息存储在内存中 * 3、该队列是否只供一个消费者进行消费 是否不进行消息的共享，true：只能一个消费者消费 false：可以多个消费者消费 * 4、是否自动删除，最后一个消费者端开连接后，该队列是否自动删除 true自动删除 false不自动删除 * 5、其他参数 */ channel.queueDeclare(QUEUE_NAME,false,false,false,null); //从控制台当中发送信息 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要发送的消息：&quot;); int number = 0; do &#123; if(number==1)&#123; System.out.println(&quot;请输入你要发送的消息：&quot;); &#125; String message = scanner.next(); /** * 发送一个消息 * 1、发送到哪个交换机 * 2、路由的Key值是哪个，本次是队列的名称 * 3、其他参数信息 * 4、发送消息的消息体 */ channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes()); System.out.println(&quot;消息发送完成:&quot;+message); System.out.println(&quot;是否继续发送消息？(是：1，否：0)&quot;); number = scanner.nextInt(); &#125;while (number==1); if(number==0)&#123; System.out.println(&quot;结束发送消息！&quot;); System.exit(0); &#125; &#125;&#125; 1.4、结果展示通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且 是按照有序的一个接收一次消息 2、消息应答2.1、概念消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。 为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。 2.2、自动应答消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权 衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用。 2.3、消息应答的方法A.Channel.basicAck(用于肯定确认) RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 B.Channel.basicNack(用于否定确认) C.Channel.basicReject(用于否定确认) 与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了 2.4、Multiple的解释手动应答的好处是可以批量应答并且减少网络拥堵 123456multiple 的 true 和 false 代表不同意思 true 代表批量应答 channel 上未应答的消息 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答false 同上面相比 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答 2.5、消息自动重新入队如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。 2.6、消息手动应答代码默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改 为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。 消息生产者 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lxg.rabbitmq.three;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import java.util.Scanner;/** * 消息在手动应答时是不丢失的，应放回队列中重新消费 */public class Task02 &#123; //队列名称 public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明队列 channel.queueDeclare(TASK_QUEUE_NAME,false,false,false,null); //从控制台中输入信息 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要发送的消息：&quot;); int number = 0; do &#123; if(number==1)&#123; System.out.println(&quot;请输入你要发送的消息：&quot;); &#125; String message = scanner.next(); channel.basicPublish(&quot;&quot;,TASK_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;生产者发出消息:&quot;+message); System.out.println(&quot;是否继续发送消息？(是：1，否：0)&quot;); number = scanner.nextInt(); &#125;while (number==1); if(number==0)&#123; System.out.println(&quot;结束发送消息！&quot;); System.exit(0); &#125; &#125;&#125; 消费者01 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lxg.rabbitmq.three;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.lxg.rabbitmq.utils.SleepUtils;import com.rabbitmq.client.CancelCallback;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 消息在手动应答时不丢失，放回队列重新消费 */public class Worker1 &#123; //队列名称 public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); System.out.println(&quot;C1等待接收消息处理时间较短&quot;); DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123; //模拟处理时间（沉睡） SleepUtils.sleep(1); System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); //手动应答 /** * 1、消息的标记 tag * 2、是否批量应答 false:不批量应答 true：表示批量应答 */ channel.basicAck(message.getEnvelope().getDeliveryTag(),false); &#125;; CancelCallback cancelCallback = consumerTag -&gt; &#123; System.out.println(&quot;消费者取消消费接口回调逻辑&quot;); &#125;; //采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback); &#125;&#125; 消费者02 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lxg.rabbitmq.three;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.lxg.rabbitmq.utils.SleepUtils;import com.rabbitmq.client.CancelCallback;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 消息在手动应答时不丢失，放回队列重新消费 */public class Worker2 &#123; //队列名称 public static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); System.out.println(&quot;C2等待接收消息处理时间较短&quot;); DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123; //模拟处理时间（沉睡） SleepUtils.sleep(30); System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); //手动应答 /** * 1、消息的标记 tag * 2、是否批量应答 false:不批量应答 true：表示批量应答 */ channel.basicAck(message.getEnvelope().getDeliveryTag(),false); &#125;; CancelCallback cancelCallback = consumerTag -&gt; &#123; System.out.println(&quot;消费者取消消费接口回调逻辑&quot;); &#125;; //采用手动应答 boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback); &#125;&#125; 睡眠工具类 12345678910111213package com.lxg.rabbitmq.utils;public class SleepUtils &#123; public static void sleep(int seconds) &#123; try&#123; Thread.sleep(seconds*1000); &#125;catch (InterruptedException e)&#123; Thread.currentThread().interrupt(); &#125; &#125;&#125; 2.7、手动应答效果演示正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理 在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是 由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了 https://xiaolin-zi.oss-cn-guangzhou.aliyuncs.com/typora-img/img/202301211151626.png https://xiaolin-zi.oss-cn-guangzhou.aliyuncs.com/typora-img/img/202301211152640.png https://xiaolin-zi.oss-cn-guangzhou.aliyuncs.com/typora-img/img/202301211152131.png 3、RabbitMQ持久化3.1、概念刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标 记为持久化。 3.2、队列如何实现持久化之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化 但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新 创建一个持久化的队列，不然就会出现错误 以下为控制台中持久化与非持久化队列的 UI 显示区 这个时候即使重启 rabbitmq 队列也依然存在 3.3、消息实现持久化要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。 将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。 3.4、不公平分发在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。 为了避免这种情况，我们可以设置参数channel.basicQos(1); 12int prefetchCount = 1;channel.basicQos(prefetchCount); 意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。 3.5、预取值本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。 四、发布确认1、发布确认原理生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的 消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。 confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信 道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调 方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息。 2、发布确认的策略2.1、开启发布确认的方法发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法 12Channel channel = connection.createChannel();channel.confirmSelect(); 2.2、单个确认发布这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。 这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。 12345678910111213141516171819202122232425262728public static void publishMessageIndividually() throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //队列的声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, false, false, false, null); //开启发布确认 channel.confirmSelect(); //开始时间 long begin = System.currentTimeMillis(); //批量发消息 for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123; String message = String.valueOf(i); channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes()); //单个消息就马上进行发布确认 boolean b = channel.waitForConfirms(); if (b) &#123; System.out.println(&quot;消息:&#x27;&quot; + message + &quot;&#x27;发送成功！&quot;); &#125; &#125; //结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;条单独确认消息，耗时：&quot; + (end - begin) + &quot;ms&quot;); &#125; 2.3、批量确认发布上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。 12345678910111213141516171819202122232425262728293031323334353637383940//批量确认 public static void publishMessageBatch() throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //队列的声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, false, false, false, null); //开启发布确认 channel.confirmSelect(); //开始时间 long begin = System.currentTimeMillis(); //批量确认消息的大小 int batchSize = 100; //批量发消息，批量发布确认 for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123; String message = String.valueOf(i); channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes()); //判断达到100条消息的时候，批量确认一次 if(i%batchSize==0)&#123; //批量消息进行发布确认 boolean b = channel.waitForConfirms(); if (b) &#123; System.out.println(&quot;消息发送成功！&quot;); &#125; &#125; &#125; //结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;条批量确认消息，耗时：&quot; + (end - begin) + &quot;ms&quot;); &#125; 2.4、异步确认发布异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//异步确认 //批量确认 public static void publishMessageAsync() throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //队列的声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, false, false, false, null); //开启发布确认 channel.confirmSelect(); //开始时间 long begin = System.currentTimeMillis(); //消息确认成功 回调函数 ConfirmCallback ackCallback = (deliveryTag,multiple)-&gt;&#123; System.out.println(&quot;确认的消息：&quot;+deliveryTag); &#125;; //消息确认失败 回调函数 /** * 1、消息的标记 * 2、是否为批量确认 */ ConfirmCallback nackCallback = (deliveryTag,multiple)-&gt;&#123; System.out.println(&quot;未确认的消息：&quot;+deliveryTag); &#125;; //准备消息的监听器，监听哪些消息成功了，哪些消息失败了 /** * 1、监听哪些消息成功了 * 2、监听哪些消息失败了 */ channel.addConfirmListener(ackCallback,nackCallback);//异步通知 //批量发消息，异步发布确认 for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123; String message = String.valueOf(i); channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes()); &#125; //结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;条异步确认消息，耗时：&quot; + (end - begin) + &quot;ms&quot;); &#125; 2.5、如何处理异步未确认消息最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//异步确认 //批量确认 public static void publishMessageAsync() throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //队列的声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, false, false, false, null); //开启发布确认 channel.confirmSelect(); /** * 线程安全有序的一个哈希表，适用于高并发的情况下 * 1、轻松的将序号与消息进行关联 * 2、轻松的批量删除条目，只需要给到序号 * 3、支持高并发（多线程） */ ConcurrentSkipListMap&lt;Long,String&gt; outStandingConfirms = new ConcurrentSkipListMap&lt;&gt;(); //消息确认成功 回调函数 ConfirmCallback ackCallback = (deliveryTag,multiple)-&gt;&#123; if(multiple)&#123; //2、删除已经确认的消息，剩下的就是未确认的消息 ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outStandingConfirms.headMap(deliveryTag); confirmed.clear(); &#125;else&#123; outStandingConfirms.remove(deliveryTag); &#125; System.out.println(&quot;确认的消息：&quot;+deliveryTag); &#125;; //消息确认失败 回调函数 /** * 1、消息的标记 * 2、是否为批量确认 */ ConfirmCallback nackCallback = (deliveryTag,multiple)-&gt;&#123; //3、打印一下未确认的消息都有哪些 String message = outStandingConfirms.get(deliveryTag); System.out.println(&quot;未确认的消息是：&quot;+message+&quot;,未确认的消息tag是：&quot;+deliveryTag); &#125;; //准备消息的监听器，监听哪些消息成功了，哪些消息失败了 /** * 1、监听哪些消息成功了 * 2、监听哪些消息失败了 */ channel.addConfirmListener(ackCallback,nackCallback);//异步通知 //开始时间 long begin = System.currentTimeMillis(); //批量发消息，异步发布确认 for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123; String message = String.valueOf(i); channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes()); //1、此处记录下所有要发送的消息，消息的总和 outStandingConfirms.put(channel.getNextPublishSeqNo(),message); &#125; //结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;条异步确认消息，耗时：&quot; + (end - begin) + &quot;ms&quot;); &#125; 2.6、以上3种确认速度对比单独发布消息 同步等待确认，简单，但吞吐量非常有限。 批量发布消息 批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。 异步处理： 最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些 12345678910public static void main(String[] args) throws Exception &#123; //这个消息数量设置为 1000 好些 不然花费时间太长 publishMessagesIndividually(); publishMessagesInBatch(); handlePublishConfirmsAsynchronously();&#125;//运行结果发布 1,000 个单独确认消息耗时 50,278 ms发布 1,000 个批量确认消息耗时 635 ms发布 1,000 个异步确认消息耗时 92 ms 五、交换机在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”. 为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。 1、Exchanges1.1、Exchanges概念RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。 相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。 1.2、Exchanges的类型总共有以下类型： 直接（路由）(direct), 主题(topic) ,标题(headers) , 扇出（发布订阅）(fanout) 1.3、无名Exchange在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。 1channel.basicPublish(&quot;&quot;,&quot;hello&quot;,null,message.getBytes()); 第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话 2、临时队列之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们 来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息。 每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称 的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连 接，队列将被自动删除。 创建临时队列的方式如下: String queueName &#x3D; channel.queueDeclare().getQueue(); 创建出来之后长成这样: 3、绑定（bindings）什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定 4、Fanout4.1、Fanout介绍Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型 4.2、Fanout实战 Logs 和临时队列的绑定关系如下图： ReceiveLogs01 将接收到的消息打印在控制台： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lxg.rabbitmq.five;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 消息接收 */public class ReceiveLog01 &#123; //声明交换机的名称 public static final String EXCHANGE_NAME = &quot;logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明一个交换机 channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;); //声明一个队列（临时队列） /** * 生成一个临时队列，队列的名称是随机的 * 当消费者断开与队列的连接的时候，队列就会自动删除 */ String queueName = channel.queueDeclare().getQueue(); /** * 绑定交换机与队列 * */ channel.queueBind(queueName,EXCHANGE_NAME,&quot;&quot;); System.out.println(&quot;等待接收消息，把接收到的消息打印到控制台上......&quot;); //接收消息 DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; System.out.println(&quot;ReceiveLog01控制台打印接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); &#125;; //消费者取消消息时回调接口 channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123;&#125;); &#125;&#125; ReceiveLogs02 将接收到的消息存储在磁盘： 12345678910111213141516171819202122232425262728293031323334package com.lxg.rabbitmq.five;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;import org.apache.commons.io.FileUtils;import java.io.File;public class ReceiveLog02 &#123; private static final String EXCHANGE_NAME = &quot;logs&quot;; public static void main(String[] argv) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); /** * 生成一个临时的队列 队列的名称是随机的 * 当消费者断开和该队列的连接时 队列自动删除 */ String queueName = channel.queueDeclare().getQueue(); //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串 channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;); System.out.println(&quot;等待接收消息,把接收到的消息写到文件.....&quot;); DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123; String message = new String(delivery.getBody(), &quot;UTF-8&quot;); File file = new File(&quot;D:\\\\rabbitmq_info.txt&quot;); FileUtils.writeStringToFile(file, message, &quot;UTF-8&quot;); System.out.println(&quot;数据写入文件成功&quot;); &#125;; channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123; &#125;); &#125;&#125; EmitLog 发送消息给两个消费者接收： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.lxg.rabbitmq.five;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.MessageProperties;import java.util.Scanner;/** * 发消息给交换机 * */public class EmitLog &#123; //交换机的名称 private static final String EXCHANGE_NAME = &quot;logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;); //从控制台中输入信息 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要发送的消息：&quot;); int number = 0; do &#123; if(number==1)&#123; System.out.println(&quot;请输入你要发送的消息：&quot;); &#125; String message = scanner.next(); channel.basicPublish(EXCHANGE_NAME,&quot;&quot;, null,message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;生产者发出消息:&quot;+message); System.out.println(&quot;是否继续发送消息？(是：1，否：0)&quot;); number = scanner.nextInt(); &#125;while (number==1); if(number!=1)&#123; System.out.println(&quot;结束发送消息！&quot;); System.exit(0); &#125; &#125;&#125; 5、Direct Exchange5.1、回顾在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本 节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把 严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。 我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);绑定之后的 意义由其交换类型决定。 5.2、Direct exchange介绍上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。 在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green. 在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。 5.3、多重绑定 当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。 5.4、实战 12345678910111213141516171819202122232425262728293031package com.lxg.rabbitmq.six;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;public class ReceiveLogsDirect01 &#123;public static final String EXCHANGE_NAME = &quot;direct_logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明一个交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); //声明一个队列 channel.queueDeclare(&quot;console&quot;,false,false,false,null); channel.queueBind(&quot;console&quot;,EXCHANGE_NAME,&quot;info&quot;); channel.queueBind(&quot;console&quot;,EXCHANGE_NAME,&quot;warning&quot;); //接收消息 DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123; System.out.println(&quot;ReceiveLogsDirect01控制台打印接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); &#125;; //消费者取消消息时回调接口 channel.basicConsume(&quot;console&quot;,true,deliverCallback,consumerTag -&gt; &#123;&#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930package com.lxg.rabbitmq.six;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;public class ReceiveLogsDirect02 &#123;public static final String EXCHANGE_NAME = &quot;direct_logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明一个交换机 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); //声明一个队列 channel.queueDeclare(&quot;disk&quot;,false,false,false,null); channel.queueBind(&quot;disk&quot;,EXCHANGE_NAME,&quot;error&quot;); //接收消息 DeliverCallback deliverCallback = (consumerTag, message)-&gt;&#123; System.out.println(&quot;ReceiveLogsDirect02控制台打印接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); &#125;; //消费者取消消息时回调接口 channel.basicConsume(&quot;disk&quot;,true,deliverCallback,consumerTag -&gt; &#123;&#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.lxg.rabbitmq.six;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import java.util.Scanner;public class DirectLogs &#123; //交换机的名称 private static final String EXCHANGE_NAME = &quot;direct_logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //从控制台中输入信息 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要发送的消息：&quot;); int number = 0; do &#123; if(number==1)&#123; System.out.println(&quot;请输入你要发送的消息：&quot;); &#125; String message = scanner.next(); channel.basicPublish(EXCHANGE_NAME,&quot;error&quot;, null,message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;生产者发出消息:&quot;+message); System.out.println(&quot;是否继续发送消息？(是：1，否：0)&quot;); number = scanner.nextInt(); &#125;while (number==1); if(number!=1)&#123; System.out.println(&quot;结束发送消息！&quot;); System.exit(0); &#125; &#125;&#125; 6、Topics6.1、之前类型的问题在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志 尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型 6.2、Topic的要求发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单 词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。 在这个规则列表中，其中有两个替换符是大家需要注意的*(星号)可以代替一个单词#(井号)可以替代零个或多个单词 6.3、Topic匹配案例下图绑定关系如下 Q1–&gt;绑定的是 中间带 orange 带 3 个单词的字符串(.orange.) Q2–&gt;绑定的是 最后一个单词是 rabbit 的 3 个单词(..rabbit) 第一个单词是 lazy 的多个单词(lazy.#) 12345678910111213上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的quick.orange.rabbit 被队列 Q1Q2 接收到lazy.orange.elephant 被队列 Q1Q2 接收到quick.orange.fox 被队列 Q1 接收到lazy.brown.fox 被队列 Q2 接收到lazy.pink.rabbit 虽然满足两个绑定但只被队列 Q2 接收一次quick.brown.fox 不匹配任何绑定不会被任何队列接收到会被丢弃quick.orange.male.rabbit 是四个单词不匹配任何绑定会被丢弃lazy.orange.male.rabbit 是四个单词但匹配 Q2当队列绑定关系是下列这种情况时需要引起注意 当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了 6.4、实战 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lxg.rabbitmq.seven;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import java.util.HashMap;import java.util.Map;/** * 生产者 */public class EmitLogsTopic &#123; //交换机的名称 public static final String EXCHANGE_NAME = &quot;topic_logs&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); /** * 下图绑定关系如下 * * Q1--&gt;绑定的是 * * 中间带 orange 带 3 个单词的字符串(*.orange.*) * * Q2--&gt;绑定的是 * * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit) * * 第一个单词是 lazy 的多个单词(lazy.#) */ Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;(); bindingKeyMap.put(&quot;quick.orange.rabbit&quot;,&quot;被队列 Q1Q2 接收到&quot;); bindingKeyMap.put(&quot;lazy.orange.elephant&quot;,&quot;被队列 Q1Q2 接收到&quot;); bindingKeyMap.put(&quot;quick.orange.fox&quot;,&quot;被队列 Q1 接收到&quot;); bindingKeyMap.put(&quot;lazy.brown.fox&quot;,&quot;被队列 Q2 接收到&quot;); bindingKeyMap.put(&quot;lazy.pink.rabbit&quot;,&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;); bindingKeyMap.put(&quot;quick.brown.fox&quot;,&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;); bindingKeyMap.put(&quot;quick.orange.male.rabbit&quot;,&quot;是四个单词不匹配任何绑定会被丢弃&quot;); bindingKeyMap.put(&quot;lazy.orange.male.rabbit&quot;,&quot;是四个单词但匹配 Q2&quot;); for (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123; String bindingKey = bindingKeyEntry.getKey(); String message = bindingKeyEntry.getValue(); channel.basicPublish(EXCHANGE_NAME,bindingKey, null, message.getBytes(&quot;UTF-8&quot;)); System.out.println(&quot;生产者发出消息:&quot; + message); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.lxg.rabbitmq.seven;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 声明主题交换机及相关队列 * 消费者C1 */public class ReceiveLogsTopic01 &#123; //交换机的名称 public static final String EXCHANGE_NAME = &quot;topic_logs&quot;; //接收消息 public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME,&quot;topic&quot;); //声明队列 String queueName = &quot;Q1&quot;; channel.queueDeclare(queueName,false,false,false,null); channel.queueBind(queueName,EXCHANGE_NAME,&quot;*.orange.*&quot;); System.out.println(&quot;等待接收消息......&quot;); DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); System.out.println(&quot;C1接收的队列：&quot;+queueName+&quot;，绑定的键：&quot;+message.getEnvelope().getRoutingKey()); &#125;; //接收消息 channel.basicConsume(queueName,true,deliverCallback,consumerTag-&gt;&#123;&#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.lxg.rabbitmq.seven;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 声明主题交换机及相关队列 * 消费者C1 */public class ReceiveLogsTopic02 &#123; //交换机的名称 public static final String EXCHANGE_NAME = &quot;topic_logs&quot;; //接收消息 public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明交换机 channel.exchangeDeclare(EXCHANGE_NAME,&quot;topic&quot;); //声明队列 String queueName = &quot;Q2&quot;; channel.queueDeclare(queueName,false,false,false,null); channel.queueBind(queueName,EXCHANGE_NAME,&quot;*.*.rabbit&quot;); channel.queueBind(queueName,EXCHANGE_NAME,&quot;lazy.#&quot;); System.out.println(&quot;等待接收消息......&quot;); DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); System.out.println(&quot;C2接收的队列：&quot;+queueName+&quot;，绑定的键：&quot;+message.getEnvelope().getRoutingKey()); &#125;; //接收消息 channel.basicConsume(queueName,true,deliverCallback,consumerTag-&gt;&#123;&#125;); &#125;&#125; 六、死信队列1、死信的概念先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。 应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效 2、死信的来源消息 TTL 过期 队列达到最大长度(队列满了，无法再添加数据到 mq 中) 消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false 3、死信实战3.1、代码架构图 3.2、消息TTL过期生产者代码 12345678910111213141516171819202122232425package com.lxg.rabbitmq.eight;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;/** * 死信队列 之 生产者 */public class Producer &#123; //普通交换机名称 public static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //死信消息 设置TTL时间 time to live 单位是ms AMQP.BasicProperties properties = new AMQP.BasicProperties() .builder().expiration(&quot;10000&quot;).build(); for (int i = 0; i &lt; 10; i++) &#123; String message = &quot;info&quot;+i; channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,properties,message.getBytes()); &#125; &#125;&#125; 消费者C1代码（启动之后关闭该消费者，模拟其接收不到消息） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.lxg.rabbitmq.eight;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;import java.util.HashMap;import java.util.Map;/** * 死信队列 实战 * 消费者1 */public class Consumer01 &#123; //普通交换机名称 public static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;; //死信交换机的名称 public static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;; //普通队列名称 public static final String NORMAL_QUEUE = &quot;normal_queue&quot;; //死信队列的名称 public static final String DEAD_QUEUE = &quot;dead_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明普通和死信交换机 类型为direct channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT); //声明普通队列 Map&lt;String,Object&gt; arguments = new HashMap&lt;String,Object&gt;(); //过期时间 单位是毫秒，10s=10000ms// arguments.put(&quot;x-message-ttl&quot;,10000); //正常队列设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;); channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments); //声明死信队列 channel.queueDeclare(DEAD_QUEUE,false,false,false,null); //绑定普通的交换机与队列 channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;); //绑定死信的交换机与死信的队列 channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;); System.out.println(&quot;等待接收消息......&quot;); DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; System.out.println(&quot;C1接收的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); &#125;; channel.basicConsume(NORMAL_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125; ); &#125;&#125; 消费者C2代码（以上步骤完成后，启动C2消费者，它消费死信队列里面的消息） 123456789101112131415161718192021222324252627282930313233package com.lxg.rabbitmq.eight;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;import java.util.HashMap;import java.util.Map;/** * 死信队列 实战 * 消费者2 */public class Consumer02 &#123; //死信队列的名称 public static final String DEAD_QUEUE = &quot;dead_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); System.out.println(&quot;等待接收消息......&quot;); DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; System.out.println(&quot;C2接收的消息是：&quot;+new String(message.getBody(),&quot;UTF-8&quot;)); &#125;; channel.basicConsume(DEAD_QUEUE,true,deliverCallback,consumerTag -&gt; &#123;&#125; ); &#125;&#125; 3.3、队列达到最大长度1、消息生产者代码去掉TTL属性 123456789101112131415public class Producer &#123; private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;; public static void main(String[] argv) throws Exception &#123; try (Channel channel = RabbitMqUtils.getChannel()) &#123; channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); //该信息是用作演示队列个数限制 for (int i = 1; i &lt;11 ; i++) &#123; String message=&quot;info&quot;+i; channel.basicPublish(NORMAL_EXCHANGE,&quot;zhangsan&quot;,null, message.getBytes()); System.out.println(&quot;生产者发送消息:&quot;+message); &#125; &#125; &#125;&#125; 2、C1消费者修改以下代码（启动之后关闭该消费者，模拟其接收不到消息） 注意此时需要把原先队列删除，因为参数改变了 3、C2消费者代码不变（启动C2消费者） 3.4、消息被拒1、消息生产者代码同上生产者一致 2、C1消费者代码（启动之后关闭该消费者 模拟其接收不到消息） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.lxg.rabbitmq.eight;import com.lxg.rabbitmq.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;import java.util.HashMap;import java.util.Map;/** * 死信队列 实战 * 消费者1 */public class Consumer01 &#123; //普通交换机名称 public static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;; //死信交换机的名称 public static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;; //普通队列名称 public static final String NORMAL_QUEUE = &quot;normal_queue&quot;; //死信队列的名称 public static final String DEAD_QUEUE = &quot;dead_queue&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //声明普通和死信交换机 类型为direct channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT); //声明普通队列 Map&lt;String,Object&gt; arguments = new HashMap&lt;String,Object&gt;(); //过期时间 单位是毫秒，10s=10000ms// arguments.put(&quot;x-message-ttl&quot;,10000); //正常队列设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,DEAD_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;lisi&quot;); //设置正常队列长度的限制// arguments.put(&quot;x-max-length&quot;,6); channel.queueDeclare(NORMAL_QUEUE,false,false,false,arguments); //声明死信队列 channel.queueDeclare(DEAD_QUEUE,false,false,false,null); //绑定普通的交换机与队列 channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,&quot;zhangsan&quot;); //绑定死信的交换机与死信的队列 channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,&quot;lisi&quot;); System.out.println(&quot;等待接收消息......&quot;); DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123; String msg = new String(message.getBody(),&quot;UTF-8&quot;); if(msg.equals(&quot;info5&quot;))&#123; System.out.println(&quot;C1接收的消息是：&quot;+msg+&quot;，此消息是被C1拒绝的&quot;); channel.basicReject(message.getEnvelope().getDeliveryTag(),false); &#125;else&#123; System.out.println(&quot;C1接收的消息是：&quot;+msg); channel.basicAck(message.getEnvelope().getDeliveryTag(),false); &#125; &#125;; //开启手动应答 channel.basicConsume(NORMAL_QUEUE,false,deliverCallback,consumerTag -&gt; &#123;&#125; ); &#125;&#125; 生产者发送消息之后 3、C2消费者代码不变 启动消费者1然后再启动消费者2 七、延迟队列1、延迟队列概念延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。 2、延迟队列使用场景1.订单在十分钟之内未支付则自动取消 2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 3.用户注册成功后，如果三天内没有登陆则进行短信提醒。 4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议 这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。 3、RabbitMQ中的TTLTTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这 条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。 3.1、消息设置TTL另一种方式便是针对每条消息设置 TTL 3.2、队列设置TTL第一种是在创建队列的时候设置队列的“x-message-ttl”属性 3.3、两者区别如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。 前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已 经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延 时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为 里面的消息都是希望被立即处理的消息。 4、整合SpringBoot4.1、创建项目 4.2、添加依赖123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!--RabbitMQ 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--RabbitMQ 测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.3、修改配置文件1234spring.rabbitmq.host=106.55.228.118spring.rabbitmq.port=5672spring.rabbitmq.username=adminspring.rabbitmq.password=123 4.4、添加Swagger配置类12345678910111213141516171819202122232425262728293031package com.lxg.rabbitmq.springbootrabbitmq.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket webApiConfig()&#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() .build(); &#125; private ApiInfo webApiInfo()&#123; return new ApiInfoBuilder() .title(&quot;rabbitmq 接口文档&quot;) .description(&quot;本文档描述了 rabbitmq 微服务接口定义&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;xiaolin&quot;, &quot;https://www.xiaolin-blog.top&quot;, &quot;1849569695@qq.com&quot;)) .build(); &#125;&#125; 5、队列TTL5.1、代码架构图创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下： 5.2、配置文件类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.lxg.rabbitmq.springbootrabbitmq.config;import com.rabbitmq.client.AMQP;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.lang.management.ManagementPermission;import java.util.HashMap;import java.util.Map;import java.util.Objects;/** * TTL队列，配置文件类代码 */@Configurationpublic class TtlQueueConfig &#123; //普通交换机的名称 public static final String X_EXCHANGE = &quot;X&quot;; //死信交换机的名称 public static final String Y_DEAD_LETTER_EXCHANGE = &quot;Y&quot;; //普通队列名称 public static final String QUEUE_A = &quot;QA&quot;; public static final String QUEUE_B = &quot;QB&quot;; //死信队列的名称 public static final String QUEUE_DEAD_LETTER = &quot;QD&quot;; //声明xExchange交换机 别名 @Bean(&quot;xExchange&quot;) public DirectExchange xExchange()&#123; return new DirectExchange(X_EXCHANGE); &#125; //声明yExchange交换机 别名 @Bean(&quot;yExchange&quot;) public DirectExchange yExchange()&#123; return new DirectExchange(Y_DEAD_LETTER_EXCHANGE); &#125; //声明queueA普通队列 TTL为10s @Bean(&quot;queueA&quot;) public Queue queueA()&#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;(); //设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;); //设置TTL 单位是ms arguments.put(&quot;x-message-ttl&quot;,(10*1000)); return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build(); &#125; //声明queueB普通队列 TTL为40s @Bean(&quot;queueB&quot;) public Queue queueB()&#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;(); //设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;); //设置TTL 单位是ms arguments.put(&quot;x-message-ttl&quot;,(40*1000)); return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build(); &#125; ///声明queueD死信队列 @Bean(&quot;queueD&quot;) public Queue queueD()&#123; return QueueBuilder.durable(QUEUE_DEAD_LETTER).build(); &#125; //绑定 @Bean public Binding queueABindingX(@Qualifier(&quot;queueA&quot;) Queue queueA,@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123; return BindingBuilder.bind(queueA).to(xExchange).with(&quot;XA&quot;); &#125; //绑定 @Bean public Binding queueBBindingX(@Qualifier(&quot;queueB&quot;) Queue queueB,@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123; return BindingBuilder.bind(queueB).to(xExchange).with(&quot;XB&quot;); &#125; //绑定 @Bean public Binding queueDBindingY(@Qualifier(&quot;queueD&quot;) Queue queueD,@Qualifier(&quot;yExchange&quot;) DirectExchange yExchange)&#123; return BindingBuilder.bind(queueD).to(yExchange).with(&quot;YD&quot;); &#125;&#125; 5.3、消息生产者代码1234567891011121314151617181920212223242526272829303132333435package com.lxg.rabbitmq.springbootrabbitmq.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;/** * 发送延迟消息 * */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class SendMessageController &#123; @Autowired private RabbitTemplate rabbitTemplate; //开始发消息 @GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;) public void sendMsg(@PathVariable String message)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条信息给两个TTL队列:&#123;&#125;&quot;,new Date().toString(),message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XA&quot;,&quot;消息来自ttl为10s的队列：&quot;+message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XB&quot;,&quot;消息来自ttl为40s的队列：&quot;+message); &#125;&#125; 5.4、消息消费者代码12345678910111213141516171819202122232425package com.lxg.rabbitmq.springbootrabbitmq.consumer;import com.rabbitmq.client.Channel;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.util.Date;/** * 队列TTL 消费者 */@Slf4j@Componentpublic class DeadLetterQueueConsumer &#123; //接收消息 @RabbitListener(queues = &quot;QD&quot;) public void receiveD(Message message, Channel channel)throws Exception &#123; String msg = new String(message.getBody()); log.info(&quot;当前时间：&#123;&#125;,收到死信队列的消息：&#123;&#125;&quot;,new Date().toString(),msg); &#125;&#125; 发起一个请求 http://localhost:8080/ttl/sendMsg/嘻嘻嘻 第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。 不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？ 6、延时队列优化6.1、代码架构图在这里新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间 6.2、配置文件类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.lxg.rabbitmq.springbootrabbitmq.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * TTL队列，配置文件类代码 */@Configurationpublic class TtlQueueConfig &#123; //普通交换机的名称 public static final String X_EXCHANGE = &quot;X&quot;; //死信交换机的名称 public static final String Y_DEAD_LETTER_EXCHANGE = &quot;Y&quot;; //普通队列名称 public static final String QUEUE_A = &quot;QA&quot;; public static final String QUEUE_B = &quot;QB&quot;; //死信队列的名称 public static final String QUEUE_DEAD_LETTER = &quot;QD&quot;; //新增====================================================== public static final String QUEUE_C = &quot;QC&quot;; //声明queueC普通队列 @Bean(&quot;queueC&quot;) public Queue queueC()&#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;(); //设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;); return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build(); &#125; //绑定 @Bean public Binding queueCBindingX(@Qualifier(&quot;queueC&quot;) Queue queueC, @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123; return BindingBuilder.bind(queueC).to(xExchange).with(&quot;XC&quot;); &#125; //新增===================================================== //声明xExchange交换机 别名 @Bean(&quot;xExchange&quot;) public DirectExchange xExchange()&#123; return new DirectExchange(X_EXCHANGE); &#125; //声明yExchange交换机 别名 @Bean(&quot;yExchange&quot;) public DirectExchange yExchange()&#123; return new DirectExchange(Y_DEAD_LETTER_EXCHANGE); &#125; //声明queueA普通队列 TTL为10s @Bean(&quot;queueA&quot;) public Queue queueA()&#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;(); //设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;); //设置TTL 单位是ms arguments.put(&quot;x-message-ttl&quot;,(10*1000)); return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build(); &#125; //声明queueB普通队列 TTL为40s @Bean(&quot;queueB&quot;) public Queue queueB()&#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;(); //设置死信交换机 arguments.put(&quot;x-dead-letter-exchange&quot;,Y_DEAD_LETTER_EXCHANGE); //设置死信RoutingKey arguments.put(&quot;x-dead-letter-routing-key&quot;,&quot;YD&quot;); //设置TTL 单位是ms arguments.put(&quot;x-message-ttl&quot;,(40*1000)); return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build(); &#125; ///声明queueD死信队列 @Bean(&quot;queueD&quot;) public Queue queueD()&#123; return QueueBuilder.durable(QUEUE_DEAD_LETTER).build(); &#125; //绑定 @Bean public Binding queueABindingX(@Qualifier(&quot;queueA&quot;) Queue queueA, @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123; return BindingBuilder.bind(queueA).to(xExchange).with(&quot;XA&quot;); &#125; //绑定 @Bean public Binding queueBBindingX(@Qualifier(&quot;queueB&quot;) Queue queueB,@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange)&#123; return BindingBuilder.bind(queueB).to(xExchange).with(&quot;XB&quot;); &#125; //绑定 @Bean public Binding queueDBindingY(@Qualifier(&quot;queueD&quot;) Queue queueD,@Qualifier(&quot;yExchange&quot;) DirectExchange yExchange)&#123; return BindingBuilder.bind(queueD).to(yExchange).with(&quot;YD&quot;); &#125;&#125; 6.3、消息生产者代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lxg.rabbitmq.springbootrabbitmq.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;/** * 发送延迟消息 * */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class SendMessageController &#123; @Autowired private RabbitTemplate rabbitTemplate; //开始发消息 @GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;) public void sendMsg(@PathVariable String message)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条信息给两个TTL队列:&#123;&#125;&quot;,new Date().toString(),message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XA&quot;,&quot;消息来自ttl为10s的队列：&quot;+message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XB&quot;,&quot;消息来自ttl为40s的队列：&quot;+message); &#125; //开始发消息 带TTL @GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&quot;) public void sendExpirationMsg(@PathVariable String message,@PathVariable String ttlTime)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条TTL为：&#123;&#125;毫秒的信息给QC队列:&#123;&#125;&quot;,new Date().toString(),ttlTime,message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XC&quot;,message,msg -&gt; &#123; //发送消息的时候 延迟时长 msg.getMessageProperties().setExpiration(ttlTime); return msg; &#125;); &#125;&#125; 发起请求 http://localhost:8080/ttl/sendExpirationMsg/你好 1&#x2F;20000 http://localhost:8080/ttl/sendExpirationMsg/你好 2&#x2F;2000 看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。 7、RabbitMQ插件实现延迟队列上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。 7.1、安装延时队列插件在官网上下载 https://www.rabbitmq.com/community-plugins.html，下载 rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。 进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ进入&#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.8.8&#x2F;plugins运行命令rabbitmq-plugins enable rabbitmq_delayed_message_exchange 7.2、代码架构图在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下: 7.3、配置文件类代码在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才 投递到目标队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.lxg.rabbitmq.springbootrabbitmq.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.CustomExchange;import org.springframework.amqp.core.Queue;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * 延迟队列 配置类 */@Configurationpublic class DelayedQueueConfig &#123; //队列 public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;; //交换机 public static final String DELAYED_EXCHANGE_NAME = &quot;delayed.exchange&quot;; //routingKey public static final String DELAYED_ROUTING_KEY = &quot;delayed.routingkey&quot;; @Bean public Queue delayedQueue()&#123; return new Queue(DELAYED_QUEUE_NAME); &#125; //声明交换机 基于插件的 @Bean public CustomExchange delayedExchange()&#123; Map&lt;String,Object&gt; arguments = new HashMap&lt;&gt;(); arguments.put(&quot;x-delayed-type&quot;,&quot;direct&quot;); /** * 1、交换机的名称 * 2、交换机的类型 * 3、是否需要持久化 * 4、是否需要自动删除 * 5、其他的参数 */ return new CustomExchange(DELAYED_EXCHANGE_NAME,&quot;x-delayed-message&quot;,true,false,arguments); &#125; //绑定 @Bean public Binding delayedQueueBindingDelayedExchange(@Qualifier(&quot;delayedQueue&quot;)Queue delayedQueue, @Qualifier(&quot;delayedExchange&quot;) CustomExchange delayedExchange)&#123; return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs(); &#125;&#125; 7.4、消息生产者代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.lxg.rabbitmq.springbootrabbitmq.controller;import com.lxg.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;/** * 发送延迟消息 * */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class SendMessageController &#123; @Autowired private RabbitTemplate rabbitTemplate; //开始发消息 @GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;) public void sendMsg(@PathVariable String message)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条信息给两个TTL队列:&#123;&#125;&quot;,new Date().toString(),message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XA&quot;,&quot;消息来自ttl为10s的队列：&quot;+message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XB&quot;,&quot;消息来自ttl为40s的队列：&quot;+message); &#125; //开始发消息 带TTL @GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;) public void sendExpirationMsg(@PathVariable String message,@PathVariable String ttlTime)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条TTL为：&#123;&#125;毫秒的信息给QC队列:&#123;&#125;&quot;,new Date().toString(),ttlTime,message); rabbitTemplate.convertAndSend(&quot;X&quot;,&quot;XC&quot;,message,msg -&gt; &#123; //发送消息的时候 延迟时长 msg.getMessageProperties().setExpiration(ttlTime); return msg; &#125;); &#125; //开始发消息 基于插件的消息和延迟的时间 @GetMapping(&quot;/sendDelayedMsg/&#123;message&#125;/&#123;delayTime&quot;) public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime)&#123; log.info(&quot;当前时间:&#123;&#125;，发送一条时长为：&#123;&#125;毫秒的信息给延迟队列delayed.queue:&#123;&#125;&quot;,new Date().toString(),delayTime,message); rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,DelayedQueueConfig.DELAYED_ROUTING_KEY,message, msg -&gt; &#123; //发送消息的时候 延迟时长 单位是ms msg.getMessageProperties().setDelay(delayTime); return msg; &#125;); &#125;&#125; 7.5、消息消费者代码123456789101112131415161718192021222324252627package com.lxg.rabbitmq.springbootrabbitmq.consumer;import com.lxg.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.util.Date;/** * 基于插件延迟 的消费者 */@Slf4j@Componentpublic class DelayedQueueConsumer &#123; //监听消息 @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME) public void receiveDelayedQueue(Message message)&#123; String msg = new String(message.getBody()); log.info(&quot;当前时间：&#123;&#125;，收到延迟队列的消息:&#123;&#125;&quot;,new Date().toString(),msg); &#125;&#125; 发起请求： http://localhost:8080/ttl/sendDelayMsg/come on baby1&#x2F;20000 http://localhost:8080/ttl/sendDelayMsg/come on baby2&#x2F;2000 第二个消息被先消费掉了，符合预期 8、总结延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。 当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。 八、发布确认高级在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢: 12345应 用 [xxx] 在 [08-1516:36:04] 发 生 [ 错误日志异常 ] ， alertId=[xxx] 。 [org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620] 触发。 应用 xxx 可能原因如下服务名为： 异常为：org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620, 产 生 原 因 如 下 :1.org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not allow us to use it.||Consumer received fatal=false exception on startup: 1、发布确认SpringBoot版本1.1、确认机制方案 1.2、代码架构图 1.3、配置文件12345678在配置文件当中需要添加spring.rabbitmq.publisher-confirm-type=correlated⚫ NONE禁用发布确认模式，是默认值⚫ CORRELATED发布消息成功到交换器后会触发回调方法⚫ SIMPLE经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， 其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broke 12345spring.rabbitmq.host=106.55.228.118spring.rabbitmq.port=5672spring.rabbitmq.username=adminspring.rabbitmq.password=123spring.rabbitmq.publisher-confirm-type=correlated 1.4、添加配置类12345678910111213141516171819202122232425262728293031323334353637383940package com.lxg.rabbitmq.springbootrabbitmq.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 发布确认高级内容 配置类 */@Configurationpublic class ConfirmConfig &#123; //交换机名称 public static final String CONFIRM_EXCHANGE_NAME = &quot;confirm.exchange&quot;; //队列名称 public static final String CONFIRM_QUEUE_NAME = &quot;confirm.queue&quot;; //routingkey public static final String CONFIRM_ROUTING_KEY = &quot;key1&quot;; //声明交换机 @Bean public DirectExchange confirmExchange()&#123; return new DirectExchange(CONFIRM_EXCHANGE_NAME); &#125; //声明队列 @Bean public Queue confirmQueue()&#123; return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build(); &#125; //绑定 @Bean public Binding queueBindingExchange(@Qualifier(&quot;confirmQueue&quot;) Queue confirmQueue, @Qualifier(&quot;confirmExchange&quot;)DirectExchange confirmExchange)&#123; return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY); &#125;&#125; 1.5、消息生产者正常生产 12345678910111213141516171819202122232425262728293031323334353637package com.lxg.rabbitmq.springbootrabbitmq.controller;import com.lxg.rabbitmq.springbootrabbitmq.config.ConfirmConfig;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.security.auth.login.Configuration;/** * 开始发消息，测试确认 */@Slf4j@RestController@RequestMapping(&quot;/confirm&quot;)public class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; //发消息 @GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;) public void sendMessage(@PathVariable String message)&#123; rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME ,ConfirmConfig.CONFIRM_ROUTING_KEY,message); log.info(&quot;发送消息内容是:&#123;&#125;&quot;,message); &#125;&#125; 设置回调的生产者 12345678910111213141516171819202122232425262728293031323334353637383940package com.lxg.rabbitmq.springbootrabbitmq.controller;import com.lxg.rabbitmq.springbootrabbitmq.config.ConfirmConfig;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.connection.CorrelationData;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.security.auth.login.Configuration;/** * 开始发消息，测试确认 */@Slf4j@RestController@RequestMapping(&quot;/confirm&quot;)public class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; //发消息 @GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;) public void sendMessage(@PathVariable String message)&#123; CorrelationData correlationData = new CorrelationData(&quot;1&quot;); rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME ,ConfirmConfig.CONFIRM_ROUTING_KEY,message,correlationData); log.info(&quot;发送消息内容是:&#123;&#125;&quot;,message); &#125;&#125; 1.6、回调接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lxg.rabbitmq.springbootrabbitmq.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.connection.CorrelationData;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;@Slf4j@Componentpublic class MyCallBack implements RabbitTemplate.ConfirmCallback &#123; //这里虽然实现了类的内部接口，但后续在调用该模板类时获取不到当前实例类，所以需要 //在模板类上设置当前实例类 @Autowired private RabbitTemplate rabbitTemplate; @PostConstruct public void init() &#123; //注入 rabbitTemplate.setConfirmCallback(this); &#125; /** * 交换机确认回调方法 * 1、发消息 交换机接收到了 回调 * 1.1、correlationData 保存回调消息的ID及相关信息 * 1.2、交换机收到消息 true * 1.3、cause null * 2、发消息 交换机接收失败了 回调 * 2.1、correlationData 保存回调消息的ID及相关信息 * 2.2、交换机没收到消息 ack=false * 2.3、cause 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String id = correlationData != null ? correlationData.getId() : &quot;&quot;; if(ack)&#123; log.info(&quot;交换机已经收到了ID为：&#123;&#125;的消息&quot;,id); &#125;else&#123; log.info(&quot;交换机还没收到了ID为：&#123;&#125;的消息，原因是：&#123;&#125;&quot;,id,cause); &#125; &#125;&#125; 1.7、消息消费者12345678910111213141516171819202122package com.lxg.rabbitmq.springbootrabbitmq.consumer;import com.lxg.rabbitmq.springbootrabbitmq.config.ConfirmConfig;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;/** * 接收消息 */@Slf4j@Componentpublic class ConfitmConsumer &#123; @RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME) public void receiveConfirmMessage(Message message)&#123; String msg = new String(message.getBody()); log.info(&quot;接收到的队列confirm.queue消息：&#123;&#125;&quot;,msg); &#125;&#125; 1.8、结果分析 可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。 2、回退消息2.1、Mandatory参数在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。 1234567spring.rabbitmq.host=106.55.228.118spring.rabbitmq.port=5672spring.rabbitmq.username=adminspring.rabbitmq.password=123spring.rabbitmq.publisher-confirm-type=correlatedspring.rabbitmq.publisher-returns=true 2.2、消息生产者代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Slf4j@Componentpublic class MessageProducer implements RabbitTemplate.ConfirmCallback , RabbitTemplate.ReturnCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; //rabbitTemplate 注入之后就设置该值 @PostConstruct private void init() &#123; rabbitTemplate.setConfirmCallback(this); /** * true： * 交换机无法将消息进行路由时，会将该消息返回给生产者 * false： * 如果发现消息无法进行路由，则直接丢弃 */ rabbitTemplate.setMandatory(true); //设置回退消息交给谁处理 rabbitTemplate.setReturnCallback(this); &#125; @GetMapping(&quot;sendMessage&quot;) public void sendMessage(String message)&#123; //让消息绑定一个 id 值 CorrelationData correlationData1 = new CorrelationData(UUID.randomUUID().toString()); rabbitTemplate.convertAndSend(&quot;confirm.exchange&quot;,&quot;key1&quot;,message+&quot;key1&quot;,correlationData1) ; log.info(&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;,correlationData1.getId(),message+&quot;key1&quot;); CorrelationData correlationData2 = new CorrelationData(UUID.randomUUID().toString()); rabbitTemplate.convertAndSend(&quot;confirm.exchange&quot;,&quot;key2&quot;,message+&quot;key2&quot;,correlationData2) ; log.info(&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;,correlationData2.getId(),message+&quot;key2&quot;); &#125; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String id = correlationData != null ? correlationData.getId() : &quot;&quot;; if (ack) &#123; log.info(&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;, id); &#125; else &#123; log.error(&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;, id, cause); &#125; &#125; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; log.info(&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;, new String(message.getBody()),replyText, exchange, routingKey); &#125;&#125; 2.3、回调接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.lxg.rabbitmq.springbootrabbitmq.config;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.ReturnedMessage;import org.springframework.amqp.rabbit.connection.CorrelationData;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;@Slf4j@Componentpublic class MyCallBack implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback&#123; @Autowired private RabbitTemplate rabbitTemplate; @PostConstruct public void init() &#123; //注入 rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setReturnsCallback(this); &#125; /** * 交换机确认回调方法 * 1、发消息 交换机接收到了 回调 * 1.1、correlationData 保存回调消息的ID及相关信息 * 1.2、交换机收到消息 true * 1.3、cause null * 2、发消息 交换机接收失败了 回调 * 2.1、correlationData 保存回调消息的ID及相关信息 * 2.2、交换机没收到消息 ack=false * 2.3、cause 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; String id = correlationData != null ? correlationData.getId() : &quot;&quot;; if(ack)&#123; log.info(&quot;交换机已经收到了ID为：&#123;&#125;的消息&quot;,id); &#125;else&#123; log.info(&quot;交换机还没收到了ID为：&#123;&#125;的消息，原因是：&#123;&#125;&quot;,id,cause); &#125; &#125; //可以在当消息传递过程中不可达目的地时将消息返回给生产者。 //只有不可达目的地的时候才进行回退 @Override public void returnedMessage(ReturnedMessage returned) &#123; log.error(&quot;消息&#123;&#125;,被交换机&#123;&#125;退回，原因是:&#123;&#125;，路由key：&#123;&#125;&quot;, new String(returned.getMessage().getBody()),returned.getExchange(),returned.getReplyText(),returned.getRoutingKey()); &#125;&#125; 2.4、结果分析3、备份交换机有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。 3.1、代码架构图 3.2、修改配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.lxg.rabbitmq.springbootrabbitmq.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 发布确认高级内容 配置类 */@Configurationpublic class ConfirmConfig &#123; //交换机名称 public static final String CONFIRM_EXCHANGE_NAME = &quot;confirm.exchange&quot;; //队列名称 public static final String CONFIRM_QUEUE_NAME = &quot;confirm.queue&quot;; //routingkey public static final String CONFIRM_ROUTING_KEY = &quot;key1&quot;; //备份交换机 public static final String BACKUP_EXCHANGE_NAME = &quot;backup.exchange&quot;; //备份队列 public static final String BACKUP_QUEUE_NAME = &quot;backup.queue&quot;; //报警队列 public static final String WARNING_QUEUE_NAME = &quot;warning.queue&quot;; //声明交换机 @Bean public DirectExchange confirmExchange()&#123; return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(true) .withArgument(&quot;alternate-exchange&quot;,BACKUP_EXCHANGE_NAME).build(); &#125; //声明队列 @Bean public Queue confirmQueue()&#123; return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build(); &#125; //绑定 @Bean public Binding queueBindingExchange(@Qualifier(&quot;confirmQueue&quot;) Queue confirmQueue, @Qualifier(&quot;confirmExchange&quot;)DirectExchange confirmExchange)&#123; return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY); &#125; //备份交换机 @Bean public FanoutExchange backupExchange()&#123; return new FanoutExchange(BACKUP_EXCHANGE_NAME); &#125; //备份队列 @Bean public Queue backupQueue() &#123; return QueueBuilder.durable(BACKUP_QUEUE_NAME).build(); &#125; //报警队列 @Bean public Queue warningQueue() &#123; return QueueBuilder.durable(WARNING_QUEUE_NAME).build(); &#125; //绑定 @Bean public Binding backupQueueBindingbackupExchange(@Qualifier(&quot;backupQueue&quot;) Queue backupQueue, @Qualifier(&quot;backupExchange&quot;)FanoutExchange backupExchange)&#123; return BindingBuilder.bind(backupQueue).to(backupExchange); &#125; //绑定 @Bean public Binding warningQueueBindingbackupExchange(@Qualifier(&quot;warningQueue&quot;) Queue warningQueue, @Qualifier(&quot;backupExchange&quot;)FanoutExchange backupExchange)&#123; return BindingBuilder.bind(warningQueue).to(backupExchange); &#125;&#125; 3.3、报警消费者12345678910@Component@Slf4jpublic class WarningConsumer &#123; public static final String WARNING_QUEUE_NAME = &quot;warning.queue&quot;; @RabbitListener(queues = WARNING_QUEUE_NAME) public void receiveWarningMsg(Message message) &#123; String msg = new String(message.getBody()); log.error(&quot;报警发现不可路由消息：&#123;&#125;&quot;, msg); &#125;&#125; 3.4、测试注意事项重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报以下错: 3.5、结果分析 mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是备份交换机优先级高。 九、RabbitMQ其他知识点1、幂等性1.1、概念用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等 1.2、消息重复消费消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。 1.3、解决思路MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费 者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。 1.4、消费端的幂等性保障在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现 1.5、唯一ID+指纹机制指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。 1.6、Redis原子性利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费 2、优先级队列2.1、使用场景在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存 放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景， 所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。 2.2、如何添加a.控制台页面添加 b.队列中代码添加优先级 c.消息中代码添加优先级 d.注意事项 要让队列实现优先级需要做的事情有如下事情:队列需要设置为优先级队列，消息需要设置消息的优先 级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序 2.3、实战a.消息生产者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.lxg.rabbitmq.one;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeoutException;/** * 生产者：发消息 */public class Producer &#123; //队列名称 public static final String QUEUE_NAME = &quot;hello&quot;; //发消息 public static void main(String[] args) throws IOException, TimeoutException &#123; //创建一个连接工厂 ConnectionFactory factory = new ConnectionFactory(); //工厂IP 连接RabbitMQ的队列 factory.setHost(&quot;106.55.228.118&quot;); //用户名 factory.setUsername(&quot;admin&quot;); //密码 factory.setPassword(&quot;123&quot;); //创建连接 Connection connection = factory.newConnection(); //获取信道 Channel channel = connection.createChannel(); /** * 生成一个队列 * 1、队列名称 * 2、队列里面的消息是否持久化（存储在磁盘） 默认情况消息存储在内存中 * 3、该队列是否只供一个消费者进行消费 是否不进行消息的共享，true：只能一个消费者消费 false：可以多个消费者消费 * 4、是否自动删除，最后一个消费者端开连接后，该队列是否自动删除 true自动删除 false不自动删除 * 5、其他参数 */ Map&lt;String,Object&gt; arguments = new HashMap&lt;&gt;(); //官方允许是0-255之间，此处设置10 允许优先级范围为0-10，不要设置过大，浪费CPU与内存 arguments.put(&quot;x-max-priority&quot;,10); channel.queueDeclare(QUEUE_NAME, true, false, false, arguments); for (int i = 0; i &lt; 10; i++) &#123; String message = &quot;info&quot; + i; if(i==5)&#123; AMQP.BasicProperties properties = new AMQP.BasicProperties() .builder().priority(5).build(); channel.basicPublish(&quot;&quot;,QUEUE_NAME,properties,message.getBytes()); &#125;else&#123; channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes()); &#125; &#125; //发消息// String message = &quot;hello world!&quot;; /** * 发送一个消息 * 1、发送到哪个交换机 * 2、路由的Key值是哪个，本次是队列的名称 * 3、其他参数信息 * 4、发送消息的消息体 */// channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes()); System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; b.消息消费者 123456789101112131415161718public class Consumer &#123; private static final String QUEUE_NAME=&quot;hello&quot;; public static void main(String[] args) throws Exception &#123; Channel channel = RabbitMqUtils.getChannel(); //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU Map&lt;String, Object&gt; params = new HashMap(); params.put(&quot;x-max-priority&quot;, 10); channel.queueDeclare(QUEUE_NAME, true, false, false, params); System.out.println(&quot;消费者启动等待消费......&quot;); DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123; String receivedMessage = new String(delivery.getBody()); System.out.println(&quot;接收到消息:&quot;+receivedMessage); &#125;; channel.basicConsume(QUEUE_NAME,true,deliverCallback,(consumerTag)-&gt;&#123; System.out.println(&quot;消费者无法消费消息时调用，如队列被删除&quot;); &#125;); &#125;&#125; 3、惰性队列3.1、使用场景RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。 默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的 时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。 3.2、两种模式队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。 在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节： Map args &#x3D; new HashMap();args.put(“x-queue-mode”, “lazy”);channel.queueDeclare(“myqueue”, false, false, false, args); 3.3、内存开销对比 在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB 十、RabbitMQ集群1、clustering1.1、使用集群的原因最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的 要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞 吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键. 1.2、搭建步骤123456781.修改 3 台机器的主机名称 vim /etc/hostname 2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方 vim /etc/hosts 10.211.55.74 node1 10.211.55.75 node2 10.211.55.76 node3 1234567891011121314151617181920212223242526272829303132333.以确保各个节点的 cookie 文件使用的是同一个值在 node1 上执行远程操作命令scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookiescp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)rabbitmq-server -detached5.在节点 2 执行rabbitmqctl stop_app(rabbitmqctl stop 会将 Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)rabbitmqctl resetrabbitmqctl join_cluster rabbit@node1rabbitmqctl start_app(只启动应用服务)6.在节点 3 执行rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster rabbit@node2rabbitmqctl start_app7.集群状态rabbitmqctl cluster_status8.需要重新设置用户创建账号rabbitmqctl add_user admin 123设置用户角色rabbitmqctl set_user_tags admin administrator设置用户权限rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;9.解除集群节点(node2 和 node3 机器分别执行)rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_apprabbitmqctl cluster_statusrabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行) 2、镜像队列2.1、使用镜像的原因如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true， 但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在 一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘， 尽管如此，一般不希望遇到因单点故障导致的服务不可用。 引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。 2.2、搭建步骤121.启动三台集群节点2.随便找一个节点添加 policy 13.在 node1 上创建一个队列发送一条消息，队列存在镜像队列 14.停掉 node1 之后发现 node2 成为镜像队列 125.就算整个集群只剩下一台机器了 依然能消费队列里面的消息 说明队列里面的消息被镜像队列传递到相应机器里面了 3、Haproxy+Keepalive实现高可用负载均衡3.1、整体架构图 3.2、Haproxy实现负载均衡HAProxy 提供高可用性、负载均衡及基于 TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。 扩展 nginx,lvs,haproxy 之间的区别: http://www.ha97.com/5646.html 3.3、搭建步骤123451.下载 haproxy(在 node1 和 node2)yum -y install haproxy2.修改 node1 和 node2 的 haproxy.cfgvim /etc/haproxy/haproxy.cfg 需要修改红色 IP 为当前机器 IP 123453.在两台节点启动 haproxyhaproxy -f /etc/haproxy/haproxy.cfgps -ef | grep haproxy4.访问地址http://10.211.55.71:8888/stats 3.4、Keepalived实现双机（主备）热备试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现 故障转移. 3.5、搭建步骤1234567891011121314151617181920212223241.下载 keepalivedyum -y install keepalived2.节点 node1 配置文件vim /etc/keepalived/keepalived.conf把资料里面的 keepalived.conf 修改之后替换3.节点 node2 配置文件需要修改 global_defs 的 router_id,如:nodeB其次要修改 vrrp_instance_VI 中 state 为&quot;BACKUP&quot;；最后要将 priority 设置为小于 100 的值4.添加 haproxy_chk.sh(为了防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作)vim /etc/keepalived/haproxy_chk.sh(可以直接上传文件)修改权限 chmod 777 /etc/keepalived/haproxy_chk.sh5.启动 keepalive 命令(node1 和 node2 启动)systemctl start keepalived6.观察 Keepalived 的日志tail -f /var/log/messages -n 2007.观察最新添加的 vipip add show8.node1 模拟 keepalived 关闭状态systemctl stop keepalived 9.使用 vip 地址来访问 rabbitmq 集群 4、Federation Exchange（联合交换机）4.1、使用它的原因(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的 情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一 定的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延 迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的 阻塞。 将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部 署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里使用 Federation 插件就可以很好地解决这个问题 4.2、搭建步骤12341.需要保证每台节点单独运行2.在每台机器上开启 federation 相关插件rabbitmq-plugins enable rabbitmq_federationrabbitmq-plugins enable rabbitmq_federation_management 13.原理图(先运行 consumer 在 node2 创建 fed_exchange) 14.在 downstream(node2)配置 upstream(node1) 15、添加 policy 16、成功的前提 5、Federation Queue5.1、使用它的原因联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。 5.2、搭建步骤1、原理图 2、添加upstream（同上） 3、添加policy 6、Shovel6.1、使用它的原因Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作 为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”， 是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用 程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。 6.2、搭建步骤1、开启插件(需要的机器都开启) rabbitmq-plugins enable rabbitmq_shovel rabbitmq-plugins enable rabbitmq_shovel_management 2、原理图(在源头发送的消息直接回进入到目的地队列) 3、添加shovel源和目的地","tags":"rabbitmq"},{"title":"Nginx","url":"/2023/10/12/Nginx/","text":"# Nginx 一、内容概览1、nginx基本概念 nginx是什么，介绍 nginx 的应用场景和具体可以做什么事情 介绍什么是反向代理 介绍什么是负载均衡 介绍什么是动静分离 2、nginx的安装、常用命令和配置文件 介绍 nginx 在 linux 系统中如何进行安装 介绍 nginx 启动、关闭、重新加载常用命令 介绍 nginx 的配置文件 3、nginx配置实例之反向代理 4、nginx配置实例之负载均衡 5、nginx配置实例之动静分离 6、nginx配置高可用集群 搭建 nginx 高可用集群（主从模式） 搭建 nginx 高可用集群（双主模式） 7、nginx 原理与优化参数配置 二、Nginx简介1、Nginx的概念Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能 力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等 2、Nginx作为web服务器Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数。 https://lnmp.org/nginx.html 3、正向代理Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问 12345这个过程其实和租房子很像。租房子的时候，一般情况下，我们很难联系到房东，因为有些房东为了图方便，只把自己的房屋信息和钥匙交给中介了。而房客想要租房子，只能通过中介才能联系到房东。而对于房东来说，他可能根本不知道真正要租他的房子的人是谁，他只知道是中介在联系他。这里面一共有三个角色，租客（用户）、中介（代理服务器）和房东（国外网站，目标服务器）。引入中介（代理服务器）的原因是用户无法联系上房东（用户无法访问国外网站）。所以，正向代理，其实是&quot;代理服务器&quot;代理了&quot;客户端&quot;，去和&quot;目标服务器&quot;进行交互。通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理（有时候中介也直接冒充租客）。 正向代理的用途: 12345678突破访问限制 通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。即，租客可以通过中介，来解决无法联系上房东的问题。提高访问速度通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。即，中介手里留存了很多房源信息和钥匙，可以直接带租客去看房。隐藏客户端真实IP上网者也可以通过这种方法隐藏自己的IP，免受攻击。即，房东并不知道租客的真实身份。PS：但是中介知道了，可能骚扰更多…. 4、反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。 123我们在租房子的过程中，除了有些房源需要通过中介以外，还有一些是可以直接通过房东来租的。用户直接找到房东租房的这种情况就是我们不使用代理直接访问国内的网站的情况。还有一种情况，就是我们以为我们接触的是房东，其实有时候也有可能并非房主本人，有可能是他的亲戚、朋友，甚至是二房东。但是我们并不知道和我们沟通的并不是真正的房东。这种帮助真正的房主租房的二房东其实就是反向代理服务器。这个过程就是反向代理。对于常用的场景，就是我们在Web开发中用到的负载均衡服务器（二房东），客户端（租客）发送请求到负载均衡服务器（二房东）上，负载均衡服务器（二房东）再把请求转发给一台真正的服务器（房东）来执行，再把执行结果返回给客户端（租客）。 所以，反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。 通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。 反向代理的用途: 123456789101112隐藏服务器真实IP使用反向代理，可以对客户端隐藏服务器的IP地址。即，租客并不房东知道的真实身份。负载均衡反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。即，二房东发现房主本人很忙，于是找到房主的妻子帮忙处理租房事宜。提高访问速度反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。即，二房东同样有房屋信息和钥匙。提供安全保障反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。即，二房东可以有效的保护房东的安全。 正向代理和反向代理的区别： 123456789虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。 5、负载均衡1234客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 6、动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。 三、Nginx安装版本区别 常用版本分为四大阵营 Nginx开源版 http://nginx.org/ Nginx plus 商业版 https://www.nginx.com openresty http://openresty.org/cn/ Tengine http://tengine.taobao.org/ 1、进行Nginx官网，下载nginxhttp://nginx.org/ 2、安装相关依赖2.1、安装pcre 把安装包放到linux系统文件夹中 解压压缩文件tar -zxvf pcre-8.45.tar.gz 进行解压之后目录。执行.&#x2F;configure 命令 回到 pcre 目录下执行 make &amp;&amp; make install命令 检验是否安装成功 2.2、安装openssl和 zlib依赖 执行命令进行下载安装包 2.3、安装nginx 把安装包放入linux系统文件夹中 解压nginx 进行解压文件夹，执行.&#x2F;configure命令 执行make &amp;&amp; make install 命令 安装成功之后，在usr&#x2F;local文件夹下多出一个nginx，在nginx中有sbin存放启动脚本 查看开放的端口号 ： firewall-cmd –list-all 设置开放的端口号 ： firewall-cmd –add-service&#x3D;http –permanent sudo firewall-cmd –add-port&#x3D;80&#x2F;tcp –permanent 重启防火墙： firewall-cmd –reload 指定端口和ip访问： firewall-cmd –permanent –add-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”192.168.44.101” port protocol&#x3D;”tcp” port&#x3D;”8080” accept” 移除规则： firewall-cmd –permanent –remove-rich-rule&#x3D;”rule family&#x3D;”ipv4” source address&#x3D;”192.168.44.101” port port&#x3D;”8080” protocol&#x3D;”tcp” accept” 四、Nginx常用的命令和配置文件1、nginx的常用命令没配置环境变量时使用ngin操作命令的前提条件是：必须进入nginx的目录 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin 1.1、查看nginx的版本号.&#x2F;nginx -v 1.2、启动nginx.&#x2F;nginx 1.3、关闭nginx.&#x2F;nginx -s stop 1.4、重新加载nginx.&#x2F;nginx -s reload 修改nginx.conf 可以重新加载不需要重启nginx服务 也可以配置全局环境变量 还可以编写脚本 vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service 1234567891011121314[Unit]Description=nginx - web serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopExecQuit=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target 重新加载系统服务 systemctl daemon-reload 启动服务 systemctl start nginx.service 开机启动 systemctl enable nginx.service 2、nginx配置文件2.1、配置文件的位置nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 2.2、nginx配置文件的组成部分最小配置文件 12345678910111213141516171819202122232425262728293031323334353637383940worker_processes 1; #工作进程数量，一般和cpu数量相同events &#123; worker_connections 1024; #每一个worker的连接数&#125;http &#123; include mime.types; #引入 http 类型配置文件,以便浏览器解析文件 default_type application/octet-stream; #默认解析类型为数据流 sendfile on; # 使用linux的 sendfile(socket, file, len) 高效网络传输，数据0拷贝 keepalive_timeout 65;#虚拟主机 vhost server &#123; listen 80; server_name localhost; #域名、主机名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #nginx相对位置 html文件夹下 root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分： 第一部分：全局块 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。 比如上面第一行配置的： 1worker_processes 1; 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约 第二部分：events块 123events &#123; worker_connections 1024;&#125; events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 第三部分：http块 1234567891011121314151617181920212223http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http 全局块、server 块。 ①、http 全局块 http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等 ②、server 块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 1、全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。 2、location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name&#x2F;uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 &#x2F;uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 从上往下进行匹配，先匹配先展示。 域名适用通配符和正则匹配 两个都匹配不上，默认访问第一个 多用户二级域名： 3、Nginx安装的目录文件 conf：存放配置文件，其中nginx.conf是主配置文件，里面引用了其他配置文件 html：存放了nginx服务访问默认的页面 logs:存放日志文件，access.log访问日志，error.log错误日志，nginx.pid记录主进程的id号 sbin：存放启动命令，启动文件 五、nginx配置实例之反向代理1、反向代理实例一实现效果：使用 nginx 反向代理，访问 www.123.com 直接跳转到 106.55.228.118:8080 1.1、实现步骤 在linux系统安装tomcat，使用默认端口8080 tomcat安装文件放进linux系统中，解压 进入tomcat的bin目录中，执行.&#x2F;startuo.sh命令启动tomcat服务器 对外开放访问的端口（云服务器记得安全组，防火墙开放相应端口） 在windows系统中通过浏览器访问tomcat服务器 通过修改本地 host 文件，将 www.123.com 映射到 106.55.228.118 在 nginx.conf 配置文件中增加如下配置 启动nginx查看效果 如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 106.55.228.118:8080 路径上 注意：云服务器访问可能会显示要求备案域名 2、反向代理实例二实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 9001， 访问 http://106.55.228.118:9001/edu/ 直接跳转到 106.55.228.118:8081访问 http://106.55.228.118:9001/vod/ 直接跳转到 106.55.228.118:8082 2.1、实现步骤 准备两个tomcat服务器，一个8081端口，一个8082端口 准备一些文件夹和测试页面 在tomcat8081下的tomcat中的webapps文件夹中新建edu，存放a.html 在tomcat8082下的tomcat中的webapps文件夹中新建vod，存放b.html 打开nginx配置文件，进行反向代理配置 记得开放端口和安全组 重新加载nginx 测试 location 指令说明 该指令用于匹配 URL。 语法如下： 1234561、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 六、nginx配置实例之负载均衡实现效果：浏览器地址栏输入http://106.55.228.118/test/c.html，负载均衡效果，平均到8081和8082端口中。 1、实现步骤1.1、准备工作 准备两台tomcat服务器，一台8081，一台8082 在两台tomcat里面webapps目录下创建edu文件夹，在test文件中创建页面c.html，用于测试 在nginx配置文件中配置负载均衡 测试，打开网址，每次都会更换端口，实现均匀效果，负载均衡！ 随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题， 顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应 足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品， 很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎， nginx 就是其中的一个，在 linux 下有 Nginx、LVS、Haproxy 等等服务可以提供负载均衡服 务，而且 Nginx 提供了几种分配方式(策略)： 1、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。 2、weight weight 代表权,重默认为 1,权重越高被分配的客户端越多 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。会造成流量倾斜 12345upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; 5、down 被标记服务器无法使用 6、backup 备用机，如果其他机器正常，则不使用当前服务器，除非其他机器故障 7、least_conn 最少连接访问 8、url_hash 根据用户访问的url定向转发请求（适用于固定资源，不在同一服务器） 七、nginx配置实例之动静分离123Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。 1、实现步骤 在linux系统中准备静态资源，用于访问 在nginx配置文件中进行配置 重启nginx 测试效果 浏览器输入地址http://106.55.228.118/image/lsh.jpg 因为配置文件 autoindex on 列出当前文件夹内容 浏览器输入地址http://106.55.228.118/html/a.html 2、动静分离例子二 首先准备两台服务器，192.168.131.101和192.168.131.103，给其中一台服务03那台配置tomcat 在tomcat的webapps文件中的root目录下，准备index.html页面，和一些css、js、img资源 启动tomcat，在服务器192.168.131.103:8080下能正常访问到 在01服务器上配置nginx配置文件如下，也能正常反向代理 删除03服务器tomcat的webapps中root目录下的静态资源，不能正常访问 将静态资源传输到01服务器nginx安装目录中的html文件夹中 配置01服务器nginx.conf文件如下 或 这样配置后，如请求&#x2F;img&#x2F;wzry.jpg会直接到html&#x2F;img中请求资源 能够正常访问 八、Nginx配置高可用集群 123需要两台nginx服务器需要keeplived需要虚拟ip 1、配置高可用的准备工作 需要两台服务器 在两台服务器安装nginx 在两台服务器安装keepalived yum install keepalived –y 安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf 完成高可用配置（主从配置） 修改keepalived.conf配置文件如下： 1234567891011121314151617181920212223242526272829303132333435363738global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_form Alexandre.Cassen@firewall.loc smtp_server 106.55.228.118 smtp_connect_timeout 30 router_id MASTER #标识本节点的名称，通常为hostname&#125;## keepalived会定时执行脚本并对脚本执行的结果进行分析,动态调整vrrp_instance的优先级。##如果脚本执行结果为0,并且weight配置的值大于0,则优先级相应的增加。如果脚本执行结果非0,##并且weight配置的值小于 0,则优先级相应的减少。其他情况,维持原本配置的优先级,即配置文件中priority对应的值。vrrp_script chk_nginx &#123; script &quot;/usr/local/src/nginx_check.sh&quot; interval 2 #每2秒检测一次nginx的运行状态 weight -20 #失败一次，将自己的优先级-20&#125;vrrp_instance VI_1 &#123; state MASTER # 状态，主节点为MASTER，备份节点为BACKUP interface eth0 # 绑定VIP的网络接口，通过ifconfig查看自己的网络接口，网卡名称 virtual_router_id 51 # 虚拟路由的ID号,两个节点设置必须一样,可选IP最后一段使用,相同的VRID为一个组,他将决定多播的MAC地址 priority 100 # 节点优先级，值范围0～254，MASTER要比BACKUP高 advert_int 1 # 组播信息发送时间间隔，两个节点必须设置一样，默认为1秒 # 设置验证信息，两个节点必须一致 authentication &#123; auth_type PASS auth_pass 1111 &#125; # 虚拟IP，两个节点设置必须一样。可以设置多个，一行写一个 virtual_ipaddress &#123; 106.55.228.50 &#125;&#125; 1234567891011121314151617181920212223242526272829303132global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_form Alexandre.Cassen@firewall.loc smtp_server 120.79.54.181 smtp_connect_timeout 30 router_id BACKUP #标识本节点的名称，通常为hostname&#125;vrrp_script chk_nginx &#123; script &quot;/usr/local/src/nginx_check.sh&quot; interval 2 weight -20&#125;vrrp_instance VI_1 &#123; state BACKUP interface eth0 virtual_router_id 51 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 106.55.228.50 &#125;&#125; 在&#x2F;usr&#x2F;local&#x2F;src&#x2F;下新建脚本文件nginx_check.sh 123456789#!/bin/bash A=`ps -C nginx –no-header |wc -l` if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then killall keepalived fi fi 把两台服务器上的nginx和keepalived启动 启动nginx: .&#x2F;nginx 启动keepalived：systemctl start keepalived.service 最终测试 在浏览器输入地址输入虚拟ip测试 九、nginx原理与优化参数配置 master-workers 的机制的好处 首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销， 同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会 影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当 前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。 可以使用nginx -s reload 热部署 每个worker都是独立的进程，如果有其中的一个worker出现问题，其他worker独立的，继续进行争抢，实现请求过程，不会造成服务中断 需要设置多少个 worker Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进 程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话 下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。 #设置 worker 数量。 worker_processes 4#work 绑定 cpu(4 work 绑定 4cpu)。worker_cpu_affinity 0001 0010 0100 1000 #work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。worker_cpu_affinity 0000001 00000010 00000100 00001000 连接数 worker_connection 123451、发送一个请求，占用了worker的几个连接数？答案：2或者4个2、nginx有一个master，有四个worker，每个worker支持的最大连接数是1024，那么支持的最大并发数是？1024 或 2048 这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接 数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访 问最大并发数是： worker_connections * worker_processes &#x2F;2，而如果是 HTTP 作 为反向代 理来说，最大并发数量应该是 worker_connections * worker_processes&#x2F;4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服 务的连接，会占用两个连接。 十、负载均衡和URLRewrite1、网关 给104服务器开启防火墙，但单独设置101服务器能够访问特定的端口，能够使101能正常访问，但104无法被访问。 配置网关： 访问http://192.168.131.101： 访问http://192.168.131.101/library: 访问http://192.168.131.101/library/5.html: 静态资源位置： 十一、设置防盗链1、配置防盗链防盗链配置： 1valid_referers none | blocked | server_names | strings ....; none， 检测 Referer 头域不存在的情况。 blocked，检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以 “http:&#x2F;&#x2F;” 或 “https:&#x2F;&#x2F;” 开头。 server_names ，设置一个或多个 URL ，检测 Referer 头域的值是否是这些 URL 中的某一个。 在需要防盗链的location中配置： 1234valid_referers 192.168.131.101;if ($invalid_referer) &#123;return 403;&#125; 不加none，单独访问和页面访问都不可以 加了none单独访问图片没问题，网页引用访问不行 2、使用CURL测试防盗链 安装curl yum install -y curl 测试 curl 网址：直接返回页面源码 curl -I 网址 ：返回页面请求头 curl -e referer网址 -I 网址 ：返回页面请求头。判断referer网址是否能正常访问该网址 3、返回错误码和返回错误页面 创建错误提示页面 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;title&gt;Error&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;An error occurred.&lt;/h1&gt;&lt;p&gt;非法请求！&lt;/p&gt;&lt;p&gt;你没有权限使用我的资源！！！&lt;/p&gt;&lt;p&gt;&lt;em&gt;Faithfully yours, nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 配置nginx.conf 测试结果 上面是return错误码的形式，也可以直接return对应的html页面位置（不知道可不可行） 4、配置防盗链提醒图片 将图片放在01服务器上nginx安装目录的html中的img文件夹中 配置nginx.conf如下： reload 一下nginx 测试效果如下： 十二、高可用配置 1、安装keepalived①编译安装下载地址： 1https://www.keepalived.org/download.html# 如遇报错提示： 123configure: error:!!! OpenSSL is not properly installed on your system. !!!!!! Can not include OpenSSL headers files. !!! 安装依赖解决： 1yum install openssl-devel ②yum安装1yum install -y keepalived 配置： 使用yum安装后配置文件在 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf 十三、Https证书配置1、对称加密算法： 2、不对称加密算法： 1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。 2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。 3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。 4.A将这个消息发给B（已经用B的公钥加密消息）。 5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。 其实可以这样理解： 123客户端和服务端都有很多锁（公钥）和钥匙（私钥）客户端要发送信息给服务器端时：可以让服务器端把自己的锁（公钥）分给客户端加密然后发送，服务器接收时再用自己的钥匙（私钥）解密，这样在传输过程中，其他人只能拿到锁（公钥），却没有钥匙（私钥）解密。同理服务器向客户端发送信息也是如此。 数字签名：123但是以上加密算法还是有一定的安全风险。客户端/服务器端并不确定这个信息是谁的，而且不知道这个信有没有在传输过程中被修改过比如客户端想给服务器端写一封信，但是又想让服务器端确定这个信是客户端写的，客户端的解决方法是： 这就是数字签名。 存在的安全问题： 1客户端想请求服务器端获取公钥，但是被中间危险分子拦截，中间危险分子替你向服务器请求，但是给客户端下发一个假的公钥，客户端使用假的公钥进行加密后传输数据，就能够被中间危险分子使用私钥进行解密破解拦截了。 解决方案：数字证书 数字证书是由证书签证机关(CA)签发的对用户的公钥的认证。通俗地讲，数字证书就是个人或单位在Internet的身份证。数字证书主要包括三方面的内容：证书所有者的信息、证书所有者的公钥和证书颁发机构的签名。 那么如何对我们的公钥进行认证呢？向一个证书发布机构CA申请证书，我们需要将证书的信息告诉给CA，CA就会将这些信息写到证书中去，然后使用自己的私钥对证书进行加密，这样我们就可以将这种证书投入使用，当将这个证书发生给对方之后，对方会在自己操作系统中受信任的发布机构的证书中去找CA的证书，如果找不到，那说明证书可能有问题，程序会给出一个错误信息。如果在系统中找到了CA的证书，那么应用程序就会从证书中取出CA的公钥，这样使用这个公钥就可以对接收到的数字证书进行解密，解密之后就可以拿到我们自己的公钥信息。 3、证书自签名openssl openssl包含：SSL协议库、应用程序以及密码算法库 自签名 OpenSSL 系统内置 图形化工具 XCA 下载地址 https://www.hohnstaedt.de/xca/index.php/download 十四、在线证书申请 申请后将文件下载下来（包括公钥和证书），将文件传到服务器上。默认在nginx的安装目录中的conf文件夹中查找 证书安装： 123456789server&#123; listen 443 ssl; #本地服务器域名 server_name aa.abc.com; # ssl_certificate /data/cert/server.crt; ssl_certificate_key /data/cert/server.key&#125; 在nginx.conf中配置以上服务即可 十五、安装Discuz下载地址： Disucz! 下载_免费搭建网站_开源建站系统下载_Discuz开源建站系统_为您提供全方位建站服务! 传上服务器，解压缩，改名为bbs 访问http://120.79.54.181/bbs/install/ 1234567891011121314151617181920212223242526272829303132333435363738394041server&#123; listen 443 ssl; #本地服务器域名 server_name aa.abc.com; # ssl_certificate /data/cert/server.crt; ssl_certificate_key /data/cert/server.key index index.html index.htm index.php; #error_page 404 /404.html; #error_page 502 /502.html; location /nginx_status &#123; stub_status on; access_log off; allow 127.0.0.1; deny all; &#125; location ~ [^/]\\.php(/|$) &#123; #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123; expires 30d; access_log off; &#125; location ~ .*\\.(js|css)?$ &#123; expires 7d; access_log off; &#125; location ~ ^/(\\.user.ini|\\.ht|\\.git|\\.svn|\\.project|LICENSE|README.md) &#123; deny all; &#125; location /.well-known &#123; allow all; &#125;&#125; http协议跳转https1234567server &#123; listen 80; server_name 120.79.54.181; access_log /data/wwwlogs/access_nginx.log combined; return 301 https://$server_name$request_uri; root html; &#125; 进行安装： 注意权限问题！","tags":"nginx"},{"title":"Netty","url":"/2023/10/12/Netty/","text":"# Netty 一、Netty介绍和应用场景1、Netty的介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github上的独立项目。 Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可 靠性的网络 IO 程序。 Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下 的大量数据持续传输的应用。 Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景 要透彻理解Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码 2、Netty的应用场景 互联网行业 1）互联网行业：在分布式系统中，各个 节点之间需要远程服务调用，高性能 的 RPC 框架必不可少，Netty 作为异步 高性能的通信框架，往往作为基础通 信组件被这些 RPC 框架使用。 2）典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进 行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各 进程节点之间的内部通信 游戏行业 无论是手游服务端还是大型的网络游戏， Java 语言得到了越来越广泛的应用 Netty 作为高性能的基础通信组件，提 供了 TCP&#x2F;UDP 和 HTTP 协议栈，方便定 制和开发私有协议栈，账号登录服务器 地图服务器之间可以方便的通过 Netty 进行高性能的通信 大数据领域 经典的 Hadoop 的高性能通信和 序列化组件 （Avro 实现数据文件共享）的 RPC 框架， 默认采用 Netty 进行跨界点通信 它的 Netty Service 基于 Netty 框 架二次封装实现。 其它开源项目使用到Netty 网址：Netty.docs: Related projects 3、Netty的学习参考资料 二、Java BIO编程1、I&#x2F;O模型 I&#x2F;O模型基本说明 123451) I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能2) Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO3) Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图1】4) Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理【简单示意图2】5) Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理。一般适用于连接数较多且连接时间较长的应用。 示意图1： 示意图2： 2、BIO、NIO、AIO适用场景分析 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕 系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分 调用OS参与并发操作，编程比较复杂，JDK7开始支持。 3、Java BIO基本介绍 Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io BIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连 接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 【后有 应用实例】 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解。 4、Java BIO工作机制工作原理图： BIO编程简单流程： 123451) 服务器端启动一个ServerSocket2) 客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯3) 客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝4) 如果有响应，客户端线程会等待请求结束后，再继续执行 5、Java BIO应用实例实例说明： 使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启 动一个线程与之通讯。 要求使用线程池机制改善，可以连接多个客户端. 服务器端可以接收客户端发送的数据(telnet 方式即可) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.lxg.bio;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class BIOServer &#123; public static void main(String[] args) throws IOException &#123; //使用线程池机制 /* * 思路 * 1、创建一个线程池 * 2、如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法） * */ ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); //创建ServerSocket ServerSocket serverSocket = new ServerSocket(666); System.out.println(&quot;服务器已经启动了！&quot;); int i = 1; while (true)&#123; //监听，等待客户端连接 System.out.println(&quot;等待客户端&quot;+i+&quot;号连接中...&quot;); final Socket socket = serverSocket.accept(); System.out.println(&quot;连接到&quot;+i+&quot;号客户端&quot;); i++; //创建一个线程与之通讯 newCachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123;//重写run方法 //可以和客户端通讯 handler(socket); &#125; &#125;); &#125; &#125; //编写一个handler方法，和客户端通讯 public static void handler(Socket socket)&#123; try &#123; byte[] bytes = new byte[1024]; //通过socket获取输入流 InputStream inputStream = socket.getInputStream(); //循环的读取客户端发送的数据 while(true)&#123; //System.out.println(&quot;线程信息 id =&quot;+Thread.currentThread().getId()+ //&quot;名字=&quot;+Thread.currentThread().getName()); System.out.println(&quot;等待客户端发送数据中...&quot;); int read = inputStream.read(bytes); if(read!=-1)&#123; System.out.println(&quot;线程id为&quot;+Thread.currentThread().getId()+&quot;的客户端发送数据:&quot;+new String(bytes,0,read));//输出客户端发送的数据 &#125;else &#123; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;关闭和线程id为&quot;+Thread.currentThread().getId()+&quot;的client的连接&quot;); try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; cmd：telnet 127.0.0.1 666 输入ctrl+] 6、Java BIO问题分析 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。 当并发数较大时，需要创建大量线程来处理连接，系统资源占 用较大。 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞 在 Read 操作上，造成线程资源浪费 三、Java NIO编程1、Java NIO基本介绍 Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的 NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。【基本案例】 NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个 它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就 增加了处理过程中的灵活性，使用它可以提供非阻塞式的高 伸缩性网络 Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得 到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞 写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。【后面有案例说明】 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分 配10000个。 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求 的数量比HTTP1.1大了好几个数量级。 案例说明NIO的Buffer 1234567891011121314151617181920212223242526272829package com.lxg.nio;import java.nio.IntBuffer;public class BasicBuffer &#123; public static void main(String[] args) &#123; //举例说明Buffer的使用（简单说明） //创建一个Buffer,大小为5，即可以存放5个int IntBuffer intBuffer = IntBuffer.allocate(5); //向buffer存放数据 for (int i = 0; i &lt; intBuffer.capacity(); i++) &#123; intBuffer.put(i*2); &#125; //如何从buffer读取数据 //将buffer转换，读写切换 intBuffer.flip(); while (intBuffer.hasRemaining())&#123; System.out.println(intBuffer.get()); &#125; &#125;&#125; 2、NIO和BIO的比较 BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很 多 BIO 是阻塞的，NIO 则是非阻塞的 BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进 行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因 此使用单个线程就可以监听多个客户端通道 3、NIO三大核心原理示意图一张图描述NIO 的 Selector 、 Channel 和 Buffer 的关系 Selector 、 Channel 和 Buffer 的关系图(简单版) 关系图的说明: 每个channel 都会 对应一个Buffer Selector 对应一个线程， 一个线程对应多个channel(连接) 该图反应了有三个channel 注册到 该selector &#x2F;&#x2F;程序 程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念 Selector 会根据不同的事件，在各个通道上切换 Buffer 就是一个内存块 ， 底层是有一个数组 数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是 输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换 channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统 通道就是双向的 4、缓冲区（Buffer）基本介绍 缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个 容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对 象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图: 【后面举例说 明】 Buffer类及其子类 在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图: Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素 的信息: Buffer类相关方法一览 123456789101112131415161718192021public abstract class Buffer &#123;//JDK1.4时，引入的apipublic final int capacity( )//返回此缓冲区的容量public final int position( )//返回此缓冲区的位置public final Buffer position (int newPositio)//设置此缓冲区的位置public final int limit( )//返回此缓冲区的限制public final Buffer limit (int newLimit)//设置此缓冲区的限制public final Buffer mark( )//在此缓冲区的位置设置标记public final Buffer reset( )//将此缓冲区的位置重置为以前标记的位置public final Buffer clear( )//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖public final Buffer flip( )//反转此缓冲区public final Buffer rewind( )//重绕此缓冲区public final int remaining( )//返回当前位置与限制之间的元素数public final boolean hasRemaining( )//告知在当前位置和限制之间是否有元素public abstract boolean isReadOnly( );//告知此缓冲区是否为只读缓冲区//JDK1.6时引入的apipublic abstract boolean hasArray();//告知此缓冲区是否具有可访问的底层实现数组public abstract Object array();//返回此缓冲区的底层实现数组public abstract int arrayOffset();//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量public abstract boolean isDirect();//告知此缓冲区是否为直接缓冲区&#125; 123456public Buffer flip() &#123; limit = position; position = 0; mark = -1; return this; &#125; ByteBuffer 从前面可以看出对于 Java 中的基本数据类型(boolean除外)，都有一个 Buffer 类型与之 相对应，最常用的自然是ByteBuffer 类（二进制数据），该类的主要方法如下： 1234567891011121314public abstract class ByteBuffer &#123;//缓冲区创建相关apipublic static ByteBuffer allocateDirect(int capacity)//创建直接缓冲区public static ByteBuffer allocate(int capacity)//设置缓冲区的初始容量public static ByteBuffer wrap(byte[] array)//把一个数组放到缓冲区中使用//构造初始化位置offset和上界length的缓冲区public static ByteBuffer wrap(byte[] array,int offset, int length)//缓存区存取相关APIpublic abstract byte get( );//从当前位置position上get，get之后，position会自动+1public abstract byte get (int index);//从绝对位置getpublic abstract ByteBuffer put (byte b);//从当前位置上添加，put之后，position会自动+1public abstract ByteBuffer put (int index, byte b);//从绝对位置上put&#125; 5、通道（channel）基本介绍 NIO的通道类似于流，但有些区别如下： • 通道可以同时进行读写，而流只能读或者只能写 • 通道可以实现异步读写数据 • 通道可以从缓冲读数据，也可以写数据到缓冲: BIO 中的 stream 是单向的，例如 FileInputStream 对 象只能进行读取数据的操作，而 NIO 中的通道 (Channel)是双向的，可以读操作，也可以写操作。 Channel在NIO中是一个接口 public interface Channel extends Closeable{} 常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】 FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。 FileChannel类FileChannel主要用来对本地文件进行 IO 操作，常见的方法有 public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中 public int write(ByteBuffer src) ，把缓冲区的数据写到通道中 public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道 中复制数据到当前通道 public long transferTo(long position, long count, WritableByteChannel target)，把数据从当 前通道复制给目标通道 应用实例1-本地文件写数据实例要求: 使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,尚硅谷” 写入 到file01.txt 中 文件不存在就创建 代码演示 123456789101112131415161718192021222324252627282930313233package com.lxg.nio;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel01 &#123; public static void main(String[] args) throws IOException &#123; String str = &quot;hello,world&quot;; //创建一个输出流-&gt;channel FileOutputStream fileOutputStream = new FileOutputStream(&quot;file01.txt&quot;); //通过fileOutputStream 获取对应的FileChannel //这个真实类型是FileChannelImpl FileChannel fileChannel = fileOutputStream.getChannel(); //创建一个缓冲区ByteBuffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //将str放入byteBuffer byteBuffer.put(str.getBytes()); //反正byteBuffer进行反正 byteBuffer.flip(); //将byteBuffer数据写入到fileChannel fileChannel.write(byteBuffer); fileOutputStream.close(); &#125;&#125; 应用实例2-本地文件读数据实例要求: 使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读 入到程序，并显示在控制台屏幕 假定文件已经存在 代码演示 1234567891011121314151617181920212223242526272829303132package com.lxg.nio;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel02 &#123; public static void main(String[] args) throws IOException &#123; //创建一个文件输入流FileInputStrem File file = new File(&quot;file01.txt&quot;); FileInputStream fis = new FileInputStream(file); //通过输入流对象获取对应的通道 FileChannel fileChannel = fis.getChannel(); //创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); //将通道数据读入到缓冲区 fileChannel.read(byteBuffer); //将byteBuffer的字节数据转成字符串 System.out.println(new String(byteBuffer.array())); fis.close(); &#125;&#125; 应用实例3-使用一个Buffer完成文件读取实例要求: 使用 FileChannel(通道) 和 方法 read , write，完成文件的拷贝 拷贝一个文本文件 1.txt , 放在项目下即可 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lxg.nio;import java.io.*;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel03 &#123; public static void main(String[] args) throws IOException &#123; //创建文件输入流和文件输出流 FileOutputStream fileOutputStream = new FileOutputStream(&quot;file02.txt&quot;); /* File file = new File(&quot;file01.txt&quot;); FileInputStream fileInputStream = new FileInputStream(file);*/ FileInputStream fileInputStream = new FileInputStream(&quot;file01.txt&quot;); FileChannel outputStreamChannel = fileOutputStream.getChannel(); FileChannel inputStreamChannel = fileInputStream.getChannel();// ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); ByteBuffer byteBuffer = ByteBuffer.allocate(5); while (true)&#123; //重置各种标记 byteBuffer.clear(); int read = inputStreamChannel.read(byteBuffer); if(read==-1)&#123; break; &#125; //将buffer中的数据写到outputStreamChannel byteBuffer.flip(); outputStreamChannel.write(byteBuffer); &#125; //关闭流 fileOutputStream.close(); fileInputStream.close(); &#125;&#125; 应用实例4-拷贝文件transferFrom方法实例要求: 使用 FileChannel(通道) 和 方法 transferFrom ，完成文件的拷贝 拷贝一张图片 代码演示 123456789101112131415161718192021222324252627282930package com.lxg.nio;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;public class NIOFileChannel04 &#123; public static void main(String[] args) throws IOException &#123; //创建相关流 FileInputStream fileInputStream = new FileInputStream(&quot;a.jpg&quot;); FileOutputStream fileOutputStream = new FileOutputStream(&quot;a2.jpg&quot;); //获取流对应的通道 FileChannel sourceCh = fileInputStream.getChannel(); FileChannel destCh = fileOutputStream.getChannel(); //使用transferForm完成拷贝 destCh.transferFrom(sourceCh,0,sourceCh.size()); //关闭相关通道和流 sourceCh.close(); destCh.close(); fileInputStream.close(); fileOutputStream.close(); &#125;&#125; 关于Buffer和Channel的注意事项和细节 ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。[举例说明] 12345678910111213141516171819202122232425262728package com.lxg.nio;import java.nio.ByteBuffer;public class NIOByteBufferPutGet &#123; public static void main(String[] args) &#123; //创建一个Buffer ByteBuffer buffer = ByteBuffer.allocate(64); //类型化方式放入数据 buffer.putInt(100); buffer.putLong(9L); buffer.putChar(&#x27;x&#x27;); buffer.putShort((short) 4); //取出 buffer.flip(); System.out.println(); System.out.println(buffer.getInt()); System.out.println(buffer.getLong()); System.out.println(buffer.getChar()); System.out.println(buffer.getShort()); &#125;&#125; 可以将一个普通Buffer 转成只读Buffer [举例说明] 12345678910111213141516171819202122232425262728package com.lxg.nio;import java.nio.ByteBuffer;public class ReadOnlyBuffer &#123; public static void main(String[] args) &#123; //创建一个Buffer ByteBuffer byteBuffer = ByteBuffer.allocate(64); for (int i = 0; i &lt; 64; i++) &#123; byteBuffer.put((byte) i); &#125; //读取 byteBuffer.flip(); //得到一个只读的Buffer ByteBuffer readOnlyBuffer = byteBuffer.asReadOnlyBuffer(); System.out.println(readOnlyBuffer.getClass());// readOnlyBuffer.put((byte) 100);//ReadOnlyBufferException while (readOnlyBuffer.hasRemaining())&#123; System.out.println(readOnlyBuffer.get()); &#125; &#125;&#125; NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成. [举例说明] 12345678910111213141516171819202122232425262728293031323334353637package com.lxg.nio;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.util.RandomAccess;/** *说明 * 1、MappedByteBuffer可让文件直接在内存（堆外内存）修改，操作系统不需要拷贝一次 */public class MappedByteBufferTest &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;file01.txt&quot;, &quot;rw&quot;); //获取对应的通道 FileChannel channel = randomAccessFile.getChannel(); /** * 参数1：使用读写模式 * 参数2: 可以直接修改的起始位置 * 参数3: 是映射到内存的大小，即将file01.txt的多少个字节映射到内存 * 可以直接修改的范围就是0-5 5个字节，不是索引到5 * 实际类型是DirectByteBuffer */ MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5); mappedByteBuffer.put(0, (byte) &#x27;H&#x27;); mappedByteBuffer.put(3, (byte) &#x27;9&#x27;); mappedByteBuffer.put(4, (byte) &#x27;Y&#x27;); randomAccessFile.close(); System.out.println(&quot;修改成功！&quot;); &#125;&#125; 前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 分散和 聚集Gathering【举例说明】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.lxg.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Arrays;/** * Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入【分散】 * Gathering： 从buffer读取数据时，可以采用buffer数组，依次读取 */public class ScatteringAndGatheringTest &#123; public static void main(String[] args) throws IOException &#123; //使用ServerSocketChannel和SocketChannel 网络 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress inetSocketAddress = new InetSocketAddress(7000); //绑定端口到socket并启动 serverSocketChannel.socket().bind(inetSocketAddress); //创建buffer数组 ByteBuffer[] byteBuffers = new ByteBuffer[2]; byteBuffers[0] = ByteBuffer.allocate(5); byteBuffers[1] = ByteBuffer.allocate(3); //等待客户端连接（telnet） System.out.println(&quot;正在等待客户端连接...&quot;); SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;连接成功！&quot;); int messageLength = 8;//假定从客户端接收8个字节 //循环读取，每次读满8个字节就重新进行读取 while (true)&#123; int byteRead = 0; while (byteRead&lt;messageLength)&#123; long read = socketChannel.read(byteBuffers); byteRead+=read;//累计读取的字节数 System.out.println(&quot;byteRead=&quot;+byteRead); //使用流打印，看看当前这个buffer的position和limit Arrays.asList(byteBuffers).stream().map(buffer -&gt; &quot;position=&quot;+buffer.position() +&quot;,limit=&quot;+ buffer.limit()).forEach(System.out::println); &#125; //将所有的buffer进行flip Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip()); //将数据读取出显示到客户端 long byteWrite = 0; while(byteWrite&lt;messageLength)&#123; long write = socketChannel.write(byteBuffers); byteWrite+=write; &#125; //将所有的buffer进行clear Arrays.asList(byteBuffers).forEach(buffer-&gt;&#123; buffer.clear(); &#125;); System.out.println(&quot;byteRead=&quot;+byteRead+&quot;byteWrite=&quot;+byteWrite +&quot;messageLength=&quot;+messageLength); &#125; &#125;&#125; 6、Selector（选择器）基本介绍 Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器) **Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以 事件的方式可以注册到同一个Selector)**，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。【示意图】 只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少 了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 避免了多线程之间的上下文切换导致的开销 Selector示意图和特点说明 123456特点再说明:1) Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。2) 当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。3) 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。4) 由于读写操作都是非阻塞的，这就可以充分提升 IO线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。5) 一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升 Selector类相关方法Selector 类是一个抽象类, 常用方法和说明如下: 123456public abstract class Selector implements Closeable &#123;public static Selector open();//得到一个选择器对象public int select(long timeout);//监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的SelectionKey 加入到内部集合中并返回，参数用来设置超时时间public Set&lt;SelectionKey&gt; selectedKeys();//从内部集合中得到所有的 SelectionKey&#125; 注意事项 NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket selector 相关方法说明 12selector.select()//阻塞 selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回 selector.wakeup();//唤醒selector selector.selectNow();//不阻塞，立马返还 7、NIO非阻塞 网络编程原理分析图NIO 非阻塞 网络编程相关的(Selector、SelectionKey、 ServerScoketChannel和SocketChannel) 关系梳理图： 对上图的说明: 当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel Selector 进行监听 select 方法, 返回有事 件发生的通道的个数. 将socketChannel注册到Selector上, register(Selector sel, int ops), 一个 selector上可以注册多个SocketChannel 注册后返回一个 SelectionKey, 会和该 Selector 关联(集合) 进一步得到各个 SelectionKey (有事件发 生) 在通过 SelectionKey 反向获取 SocketChannel , 方法 channel() 可以通过 得到的 channel , 完成业务处 理 代码撑腰 8、NIO非阻塞 网络编程快速入门案例要求： 1231) 编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）2) 目的：理解NIO非阻塞网络编程机制3) 看代码演示 Server: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.lxg.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;import java.util.Set;public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; //创建ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //得到一个Selector对象 Selector selector = Selector.open(); //绑定一个监听端口6666,在服务器端监听 serverSocketChannel.socket().bind(new InetSocketAddress(6666)); //设置为非阻塞 /**可以通过ServerSocketChannel的configureBlocking(false)方法将获得连接设置为非阻塞的。此时若没有连接，accept会返回null 可以通过SocketChannel的configureBlocking(false)方法将从通道中读取数据设置为非阻塞的。若此时通道中没有数据可读，read会返回-1 */ serverSocketChannel.configureBlocking(false); //把serverSocketChannel 注册到 selector 关心事件为OP_ACCEPT serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //循环等待客户端连接 while(true)&#123; //等待了一秒钟没有事件发生，就继续 if(selector.select(1000)==0)&#123; System.out.println(&quot;服务器等待了1秒，无连接...&quot;); continue; &#125; //如果返回的&gt;0,就获取到相关的selectionKey集合 /** * 1、如果返回的&gt;0，表示已经获取到关注的事件 * 2、此方法返回关注事件的集合 * 3、通过selectionKeys反向获取通道 */ Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); //遍历selectionKeys，使用迭代器进行遍历 Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext())&#123; //获取到SelectionKey SelectionKey selectionKey = keyIterator.next(); //根据key对应的通道发生的事件做相应的处理 if(selectionKey.isAcceptable())&#123; //有新的客户端连接 //给该客户端生成一个SocketChannel SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;客户端连接成功！生成了一个SocketChannel：&quot;+socketChannel.hashCode()); //将SocketChannel设置为非阻塞 socketChannel.configureBlocking(false); //将当前的SocketChannel注册到selector //关联一个Buffer socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024)); &#125; if(selectionKey.isReadable())&#123; //发生了读取事件 //通过key反向获取到对应的channel SocketChannel channel = (SocketChannel) selectionKey.channel(); //获取到该channel关联的buffer ByteBuffer buffer = (ByteBuffer) selectionKey.attachment(); channel.read(buffer); System.out.println(&quot;from 客户端：&quot;+new String(buffer.array())); &#125; //手动从集合中移动当前的selectionKey，防止重复操作 keyIterator.remove(); &#125; &#125; &#125;&#125; Client: 123456789101112131415161718192021222324252627282930313233package com.lxg.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; //得到一个网络通道 SocketChannel socketChannel = SocketChannel.open(); //设置非阻塞模式 socketChannel.configureBlocking(false); //提供服务器端的ip和端口 InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666); //连接服务器 if(!socketChannel.connect(inetSocketAddress))&#123; while (!socketChannel.finishConnect())&#123; System.out.println(&quot;因为连接需要时间，客户端不会阻塞，可以做其他工作...&quot;); &#125; &#125; //如果连接成功，就发送数据 String str = &quot;hello,小林你好！&quot;; //wraps a byte array into a buffer ByteBuffer buffer = ByteBuffer.wrap(str.getBytes()); //发送数据(将buffer的数据写入到channel中） socketChannel.write(buffer); System.in.read(); &#125;&#125; 9、SelectionKey SelectionKey，表示 Selector 和网络通道的注册关系, 共四种: int OP_ACCEPT：有新的网络连接可以accept，值为 16 int OP_CONNECT：代表连接已经建立，值为 8 int OP_READ：代表读操作， 值为 1 int OP_WRITE：代表写操作，值为 4源码中： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; SelectionKey相关方法 123456789public abstract class SelectionKey &#123;public abstract Selector selector();//得到与之关联的Selector 对象public abstract SelectableChannel channel();//得到与之关联的通道public final Object attachment();//得到与之关联的共享数据public abstract SelectionKey interestOps(int ops);//设置或改变监听事件public final boolean isAcceptable();//是否可以 acceptpublic final boolean isReadable();//是否可以读public final boolean isWritable();//是否可以写&#125; 10、ServerSocketChannel ServerSocketChannel 在服务器端监听新的客户端 Socket 连接 相关方法如下 123456789public abstract class ServerSocketChannelextends AbstractSelectableChannelimplements NetworkChannel&#123;public static ServerSocketChannel open()，得到一个 ServerSocketChannel 通道public final ServerSocketChannel bind(SocketAddress local)，设置服务器端端口号public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式public SocketChannel accept()，接受一个连接，返回代表这个连接的通道对象public final SelectionKey register(Selector sel, int ops)，注册一个选择器并设置监听事件&#125; 11、SocketChannel SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通 道，或者把通道里的数据读到缓冲区。 相关方法如下： 123456789101112public abstract class SocketChannelextends AbstractSelectableChannelimplements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel&#123;public static SocketChannel open();//得到一个 SocketChannel 通道public final SelectableChannel configureBlocking(boolean block);//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式public boolean connect(SocketAddress remote);//连接服务器public boolean finishConnect();//如果上面的方法连接失败，接下来就要通过该方法完成连接操作public int write(ByteBuffer src);//往通道里写数据public int read(ByteBuffer dst);//从通道里读数据public final SelectionKey register(Selector sel, int ops, Object att);//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据public final void close();//关闭通道&#125; 12、NIO 网络编程应用实例-群聊系统实例要求: 编写一个 NIO 群聊系统，实现服务器 端和客户端之间的数据简单通讯（非 阻塞） 实现多人群聊 服务器端：可以监测用户上线，离线， 并实现消息转发功能 客户端：通过channel 可以无阻塞发送 消息给其它所有用户，同时可以接受 其它用户发送的消息(有服务器转发得 到) 目的：进一步理解NIO非阻塞网络编程 机制 代码演示 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.lxg.nio.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectableChannel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class GroupChatClient &#123; //声明相关属性 private final String HOST = &quot;127.0.0.1&quot;;//服务器的ip private final int POST = 9999;//服务器的端口 private Selector selector; private SocketChannel socketChannel; private String username; //构造器,完成初始化工作 public GroupChatClient() throws IOException &#123; selector = Selector.open(); //连接服务器 socketChannel = SocketChannel.open(new InetSocketAddress(HOST, POST)); //设置非阻塞 socketChannel.configureBlocking(false); //将channel注册到selector socketChannel.register(selector, SelectionKey.OP_READ); //得到username username = socketChannel.getLocalAddress().toString().substring(1); System.out.println(username+&quot;is ok...&quot;); &#125; //向服务器发送消息 public void sendInfo(String info)&#123; info = username + &quot;说：&quot;+info; try&#123; socketChannel.write(ByteBuffer.wrap(info.getBytes())); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //读取从服务器端转发其他客户端过来的消息 private void readInfo()&#123; try&#123; int readChannels = selector.select(); if(readChannels&gt;0)&#123;//有可以用的通道 Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; SelectionKey key = iterator.next(); if(key.isReadable())&#123; //得到相关通道 SocketChannel sc = (SocketChannel) key.channel(); //得到一个Buffer ByteBuffer buffer = ByteBuffer.allocate(1024); //读取 sc.read(buffer); //把读到的缓冲区的数据转换成字符串 String msg = new String(buffer.array()); System.out.println(msg.trim()); &#125; iterator.remove(); &#125; &#125;else&#123;// System.out.println(&quot;没有可用的通道...&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws IOException &#123; //启动我们客户端 GroupChatClient chatClient = new GroupChatClient(); //启动一个线程,每隔3秒，从服务器端读取转发过来的信息 new Thread()&#123; @Override public void run() &#123; while (true) &#123; chatClient.readInfo(); try&#123; Thread.currentThread().sleep(3000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); //发送数据给服务器端 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine())&#123; String s = scanner.nextLine(); chatClient.sendInfo(s); &#125; &#125;&#125; 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.lxg.nio.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;public class GroupChatServer &#123; //定义相关属性 private Selector selector; private ServerSocketChannel listenChannel; private static final int PORT = 9999; //构造器,进行初始化操作 public GroupChatServer()&#123; try&#123; //得到选择器 selector = Selector.open(); //ServerSocketChannel listenChannel = ServerSocketChannel.open(); //绑定端口 listenChannel.socket().bind(new InetSocketAddress(PORT)); //设置非阻塞模式 listenChannel.configureBlocking(false); //将listenChannel注册到selector listenChannel.register(selector, SelectionKey.OP_ACCEPT); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //监听 public void listen()&#123; try &#123; //循环处理 while (true)&#123; int count = selector.select(); if(count&gt;0)&#123; //有事件要处理 //遍历得到的selectionKey集合 Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; //取出selectionKey SelectionKey key = iterator.next(); //监听到了accept if(key.isAcceptable())&#123; SocketChannel sc = listenChannel.accept(); //设置非阻塞 sc.configureBlocking(false); //将该sc注册到selector上 sc.register(selector,SelectionKey.OP_READ); //提示用户上线 System.out.println(&quot;用户&quot;+sc.getRemoteAddress()+&quot;已上线了&quot;); &#125; if (key.isReadable())&#123; //通道发生read事件，即通道是可读的状态 //处理读取事件（调用自定义方法） readData(key); &#125; //处理结束将当前的key删除，防止重复处理 iterator.remove(); &#125; &#125;else&#123; System.out.println(&quot;等待......&quot;); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; &#125; &#125; /** * 读取客户端消息 * @param selectionKey */ private void readData(SelectionKey selectionKey)&#123; //取到关联的channel SocketChannel channel = null; try&#123; //得到channel channel = (SocketChannel) selectionKey.channel(); //创建buffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int count = channel.read(byteBuffer); if(count&gt;0)&#123; //把缓冲区的数据转成字符串 String msg = new String(byteBuffer.array()); //输出该消息 System.out.println(&quot;from 客户端消息：&quot;+msg); //向其他客户端(排除自己）转发消息，调用自定义方法处理 sendInfoToOtherClients(msg,channel); &#125; &#125;catch (IOException e)&#123; try &#123; System.out.println(&quot;用户&quot;+channel.getRemoteAddress()+&quot;离线了&quot;); //取消注册 selectionKey.cancel(); //关闭通道 channel.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; public void sendInfoToOtherClients(String msg,SocketChannel self) throws IOException &#123; System.out.println(&quot;服务器转发消息中......&quot;); //遍历所有注册到selector上的SocketChannel，并排除self for(SelectionKey key : selector.keys())&#123; //通过key取出对应的SocketChannel Channel targetChannel = key.channel(); //排除自己,也排除服务器端的ServerSocketChannel if(targetChannel instanceof SocketChannel &amp;&amp; targetChannel!=self)&#123; //转型 SocketChannel dest = (SocketChannel) targetChannel; //将msg储存到buffer ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes()); //将buffer写入通道 dest.write(buffer); &#125; &#125; &#125; public static void main(String[] args) &#123; //创建一个服务器对象 GroupChatServer groupChatServer = new GroupChatServer(); groupChatServer.listen(); &#125;&#125; 13、NIO与零拷贝零拷贝基本介绍 零拷贝是网络编程的关键，很多性能优化都离不开。 在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝 另外我们看下NIO 中如何使用零拷贝 传统IO数据读写 Java 传统 IO 和 网络编程的一段代码 123456File file = new File(&quot;test.txt&quot;);RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);byte[] arr = new byte[(int) file.length()];raf.read(arr);Socket socket = new ServerSocket(8080).accept();socket.getOutputStream().write(arr); 传统IO123456789早期的数据IO，由用户进程向CPU发起，应用程序与磁盘之间的 I/O 操作都是通过 CPU 的中断完成的。CPU还要负责将磁盘缓冲区拷贝到内核缓冲区(pageCache)，再从内核缓冲区拷贝到用户缓冲区。为了减少CPU占用，产生了DMA技术，大大解放了CPU.DMA 的全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。 传统用户通过cpu读取磁盘数据过程: 由于cpu要参与从磁盘读数据到寄存器，又存入内存。这中间cpu都是阻塞状态不能干别的工作,由此产生DMA技术: 12345678910111213用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；DMA 进一步将 I/O 请求发送给磁盘；磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； DMA技术存在的问题：举个例子，从本地文件中发一张图片给你的好盆友。 传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取图片到到缓存区中，然后通过 write() 方法把缓存中的图片输出到网络端口。 1234567read操作：当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。write操作：当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（socket buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送 需要进行两次DMA拷贝，两次CPU拷贝，四次上下文切换 总共四次拷贝，四次切换，代价属实有点点大。 上下文切换：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。 CPU 拷贝：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。 DMA 拷贝：由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。 零拷贝的想法1.用户态可以直接操作读写，不需要切换用户态内核态 2.尽量减少拷贝次数，尽量减少上下文切换次数 3.写时复制，需要写操作的时候再拷贝，只是读操作没必要拷贝 用户态直接IO用户态直接 I&#x2F;O 使得应用进程或运行在用户态（user space）下的库函数直接访问硬件设备。 用户态直接 I&#x2F;O 只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统 就是一个代表。 其次，这种零拷贝机制会直接操作磁盘 I&#x2F;O，由于 CPU 和磁盘 I&#x2F;O 之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步 I&#x2F;O 使用。 写时复制写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中。 这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。 mmap优化 mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核 空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝 次数。如下图 以mmap+write的方式替代传统的read+write的方式，减少了一次拷贝 mmap 是 Linux 提供的一种内存映射文件方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址 使用 mmap 的目的是将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射。 从而实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程。 mmap示意图 整个拷贝过程会发生 4 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。 mmap 主要的用处是提高 I&#x2F;O 性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费。 sendFile优化 Linux 2.1 版本 提供了 sendFile 函数，其基本 原理如下：数据根本不 经过用户态，直接从内 核缓冲区进入到 Socket Buffer，同时，由于和用 户态完全无关，就减少 了一次上下文切换 通过 Sendfile 系统调用，数据可以直接在内核空间内部进行 I&#x2F;O 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝 示意图和小结 将要读取的文件缓冲区的文件 fd 和要发送的Socket缓冲区的Socket fd 传给sendfile函数， Sendfile 调用中 I&#x2F;O 数据对用户空间是完全不可见的。也就是说，这是一次完全意义上的数据传输过程。 也就是说用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程。 整个拷贝过程会发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。 提示：零拷贝从操作系统角度，是没有cpu 拷贝 Linux 在 2.4 版本中，做了 一些修改，避免了从内核 缓冲区拷贝到 Socket buffer 的操作，直接拷贝到 协议栈，从而再一次减少 了数据拷贝。具体如下图 和小结： Sendfile+DMA gather copy 它只适用于将数据从文件拷贝到 socket 套接字上的传输过程。 它将内核空间的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer）中， 由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中。 这样 DMA 引擎直接利用 gather 操作将页缓存中数据打包发送到网络中即可，本质就是和虚拟内存映射的思路类似。 这里其实有 一次cpu 拷贝 kernel buffer -&gt; socket buffer 但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以 忽略 整个拷贝过程会发生 2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝。 拓展：Splice零拷贝技术Splice相当于在Sendfile+DMA gather copy上的提升 Splice 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。 基于 Splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝。 用户进程通过 splice() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。 CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。 CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。 CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。 上下文从内核态（kernel space）切换回用户态（user space），Splice 系统调用执行返回。 对比 无论是传统 I&#x2F;O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。 拷贝方式 CPU拷贝 DMA拷贝 系统调用 上下文切换 传统方式 2 2 read&#x2F;write 4 内存映射（mmap+write） 1 2 mmap&#x2F;write 4 sendfile 1 2 sendfile 2 sendfile+DMA gather copy 0 2 sendfile 2 splice 0 2 splice 2 零拷贝的再次理解 我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是 重复的（只有 kernel buffer 有一份数据）。 零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下 文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。 mmap和sendFile的区别 mmap 适合小数据量读写，sendFile 适合大文件传输。 mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最 少 2 次数据拷贝。 sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝 到 Socket NIO零拷贝案例案例要求： 使用传统的IO 方法传递一个大文件 使用NIO 零拷贝方式传递(transferTo)一个大文件 看看两种传递方式耗时时间分别是多少 传统IO服务端 1234567891011121314151617181920212223242526272829303132package com.lxg.nio.zerocopy;import java.io.DataInputStream;import java.net.ServerSocket;import java.net.Socket;public class OldIOServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(7001); while (true) &#123; Socket socket = serverSocket.accept(); DataInputStream dataInputStream = new DataInputStream(socket.getInputStream()); try &#123; byte[] byteArray = new byte[4096]; while (true) &#123; int readCount = dataInputStream.read(byteArray, 0, byteArray.length); if (-1 == readCount) &#123; break; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125;&#125; 传统IO客户端 123456789101112131415161718192021222324252627282930313233343536package com.lxg.nio.zerocopy;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.InputStream;import java.net.Socket;public class OldIOClient &#123; public static void main(String[] args) throws Exception &#123; Socket socket = new Socket(&quot;localhost&quot;, 7001); String fileName = &quot;protoc-3.6.1-win32.zip&quot;; InputStream inputStream = new FileInputStream(fileName); DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream()); byte[] buffer = new byte[4096]; long readCount; long total = 0; long startTime = System.currentTimeMillis(); while ((readCount = inputStream.read(buffer)) &gt;= 0) &#123; total += readCount; dataOutputStream.write(buffer); &#125; System.out.println(&quot;发送总字节数： &quot; + total + &quot;, 耗时： &quot; + (System.currentTimeMillis() - startTime)); dataOutputStream.close(); socket.close(); inputStream.close(); &#125;&#125; NIO服务端 123456789101112131415161718192021222324252627282930313233343536package com.lxg.nio.zerocopy;import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;public class NewIOServer &#123; public static void main(String[] args) throws IOException &#123; InetSocketAddress address = new InetSocketAddress(7001); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); ServerSocket serverSocket = serverSocketChannel.socket(); serverSocket.bind(address); //创建buffer ByteBuffer byteBuffer = ByteBuffer.allocate(4096); while(true)&#123; SocketChannel s = serverSocketChannel.accept(); int readCount = 0; while (readCount!=-1)&#123; try&#123; readCount = s.read(byteBuffer); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; // byteBuffer.rewind();//倒带 position=0，mark作废 &#125; &#125; &#125;&#125; NIO客户端 123456789101112131415161718192021222324252627282930313233343536373839404142package com.lxg.nio.zerocopy;import java.io.FileInputStream;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.channels.FileChannel;import java.nio.channels.SocketChannel;public class NewIOClient &#123; public static void main(String[] args) throws IOException &#123;// SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;localhost&quot;, 7001)); SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 7001)); String fileName = &quot;jdk-sourall.zip&quot;; //得到一个文件Channel FileChannel fileChannel = new FileInputStream(fileName).getChannel(); //准备发送 long startTime = System.currentTimeMillis(); //在linux下一个transferTo方法就可以完成传输 //在windows下一次调用transferTo只能发送8m，就需要分段传输文件，而且要注意传输时的位置 //transferTo底层使用到零拷贝 long position = 0; long total = 0; while (position&lt;fileChannel.size())&#123; long transferCount = fileChannel.transferTo(position, fileChannel.size(), socketChannel); if(transferCount&lt;=0)&#123; break; &#125; total+=transferCount; position+=transferCount; &#125; System.out.println(&quot;发送的总字节数=&quot;+total +&quot;耗时：&quot;+(System.currentTimeMillis()-startTime));// long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel);// System.out.println(&quot;发送的总字节数=&quot;+transferCount +&quot;耗时：&quot;+(System.currentTimeMillis()-startTime)); //关闭 fileChannel.close(); &#125;&#125; 14、Java AIO基本介绍 JDK 7 引入了 Asynchronous I&#x2F;O，即 AIO。在进行 I&#x2F;O 编程中，常用到两种模式： Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得 到通知，进行相应的处理 AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作 系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时 间较长的应用 目前 AIO 还没有广泛应用，Netty 也是基于NIO, 而不是AIO， 因此我们就不详解 AIO了，有兴趣可以参考 &lt;&gt; http://www.52im.net/thread-306-1-1.html 15、BIO、NIO、AIO对比表 模型 BIO NIO AIO IO模型 同步阻塞 同步非阻塞（多路复用） 异步非阻塞 编程难度 简单 复杂 复杂 可靠性 差 好 好 吞吐量 低 高 高 举例说明： 同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。 同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说 下，我先干其他事情，一会过来看是否轮到自己. 异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事 情，理发师自己来家给你理发 四、Netty概述1、原生NIO存在的问题 NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、 SocketChannel、ByteBuffer 等。 需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失 败缓存、网络拥塞和异常流的处理等等。 JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导 致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。 2、Netty官网说明官网：https://netty.io/ Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; client 1Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能协议服务器和客户端 Netty 是由 JBOSS 提供的一个 Java 开源框架。Netty 提供异步的、基于事件驱动的网 络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序 Netty 可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了 NIO 的 开发过程 Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游 戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采 用了 Netty 3、Netty的优点Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。 设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展 的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个 线程池. 使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。 安全：完整的 SSL&#x2F;TLS 和 StartTLS 支持。 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复， 同时，更多的新功能会被加入 4、Netty版本说明 netty版本分为 netty3.x 和 netty4.x、netty5.x 因为Netty5出现重大bug，已经被官网废弃了，目前推荐使用的是Netty4.x的稳定版 本 目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x 在本课程中，我们讲解 Netty4.1.x 版本 5 五、Netty高性能架构设计1、线程模型基本介绍 不同的线程模式，对程序的性能有很大影响，为了搞清Netty 线程模式，我们来系统 的讲解下 各个线程模式， 最后看看Netty 线程模型有什么优越性. 目前存在的线程模型有： 传统阻塞 I&#x2F;O 服务模型 Reactor 模式 根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 • 单 Reactor 单线程； • 单 Reactor 多线程； • 主从 Reactor 多线程 Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor) 2、传统阻塞I&#x2F;O服务模型工作原理图黄色的框表示对象， 蓝色的框表示线程 白色的框表示方法(API) 模型特点 采用阻塞IO模式获取输入的数据 每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回 问题分析 当并发数很大，就会创建大量的线程，占用很大系统资源 连接创建后，如果当前线程暂时没有数据可读，该线程 会阻塞在read 操作，造成线程资源浪费 3、Reactor模式针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案： 基于 I&#x2F;O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等 待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应 用程序，线程从阻塞状态返回，开始进行业务处理 Reactor 对应的叫法: 反应器模式 分发者模式(Dispatcher) 通知者模式(notifier) 基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理 任务分配给线程进行处理，一个线程可以处理多个连接的业务。 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想， 如图： 说明: Reactor 模式，通过一个或多个输 入同时传递给服务处理器的模式 (基于事件驱动) 服务器端程序处理传入的多个请求, 并将它们同步分派到相应的处理线 程， 因此Reactor模式也叫 Dispatcher模式 Reactor 模式使用IO复用监听事件, 收到事件后，分发给某个线程(进 程), 这点就是网络服务器高并发处 理关键 Reactor 模式中 核心组成： Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处 理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并 将线路转移到适当的联系人； Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类似于客户想要与之交谈的公 司中的实际官员。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行 非阻塞操作 Reactor 模式分类：根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 单 Reactor 单线程 单 Reactor 多线程 主从 Reactor 4、单Reactor单线程工作原理示意图：演示下NIO 群聊,说 明 方案说明： Select 是前面 I&#x2F;O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻 塞对象监听多路连接请求 Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发 如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理 如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应 Handler 会完成 Read→业务处理→Send 的完整业务流程 结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写 等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。 方案优缺点分析： 优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成 缺点：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某 个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈 缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不 可用，不能接收和处理外部消息，造成节点故障 使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复 杂度 O(1) 的情况 5、单Reactor多线程工作原理示意图： 方案说明 Reactor 对象通过select 监控客户端请求 事件, 收到事件后，通过dispatch进行分发 如果建立连接请求, 则右Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象 处理完成连接后的各种事件 如果不是连接请求，则由reactor分发调用连接对 应的handler 来处理 handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线 程池的某个线程处理业务 worker 线程池会分配独立线程完成真正的业务， 并将结果返回给handler handler收到响应后，通过send 将结果返回给 client 方案优缺点分析： 优点：可以充分的利用多核cpu 的处理能力 缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在 单线程运行， 在高并发场景容易出现性能瓶颈 6、主从Reactor多线程工作原理示意图：针对单 Reactor 多线程模型中，Reactor 在单线程中运 行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行 subreactor可以有很多个 方案说明 Reactor主线程 MainReactor 对象通过select 监听连接事件, 收 到事件后，通过Acceptor 处理连接事件 当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor subreactor 将连接加入到连接队列进行监听,并创建handler 进行各种事件处理 当有新事件发生时， subreactor 就会调用对应的handler处 理 handler 通过read 读取数据，分发给后面的worker 线程处理 worker 线程池分配独立的worker 线程进行业务处理，并返 回结果 Scalable IO in Java 对 Multiple Reactors 的原理图解： 方案优缺点说明： 优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线 程完成后续的业务处理。 优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线 程，子线程无需返回数据。 缺点：编程复杂度较高 结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型， Memcached 主从多线程，Netty 主从多线程模型的支持 7、Reactor模式小结3 种模式用生活案例来理解 单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服 单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待 主从 Reactor 多线程，多个前台接待员，多个服务生 Reactor 模式具有如下的优点： 响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的 可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程 的切换开销 扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源 复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性 8、Netty模型工作原理示意图1-简单版Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多 线程模型有多个 Reactor BossGroup 线程维护Selector , 只关注Accecpt 当接收到Accept事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel并注册到 Worker 线程(事件循环), 并进行维护 当Worker线程监听到selector 中通道发生自己感 兴趣的事件后，就进行处理(就由handler)， 注意 handler 已经加入到通道 工作原理示意图2-进阶版Netty 主要基于主从 Reactors 多线程模型（如 图）做了一定的改进，其 中主从 Reactor 多线程模 型有多个 Reactor 工作原理示意图-详细版 Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写 BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循 环 ，每一个事件循环是 NioEventLoop NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络 通讯 NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop 每个Boss NioEventLoop 循环执行的步骤有3步 1. 轮询accept 事件 2. 处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其 注册到某个worker NIOEventLoop 上的 selector 3. 处理任务队列的任务 ， 即 runAllTasks 每个 Worker NIOEventLoop 循环执行的步骤 轮询read, write 事件 处理i&#x2F;o事件， 即read , write 事件，在对应NioScocketChannel 处理 处理任务队列的任务 ， 即 runAllTasks 每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道), pipeline中包含了channel，即通过pipeline可以获取到对应通道，管道中维护了很多的处理器 9、Netty快速入门实例-TCP服务 实例要求：使用IDEA 创建Netty项目 Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~” 服务器可以回复消息给客户端 “hello, 客户端~” 目的：对Netty 线程模型 有一个初步认识, 便于理解Netty 模型理论 看代码演示 编写服务端 编写客户端 对netty 程序进行分析，看看netty模型特点 说明: 创建Maven项目，并引入Netty netty依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.86.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.lxg.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; //创建BOSSGroup和WorkerGroup /** * 说明 * 1、创建了两个线程组boosGroup和workerGroup * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成 * 3、两个都是无限循环 * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数 * 默认是以cpu核数*2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; //创建服务器端的启动对象，配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //使用链式编程来进行设置 bootstrap.group(bossGroup, workerGroup)//设置两个线程组 .channel(NioServerSocketChannel.class) //使用NioServerSocketChannel作为服务器的通道来实现 .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列等待连接的个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个初始化对象（匿名对象） //给pipeline设置处理器 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); //给我们的workerGroup的EventLoop对应的管道设置处理器 System.out.println(&quot;服务器is ready......&quot;); //绑定一个端口并且同步，生成了一个ChannelFuture对象 //启动服务器了（绑定好端口了） ChannelFuture cf = bootstrap.bind(6668).sync(); //对关闭通道进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务端handler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.lxg.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelPipeline;import io.netty.util.CharsetUtil;//继承入栈的handler适配器/** * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范） * 2、这是我们自定义一个Handler，才能成为一个Handler */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; /** * 读取数据事件（这里我们可以读取客户端发送过来的消息） * * @param ctx ：是上下文对象。含有管道pipeline，通道channel，地址 * @param msg ：就是客户端发送过来的数据，默认是Object * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(&quot;服务器读取线程：&quot;+Thread.currentThread().getName()); System.out.println(&quot;server ctx=&quot;+ctx); System.out.println(&quot;看看channel和pipeline的关系&quot;); Channel channel = ctx.channel(); ChannelPipeline pipeline = ctx.pipeline();//本质是一个双向链表，出站入站 //将msg转成一个ByteBuf /** *ByteBuf是Netty提供的，不是NIO的ByteBuffer */ ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;客户端发送消息是：&quot;+buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;客户端地址是：&quot;+ctx.channel().remoteAddress()); &#125; /** * 数据读取完毕 * @param ctx * @throws Exception */ @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //writeAndFlush是write+flush //将数据写入缓冲区，并刷新 //一般来讲，我们对这个发送的数据进行编码 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;,CharsetUtil.UTF_8)); &#125; /** * 处理异常，一般是需要关闭通道 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lxg.netty.simple;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; //客户端需要一个事件循环组 EventLoopGroup group = new NioEventLoopGroup(); try &#123; //创建客户端启动对象 //注意客户端使用的不是ServerBootStrap而是Bootstrap Bootstrap bootstrap = new Bootstrap(); //设置相关参数 bootstrap.group(group) //设置线程组 .channel(NioSocketChannel.class) //设置客户端通道的实现类（反射） .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new NettyClientHandler()); //加入自己的处理器 &#125; &#125;); System.out.println(&quot;客户端 is ok ！&quot;); //启动客户端去连接服务器端 //关于ChannelFuture后面再分析，涉及到netty的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6668).sync(); //给关闭通道进行监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lxg.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; /** * 当通道就绪就会触发该方法 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;client&quot;+ctx); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,server！(&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8)); &#125; /** * 当通道有读取事件时，会触发 * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息：&quot;+buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址：&quot;+ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 10、Netty模型任务队列中的 Task 有 3 种典型使用场景 用户程序自定义的普通任务 [举例说明] 用户自定义定时任务 非当前 Reactor 线程调用 Channel 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后 调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到 任务队列中后被异步消费 123456789101112131415161718192021222324252627282930313233343536373839404142434445//比如我们这里有一个非常耗费时间的业务-&gt;异步执行-&gt;提交到该channel对应的NIOEventLoop的taskQueue中 /*Thread.sleep(10*1000); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵2&quot;,CharsetUtil.UTF_8));*/ //解决方案1：用户程序自定义的普通任务 ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发生异常&quot;+e.getMessage()); &#125; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵2&quot;,CharsetUtil.UTF_8)); &#125; &#125;); ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(20*1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发生异常&quot;+e.getMessage()); &#125; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵3&quot;,CharsetUtil.UTF_8)); &#125; &#125;); //解决方案2：用户自定义定时任务-&gt;该任务是提交到scheduleTaskQueue中 ctx.channel().eventLoop().schedule(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(20*1000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;发生异常&quot;+e.getMessage()); &#125; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵4&quot;,CharsetUtil.UTF_8)); &#125; &#125;,5, TimeUnit.SECONDS); System.out.println(&quot;go on ...&quot;); 方案再说明 Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负 责网络读写操作。 NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道。 NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop 负责 NioEventLoopGroup 下包含多个 NioEventLoop 每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue 每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel 每个 NioChannel 只会绑定在唯一的 NioEventLoop 上 每个 NioChannel 都绑定有一个自己的 ChannelPipelin 11、异步模型基本介绍 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实 际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。 Netty 中的 I&#x2F;O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。 调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获 取或者通过通知机制获得 IO 操作结果 Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun返回 显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future去监控方法 fun 的处理过程(即 ： Future-Listener 机制) Future说明 表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等 等. ChannelFuture 是一个接口 ： public interface ChannelFuture extends Future 我们可以添加监听器，当监听的事件发生时，就会通知到监听器. 案例说明 工作原理示意图 说明: 在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。 Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来 Future-Listener 机制 当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。 常见有如下操作 • 通过 isDone 方法来判断当前操作是否完成； 通过 isSuccess 方法来判断已完成的当前操作是否成功； 通过 getCause 方法来获取已完成的当前操作失败的原因； 通过 isCancelled 方法来判断已完成的当前操作是否被取消；通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知 指定的监听器；如果 Future 对象已完成，则通知指定的监听器 举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑 1234567serverBootstrap.bind(port).addListener(future -&gt; &#123;if(future.isSuccess()) &#123;System.out.println(newDate() + &quot;: 端口[&quot;+ port + &quot;]绑定成功!&quot;);&#125; else&#123;System.err.println(&quot;端口[&quot;+ port + &quot;]绑定失败!&quot;);&#125;&#125;); 小结： 相比传统阻塞 I&#x2F;O，执行 I&#x2F;O 操作后线程会被阻塞住, 直到操作完成；异步处理的好 处是不会造成线程阻塞，线程在 I&#x2F;O 操作期间可以执行别的程序，在高并发情形下会更稳 定和更高的吞吐量 13、快速入门实例-HTTP服务 实例要求：使用IDEA 创建Netty项目 Netty 服务器在 6668 端口监听，浏览器发出请求 “http://localhost:6668/ “ 服务器可以回复消息给客户端 “Hello! 我是服务器 5 “ , 并 对特定请求资源进行过滤. 目的：Netty 可以做Http服务开发，并且理解Handler实例 和客户端及其请求的关系. 看代码演示 TestServer: 123456789101112131415161718192021222324252627282930package com.lxg.netty.http;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class TestServer &#123; public static void main(String[] args) throws Exception&#123; NioEventLoopGroup bossGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new TestServerInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(9999).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; TestServerInitializer: 12345678910111213141516171819202122232425262728package com.lxg.netty.http;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.http.HttpServerCodec;public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //向管道加入处理器 //得到管道 ChannelPipeline pipeline = socketChannel.pipeline(); //加入一个netty提供的httpServerCodec codec =&gt; coder - decoder /** * HttpServerCodec说明 * 1、HttpServerCodec 是netty提供的处理http的编码解码器 */ pipeline.addLast(&quot;MyHttpServerCodec&quot;,new HttpServerCodec()); //2、增加一个自定义的handler pipeline.addLast(&quot;MyTestHttpServerHandler&quot;,new TestHttpServerHandler()); &#125;&#125; TestHttpServerHandler: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lxg.netty.http;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.util.CharsetUtil;import java.net.URI;/** * 说明 * 1、SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类 * 2、HttpObject 表示 客户端和服务器端相互通讯的数据被封装成HttpObject */public class TestHttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; //读取客户端数据，当有读取事件发生时触发 @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; //判断msg是不是一个httprequest请求 if(msg instanceof HttpRequest)&#123; System.out.println(&quot;pipeline &quot; + ctx.pipeline().hashCode()+&quot;TestHttpServerHandler hash=&quot;+this.hashCode()); System.out.println(&quot;msg类型=&quot;+msg.getClass()); System.out.println(&quot;客户端地址：&quot;+ctx.channel().remoteAddress()); //获取到 HttpRequest httpRequest = (HttpRequest) msg; //获取uri,过滤指定资源 URI uri = new URI(httpRequest.uri()); if(&quot;/favicon.ico&quot;.equals(uri.getPath()))&#123; System.out.println(&quot;请求了 favicon.ico，不做响应&quot;); return; &#125; //回复信息给浏览器[http协议] ByteBuf content = Unpooled.copiedBuffer(&quot;hello，我是服务器&quot;, CharsetUtil.UTF_8); //构造一个http的响应，即httpresponse FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content); response.headers().set(HttpHeaderNames.CONTENT_TYPE,&quot;text/plain;charset=UTF-8&quot;); response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes()); //将构建好response返回 ctx.writeAndFlush(response); &#125; &#125;&#125; 六、Netty核心模块组件1、Bootstrap、ServerBootstrap Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置 整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类， ServerBootstrap 是服务端启动引导类 常见的方法有 public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法 用于服务器端，用来设置两个 EventLoop public B group(EventLoopGroup group) ，该方法用于客户端，用来设置一个 EventLoop public B channel(Class channelClass)，该方法用来设置一个服务器端的通道实现 public B option(ChannelOption option, T value)，用来给 ServerChannel 添加配置 public ServerBootstrap childOption(ChannelOption childOption, T value)，用来给接收到的 通道添加配置 public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类 （自定义的 handler） public ChannelFuture bind(int inetPort) ，该方法用于服务器端，用来设置占用的端口号 public ChannelFuture connect(String inetHost, int inetPort) ，该方法用于客户端，用来连接服务器 12345678910childHandler()和childOption()都是给workerGroup （也就是group方法中的childGroup参数）进行设置的，option()和handler()都是给bossGroup（也就是group方法中的parentGroup参数）设置的。另一种方法说option()和handler()是在server启动时进行设置和调用，childHandler()和childOption()是在连接建立是设置和调用的。其实都是对的。bossGroup是在服务器一启动就开始工作，负责监听客户端的连接请求。当建立连接后就交给了workGroup进行事务处理，两种是从不同的角度解释的。handler在初始化时就会执行，而childHandler会在客户端成功connect后才执行，这是两者的区别。客户端Bootstrap只有handler()方法，因为客户端只需要一个事件线程组 2、Future、ChannelFuture Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以 过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发 注册的监听事件 常见的方法有 Channel channel()，返回当前正在进行 IO 操作的通道 ChannelFuture sync()，等待异步操作执行完毕 3、Channel Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。 通过Channel 可获得当前网络连接的通道的状态 通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小） Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着 任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成 调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方 支持关联 I&#x2F;O 操作与对应的处理程序 不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型: NioSocketChannel，异步的客户端 TCP Socket 连接。 NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 NioDatagramChannel，异步的 UDP 连接。 NioSctpChannel，异步的客户端 Sctp 连接。 NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。 4、Selector Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连 接的 Channel 事件。 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询 (Select) 这些注册的 Channel 是否有已就绪的 I&#x2F;O 事件（例如可读，可写，网络连接 完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channe 5、ChannelHandler 及其实现类 ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。 ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方 便使用期间，可以继承它的子类 ChannelHandler 及其实现类一览图(后) 相关接口和类一览图： 1234567891011• ChannelInboundHandler 用于处理入站 I/O 事件。• ChannelOutboundHandler 用于处理出站 I/O 操作。//适配器• ChannelInboundHandlerAdapter用于处理入站 I/O 事件。• ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。• ChannelDuplexHandler 用于处理入站和出站事件。 我们经常需要自定义一 个 Handler 类去继承 ChannelInboundHandlerA dapter，然后通过重写 相应方法实现业务逻辑， 我们接下来看看一般都 需要重写哪些方法 12345678910111213141516171819202122232425262728293031323334public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapterimplements ChannelInboundHandler &#123;public ChannelInboundHandlerAdapter() &#123; &#125;public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;ctx.fireChannelRegistered();&#125;public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;ctx.fireChannelUnregistered();&#125;//通道就绪事件public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;ctx.fireChannelActive();&#125;public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;ctx.fireChannelInactive();&#125;//通道读取数据事件public void channelRead(ChannelHandlerContext ctx, Object msg) throwsException &#123;ctx.fireChannelRead(msg);&#125;//数据读取完毕事件public void channelReadComplete(ChannelHandlerContext ctx) throws Exception&#123; ctx.fireChannelReadComplete();&#125;public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception&#123; ctx.fireUserEventTriggered();&#125;public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception&#123; ctx.fireChannelWritabilityChanged();&#125;public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception&#123; ctx.fireExceptionCaught(cause);&#125; 6、Pipeline 和 ChannelPipelineChannelPipeline 是一个重点： ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解： ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站 事件和出站操作) ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事 件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下 • 一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler • 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler， 出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰 常用方法 1234• ChannelPipeline addFirst(ChannelHandler... handlers)，把一个业务处理类（handler）添加到链中的第一个位置• ChannelPipeline addLast(ChannelHandler... handlers)，把一个业务处理类（handler）添加到链中的最后一个位置 7、ChannelHandlerContext 保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象 即ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便 对 ChannelHandler进行调用. 常用方法 1234ChannelFuture close()，关闭通道• ChannelOutboundInvoker flush()，刷新• ChannelFuture writeAndFlush(Object msg) ， 将 数 据 写 到 ChannelPipeline 中 当 前• ChannelHandler 的下一个 ChannelHandler 开始处理 8、ChannelOption Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。 ChannelOption 参数如下: ChannelOption.SO_BACKLOG ： 对应 TCP&#x2F;IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服 务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户 端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定 了队列的大小。 ChannelOption.SO_KEEPALIVE ： 一直保持连接活动状态 9、EventLoopGroup 和其实现类 NioEventLoopGroup EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源， 一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。 EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。 通常一个服务端口即一个 ServerSocketChannel对应一个Selector 和一个EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示： 12345678910111213• BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的Selector 实例BossEventLoop 不断轮询Selector 将连接事件分离出来• 通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给WorkerEventLoopGroup• WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个SocketChannel 注册到其维护的Selector 并对其后续的 IO 事件进行处理 常用方法 12• public NioEventLoopGroup()，构造方法• public Future&lt;?&gt; shutdownGracefully()，断开连接，关闭线程 10、Upooled类 Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类 常用方法如下所示 12//通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）public static ByteBuf copiedBuffer(CharSequence string, Charset charse 举例说明Unpooled 获取 Netty的数据容器ByteBuf 的基本使用 【案例演示 123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;public class NettyByteBuf01 &#123; public static void main(String[] args) &#123; //创建一个ByteBuf /** * 说明 * 1、创建对象，该对象包含一个数组arr，是一个byte[10] * 2、在netty的buffer中，不需要使用flip进行反转 * 底层维护了readerIndex和writerIndex * 3、通过readerIndex和writerIndex还有capacity，将buffer分成了三个区域 * 0--readerIndex ：已经读取的区域 * 0-writerIndex：已经写的区域 * readerIndex--writerIndex:可读的区域 * writerIndex--capacity:表示可写的区域 */ ByteBuf buffer = Unpooled.buffer(10); for (int i = 0; i &lt; 10; i++) &#123; buffer.writeByte(i); &#125; System.out.println(&quot;capacity=&quot;+buffer.capacity()); //输出 for (int i = 0; i &lt; buffer.capacity(); i++) &#123; System.out.println(buffer.getByte(i)); &#125; System.out.println(&quot;==================================&quot;); for (int i = 0; i &lt; buffer.capacity(); i++) &#123; System.out.println(buffer.readByte()); &#125; System.out.println(&quot;执行结束！&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lxg.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.util.CharsetUtil;import java.nio.charset.Charset;public class NettyByteBuf02 &#123; public static void main(String[] args) &#123; //创建一个ByteBuf ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;hello,world!&quot;, Charset.forName(&quot;UTF-8&quot;)); //使用相关的api if(byteBuf.hasArray())&#123; //true byte[] content = byteBuf.array(); //将content转成字符串 System.out.println(new String(content, Charset.forName(&quot;UTF-8&quot;))); System.out.println(&quot;byteBuf=&quot;+byteBuf); System.out.println(byteBuf.arrayOffset());//0 System.out.println(byteBuf.readerIndex());//0 System.out.println(byteBuf.writerIndex());//12 System.out.println(byteBuf.capacity());//36 //System.out.println(byteBuf.readByte()); //读出一个字节 h--&gt;104 System.out.println(byteBuf.getByte(0)); int len = byteBuf.readableBytes();//可读的字节数等于12 System.out.println(&quot;len=&quot;+len); //使用for取出各个字节 for (int i = 0; i &lt;len ; i++) &#123; System.out.print((char)byteBuf.getByte(i)); &#125; System.out.println(); //从哪开始读，读几个字节，字节编码 System.out.println(byteBuf.getCharSequence(0,4,Charset.forName(&quot;UTF-8&quot;))); System.out.println(byteBuf.getCharSequence(4,6,Charset.forName(&quot;UTF-8&quot;))); &#125; &#125;&#125; 11、Netty应用实例-群聊系统实例要求: 编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞） 实现多人群聊 服务器端：可以监测用户上线，离线，并实现消息转发功能 客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用 户发送的消息(有服务器转发得到) 目的：进一步理解Netty非阻塞网络编程机制 看代码演示 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.lxg.netty.groupchat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class GroupChatServer &#123; private int post;//监听端口 public GroupChatServer(int post) &#123; this.post = post; &#125; //编写run方法，处理客户端的请求 public void run() throws Exception &#123; //创建两个线程组 EventLoopGroup boosGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(boosGroup,workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG,128) .childOption(ChannelOption.SO_KEEPALIVE,true) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //获取到pipeline ChannelPipeline pipeline = socketChannel.pipeline(); //向pipeline加入解码器 pipeline.addLast(&quot;decoder&quot;,new StringDecoder()); //向pipeline加入编码器 pipeline.addLast(&quot;encoder&quot;,new StringEncoder()); //加入自定义的业务处理handler pipeline.addLast(new GroupChatServerHandler()); &#125; &#125;); System.out.println(&quot;Netty服务器已经启动完毕！&quot;); ChannelFuture channelFuture = bootstrap.bind(post).sync(); //监听关闭事件 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; boosGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; new GroupChatServer(7000).run(); &#125;&#125; 服务器端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lxg.netty.groupchat;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.util.concurrent.GlobalEventExecutor;import java.text.SimpleDateFormat;import java.util.*;public class GroupChatServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; //public static List&lt;Channel&gt; channelList = new ArrayList&lt;&gt;(); //使用一个hashmap管理// public static Map&lt;String,Channel&gt; channels = new HashMap&lt;&gt;();// public static Map&lt;User,Channel&gt; channels2 = new HashMap&lt;&gt;(); //定义一个channel组，管理所有的channel //GlobalEventExecutor.INSTANCE是全局的事件执行器，是一个单例 private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); /** * 表示连接建立，一旦连接，第一个被执行 * 将当前channel加入到channelGroup * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; Channel channel = ctx.channel(); //将该客户加入聊天的信息推送给其他在线的客户端 /** * 该方法会将channelGroup中所有channel遍历，并发送消息，我们不需要自己遍历 * 因为是先发送再加入所以排除了新进来的自己 */ channelGroup.writeAndFlush(&quot;[客户端]&quot;+channel.remoteAddress()+&quot;加入聊天室&quot;+sdf.format(new Date())+&quot;\\n&quot;); channelGroup.add(channel);// channels.put(&quot;id100&quot;,channel);// channels2.put(new User(10,&quot;小林&quot;),channel); &#125; //断开连接，将xx客户离开信息推送给当前在线的客户 //不需要channelGroup.remove(channel); @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; Channel channel = ctx.channel(); channelGroup.writeAndFlush(&quot;[客户端]&quot;+channel.remoteAddress()+&quot;离开聊天室&quot;+sdf.format(new Date())+&quot;\\n&quot;); System.out.println(&quot;channelGroup size=&quot;+channelGroup.size()); &#125; //表示channel处于活动状态，提示xx上线了 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()+&quot;已上线~&quot;+sdf.format(new Date())+&quot;\\n&quot;); &#125; //表示channel处于非活动状态，提示xx下线了 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()+&quot;已离线~&quot;+sdf.format(new Date())+&quot;\\n&quot;); &#125; //读取数据 @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; //获取到当前channel Channel channel = ctx.channel(); //这时我们遍历channelGroup，根据不同的情况，回送不同的消息 channelGroup.forEach(ch -&gt;&#123; if (channel!=ch)&#123;//不是当前channel，进行消息转发 ch.writeAndFlush(&quot;[客户]&quot;+channel.remoteAddress()+&quot;发送消息：&quot;+msg+sdf.format(new Date())+&quot;\\n&quot;); &#125;else&#123; ch.writeAndFlush(&quot;[您]发送了消息：&quot;+msg+sdf.format(new Date())+&quot;\\n&quot;); &#125; &#125;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; //关闭通道 ctx.close(); &#125;&#125; 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.lxg.netty.groupchat;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.util.Scanner;public class GroupChatClient &#123; //属性 private final String host; private final int port; public GroupChatClient(String host, int port) &#123; this.host=host; this.port=port; &#125; public void run() throws Exception &#123; NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //得到pipeline ChannelPipeline pipeline = socketChannel.pipeline(); //加入相关handler pipeline.addLast(&quot;decoder&quot;, new StringDecoder()); pipeline.addLast(&quot;encoder&quot;, new StringEncoder()); //加入自定义handler pipeline.addLast(new GroupChatClientHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); //得到channel Channel channel = channelFuture.channel(); System.out.println(&quot;------&quot;+channel.localAddress()+&quot;------&quot;); //客户端需要输入信息，创建一个扫描器 Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.nextLine(); //通过channel发送到服务器端 channel.writeAndFlush(msg ); &#125; &#125;finally &#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; new GroupChatClient(&quot;127.0.0.1&quot;,7000).run(); &#125;&#125; 客户端handler： 123456789101112package com.lxg.netty.groupchat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class GroupChatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String msg) throws Exception &#123; System.out.println(msg.trim()); &#125;&#125; 12、Netty心跳检测机制案例实例要求: 编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲 当服务器超过5秒没有写操作时，就提示写空闲 实现当服务器超过7秒没有读或者写操作时，就提示读写空闲 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.lxg.netty.heartbeat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;public class MyServer &#123; public static void main(String[] args) throws Exception&#123; //创建两个线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO))//在bossGroup增加一个日志处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //获取pipeline ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); //加入一个netty提供的IdleStateHandler /** * 说明 * 1、IdleStateHandler是netty提供的处理空闲状态的处理器 * 2、long readerIdleTime：表示多长时间没有读操作，就会发送一个心跳监测包检测是否还是连接状态 * 3、long writerIdleTime：表示多长时间没有写操作，就会发送一个心跳监测包检测是否还是连接状态 * 4、long allIdleTime：表示多长时间没有读和写操作，就会发送一个心跳监测包检测是否还是连接状态 * 5、文档说明： * Triggers an IdleStateEvent when a Channel has not performed read, write, * or both operation for a while * 6、当IdleStateEvent被触发后，就会传递给管道的下一个handler去处理 * 通过调用（触发）下一个handler的userEventTiggered，在该方法中去处理IdleStateEvent（读空闲、写空闲、读写空闲） */ pipeline.addLast(new IdleStateHandler(5,10,20,TimeUnit.SECONDS)); //加入一个对空闲监测进一步处理的handler（自定义） pipeline.addLast(new MyServerHandler()); &#125; &#125;); System.out.println(&quot;服务端初始化完成&quot;); //启动服务器 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端handler： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.lxg.netty.heartbeat;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.timeout.IdleStateEvent;import io.netty.handler.timeout.IdleStateHandler;import io.netty.util.CharsetUtil;public class MyServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; private int times; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; System.out.println(&quot;客户端发送消息：&quot;+msg); if (&quot;I am alive&quot;.equals(msg)) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;ok&quot;, CharsetUtil.UTF_8)); &#125; &#125; /** * * @param ctx 上下文 * @param evt 事件 * @throws Exception */ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if(evt instanceof IdleStateEvent)&#123; //将evt向下转型 IdleStateEvent IdleStateEvent event = (IdleStateEvent) evt; String eventType = null; switch (event.state())&#123; case READER_IDLE: eventType = &quot;读空闲&quot;; break; case WRITER_IDLE: eventType = &quot;写空闲&quot;; break; case ALL_IDLE: eventType = &quot;读写空闲&quot;; break; &#125; System.out.println(ctx.channel().remoteAddress() + &quot;---超时事件---&quot;+eventType); System.out.println(&quot;服务器做相应处理.....&quot;); times++; //如果发生空闲次数过多，我们关闭通道 if (times&gt;3)&#123; System.out.println(&quot;空闲次数超过三次 关闭连接&quot;); ctx.writeAndFlush(&quot;you are out&quot;); ctx.channel().close(); &#125; &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.lxg.netty.heartbeat;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.util.Random;public class MyServerClient &#123; public static void main(String[] args) &#123; //客户端只需要一个事件循环组 EventLoopGroup group = new NioEventLoopGroup(); // 客户端启动的对象 Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); socketChannel.pipeline().addLast(new HreatbeatClientHandler()); &#125; &#125;); System.out.println(&quot;客户端初始化完成&quot;); try &#123; ChannelFuture future = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync(); String data = &quot;I am alive&quot;; while (future.channel().isActive()) &#123; //模拟空闲状态 int num = new Random().nextInt(10); Thread.sleep(num * 1000); future.channel().writeAndFlush(data); &#125; //future.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125; static class HreatbeatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println(&quot;server data:&quot; + s); if (&quot;you are out&quot;.equals(s)) &#123; System.out.println(&quot;关闭&quot;); channelHandlerContext.channel().close(); &#125; &#125; &#125;&#125; 13、Netty 通过WebSocket编程实现服务器和客户端长连接实例要求: Http协议是无状态的, 浏览器和服务 器间的请求响应一次，下一次会重 新创建连接. 要求：实现基于webSocket的长连接 的全双工的交互 改变Http协议多次请求的约束，实 现长连接了， 服务器可以发送消息 给浏览器 客户端浏览器和服务器端会相互感 知，比如服务器关闭了，浏览器会 感知，同样浏览器关闭了，服务器 会感知 服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.lxg.netty.websocket;import com.lxg.netty.heartbeat.MyServerHandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;public class MyServer &#123; public static void main(String[] args) throws Exception &#123; //创建两个线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO))//在bossGroup增加一个日志处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //获取pipeline ChannelPipeline pipeline = socketChannel.pipeline(); //因为基于http协议，使用http的编码和解码器 pipeline.addLast(new HttpServerCodec()); //是以块方式写的，添加ChunkedWrite处理器 pipeline.addLast(new ChunkedWriteHandler()); /** * 说明 * 1、http数据在传输过程中是分段的，HttpObjectAggregator就可以将多个段聚合起来 * 2、这就是为什么当浏览器发送大量数据时，就会发出多次http请求 */ pipeline.addLast(new HttpObjectAggregator(8192)); /** * 说明 * 1、对于websocket，它的数据是以帧（frame）的形式传递 * 2、可以看到WebSocketFrame下面有六个子类 * 3、浏览器发送请求时：ws://localhost:7000/hello 表示请求的uri * 4、WebSocketServerProtocolHandler核心功能是将http协议升级为ws协议，保持长链接 * 5、是通过一个 状态码101 */ pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/hello&quot;)); //自定义的handler，处理业务逻辑 pipeline.addLast(new MyTextWebSocketFrameHandler()); &#125; &#125;); System.out.println(&quot;服务端初始化完成&quot;); //启动服务器 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务端handler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lxg.netty.websocket;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import java.time.LocalDate;import java.time.LocalDateTime;//这里 TextWebSocketFrame类型，表示一个文本帧（frame）public class MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; System.out.println(&quot;服务器端收到消息:&quot;+msg.text()); //回复消息 ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;服务器时间：&quot;+ LocalDateTime.now()+&quot;&quot; + &quot;,收到消息：&quot;+msg.text())); &#125; /** * 当web客户端连接后，触发方法 * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; //id 表示唯一的标识，LongText是唯一的，shortText不是唯一 System.out.println(&quot;handlerAdded被调用了&quot; + ctx.channel().id().asLongText()); System.out.println(&quot;handlerAdded被调用了&quot; + ctx.channel().id().asShortText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;handlerRemoved被调用&quot; + ctx.channel().id().asLongText() ); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(&quot;异常发生&quot;+cause.getMessage()); ctx.close();//关闭连接 &#125;&#125; 客户端页面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var socket; //判断当前浏览器是否支持websocket if(window.WebSocket)&#123; //go on socket = new WebSocket(&quot;ws://localhost:7000/hello&quot;); //相当于channelRead0，ev收到服务器端回送的消息 socket.onmessage = function (ev)&#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; + ev.data; &#125; //相当于连接开启（感知到连接开启） socket.onopen= function (ev)&#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = &quot;连接开启了...&quot;; &#125; //相当于连接关闭（感知到连接关闭） socket.onclose= function (ev)&#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; +&quot;连接关闭了...&quot;; &#125; &#125;else&#123; alert(&quot;当前浏览器不支持WebSocket&quot;); &#125; //发送消息到服务器 function send(message) &#123; if(!window.socket)&#123;//先判断socket是否创建好 return; &#125; if(socket.readyState == WebSocket.OPEN)&#123; //通过socket发送消息 socket.send(message) &#125;else &#123; alert(&quot;连接没有开启！&quot;); &#125; &#125;&lt;/script&gt; &lt;form onsubmit=&quot;return false&quot;&gt; &lt;textarea name=&quot;message&quot; style=&quot;height: 300px;width: 300px&quot;&gt; &lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;发送消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt; &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px;width: 300px&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;清空内容&quot; onclick=&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 七、Google Protobuf1、编码和解码的基本介绍 编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送 数据时就需要编码，接收数据时就需要解码 [示意图] codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。 encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成 业务数据 2、Netty 本身的编码解码的机制和问题分析 Netty 自身提供了一些 codec(编解码器) Netty 提供的编码器 • StringEncoder，对字符串数据进行编码 • ObjectEncoder，对 Java 对象进行编码 • … Netty 提供的解码器 • StringDecoder, 对字符串数据进行解码 • ObjectDecoder，对 Java 对象进行解码 • … Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象 的编码和解码，底层使用的仍是 Java 序列化技术 , 而Java 序列化技术本身效率就不高，存 在如下问题： 无法跨语言 序列化后的体积太大，是二进制编码的 5 倍多。 序列化性能太低 &#x3D;&gt;引出新的解决方案[Google的Protobuf] 3、ProtobufProtobuf基本介绍和使用示意图 Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高 效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做 数据存储或 RPC[远程过程调用 remote procedure call ] 数据交换格式 。 目前很多公司 http+json →tcp+protobuf 参考文档 : https://developers.google.com/protocol-buffers/docs/proto 语言指南 (翻墙) Protobuf 是以 message 的方式来管理数据的. 支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的] （支持目前绝 大多数语言，例如 C++、C#、Java、python 等 高性能，高可靠性 使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描 述。说明，在idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮。 然后通过 protoc.exe 编译器根据.proto 自动生成.java 文件 protobuf 使用示意图： Protobuf快速入门实例编写程序，使用Protobuf完成如下功能 客户端可以发送一个Student PoJo 对象到服 务器 (通过 Protobuf 编码) 服务端能接收Student PoJo 对象，并显示信 息(通过 Protobuf 解码) 具体 看演示步骤 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt; 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.lxg.netty.codec;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; //创建BOSSGroup和WorkerGroup /** * 说明 * 1、创建了两个线程组boosGroup和workerGroup * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成 * 3、两个都是无限循环 * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数 * 默认是以cpu核数*2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; //创建服务器端的启动对象，配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //使用链式编程来进行设置 bootstrap.group(bossGroup, workerGroup)//设置两个线程组 .channel(NioServerSocketChannel.class) //使用NioServerSocketChannel作为服务器的通道来实现 .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列等待连接的个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态 //.handler(null) //该handler对应boosGroup，childHandler对应workGroup .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个初始化对象（匿名对象） //给pipeline设置处理器 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); //在pipeline加入ProtobufDecoder //指定哪种对象进行解码 pipeline.addLast(&quot;Decoder&quot;,new ProtobufDecoder(StudentPOJO.Student.getDefaultInstance())); ch.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); //给我们的workerGroup的EventLoop对应的管道设置处理器 System.out.println(&quot;服务器is ready......&quot;); //绑定一个端口并且同步，生成了一个ChannelFuture对象 //启动服务器了（绑定好端口了） ChannelFuture cf = bootstrap.bind(6668).sync(); //给cf注册监听器，监控我们关心的事件 cf.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if(cf.isSuccess())&#123; System.out.println(&quot;监听端口 6668成功&quot;); &#125;else&#123; System.out.println(&quot;监听端口 6668失败&quot;); &#125; &#125; &#125;); //对关闭通道进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端handler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.lxg.netty.codec;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.*;import io.netty.util.CharsetUtil;//继承入栈的handler适配器/** * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范） * 2、这是我们自定义一个Handler，才能成为一个Handler *///public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;public class NettyServerHandler extends SimpleChannelInboundHandler&lt;StudentPOJO.Student&gt; &#123;// *// * 读取数据事件（这里我们可以读取客户端发送过来的消息）// *// * @param ctx ：是上下文对象。含有管道pipeline，通道channel，地址// * @param msg ：就是客户端发送过来的数据，默认是Object// * @throws Exception//// @Override// public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;//// //读取从客户端发送的StudentPOJO.Student// StudentPOJO.Student student = (StudentPOJO.Student) msg;// System.out.println(&quot;客户端发送的数据：id=&quot;+student.getId()+&quot;,名字=&quot;+student.getName());// &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, StudentPOJO.Student student) throws Exception &#123; System.out.println(&quot;客户端发送的数据：id=&quot;+student.getId()+&quot;,名字=&quot;+student.getName()); &#125; /** * 数据读取完毕 * @param ctx * @throws Exception */ @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //writeAndFlush是write+flush //将数据写入缓冲区，并刷新 //一般来讲，我们对这个发送的数据进行编码 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;,CharsetUtil.UTF_8)); &#125; /** * 处理异常，一般是需要关闭通道 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.lxg.netty.codec;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.protobuf.ProtobufEncoder;public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; //客户端需要一个事件循环组 EventLoopGroup group = new NioEventLoopGroup(); try &#123; //创建客户端启动对象 //注意客户端使用的不是ServerBootStrap而是Bootstrap Bootstrap bootstrap = new Bootstrap(); //设置相关参数 bootstrap.group(group) //设置线程组 .channel(NioSocketChannel.class) //设置客户端通道的实现类（反射） .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //在pipeline中加入ProtoBufEncoder ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(&quot;encoder&quot;,new ProtobufEncoder()); pipeline.addLast(new NettyClientHandler()); //加入自己的处理器 &#125; &#125;); System.out.println(&quot;客户端 is ok ！&quot;); //启动客户端去连接服务器端 //关于ChannelFuture后面再分析，涉及到netty的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6668).sync(); //给关闭通道进行监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端handler： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lxg.netty.codec;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; /** * 当通道就绪就会触发该方法 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //发送一个Student对象到服务器 StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(4).setName(&quot;李四&quot;).build(); //发送Teacher。Member...... ctx.writeAndFlush(student); &#125; /** * 当通道有读取事件时，会触发 * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息：&quot;+buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址：&quot;+ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; Student.proto: 12345678syntax = &quot;proto3&quot;;//版本option java_outer_classname = &quot;StudentPOJO&quot;;//生成的外部类名，同时也是文件名//protobuf是使用message管理数据message Student&#123;//会在StudentPOJO外部类生成一个内部类Student，他是真正发送的POJO对象 int32 id=1;//Student类中有一个属性 名字为id类型为int32（protobuf类型），1表示属性序号，不是值 string name = 2;&#125; 转化为StudentPOJO.java Protobuf快速入门实例2编写程序，使用Protobuf完成如下功能 客户端可以随机发送Student PoJo&#x2F; Worker PoJo 对 象到服务器 (通过 Protobuf 编码) 服务端能接收Student PoJo&#x2F; Worker PoJo 对象(需要 判断是哪种类型)，并显示信息(通过 Protobuf 解码) 具体 看演示步骤 服务器端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.lxg.netty.codec2;import com.lxg.netty.codec.StudentPOJO;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; //创建BOSSGroup和WorkerGroup /** * 说明 * 1、创建了两个线程组boosGroup和workerGroup * 2、boosGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成 * 3、两个都是无限循环 * 4、bossGroup和workerGroup含有的子线程（NioEventLoop)的个数 * 默认是以cpu核数*2 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; //创建服务器端的启动对象，配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //使用链式编程来进行设置 bootstrap.group(bossGroup, workerGroup)//设置两个线程组 .channel(NioServerSocketChannel.class) //使用NioServerSocketChannel作为服务器的通道来实现 .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列等待连接的个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态 //.handler(null) //该handler对应boosGroup，childHandler对应workGroup .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个初始化对象（匿名对象） //给pipeline设置处理器 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); //在pipeline加入ProtobufDecoder //指定哪种对象进行解码 pipeline.addLast(&quot;Decoder&quot;,new ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance())); ch.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); //给我们的workerGroup的EventLoop对应的管道设置处理器 System.out.println(&quot;服务器is ready......&quot;); //绑定一个端口并且同步，生成了一个ChannelFuture对象 //启动服务器了（绑定好端口了） ChannelFuture cf = bootstrap.bind(6668).sync(); //给cf注册监听器，监控我们关心的事件 cf.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if(cf.isSuccess())&#123; System.out.println(&quot;监听端口 6668成功&quot;); &#125;else&#123; System.out.println(&quot;监听端口 6668失败&quot;); &#125; &#125; &#125;); //对关闭通道进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.lxg.netty.codec2;import com.lxg.netty.codec.StudentPOJO;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;//继承入栈的handler适配器/** * 1、自定义一个Handler需要继续netty规定好的某个HandlerAdapter（规范） * 2、这是我们自定义一个Handler，才能成为一个Handler *///public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;public class NettyServerHandler extends SimpleChannelInboundHandler&lt;MyDataInfo.MyMessage&gt; &#123;// *// * 读取数据事件（这里我们可以读取客户端发送过来的消息）// *// * @param ctx ：是上下文对象。含有管道pipeline，通道channel，地址// * @param msg ：就是客户端发送过来的数据，默认是Object// * @throws Exception//// @Override// public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;//// //读取从客户端发送的StudentPOJO.Student// StudentPOJO.Student student = (StudentPOJO.Student) msg;// System.out.println(&quot;客户端发送的数据：id=&quot;+student.getId()+&quot;,名字=&quot;+student.getName());// &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg) throws Exception &#123; //根据datatype来显示不同的信息 MyDataInfo.MyMessage.DataType dataType = msg.getDataType(); if(dataType== MyDataInfo.MyMessage.DataType.StudentType)&#123; MyDataInfo.Student student = msg.getStudent(); System.out.println(&quot;学生id为：&quot;+student.getId()+&quot;，姓名为：&quot;+student.getName()); &#125;else if (dataType== MyDataInfo.MyMessage.DataType.workerType)&#123; MyDataInfo.Worker worker = msg.getWorker(); System.out.println(&quot;工人年龄为：&quot;+worker.getAge()+&quot;，姓名为：&quot;+worker.getName()); &#125;else&#123; System.out.println(&quot;传输的数据类型不正确，请检查！&quot;); &#125; &#125; /** * 数据读取完毕 * @param ctx * @throws Exception */ @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //writeAndFlush是write+flush //将数据写入缓冲区，并刷新 //一般来讲，我们对这个发送的数据进行编码 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello，客户端！(&gt;^ω^&lt;)喵&quot;,CharsetUtil.UTF_8)); &#125; /** * 处理异常，一般是需要关闭通道 * @param ctx * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.lxg.netty.codec2;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.protobuf.ProtobufEncoder;public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; //客户端需要一个事件循环组 EventLoopGroup group = new NioEventLoopGroup(); try &#123; //创建客户端启动对象 //注意客户端使用的不是ServerBootStrap而是Bootstrap Bootstrap bootstrap = new Bootstrap(); //设置相关参数 bootstrap.group(group) //设置线程组 .channel(NioSocketChannel.class) //设置客户端通道的实现类（反射） .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //在pipeline中加入ProtoBufEncoder ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(&quot;encoder&quot;,new ProtobufEncoder()); pipeline.addLast(new NettyClientHandler()); //加入自己的处理器 &#125; &#125;); System.out.println(&quot;客户端 is ok ！&quot;); //启动客户端去连接服务器端 //关于ChannelFuture后面再分析，涉及到netty的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6668).sync(); //给关闭通道进行监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.lxg.netty.codec2;import com.lxg.netty.codec.StudentPOJO;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.util.Random;public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; /** * 当通道就绪就会触发该方法 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //随机发送一个Student或Worker对象到服务器 int random = new Random().nextInt(3); MyDataInfo.MyMessage myMessage = null; if(0==random)&#123;//发送Student对象 myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder() .setId(5).setName(&quot;王五&quot;).build()).build(); &#125;else &#123;//发送一个Worker对象 myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.workerType).setWorker(MyDataInfo.Worker.newBuilder() .setAge(20).setName(&quot;小林&quot;).build()).build(); &#125; ctx.writeAndFlush(myMessage); &#125; /** * 当通道有读取事件时，会触发 * @param ctx * @param msg * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息：&quot;+buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址：&quot;+ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; proto文件： 1234567891011121314151617181920212223242526272829303132syntax = &quot;proto3&quot;;option optimize_for = SPEED;//加快解析option java_package=&quot;com.lxg.netty.codec2&quot;;//指定生成到哪个包下option java_outer_classname=&quot;MyDataInfo&quot;;//外部类名//Protobuf可以使用message管理其他的messagemessage MyMessage&#123; //定义一个枚举类型 enum DataType&#123; StudentType=0;//在proto3要求enum的编号从0开始 workerType=1; &#125; //用data_type来标识传的是哪个枚举类型 DataType data_type = 1; //标识每次枚举类型最多只能出现其中的一个，节省空间 oneof dataBody&#123; Student student = 2; Worker worker = 3; &#125;&#125;message Student&#123; int32 id=1;//Student类的属性 string name=2;&#125;message Worker&#123; string name=1; int32 age=2;&#125; 八、Netty编解码器和handler的调用机制1、基本说明 netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、 ChannelHandler、ChannelPipe等 ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。例如，实 现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就 可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响 应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或 者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不 过它是用来处理出站数据的 ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如 果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即 客户端发送给服务端的数据会通过pipeline中的一系列 ChannelOutboundHandler，并被这些Handler处理，反之则称为入站的 2、编码解码器 当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会 被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会 被编码成字节。 Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHadnler或者 ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。 以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后， 它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发 给ChannelPipeline中的下一个ChannelInboundHandler。 3、解码器-ByteToMessageDecoder 关系继承图 由于不可能知道远程节点是否会 一次性发送一个完整的信息， tcp有可能出现粘包拆包的问题， 这个类会对入站数据进行缓冲， 直到它准备好被处理 一个关于ByteToMessageDecoder实例分析 123456789101112131415public class ToIntegerDecoder extends ByteToMessageDecoder &#123;@Overrideprotected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception&#123;if (in.readableBytes() &gt;= 4) &#123;out.add(in.readInt());&#125;&#125;&#125;说明：1) 这个例子，每次入站从ByteBuf中读取4字节，将其解码为一个int，然后将它添加到下一个List中。当没有更多元素可以被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。int在被添加到List中时，会被自动装箱为Integer。在调用readInt()方法前必须验证所输入的ByteBuf是否具有足够的数据2) decode 执行分析图 [示意图] 4、Netty的handler链的调用机制实例要求: 使用自定义的编码器和解码器来 说明Netty的handler 调用机制 客户端发送long -&gt; 服务器 服务端发送long -&gt; 客户端 案例演示 服务端： 123456789101112131415161718192021222324252627package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class MyServer &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup boosGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(boosGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());//自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; boosGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务端Initializer: 1234567891011121314151617181920package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); //入站的handler进行解码MyByteToLongDecoder pipeline.addLast(new MyByteToLongDecoder()); //出站的handler进行编码 pipeline.addLast(new MyLongToByteEncoder()); //加入自定义handler pipeline.addLast(new MyServerHandler()); &#125;&#125; 服务端handler： 1234567891011121314151617181920212223package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class MyServerHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123; System.out.println(&quot;从客户端：&quot;+ctx.channel().remoteAddress()+&quot;读取到long&quot;+msg); //给客户端发送一个long ctx.writeAndFlush(98765L); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; Decoder： 12345678910111213141516171819202122232425262728293031323334package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import io.netty.util.concurrent.EventExecutorGroup;import java.util.List;public class MyByteToLongDecoder extends ByteToMessageDecoder &#123; /** * decode会根据接收到的数据，被调用多次，直到确定没有新的元素被添加到list * 或者是ByteBuf没有更多的可读字节为止 * 如果list out不为空，就会将list的内容传递给下一个channelinboundhandler处理 * 该处理器的方法也会被调用多次 * * @param ctx：上下文对象 * @param byteBuf：入站的ByteBuf * @param list：list集合，将解码后的数据传给下一个handler * @throws Exception */ @Override protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; System.out.println(&quot;MyByteToLongDecoder中的decode被调用了！&quot;); //因为long8个字节,需要判断有8个字节才能读取一个long if(byteBuf.readableBytes()&gt;=8)&#123; list.add(byteBuf.readLong()); &#125; &#125;&#125; Encoder: 123456789101112131415161718package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class MyLongToByteEncoder extends MessageToByteEncoder&lt;Long&gt; &#123; //编码方法 @Override protected void encode(ChannelHandlerContext ctx, Long msg, ByteBuf byteBuf) throws Exception &#123; System.out.println(&quot;MyLongToByteEncoder中encode被调用了！&quot;); System.out.println(&quot;msg=&quot;+msg); byteBuf.writeLong(msg); &#125;&#125; 客户端： 1234567891011121314151617181920212223242526package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;public class MyClient &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer());//自定义初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端Initializer: 123456789101112131415161718192021package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); //加入出站的handler对数据进行一个编码 pipeline.addLast(new MyLongToByteEncoder()); //这是入站的解码器（入站handler） pipeline.addLast(new MyByteToLongDecoder()); //加入自定义的handler，处理业务 pipeline.addLast(new MyClientHandler()); &#125;&#125; 客户端handler： 1234567891011121314151617181920212223242526272829303132package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;import io.netty.util.concurrent.EventExecutorGroup;public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, Long msg) throws Exception &#123; System.out.println(&quot;服务器的ip=&quot;+channelHandlerContext.channel().remoteAddress()); System.out.println(&quot;收到服务器的消息是=&quot;+msg); &#125; //重写channelActive发送数据 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;MyClientHandler发送数据&quot;);// ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;&quot;)); ctx.writeAndFlush(123456L);//发送的是一个long //分析 //1、&quot;abcdabcdabcdacbd&quot;是16个字节 //2、该处理器的前一个handler是MyLongToByteEncoder //3、MyLongToByteEncoder父类MessageToByteEncoder会判断当前msg是不是应该处理的类型 //如果是就处理，不是就跳过 //4、因此我们在编写Encoder时要注意传入的数据类型和处理的数据类型一致// ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;abcdabcdasdfasdf&quot;, CharsetUtil.UTF_8)); &#125;&#125; 结论： 不论解码器handler 还是 编码器handler 即接 收的消息类型必须与待处理的消息类型一致， 否则该handler不会被执行 在解码器 进行数据解码时，需要判断 缓存 区(ByteBuf)的数据是否足够 ，否则接收到的结果和期望结果可能不一致 5、解码器-ReplayingDecoder public abstract class ReplayingDecoder extends ByteToMessageDecoder ReplayingDecoder扩展了ByteToMessageDecoder类，使用这个类，我们不必调用 readableBytes()方法。参数S指定了用户状态管理的类型，其中Void代表不需要状态 管理 应用实例：使用ReplayingDecoder 编写解码器，对前面的案例进行简化 [案例演示] ReplayingDecoder使用方便，但它也有一些局限性： 并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException。 ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格 式复杂时，消息会被拆成了多个碎片，速度变慢 12345678910111213141516171819package com.lxg.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;public class MyByteToLongDecoder2 extends ReplayingDecoder&lt;Void&gt; &#123; @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; System.out.println(&quot;MyByteToLongDecoder2中的decode被调用了！&quot;); //在ReplayingDecoder中不需要判断数据是否足够读取，内部会进行处理判断 list.add(byteBuf.readLong()); &#125;&#125; 6、其它编解码器其它解码器 LineBasedFrameDecoder：这个类在Netty内 部也有使用，它使用行尾控制字符（\\n或者\\r\\n） 作为分隔符来解析数据。 DelimiterBasedFrameDecoder：使用自定义 的特殊字符作为消息的分隔符。 HttpObjectDecoder：一个HTTP数据的解码器 LengthFieldBasedFrameDecoder：通过指定 长度来标识整包消息，这样就可以自动的处理 黏包和半包消息。 7、Log4j 整合到Netty 在Maven 中添加对Log4j的依赖 在 pom.xml 12345678910111213141516171819202122&lt;dependency&gt;&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.slf4j&lt;/groupId&gt;&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.slf4j&lt;/groupId&gt;&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;version&gt;1.7.25&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.slf4j&lt;/groupId&gt;&lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;&lt;version&gt;1.7.25&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 配置 Log4j , 在 resources&#x2F;log4j.propertie 1234log4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%p] %C&#123;1&#125; - %m%n 演示整合 九、TCP粘包和拆包 及解决方案1、TCP 粘包和拆包基本介绍 TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端） 都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发 给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合 并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于 分辨出完整的数据包了，因为面向流的通信是无消息保护边界的 由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘 包、拆包问题, 看一张图 示意图TCP粘包、拆包图解 说明： 12345假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：1) 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包2) 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包3) 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包4) 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。 2、TCP 粘包和拆包现象实例在编写Netty 程序时，如果没有做处理，就会发生粘包和拆包的问题 看一个具体的实例： 服务器端： 123456789101112131415161718192021222324252627package com.lxg.netty.tcp;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class MyServer &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup boosGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(boosGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());//自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; boosGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端Initializer： 123456789101112131415package com.lxg.netty.tcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new MyServerHandler()); &#125;&#125; 服务器端handler： 1234567891011121314151617181920212223242526272829303132333435package com.lxg.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;public class MyServerHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; private int count; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; byte[] buffer = new byte[msg.readableBytes()]; msg.readBytes(buffer); //将buffer转为字符串 String message = new String(buffer, Charset.forName(&quot;UTF-8&quot;)); System.out.println(&quot;服务器端接收到数据&quot;+message); System.out.println(&quot;服务器接收到消息量=&quot;+(++this.count)); //服务器回送数据给客户端,回送一个随机id ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString()+&quot;、&quot;, Charset.forName(&quot;UTF-8&quot;)); ctx.writeAndFlush(responseByteBuf); &#125;&#125; 客户端： 1234567891011121314151617181920212223242526package com.lxg.netty.tcp;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;public class MyClient &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer());//自定义初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端Initializer： 123456789101112131415package com.lxg.netty.tcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new MyClientHandler()); &#125;&#125; 客户端handler： 123456789101112131415161718192021222324252627282930313233343536373839package com.lxg.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;public class MyClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; private int count; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //使用客户端发送10条数据 hello，server for (int i = 0; i &lt; 10; i++) &#123; ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;hello,server &quot; + i, Charset.forName(&quot;UTF-8&quot;)); ctx.writeAndFlush(byteBuf); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; byte[] buffer = new byte[msg.readableBytes()]; msg.readBytes(buffer); String message = new String(buffer, Charset.forName(&quot;UTF-8&quot;)); System.out.println(&quot;客户端接收到消息=&quot;+message); System.out.println(&quot;客户端接收到消息数量=&quot;+(++this.count)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 3、TCP 粘包和拆包解决方案 使用自定义协议 + 编解码器 来解决 关键就是要解决 服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服 务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。 看一个具体的实例: 要求客户端发送 5 个 Message 对象, 客户端每次发送一个 Message 对象 服务器端每次接收一个Message, 分5次进行解码， 每读取到 一个Message , 会回 复一个Message 对象 给客户端 代码演示 服务器端： 123456789101112131415161718192021222324252627package com.lxg.netty.protocoltcp;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class MyServer &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup boosGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(boosGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());//自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; boosGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端Initializer： 1234567891011121314151617package com.lxg.netty.protocoltcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new MyMessageDecoder());//解码器 pipeline.addLast(new MyMessageEncoder());//编码器 pipeline.addLast(new MyServerHandler()); &#125;&#125; 服务器端handler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lxg.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;//处理业务的handlerpublic class MyServerHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; private int count; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123; //接收到数据，并处理 int len = msg.getLen(); byte[] content = msg.getContent(); System.out.println(); System.out.println(); System.out.println(&quot;服务端接收到信息如下：&quot;); System.out.println(&quot;长度=&quot;+len); System.out.println(&quot;内容=&quot;+new String(content,Charset.forName(&quot;UTF-8&quot;))); System.out.println(&quot;服务器接收到消息包数量=&quot;+(++this.count)); //回复消息 String responseContent = UUID.randomUUID().toString(); byte[] responseContent2 = responseContent.getBytes(&quot;UTF-8&quot;); int responseLen = responseContent2.length; //构建一个协议包 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(responseLen); messageProtocol.setContent(responseContent2); ctx.writeAndFlush(messageProtocol); &#125;&#125; 客户端： 1234567891011121314151617181920212223242526package com.lxg.netty.protocoltcp;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;public class MyClient &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer());//自定义初始化类 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync(); channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 客户端Initializer： 1234567891011121314151617package com.lxg.netty.protocoltcp;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new MyMessageEncoder());//加入编码器 pipeline.addLast(new MyMessageDecoder());//解码器 pipeline.addLast(new MyClientHandler()); &#125;&#125; 客户端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lxg.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;public class MyClientHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; private int count; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //使用客户端发送10条数据 今天天气真不错！ for (int i = 0; i &lt; 5; i++) &#123; String mes = &quot;今天天气真不错！&quot;; byte[] content = mes.getBytes(Charset.forName(&quot;UTF-8&quot;)); int len = content.length; //创建协议包对象 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(len); messageProtocol.setContent(content); ctx.writeAndFlush(messageProtocol); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123; int len = msg.getLen(); byte[] content = msg.getContent(); System.out.println(&quot;客户端接收到消息如下：&quot;); System.out.println(&quot;长度=&quot;+len); System.out.println(&quot;内容=&quot;+new String(content,Charset.forName(&quot;UTF-8&quot;))); System.out.println(&quot;客户端接收到的消息数量=&quot;+(++this.count)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(&quot;异常消息=&quot;+cause.getMessage()); ctx.close(); &#125;&#125; 协议包类： 12345678910111213141516171819202122232425package com.lxg.netty.protocoltcp;//协议包public class MessageProtocol &#123; private int len; private byte[] content; public int getLen() &#123; return len; &#125; public void setLen(int len) &#123; this.len = len; &#125; public byte[] getContent() &#123; return content; &#125; public void setContent(byte[] content) &#123; this.content = content; &#125;&#125; 解码： 12345678910111213141516171819202122232425262728package com.lxg.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;public class MyMessageDecoder extends ReplayingDecoder&lt;Void&gt; &#123; @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; System.out.println(&quot;MyMessageDecoder decode被调用了！&quot;); //需要将得到的二进制字节码转换为MessageProtocol数据包（对象） int length = in.readInt(); byte[] content = new byte[length]; in.readBytes(content); //封装成MessageProtocol对象，放入out，传递给下一个handler业务处理 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setContent(content); messageProtocol.setLen(length); out.add(messageProtocol); &#125;&#125; 编码： 12345678910111213141516package com.lxg.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class MyMessageEncoder extends MessageToByteEncoder&lt;MessageProtocol&gt; &#123; @Override protected void encode(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol, ByteBuf out) throws Exception &#123; System.out.println(&quot;MyMessageEncoder encode 方法被调用了！&quot;); out.writeInt(messageProtocol.getLen()); out.writeBytes(messageProtocol.getContent()); &#125;&#125; 十、Netty核心源码剖析1、基本说明 只有看过Netty源码，才能说是真的掌握了Netty框 架。 在 io.netty.example 包下，有很多Netty源码案例， 可以用来分析 源码分析章节 是针对有Java项目经验，并且玩过 框架源码的人员讲的，否则你听起来会有相当的难度。 2、Netty 启动过程源码剖析源码剖析目的用源码分析的方式走一下 Netty （服务器）的启动过程，更好的理解Netty 的整体 设计和运行机制。 源码剖析说明： 源码需要剖析到Netty 调用doBind方法， 追踪到NioServerSocketChannel的doBind 并且要Debug 程序到 NioEventLoop类 的run代码 ，无限循环，在服务器端运行 源码剖析过程1、demo源码的基本理解 服务器启动类代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */package com.lxg.netty.source.echo;import com.lxg.netty.source.util.ServerUtil;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.ssl.SslContext;/** * Echoes back any received data from a client. */public final class EchoServer &#123; static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;)); public static void main(String[] args) throws Exception &#123; // Configure SSL. final SslContext sslCtx = ServerUtil.buildSslContext(); // Configure the server. EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final EchoServerHandler serverHandler = new EchoServerHandler(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); &#125; //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(serverHandler); &#125; &#125;); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 1234567891011121314151617181920212223说明：1)先看启动类：main方法中，首先创建了关于SSL的配置类。2)重点分析下创建了两个EventLoopGroup对象：EventLoopGroup bossGroup new NioEventLoopGroup(1);EventLoopGroup workerGroup new NioEventLoopGroupO;(I)这两个对象是整个Nety的核心对象，可以说，整个Nety的运作都依赖于他们。bossGroup用于接受Tcp请求，他会将请求交给workerGroup，workerGroup会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。(2)EventLoopGroup是事件循环组（线程组）含有多个EventLoop,可以注册channel,用于在事件循不中去进行选择（和选择器相关）.[debug看](3)new NioEventLoopGroup(1);这个1表示bossGroup事件组有1个线程你可以指定，如果new NioEventLoopGroup()会含有默认个线程cpu核数*2，即可以充分的利用多核的优势，【可以dubug一把】DEFAULT_EVENT_LOOP_THREADS Math.max(1,SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;,NettyRuntime.availableProcessors()*2));会创建EventExecutor数组children=new EventExecutor[nThreads];/debug一下每个元素的类型就是NIOEventLoop,.NIOEventLoop实现了EventLoop接口和Executor接口 try块中创建了一个ServerBootstrap对象，他是一个引导类，用于启动服务器和引导整个稈序的初始化.（看下源码allows easy bootstrap of&#123;@link ServerChannel&#125;)。它和ServerChannel关联，而ServerChannel继承了Channel,.有一些方法remoteAddress等[可以Debug下]随后，变量b调用了group方法将两个group放入了自己的字段中，用于后期引导使用【dbug下group方法*Set the @link EventLoopGroup for the parent (acceptor)and the child (client).These*&#123;@link EventLoopGroup)&#x27;s are used to handle all the events and IO for &#123;@link ServerChannel&#125;and@link Channel&#x27;s.*/】。(4)然后添加了一个channel,其中参数一个Class对象，引导类将通过这个Class对象反射创建ChannelFactory。然后添加了一些TCP的参数。[说明：Channel的创建在bind方法，可以Debug下bind,会找channel channelFactory.newChannelO);(5)再添加了一个服务器专属的日志处理器handler.(6再添加一个SocketChannel(不是ServerSocketChannel)的handler。.(7)然后绑定端口并阻塞至连接成功。(8)最后main线程阻塞等待关闭.(9)finally块中的代码将在服务器关闭时优雅关闭所有资源 服务器处理器类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */package com.lxg.netty.source.echo;import io.netty.channel.ChannelHandler.Sharable;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;/** * Handler implementation for the echo server. */@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ctx.write(msg); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; // Close the connection when an exception is raised. cause.printStackTrace(); ctx.close(); &#125;&#125; 123说明：1)这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。2)大致讲解了我们的demo源码的作用。后面的debug的时候会详细 2、分析EventLoopGroup的过程 构造器方法： 123public NioEventLoopGroup(int nThreads) &#123; this(nThreads, (Executor)null); &#125; 上面的this(nThreads, (Executor)null);调用构造器（通过alt+d看即可） 123public NioEventLoopGroup(int nThreads, Executor executor) &#123; this(nThreads, executor, SelectorProvider.provider()); &#125; this(nThreads, executor, SelectorProvider.provider());又调用下面构造器 123public NioEventLoopGroup(int nThreads, Executor executor, SelectorProvider selectorProvider) &#123; this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE); &#125; this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);又调用如下构造器 123public NioEventLoopGroup(int nThreads, Executor executor, SelectorProvider selectorProvider, SelectStrategyFactory selectStrategyFactory) &#123; super(nThreads, executor, new Object[]&#123;selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()&#125;); &#125; super(nThreads, executor, new Object[]{selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()});方法的父类是MultithreadEventLoopGroup，构造器为 123protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); &#125; 追踪到源码，真正的构造器是MultithreadEventExecutorGroup类的 分析如下代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*** nThreads:使用的线程数，默认是core*2* executor：执行器，如果传入null，则采用Netty默认的线程工厂和默认的执行器ThreadPerTaskExecutor* chooserFactory：单例 new DefaultEventExecutorChooseFactory()* args:args在创建执行器时传入的固定参数*/protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; checkPositive(nThreads, &quot;nThreads&quot;); if (executor == null) &#123; //如果传入的执行器为空，采用默认的线程工厂和默认的执行器 executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; //创建指定线程数的执行器数组 children = new EventExecutor[nThreads]; //初始化线程数组 for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; //创建new NioEventLoop children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; // TODO: Think about if this is a good exception type throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e); &#125; finally &#123; //如果创建失败，优雅关闭 if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; // Let the caller handle the interruption. Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125; chooser = chooserFactory.newChooser(children); final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); &#125; &#125; &#125;; //为每一个单例线程池添加一个关闭监听器 for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); //将所有的单例线程池添加到一个HashSet中 Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet); &#125; 1234567说明：l)如果executor是null,创建一个默认的ThreadPerTaskExecutor,使用Netty默认的线程工厂。2)根据传入的线程数(CPU*2)创建一个线程池（单例线程池）数组。3)循环填充数组中的元素。如果异常，则关闭所有的单例线程池。4)根据线程选择工厂创建一个线程选择器。5)为每一个单例线程池添加一个关闭监听器。6将所有的单例线程池添加到一个HashSet中。 3、ServerBootstrap创建和构造过程 ServerBootstrap是个空构造器，但是有默认的成员变量 12345678910private static final InternalLogger logger = InternalLoggerFactory.getInstance(ServerBootstrap.class); // The order in which child ChannelOptions are applied is important they may depend on each other for validation // purposes. private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;(); private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();//config对象，会在后面起很大作用 private final ServerBootstrapConfig config = new ServerBootstrapConfig(this); private volatile EventLoopGroup childGroup; private volatile ChannelHandler childHandler; 分析一下ServerBootstrap的基本使用情况 12345678910111213141516ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); &#125; //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(serverHandler); &#125; &#125;); 123456说明：1)链式调用：group方法，将boss和worker传入，boss赋值给parentGroup属性，worker赋值给childGroup属性2)channel方法传入NioServerSocketChannel class对象。会根据这个class创建channel对象。3)option方法传入TCP参数，放在一个LinkedHashMap中。4)handler方法传入一个handler中，这个hanlder只专属于ServerSocketChannel而不是SocketChannelS)childHandler传入一个hanlder,这个handler将会在每个客户端连接的时候调用。供SocketChannel使用 4、绑定端口的分析 服务器就是在这个bind方法里启动完成的bind方法代码，追踪到创建了一个端口对象，并做了一些空判断，核心代码doBind,我们看看 1234public ChannelFuture bind(SocketAddress localAddress) &#123; validate(); return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;)); &#125; doBind源码剖析，核心是两个方法initAndRegister和doBind0 1234567891011121314151617181920212223242526272829303132333435private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it&#x27;s not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125; &#125; 分析说明initAndRegister 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; //说明：channelFactory.newChannel();方法的作用通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel。追踪源码可以得到下面结论 (1)通过NIO的SelectorProvider的openServerSocketChannel方法得到JDK的channel。目的是让Netty包装JDK的channel。(2)创建了一个唯一的Channelld,创建了一个NioMessageUnsafe,用于操作消息，创建了一个DefaultChannelPipeline管道，是个双向链表结构，用于过滤所有的进出的消息。(3)创建了一个NioServerSocketChannelConfig对象，用于对外展示一些配置。 channel = channelFactory.newChannel(); //说明：init初始化这个NioServerSocketChannel具体追踪源码可以得到如下结论 (I)init方法，这是个抽象方法(AbstractBootstrap类的)，由ServerBootstrap实现（可以追一下源码∥setChannelOptions(channel,options,logger);)。(2)设置NioServerSocketChannel的TCP属性。(3)由于LinkedHashMap是非线程安全的，使用同步进行处理。(4)对NioServerSocketChannel的ChannelPipeline添加ChannelInitializer处理器。(5)可以看出，init的方法的核心作用在和ChannelPipeline相关。(6)从NioServerSocketChannel的初始化过程中，我们知道，pipeline是一个双向链表，并且，他本身就初始化了head和tail,这里调用了他的addLast方法，也就是将整个handler插入到tail的前面，因为tail永远会在后面，需要做一些系统的固定工作。 init(channel); &#125; catch (Throwable t) &#123; if (channel != null) &#123; // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;)) channel.unsafe().closeForcibly(); // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t); &#125; ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; // If we are here and the promise is not failed, it&#x27;s one of the following cases: // 1) If we attempted registration from the event loop, the registration has been completed at this point. // i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered. // 2) If we attempted registration from the other thread, the registration request has been successfully // added to the event loop&#x27;s task queue for later execution. // i.e. It&#x27;s safe to attempt bind() or connect() now: // because bind() or connect() will be executed *after* the scheduled registration task is executed // because register(), bind(), and connect() are all bound to the same thread. return regFuture; &#125; 123456说明：l)基本说明：initAndRegister()初始化NioServerSocketChannel通道并注册各个handler,返回一个future2)通过ServerBootstrap的通道工厂反射创建一个NioServerSocketChannel。3)init初始化这个NioServerSocketChannel.4)config().group().register(channel)通过ServerBootstrap的bossGroup注册NioServerSocketChannel.5)最后，返回这个异步执行的占位符即regFuture。 init方法会调用addLast，现在进入addLast方法内查看 12345678910111213141516171819202122232425262728@Override public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123; final AbstractChannelHandlerContext newCtx; synchronized (this) &#123; checkMultiplicity(handler); newCtx = newContext(group, filterName(name, handler), handler); addLast0(newCtx); // If the registered is false it means that the channel was not registered on an eventLoop yet. // In this case we add the context to the pipeline and add a task that will call // ChannelHandler.handlerAdded(...) once the channel is registered. if (!registered) &#123; newCtx.setAddPending(); callHandlerCallbackLater(newCtx, true); return this; &#125; EventExecutor executor = newCtx.executor(); if (!executor.inEventLoop()) &#123; callHandlerAddedInEventLoop(newCtx, executor); return this; &#125; &#125; callHandlerAdded0(newCtx); return this; &#125; 12345678说明：l)addLast方法，在DefaultChannelPipeline类中2)addLast方法这就是pipeline方法的核心3)检杳该handler是否符合标准。4)创建一个AbstractChannelHandlerContext对象，这里说一下，ChannelHandlerContext对象是ChannelHandler和ChannelPipeline之间的关联，每当有ChannelHandler添加到Pipeline中时，都会创建Context,.Context的主要功能是管理他所关联的Handler和同一个Pipeline中的其他Handler之间的交互。S)将Contexl添加到链表中。也就是追加到tail节点的前面。6)最后，同步或者异步或者晚点异步的调用callHandlerAdded0方法 前面说了dobind方法有两个重要的步骤，initAndRegister说完了，现在看看doBind0方法，代码如下： 1234567891011121314151617private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123; // This method is invoked before channelRegistered() is triggered. Give user handlers a chance to set up // the pipeline in its channelRegistered() implementation. channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125; &#125;); &#125; 12说明：1、该方法的参数为initAndRegister的future,NioServerSocketChannel,端口地址，NioServerSocketChannel promise 2、这里就可以根据前面的断点，一直debug 12345678910111213141516171819202122将调用LoggingHandler的invokeBind方法，最后会追到//DefaultChannelPipeline类的bind//然后进入到unsafe.bind方法debug,注意要追踪到 //unsafe.bind,要debug第二圈的时候，才能看到@Overridepublic void bind(ChannelHandlerContext ctx,SocketAddress localAddress,ChannelPromise promise)throws Exception&#123;unsafe.bind(localAddress,promise);&#125;继续追踪AbstractChannel的 public final void bind(final SocketAddress localAddress,final ChannelPromise promise)&#123;//..try//!小红旗可以看到，这里最终的方法就是doBind方法，执行成功后，执行通道的fireChannelActive方法，告诉所有的handler,已经成功绑定。doBind(localAddress);//&#125;catch (Throwable t)&#123;&#125;safeSetFailure(promise,t);closeIfClosed();return;&#125;&#125; 123456783)最终doBind就会追踪到NioServerSocketChannel的doBind,说明Netty底层使用的是Nio@Overrideprotected void doBind(SocketAddress localAddress)throws Exceptionif (PlatformDependent.java Version()&gt;=7)&#123;javaChannel(.bind(localAddress,config.getBacklog();else&#123;javaChannel().socket().bind(localAddress,config.getBacklog();&#125; 回到bind方法(alt+v),最后一步：safeSetSuccess(promise),告诉promise任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，0k了 继续atl+V服务器就回进入到(NioEventLoop类)一个循环代码，进行监听 123456@Overrideprotected void run()for (;;)&#123; try&#123;&#125; Netty启动过程梳理 创建2个 EventLoopGroup 线程池数组。数组默认大小CPU*2，方便chooser选择 线程池时提高性能 BootStrap 将 boss 设置为 group属性，将 worker 设置为 childer 属性 通过 bind 方法启动，内部重要方法为 initAndRegister 和 dobind 方法 initAndRegister 方法会反射创建 NioServerSocketChannel 及其相关的 NIO 的对象， pipeline ， unsafe，同时也为 pipeline 初始了 head 节点和 tail 节点。 在register0 方法成功以后调用在 dobind 方法中调用 doBind0 方法，该方法会 调 用 NioServerSocketChannel 的 doBind 方法对 JDK 的 channel 和端口进行绑定， 完成 Netty 服务器的所有启动，并开始监听连接事件 3、Netty 接受请求过程源码剖析源码剖析目的 服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分 析 Netty 在启动之后是如何接受客户端请求的 在 io.netty.example 包 源码剖析说明： 从之前服务器启动的源码中，我们得知，服务器最终注册了一个 Accept 事件等待 客户端的连接。我们也知道，NioServerSocketChannel 将自己注册到了 boss 单例线 程池（reactor 线程）上，也就是 EventLoop 。 先简单说下EventLoop的逻辑(后面我们详细讲解EventLoop) ü EventLoop 的作用是一个死循环，而这个循环中做3件事情： 有条件的等待 Nio 事件。 处理 Nio 事件。 处理消息队列中的任务。 仍用前面的项目来分析：进入到 NioEventLoop 源码中后，在private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) 方法开始调试 最终我们要分析到AbstractNioChannel 的 doBeginRead 方法， 当到这个方法时， 针对于这个客户端的连接就完成了，接下来就可以监听读事件 源码分析过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273741.断点位置NioEventLoop的如下方法processSelectedKey if((readyOps &amp;(SelectionKey.OP READ | SelectionKey.OP ACCEPT))!=0 readyOps ==0)&#123;unsafe.read();/断点位置&#125;2.执行浏览器http://localhost::8007/客户端发出请求3.从的断点我们可以看到，readyOps是16，也就是Accept事件。说明浏览器的请求已经进来了。 4.这个unsafe是boss线程中NioServerSocketChannel的AbstractNioMessageChannelSNioMessageUnsafe对象。我们进入到AbstractNioMessageChannelSNioMessageUnsafe的read方法中 5.read方法代码并分析：@Overridepublic void read()assert eventLoop().inEventLoop();final ChannelConfig config=config();final ChannelPipeline pipeline=pipeline();final RecvByteBufAllocator.Handle allocHandle unsafe().recvBufAllocHandle();allocHandle.reset(config);boolean closed = false;Throwable exception = null;try try&#123; do&#123; int localRead = doReadMessages(readBuf); if (localRead ==0)&#123; break; &#125; if (localRead &lt;0) closed = true; break; &#125; allocHandle.incMessagesRead(localRead); &#125;while (allocHandle.continueReading());&#125;catch (Throwable t)&#123; exception = t; int size = readBuf.size(); for (int i=0;i&lt;size;i+)&#123; readPending = false; pipeline.fireChannelRead(readBuf.get(i)); readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception !=null)&#123; closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); &#125; if(closed)&#123; inputShutdown = true; if (isOpen())&#123; close(voidPromise()); &#125; &#125; &#125;finally //Check if there is a readPending which was not processed yet. //This could be for two reasons: //The user called Channel.readO or ChannelHandlerContext.read()in channelRead(...)method //The user called Channel.read()or ChannelHandlerContext.read()in channelReadComplete(...)method // //See https://github.com/netty/netty/issues/2254 if (!readPending &amp;&amp;!config.isAutoRead())&#123; removeReadOp(); &#125; &#125;&#125;说明： 1)检查该eventloop线程是否是当前线程。assert eventLoop().inEventLoop() 2)执行doReadMessages方法，并传入一个readBuf变量，这个变量是一个List,也就是容器。 3)循环容器，执行pipeline.fireChannelRead(readBuf..get(①)； 4)doReadMessages是读取boss线程中的NioServerSocketChannel接受到的请求。并把这些请求放进容器,一会我们debug下doReadMessages方法 5)循环遍历容器中的所有请求，调用pipeline的fireChannelRead方法，用于处理这些接受的请求或者其他事件，在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的handler的ChannelRead方法(debug进入) 1234567891011121314151617181920212223242526272829303132333435363738394041424344456.追踪一下doReadMessages方法，就可以看得更清晰protected int doReadMessages(List&lt;Object&gt;buf)throws Exception&#123; SocketChannel ch SocketUtils.accept(javaChannelO); buf.add(new NioSocketChannel(this,ch)); return 1;&#125;说明：l)通过工具类，调用NioServerSocketChannel内部封装的serverSocketChannel的accept方法，这是Nio做法。2)获取到一个JDK的SocketChannel,然后，使用NioSocketChannel进行封装。最后添加到容器中3)这样容器buf中就有了NioSocketChannel[如果有兴趣可以追一下NioSocketChannel是如何创建的，我就不追了]7.回到read方法，继续分析循环执行pipeline.fireChannelRead方法l)前面分析doReadMessages方法的作用是通过ServerSocket的accept方法获取到Tcp连接，然后封装成Netty的NioSocketChannel对象。最后添加到容器中2)在read方法中，循环调用ServerSocket的pipeline的fireChannelRead方法，开始执行管道中的handler的ChannelRead方法(debug进入)3)经过dubug(多次)，可以看到会反复执行多个handler的ChannelRead,我们知道，pipeline里面有4个handler ，分别是Head,LoggingHandler,ServerBootstrapAcceptor,Tail.4)我们重点看看ServerBootstrapAcceptor。debug之后，断点会进入到ServerBootstrapAcceptor中来。我们来看看ServerBootstrapAcceptor的channelRead方法（要多次debug才可以）5)channelRead方法public void channelRead(ChannelHandlerContext ctx,Object msg)&#123; final Channel child =(Channel)msg; child.pipeline().addLast(childHandler); setChannelOptions(child,childOptions,logger); for (Entry&lt;AttributeKey&lt;?&gt;,Object&gt;e:childAttrs)&#123; child.attr((AttributeKey&lt;Object)e.getKey().set(e.getValue());ty&#123;//将客户端连接注册到worker线程池 childGroup.register(child).addListener(new ChannelFutureListener()&#123; @Override public void operationComplete(ChannelFuture future)throws Exception&#123; if(!future.isSuccess()&#123; forceClose(child,future.cause(); &#125; &#125;);&#125;catch (Throwable t)&#123; forceClose(child,t); &#125;&#125;说明： l)msg强转成Channel,实际上就是NioSocketChannel。 2)添加NioSocketChannel的pipeline的handler,就是我们main方法里面设置的childHandler方法里的。 3)设置NioSocketChannel的各种属性。 4)将该NioSocketChannel注册到childGroup中的一个EventLoop上，并添加一个监听器。 5)这个childGroup就是我们main方法创建的数组workerGroup. 8、进入register方法查看（步步追踪到） 123456789101112131415@Overridepublic final void register(EventLoop eventLoop,final ChannelPromise promise)AbstractChannel.this.eventLoop = eventLoop;if (eventLoop.inEventLoop())&#123;register0(promise);elseeventLoop.execute(new Runnable()@Overridepublic void run()&#123;register0(promise),//进入到这里 &#125; &#125;); &#125;&#125;继续进入到下面方法，执行管道中可能存在的任务、这里我们就不追了 1234567891011121314159.最终会调用doBeginRead方法，也就是AbstractNioChannel类的方法@Overrideprotected void doBeginRead()throws Exception&#123;//Channel.read()or ChannelHandlerContext.read()was called final SelectionKey selectionKey this.selectionKey;// if (!selectionKey.is Valid()&#123; return; &#125; readPending = true; final int interestOps = selectionKey.interestOps(); if ((interestOps &amp; readInterestOp)==0)&#123; selectionKey.interestOps(interestOps | readInterestOp); &#125;&#125; 12310.这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在doBeginRead(需要先放过该断点，然后浏览器请求，才能看到效果)11.执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了 Netty接受请求过程梳理总体流程：接受连接—–&gt;创建一个新的NioSocketChannel———–&gt;注册到一个 worker EventLoop 上——–&gt; 注册selecot Read 事件。 服务器轮询 Accept 事件，获取事件后调用 unsafe 的 read 方法，这个 unsafe 是 ServerSocket 的内部类，该方 法内部由2部分组成 doReadMessages 用于创建 NioSocketChannel 对象，该对象包装 JDK 的 Nio Channel 客户端。该方法会像创建 ServerSocketChanel 类似创建相关的 pipeline ， unsafe，config 随后执行 执行 pipeline.fireChannelRead 方法，并将自己绑定到一个 chooser 选择器选择的 workerGroup 中的 一个 EventLoop。并且注册一个0，表示注册成功，但并没有注册读（1）事件 4、Pipeline Handler HandlerContext创建源码剖析源码剖析目的Netty 中的 ChannelPipeline 、 ChannelHandler 和 ChannelHandlerContext 是非常 核心的组件, 我们从源码来分析Netty 是如何设计这三个核心组件的，并分析是如何创建 和协调工作的. 源码剖析说明 ： 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析 源码剖析： 123456781. ChannelPipeline | ChannelHandler | ChannelHandlerContext 介绍1.1 三者关系1) 每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。2) 每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline）3) 每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context）4) 他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称handler） 上图中：ChannelSocket 和 ChannelPipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链 表，Context 只是对 Handler 的封装。 当一个请求进来的时候，会进入 Socket 对应的 pipeline，并经过 pipeline 所有的 handler，对，就是设计模式 中的过滤器模式。 121.2 ChannelPipeline 作用及设计1) pipeline 的接口设计 部分源码： 12可以看到该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表， 看看他的几个代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，类似是一个 LinkedList。同时，也能返回 channel（也就是 socket）1) 在 pipeline 的接口文档上，提供了一幅图 123456789101112对上图的解释说明：* 这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户控制事件如何处理以及 handler 在 pipeline 中如何交互。* 上图描述了一个典型的 handler 在 pipeline 中处理 I/O 事件的方式，IO 事件由 inboundHandler 或者outBoundHandler 处理，并通过调用 ChannelHandlerContext.fireChannelRead 方法转发给其最近的处理程序 * 入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 I / O 线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer) 获取。* 通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器 - 将二进制数据转换为 Java 对象。协议编码器 - 将 Java 对象转换为二进制数据。业务逻辑处理程序 - 执行实际业务逻辑（例如数据库访问）* 你的业务程序不能将线程阻塞，会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如：// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池pipeline.addLast（group，“handler”，new MyBusinessLogicHandler（））; 1234567891011121314151617181.3 ChannelHandler 作用及设计1) 源码public interface ChannelHandler &#123;//当把 ChannelHandler 添加到 pipeline 时被调用void handlerAdded(ChannelHandlerContext ctx) throws Exception;//当从 pipeline 中移除时调用void handlerRemoved(ChannelHandlerContext ctx) throws Exception;// 当处理过程中在 pipeline 发生异常时调用@Deprecatedvoid exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;&#125;2) ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承ChannelHandler ChannelInboundHandler 入站事件接口 12345* channelActive 用于当 Channel 处于活动状态时被调用；* channelRead 当从 Channel 读取数据时被调用等等方法。* 程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，Netty 会回调对应的方法。 ChannelOutboundHandler 出站事件接口 123* bind 方法，当请求将 Channel 绑定到本地地址时调用* close 方法，当请求关闭 Channel 时调用等等* 出站操作都是一些连接和写出数据类似的方法。 ChannelDuplexHandler 处理出站和入站事件 ChannelDuplexHandler 间接实现了入站接口并直接实现了出站接口。 是一个通用的能够同时处理入站事件和出站事件的类。 1.4 ChannelHandlerContext 作用及设计 ChannelHandlerContext UML 图 123ChannelHandlerContext 继承了出站方法调用接口和入站方法调用接口1) ChannelOutboundInvoker 和 ChannelInboundInvoker 部分源码 这两个 invoker 就是针对入站或出站方法来的，就是在 入站或出站 handler 的外层再包装一层，达到在方法前 后拦截并做一些特定操作的目的 ChannelHandlerContext 部分源码 12345* ChannelHandlerContext 不仅仅继承了他们两个的方法，同时也定义了一些自己的方法* 这些方法能够获取 Context 上下文环境中对应的比如 channel，executor，handler ，pipeline，内存分配器，关联的 handler 是否被删除。* Context 就是包装了 handler 相关的一切，以方便 Context 可以在 pipeline 方便的操作 handler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596972. ChannelPipeline | ChannelHandler | ChannelHandlerContext 创建过程分为 3 个步骤来看创建的过程：* 任何一个 ChannelSocket 创建的同时都会创建 一个 pipeline。* 当用户或系统内部调用 pipeline 的 add*** 方法添加 handler 时，都会创建一个包装这 handler 的 Context。* 这些 Context 在 pipeline 中组成了双向链表。2.1 Socket 创建的时候创建 pipeline在 SocketChannel 的抽象父类 AbstractChannel 的构造方法中protected AbstractChannel(Channel parent) &#123;this.parent = parent; //断点测试id = newId();unsafe = newUnsafe();pipeline = newChannelPipeline();&#125;Debug 一下, 可以看到代码会执行到这里, 然后继续追踪到 protected DefaultChannelPipeline(Channel channel) &#123;this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);succeededFuture = new SucceededChannelFuture(channel, null);voidPromise = new VoidChannelPromise(channel, true);tail = new TailContext(this);head = new HeadContext(this);head.next = tail;tail.prev = head;&#125;说明：1）将 channel 赋值给 channel 字段，用于 pipeline 操作 channel。2）创建一个 future 和 promise，用于异步回调使用。3）创建一个 inbound 的 tailContext，创建一个既是 inbound 类型又是 outbound 类型的 headContext.4）最后，将两个 Context 互相连接，形成双向链表。5）tailContext 和 HeadContext 非常的重要，所有 pipeline 中的事件都会流经他们， 2.2 在 add** 添加处理器的时候创建 Context**看下 DefaultChannelPipeline 的 addLast 方法如何创建的 Context，代码如下@Overridepublic final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) &#123;if (handlers == null) &#123; //断点throw new NullPointerException(&quot;handlers&quot;);&#125;for (ChannelHandler h: handlers) &#123;if (h == null) &#123;break;&#125;addLast(executor, null, h);&#125;return this;&#125;继续 Debugpublic final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;final AbstractChannelHandlerContext newCtx;synchronized (this) &#123;checkMultiplicity(handler);newCtx = newContext(group, filterName(name, handler), handler);addLast0(newCtx);// If the registered is false it means that the channel was not registered on an eventloop yet.// In this case we add the context to the pipeline and add a task that will call// ChannelHandler.handlerAdded(...) once the channel is registered.if (!registered) &#123;newCtx.setAddPending();callHandlerCallbackLater(newCtx, true);return this;&#125;EventExecutor executor = newCtx.executor();if (!executor.inEventLoop()) &#123;newCtx.setAddPending();executor.execute(new Runnable() &#123;@Overridepublic void run() &#123;callHandlerAdded0(newCtx);&#125;&#125;);return this;&#125;&#125;callHandlerAdded0(newCtx);return this;&#125;说明1) pipeline 添加 handler，参数是线程池，name 是 null， handler 是我们或者系统传入的 handler。Netty 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：2) 检查这个 handler 实例是否是共享的，如果不是，并且已经被别的 pipeline 使用了，则抛出异常。3) 调用 newContext(group, filterName(name, handler), handler) 方法，创建一个 Context。从这里可以看出来了，每次添加一个 handler 都会创建一个关联 Context。4) 调用 addLast 方法，将 Context 追加到链表中。5) 如果这个通道还没有注册到 selecor 上，就将这个 Context 添加到这个 pipeline 的待办任务中。当注册好了以后，就会调用 callHandlerAdded0 方法（默认是什么都不做，用户可以实现这个方法）。6) 到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成最初的链表。tail是入站 inbound 类型的 handler， head 既是 inbound 也是 outbound 类型的 handler。在调用 pipeline 的 addLast方法的时候，会根据给定的 handler 创建一个 Context，然后，将这个 Context 插入到链表的尾端（tail 前面）。到此就 OK 了 Pipeline Handler HandlerContext创建过程梳理 每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建 tail 节点和 head 节点，形成最初的链表。 在调用 pipeline 的 addLast 方法的时候，会根据给定的 handler 创建一个 Context， 然后，将这个 Context 插入到链表的尾端（tail 前面）。 Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表 入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开 5、ChannelPipeline 调度 handler 的源码剖析源码剖析目的 当一个请求进来的时候，ChannelPipeline 是如何调用内部的这些 handler 的呢？ 我们一起来分析下。 首先，当一个请求进来的时候，会第一个调用 pipeline 的 相关方法，如果是入站 事件，这些方法由 fire 开头，表示开始管道的流动。让后面的 handler 继续处理 源码剖析说明 ： 当浏览器输入 http://localhost:8007。可以看到会执行handler 在Debug时，可以将断点下在 DefaultChannelPipeline 类的 123public final ChannelPipeline fireChannelActive() &#123; AbstractChannelHandlerContext.invokeChannelActive(head);//断点 return this; &#125; 源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041053. DefaultChannelPipeline 是如何实现这些 fire 方法的3.1 DefaultChannelPipeline 源码public class DefaultChannelPipeline implements ChannelPipeline &#123;@Overridepublic final ChannelPipeline fireChannelActive() &#123;AbstractChannelHandlerContext.invokeChannelActive(head);return this;&#125;@Overridepublic final ChannelPipeline fireChannelInactive() &#123;AbstractChannelHandlerContext.invokeChannelInactive(head);return this;&#125;@Overridepublic final ChannelPipeline fireExceptionCaught(Throwable cause) &#123;AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);return this;&#125;@Overridepublic final ChannelPipeline fireUserEventTriggered(Object event) &#123;AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);return this;&#125;@Overridepublic final ChannelPipeline fireChannelRead(Object msg) &#123;AbstractChannelHandlerContext.invokeChannelRead(head, msg);return this;&#125;@Overridepublic final ChannelPipeline fireChannelReadComplete() &#123;AbstractChannelHandlerContext.invokeChannelReadComplete(head);return this;&#125;@Overridepublic final ChannelPipeline fireChannelWritabilityChanged() &#123;AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);return this;&#125;&#125;说明：可以看出来，这些方法都是 inbound 的方法，也就是入站事件，调用静态方法传入的也是 inbound 的类型 headhandler。这些静态方法则会调用 head 的 ChannelInboundInvoker 接口的方法，再然后调用 handler 的真正方法3.2 再看下 piepline 的 outbound 的 fire 方法实现源码public class DefaultChannelPipeline implements ChannelPipeline &#123;@Overridepublic final ChannelFuture bind(SocketAddress localAddress) &#123;return tail.bind(localAddress);&#125;@Overridepublic final ChannelFuture connect(SocketAddress remoteAddress) &#123;return tail.connect(remoteAddress);&#125;@Overridepublic final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) &#123;return tail.connect(remoteAddress, localAddress);&#125;@Overridepublic final ChannelFuture disconnect() &#123;return tail.disconnect();&#125;@Overridepublic final ChannelFuture close() &#123;return tail.close();&#125;@Overridepublic final ChannelFuture deregister() &#123;return tail.deregister();&#125;@Overridepublic final ChannelPipeline flush() &#123;tail.flush();return this;&#125;@Overridepublic final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;return tail.bind(localAddress, promise);&#125;@Overridepublic final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;return tail.connect(remoteAddress, promise);&#125;@Overridepublic final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) &#123;return tail.connect(remoteAddress, localAddress, promise);&#125;@Overridepublic final ChannelFuture disconnect(ChannelPromise promise) &#123;return tail.disconnect(promise);&#125;&#125;说明：1) 这些都是出站的实现，但是调用的是 outbound 类型的 tail handler 来进行处理，因为这些都是 outbound 事件。2) 出站是 tail 开始，入站从 head 开始。因为出站是从内部向外面写，从 tail 开始，能够让前面的 handler 进行处理，防止 handler 被遗漏，比如编码。反之，入站当然是从 head 往内部输入，让后面的 handler 能够处理这些输入的数据。比如解码。因此虽然 head 也实现了 outbound 接口，但不是从 head 开始执行出站任务4. 关于如何调度，用一张图来表示: 12345说明：1) pipeline 首先会调用 Context 的静态方法 fireXXX，并传入 Context2) 然后，静态方法调用 Context 的 invoker 方法，而 invoker 方法内部会调用该 Context 所包含的Handler 的真正的 XXX 方法，调用结束后，如果还需要继续向后传递，就调用 Context 的 fireXXX2 方法，循环往复。 ChannelPipeline 调度 handler 梳理 Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始。 而节点中间的传递通过 AbstractChannelHandlerContext 类内部的 fire 系列方法，找 到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对handler 的调度 6、Netty 心跳(heartbeat)服务源码剖析源码剖析目的Netty 作为一个网络框架，提供了诸多功能，比如编码解码等，Netty 还提供了非常重 要的一个服务—–心跳机制heartbeat。通过心跳检查对方是否有效，这是 RPC 框架 中是必不可少的功能。下面我们分析一下Netty内部 心跳服务源码实现 源码剖析说明： Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 三 个Handler 检测连接的有效性，重点分析 IdleStateHandler . 如图 源码剖析： Netty 提供的心跳介绍 Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 三个 Handler 检测连接的有效性。 如图 ReadTimeout 事件和 WriteTimeout 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以 下，我们重点看 IdleStateHandler。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849506. IdleStateHandler 分析6.1 4 个属性private final boolean observeOutput; //是否考虑出站时较慢的情况。默认值是 falseprivate final long readerIdleTimeNanos;//读事件空闲时间，0 则禁用事件private final long writerIdleTimeNanos;//写事件空闲时间，0 则禁用事件private final long allIdleTimeNanos;//读或写空闲时间，0 则禁用事件6.2 handlerAdded 方法 @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; if (ctx.channel().isActive() &amp;&amp; ctx.channel().isRegistered()) &#123; // channelActive() event has been fired already, which means this.channelActive() will // not be invoked. We have to initialize here instead. initialize(ctx); &#125; else &#123; // channelActive() event has not been fired yet. this.channelActive() will be invoked // and initialization will occur there. &#125; &#125;当该 handler 被添加到 pipeline 中时，则调用 initialize 方法private void initialize(ChannelHandlerContext ctx) &#123;// Avoid the case where destroy() is called before scheduling timeouts.// See: https://github.com/netty/netty/issues/143switch (state) &#123;case 1:case 2:return;&#125;state = 1;initOutputChanged(ctx);lastReadTime = lastWriteTime = ticksInNanos();if (readerIdleTimeNanos &gt; 0) &#123;//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中readerIdleTimeout = schedule(ctx, new ReaderIdleTimeoutTask(ctx),readerIdleTimeNanos, TimeUnit.NANOSECONDS);&#125;if (writerIdleTimeNanos &gt; 0) &#123;writerIdleTimeout = schedule(ctx, new WriterIdleTimeoutTask(ctx),writerIdleTimeNanos, TimeUnit.NANOSECONDS);&#125;if (allIdleTimeNanos &gt; 0) &#123;allIdleTimeout = schedule(ctx, new AllIdleTimeoutTask(ctx),allIdleTimeNanos, TimeUnit.NANOSECONDS);&#125;&#125;只要给定的参数大于 0，就创建一个定时任务，每个事件都创建。同时，将 state 状态设置为 1，防止重复初始化。调用 initOutputChanged 方法，初始化 “监控出站数据属性”。 6.3 该类内部的 3 个定时任务类 123456789101112131415161718191) 这 3 个定时任务分别对应 读，写，读或者写 事件。共有一个父类(AbstractIdleTask)。这个父类提供了一个模板方法 private abstract static class AbstractIdleTask implements Runnable &#123;private final ChannelHandlerContext ctx;AbstractIdleTask(ChannelHandlerContext ctx) &#123;this.ctx = ctx;&#125;@Overridepublic void run() &#123;if (!ctx.channel().isOpen()) &#123;return;&#125;run(ctx);&#125;protected abstract void run(ChannelHandlerContext ctx);&#125;说明： 当通道关闭了，就不执行任务了。反之，执行子类的 run 方法 12345678910111213141516171819202122232425262728293031323334353637383940417. 读事件的 run 方法（即 ReaderIdleTimeoutTask 的 run 方法）分析1) 代码及其说明 @Overrideprotected void run(ChannelHandlerContext ctx) &#123;long nextDelay = readerIdleTimeNanos;//读操作超时时间if (!reading) &#123; //当前是否在读操作 //不是 //计算设置的超时时间-距离上次读操作时间间隔nextDelay -= ticksInNanos() - lastReadTime;&#125; //计算结果小于0，说明已经超时if (nextDelay &lt;= 0) &#123;// Reader is idle - set a new timeout and notify the callback.// 用于取消任务 promisereaderIdleTimeout = schedule(ctx, this, readerIdleTimeNanos, TimeUnit.NANOSECONDS);boolean first = firstReaderIdleEvent;firstReaderIdleEvent = false;try &#123;//再次提交任务IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);//触发用户 handler usechannelIdle(ctx, event);&#125; catch (Throwable t) &#123;ctx.fireExceptionCaught(t);&#125; //计算结果大于0，说明没超时&#125; else &#123;// Read occurred before the timeout - set a new timeout with shorter delay.readerIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);&#125;&#125;说明：1) 得到用户设置的超时时间。2) 如果读取操作结束了（执行了 channelReadComplete 方法设置） ，就用当前时间减去给定时间和最后一次读（执操作的时间行了 channelReadComplete 方法设置），如果小于 0，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。3) 触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 promise 对象，用于做取消操作。然后，设置 first 属性为 false ，表示，下一次读取不再是第一次了，这个属性在 channelRead 方法会被改成 true。4) 创建一个 IdleStateEvent 类型的写事件对象，将此对象传递给用户的 UserEventTriggered 方法。完成触发事件的操作。5) 总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 UserEventTriggered 方法。//前面介绍 IdleStateHandler 说过,可以看一下 1234567891011121314151617181920212223242526272829308. 写事件的 run 方法(即 WriterIdleTimeoutTask 的 run 方法)分析1) run 代码和分析@Overrideprotected void run(ChannelHandlerContext ctx) &#123;long lastWriteTime = IdleStateHandler.this.lastWriteTime;long nextDelay = writerIdleTimeNanos - (ticksInNanos() - lastWriteTime);if (nextDelay &lt;= 0) &#123;// Writer is idle - set a new timeout and notify the callback.writerIdleTimeout = schedule(ctx, this, writerIdleTimeNanos, TimeUnit.NANOSECONDS);boolean first = firstWriterIdleEvent;firstWriterIdleEvent = false;try &#123;if (hasOutputChanged(ctx, first)) &#123;return;&#125;IdleStateEvent event = newIdleStateEvent(IdleState.WRITER_IDLE, first);channelIdle(ctx, event);&#125; catch (Throwable t) &#123;ctx.fireExceptionCaught(t);&#125;&#125; else &#123;// Write occurred before the timeout - set a new timeout with shorter delay.writerIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);&#125;&#125;说明：写任务的 run 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对 出站较慢数据的判断hasOutputChanged 1234567891011121314151617181920212223242526272829303132333435363738399. 所有事件的 run 方法(即 AllIdleTimeoutTask 的 run 方法)分析代码分析@Overrideprotected void run(ChannelHandlerContext ctx) &#123;long nextDelay = allIdleTimeNanos;if (!reading) &#123;nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);&#125;if (nextDelay &lt;= 0) &#123;// Both reader and writer are idle - set a new timeout and// notify the callback.allIdleTimeout = schedule(ctx, this, allIdleTimeNanos, TimeUnit.NANOSECONDS);boolean first = firstAllIdleEvent;firstAllIdleEvent = false;try &#123;if (hasOutputChanged(ctx, first)) &#123;return;&#125;IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, first);channelIdle(ctx, event);&#125; catch (Throwable t) &#123;ctx.fireExceptionCaught(t);&#125;&#125; else &#123;// Either read or write occurred before the timeout - set a new// timeout with shorter delay.allIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);&#125;&#125;说明：1) 表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：2) 需要大家注意的地方是long nextDelay = allIdleTimeNanos;if (!reading) &#123;// 当前时间减去 最后一次写或读 的时间 ，若大于 0，说明超时了nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);&#125;3) 这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。 1234567891010. 小结 Netty 的心跳机制1) IdleStateHandler 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 handler 的 userEventTriggered 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。2) IdleStateHandler 的实现基于 EventLoop 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。3) 内部有 3 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。4) 同时，IdleStateHandler 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。Netty 通过构造方法中的 observeOutput 属性来决定是否对出站缓冲区的情况进行判断。5) 如果出站缓慢，Netty 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 OOM , OOM 比空闲的问题更大。6) 所以，当你的应用出现了内存溢出，OOM 之类，并且写空闲极少发生（使用了 observeOutput 为 true），那么就需要注意是不是数据出站速度过慢。7) 还有一个注意的地方：就是 ReadTimeoutHandler ，它继承自 IdleStateHandler，当触发读空闲事件的时候，就触发 ctx.fireExceptionCaught 方法，并传入一个 ReadTimeoutException，然后关闭 Socket。8) 而 WriteTimeoutHandler 的实现不是基于IdleStateHandler 的，他的原理是，当调用 write 方法的时候，会创建一个定时任务，任务内容是根据传入的 promise 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 promise 的 isDone 方法返回 false，表明还没有写完，说明超时了，则抛出异常。当 write方法完成后，会打断定时任务。 7、Netty 核心组件 EventLoop 源码剖析源码剖析目的Echo第一行代码就是 ：EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1); 下面分析其最核心的组件 EventLoop。 源码剖析源码剖析： EventLoop 介绍1.1 首先看看 NioEventLoop 的继承图 12345说明重点：1) ScheduledExecutorService 接口表示是一个定时任务接口，EventLoop 可以接受定时任务。2) EventLoop 接口：Netty 接口文档说明该接口作用：一旦 Channel 注册了，就处理该 Channel 对应的所有I/O 操作。3) SingleThreadEventExecutor 表示这是一个单个线程的线程池4) EventLoop 是一个单例的线程池，里面含有一个死循环的线程不断的做着 3 件事情：监听端口，处理端口事件，处理队列事件。每个 EventLoop 都可以绑定多个 Channel，而每个 Channel 始终只能由一个 EventLoop 来处理 NioEventLoop 的使用 - execute 方法 2.1 execute 源码剖析 1234567891011121314151617181920212223242526272829在EventLoop 的 使 用 ， 一 般 就 是SingleThreadEventExecutor 类中)@Overridepublic void execute(Runnable task) &#123;if (task == null) &#123;throw new NullPointerException(&quot;task&quot;);&#125;boolean inEventLoop = inEventLoop();if (inEventLoop) &#123;addTask(task);&#125; else &#123;startThread();addTask(task);if (isShutdown() &amp;&amp; removeTask(task)) &#123;reject();&#125;&#125;if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;wakeup(inEventLoop);&#125;&#125;说明:1) 首先判断该 EventLoop 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。2) 如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。3) 如果 addTaskWakesUp 是 false，并且任务不是 NonWakeupRunnable 类型的，就尝试唤醒 selector。这个时候，阻塞在 selecor 的线程就会立即返回4) 可以下断点来追踪 123456789101112131415162.2 我们 debug addTask 和 offerTask 方法源码protected void addTask(Runnable task) &#123;if (task == null) &#123;throw new NullPointerException(&quot;task&quot;);&#125;if (!offerTask(task)) &#123;reject(task);&#125;&#125;final boolean offerTask(Runnable task) &#123;if (isShutdown()) &#123;reject();&#125;return taskQueue.offer(task);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465663. NioEventLoop 的父类 SingleThreadEventExecutor 的 startThread 方法3.1 当执行 execute 方法的时候，如果当前线程不是 EventLoop 所属线程，则尝试启动线程，也就是 startThread 方法，dubug 代码如下： private void startThread() &#123;if (state == ST_NOT_STARTED) &#123;if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;try &#123;doStartThread();&#125; catch (Throwable cause) &#123;STATE_UPDATER.set(this, ST_NOT_STARTED);PlatformDependent.throwException(cause);&#125;&#125;&#125;&#125;说明:该方法首先判断是否启动过了，保证 EventLoop 只有一个线程，如果没有启动过，则尝试使用 compareAndSet 将 state 状态改为 ST_STARTED，也就是已启动。然后调用 doStartThread 方法。如果失败，则进行回滚看下 doStartThread 方法 private void doStartThread() &#123;executor.execute(new Runnable() &#123;@Overridepublic void run() &#123;boolean success = false;updateLastExecutionTime();try &#123;SingleThreadEventExecutor.this.run();success = true;&#125; finally &#123;for (;;) &#123;int oldState = state;if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123;break;&#125;&#125;try &#123;for (;;) &#123;if (confirmShutdown()) &#123;break;&#125;&#125;&#125; finally &#123;try &#123;cleanup();&#125; finally &#123;STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);threadLock.release();terminationFuture.setSuccess(null);&#125;&#125;&#125;&#125;&#125;);&#125;说明：1) 首先调用 executor 的 execute 方法，这个 executor 就是在创建 Event LoopGroup 的时候创建的ThreadPerTaskExecutor 类。该 execute 方法会将 Runnable 包装成 Netty 的 FastThreadLocalThread。2) 任务中，首先判断线程中断状态，然后设置最后一次的执行时间。3) 执行当前 NioEventLoop 的 run 方法，注意：这个方法是个死循环，是整个 EventLoop 的核心4) 在 finally 块中，使用 CAS 不断修改 state 状态，改成 ST_SHUTTING_DOWN。也就是当线程 Loop 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 break。然后，执行 cleanup 操作，更新状态为5) ST_TERMINATED，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 terminationFuture 方法。6) 其实最核心的就是 Event Loop 自身的 run 方法。再继续深入 run 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481494. EventLoop 中的 Loop 是靠 run 实现的, 我们分析下 run 方法(该方法在 NioEventLoop)@Overrideprotected void run() &#123;for (;;) &#123;try &#123;switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;case SelectStrategy.CONTINUE:continue;case SelectStrategy.SELECT:select(wakenUp.getAndSet(false));if (wakenUp.get()) &#123;selector.wakeup();&#125;default:&#125;cancelledKeys = 0;needsToSelectAgain = false;final int ioRatio = this.ioRatio;if (ioRatio == 100) &#123;try &#123;processSelectedKeys();&#125; finally &#123;// Ensure we always run tasks.runAllTasks();&#125;&#125; else &#123;final long ioStartTime = System.nanoTime();try &#123;processSelectedKeys();&#125; finally &#123;// Ensure we always run tasks.final long ioTime = System.nanoTime() - ioStartTime;runAllTasks(ioTime * (100 - ioRatio) / ioRatio);&#125;&#125;&#125; catch (Throwable t) &#123;handleLoopException(t);&#125;// Always handle shutdown even if the loop processing threw an exception.try &#123;if (isShuttingDown()) &#123;closeAll();if (confirmShutdown()) &#123;return;&#125;&#125;&#125; catch (Throwable t) &#123;handleLoopException(t);&#125;&#125;&#125;说明:1) 从上面的步骤可以看出，整个 run 方法做了 3 件事情： select 获取感兴趣的事件。 processSelectedKeys 处理事件。 runAllTasks 执行队列中的任务。2) 上面的三个方法，我们就追一下 select 方法(体现非阻塞)核心 select 方法解析private void select(boolean oldWakenUp) throws IOException &#123;Selector selector = this.selector;try &#123;int selectCnt = 0;long currentTimeNanos = System.nanoTime();long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);for (;;) &#123;long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;if (timeoutMillis &lt;= 0) &#123;if (selectCnt == 0) &#123;selector.selectNow();selectCnt = 1;&#125;break;&#125;// If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call// Selector#wakeup. So we need to check task queue again before executing select operation.// If we don&#x27;t, the task might be pended until select operation was timed out.// It might be pended until idle timeout if IdleStateHandler existed in pipeline.if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;selector.selectNow();selectCnt = 1;break;&#125;int selectedKeys = selector.select(timeoutMillis);//否则阻塞给定时间，默认一秒selectCnt ++;// 如果 1 秒后返回，有返回值 || select 被用户唤醒 || 任务队列有任务 || 有定时任务即将被执行； 则跳出循环if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;// - Selected something,// - waken up by user, or// - the task queue has a pending task.// - a scheduled task is ready for processingbreak;&#125;if (Thread.interrupted()) &#123;// Thread was interrupted so reset selected keys and break so we not run into a busy loop.// As this is most likely a bug in the handler of the user or it&#x27;s client library we will// also log it.//// See https://github.com/netty/netty/issues/2426if (logger.isDebugEnabled()) &#123;logger.debug(&quot;Selector.select() returned prematurely because &quot; +&quot;Thread.currentThread().interrupt() was called. Use &quot; +&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;);&#125;selectCnt = 1;break;&#125;long time = System.nanoTime();if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;// timeoutMillis elapsed without anything selected.selectCnt = 1;&#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;// The selector returned prematurely many times in a row.// Rebuild the selector to work around the problem.logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);rebuildSelector();selector = this.selector;// Select again to populate selectedKeys.selector.selectNow();selectCnt = 1;break;&#125;currentTimeNanos = time;&#125;if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;if (logger.isDebugEnabled()) &#123;logger.debug(&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;,selectCnt - 1, selector);&#125;&#125;&#125; catch (CancelledKeyException e) &#123;if (logger.isDebugEnabled()) &#123;logger.debug(CancelledKeyException.class.getSimpleName() + &quot; raised by a Selector &#123;&#125; - JDKbug?&quot;,selector, e);&#125;// Harmless exception - log anyway&#125;&#125;说明：调用 selector 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 0.5秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，唤醒 selecor，防止 selecotr 阻塞时间过长 1234567895. EventLoop 作为 Netty 的核心的运行机制 小结1) 每次执行 ececute 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 run 方法，而 run 方法是整个 EventLoop 的核心，就像 EventLoop 的名字一样，Loop Loop ，不停的 Loop ，Loop 做什么呢？做 3 件事情。 调用 selector 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 0.5秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，唤醒 selecor，防止 selecotr 阻塞时间过长。 当 selector 返回的时候，回调用 processSelectedKeys 方法对 selectKey 进行处理。 当 processSelectedKeys 方法执行结束后，则按照 ioRatio 的比例执行 runAllTasks 方法，默认是 IO 任务时间和非 IO 任务时间是相同的，你也可以根据你的应用特点进行调优 。比如 非 IO 任务比较多，那么你就将ioRatio 调小一点，这样非 IO 任务就能执行的长一点。防止队列积攒过多的任务 8、handler 中加入线程池和Context 中添加线程池的源码剖析源码剖析目的 在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。 而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲， 可以有2种方式，而且这2种方式实现的区别也蛮大的。 处理耗时业务的第一种方式—handler 中加入线程池 处理耗时业务的第二种方式—Context 中添加线程池 我们就来分析下两种方式 源码剖析说明： 演示两种方式的实现，以及从源码来追踪两种方式执行流程 源码剖析： 123456789101112131415161718192021222324252627282930313233343536373839404111. 处理耗时业务的第一种方式--handler 种加入线程池11.1 对前面的 Netty demo 源码进行修改，在 EchoServerHandler 的 channelRead 方法进行异步@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws UnsupportedEncodingException,InterruptedException &#123;final Object msgCop = msg;final ChannelHandlerContext cxtCop = ctx;group.submit(new Callable&lt;Object&gt;() &#123;@Overridepublic Object call() throws Exception &#123;ByteBuf buf = (ByteBuf) msgCop;byte[] req = new byte[buf.readableBytes()];buf.readBytes(req);String body = new String(req, &quot;UTF-8&quot;);Thread.sleep(10*1000);System.err.println(body + &quot; &quot; + Thread.currentThread().getName());String reqString = &quot;Hello i am server~~~&quot;;ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());cxtCop.writeAndFlush(resp);return null;&#125;&#125;);System.out.println(&quot;go on ..&quot;);&#125;@Overridepublic void channelReadComplete(ChannelHandlerContext ctx) &#123;ctx.flush();&#125;@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;// Close the connection when an exception is raised.cause.printStackTrace();ctx.close();&#125;&#125;说明：1) 在 channelRead 方法，模拟了一个耗时 10 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池group中，这样，就不会阻塞 Netty 的 IO 线程。 11.2 这样处理之后，整个程序的逻辑如图 1234567说明：1) 解释一下上图，当 IO 线程轮询到一个 socket 事件，然后，IO 线程开始处理，当走到耗时 handler 的时候，将耗时任务交给业务线程池。2) 当耗时任务执行完毕再执行 pipeline write 方法的时候 ，(代码中使用的是 context 的 write 方法，上图画的是执行 pipeline 方法, 是一个意思)会将任务这个任务交给 IO 线程11.3 write 方法的源码(在 AbstractChannelHandlerContext 类) 123456789101112131415161718192021222324252627282911.3 write 方法的源码(在 AbstractChannelHandlerContext 类)private void write(Object msg, boolean flush, ChannelPromise promise) &#123;AbstractChannelHandlerContext next = findContextOutbound();final Object m = pipeline.touch(msg, next);EventExecutor executor = next.executor();if (executor.inEventLoop()) &#123;if (flush) &#123;next.invokeWriteAndFlush(m, promise);&#125; else &#123;next.invokeWrite(m, promise);&#125;&#125; else &#123;AbstractWriteTask task;if (flush) &#123;task = WriteAndFlushTask.newInstance(next, m, promise);&#125; else &#123;task = WriteTask.newInstance(next, m, promise);&#125;safeExecute(executor, task, promise, m);&#125;&#125;说明:1) 当判定下个 outbound 的 executor 线程不是当前线程的时候，会将当前的工作封装成 task ，然后放入mpsc 队列中，等待 IO 任务执行完毕后执行队列中的任务。2) 这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug ,客户端 Run 的方式)，当我们使用了group.submit(new Callable&lt;Object&gt;()&#123;&#125; 在 handler 中 加 入 线 程 池 ， 就 会 进 入 到 safeExecute(executor, task,promise, m); 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 safeExecute(executor,task, promise, m); （说明：普通方式执行耗时代码，看我准备好的案例即可） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464712. 处理耗时业务的第二种方式-Context 中添加线程池 1.1 在添加 pipeline 中的 handler 时候，添加一个线程池//属性static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);ServerBootstrap b = new ServerBootstrap();b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;@Overridepublic void initChannel(SocketChannel ch) throws Exception &#123;ChannelPipeline p = ch.pipeline();if (sslCtx != null) &#123;p.addLast(sslCtx.newHandler(ch.alloc()));&#125;//p.addLast(new LoggingHandler(LogLevel.INFO));//p.addLast(new EchoServerHandler());p.addLast(group,new EchoServerHandler() );&#125;&#125;);说明：1) handler 中的代码就使用普通的方式来处理耗时业务。2) 当我们在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池，如果不添加，将使用 IO 线程3) 当走到 AbstractChannelHandlerContext 的 invokeChannelRead 方法的时候，executor.inEventLoop() 是不会通过的，因为当前线程是 IO 线程 Contex（t 也就是 Handler）的 executor 是业务线程，所以会异步执行, debug下源码 static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);EventExecutor executor = next.executor();if (executor.inEventLoop()) &#123;next.invokeChannelRead(m);&#125; else &#123;executor.execute(new Runnable() &#123; //执行 run@Overridepublic void run() &#123;next.invokeChannelRead(m);&#125;&#125;);&#125;&#125;4) 验 证 时 ， 我 们 如 果 去 掉 p.addLast(group,new EchoServerHandler() ); 改 成 p.addLastnewEchoServerHandler() ); 你会发现代码不会进行异步执行5) 后面的整个流程就变成和第一个方式一样了 123456713. 两种方式的比较1) 第一种方式在 handler 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 mpscTask 中。如果 IO 时间很短，task 很多，可能一个循环下来，都没时间执行整个 task，导致响应时间达不到指标。2) 第二种方式是 Netty 标准方式(即加入到队列)，但是，这么做会将整个 handler 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。3) 各有优劣，从灵活性考虑，第一种较好 十一、用Netty自己实现dubbo RPC1、RPC基本介绍 RPC（Remote Procedure Call）— 远程 过程调用，是一个计算机 通信协议。该协议允许运 行于一台计算机的程序调 用另一台计算机的子程序， 而程序员无需额外地为这 个交互作用编程 两个或多个应用程序都分 布在不同的服务器上，它 们之间的调用都像是本地 方法调用一样(如图) 常见的 RPC 框架有: 比较知名的如阿里的Dubbo、google的gRPC、Go语言的rpcx、 Apache的thrift， Spring旗下的 Spring Cloud。 2、RPC调用流程RPC调用流程图 术语说明：在RPC 中， Client 叫服务消费者，Server 叫服 务提供者 PRC调用流程说明 服务消费方(client)以本地调用方式调用服务 client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体 client stub 将消息进行编码并发送到服务端 server stub 收到消息后进行解码 server stub 根据解码结果调用本地的服务 本地服务执行并将结果返回给 server stub server stub 将返回导入结果进行编码并发送至消费方 client stub 接收到消息并进行解码 服务消费方(client)得到结果 小结：RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调 用本地方法一样即可完成远程服务调用。 3、自己实现 dubbo RPC(基于Netty)需求说明 dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框 架 模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供 者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20 设计说明 创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。 创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。 创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求 提供者返回数据 代码实现dubbo RPC 思路分析图： 代码实现 公共接口： 12345678910package com.lxg.netty.dubborpc.publicinterface;//这个是接口，是服务提供方和服务消费方都需要public interface HelloService &#123; String hello(String mes);&#125; 实现类： 123456789101112131415161718192021package com.lxg.netty.dubborpc.provider;import com.lxg.netty.dubborpc.publicinterface.HelloService;public class HelloServiceImpl implements HelloService &#123; private static int count = 0; //当有消费方调用该方法时，就返回一个结果 @Override public String hello(String mes) &#123; System.out.println(&quot;收到客户端消息=&quot; + mes); //根据mes返回不同的结果 if (mes!= null) &#123; return &quot;你好客户端，我已经收到你的消息 [&quot; + mes + &quot;] 第&quot;+ (++count) +&quot;次&quot;; &#125; else &#123; return &quot;你好客户端，我已经收到你的消息&quot;; &#125; &#125;&#125; 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lxg.netty.dubborpc.netty;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class NettyServer &#123; public static void startServer(String hostname, int port)&#123; startServer0(hostname, port); &#125; //编写一个方法，完成对NettyServer的初始化和启动 private static void startServer0(String hostname, int port)&#123; EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); //给pipeline设置处理器 pipeline.addLast(new StringDecoder()); //解码器 pipeline.addLast(new StringEncoder()); //编码器 pipeline.addLast(new NettyServerHandler()); //自定义的处理器 &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(hostname, port).sync(); System.out.println(&quot;服务提供方开始提供服务~~&quot;); channelFuture.channel().closeFuture().sync(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; finally&#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务器端handler： 123456789101112131415161718192021222324252627282930313233package com.lxg.netty.dubborpc.netty;import com.lxg.netty.dubborpc.customer.ClientBootstrap;import com.lxg.netty.dubborpc.provider.HelloServiceImpl;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;//服务器这边的handler比较简单public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; //读取数据实际(这里我们可以读取客户端发送的消息) /* 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址 2. Object msg: 就是客户端发送的数据 默认Object */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //获取客户端发送的消息，并调用服务 System.out.println(&quot;msg=&quot; + msg); //客户端在调用服务器的api时，我们需要定义一个协议 //比如我们要求每次发消息都必须以某个字符串开头 &quot;我来啦#你好呀#&quot; if (msg.toString().startsWith(ClientBootstrap.providerName)) &#123; String result = new HelloServiceImpl().hello(msg.toString() .substring(msg.toString().lastIndexOf(&quot;#&quot;) + 1)); ctx.writeAndFlush(result); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125; 服务器端启动器： 1234567891011121314package com.lxg.netty.dubborpc.provider;import com.lxg.netty.dubborpc.netty.NettyServer;//ServerBootstrap 启动一个服务提供者，就是NettyServerpublic class ServerBootstrap &#123; public static void main(String[] args) &#123; //创建一个服务提供者，发布服务 NettyServer.startServer(&quot;127.0.0.1&quot;,7005); &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.lxg.netty.dubborpc.netty;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NettyClient &#123; //创建线程池 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static NettyClientHandler client; private int count = 0; //编写方法使用代理模式，获取一个代理对象 public Object getBean(final Class&lt;?&gt; serviceClass, final String providerName)&#123; return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;serviceClass&#125;, (proxy, method, args) -&gt; &#123; System.out.println(&quot;(proxy, method, args) 进入.....&quot; + (++count) + &quot; 次&quot;); //客户端在调用服务器api 时，我们会去调用 invoke 方法 if(client == null)&#123; initClient(); &#125; //设置要发给服务器端的信息 //providerName 协议头 args[0]就是客户端调用api hello(??)时传入的参数 client.setPara(providerName + args[0]); //返回值 return executor.submit(client).get(); &#125;); &#125; //初始化客户端 private static void initClient() throws Exception &#123; client = new NettyClientHandler(); //创建EventLoopGroup NioEventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); pipeline.addLast(client); //加入自己的处理器 &#125; &#125;); bootstrap.connect(&quot;127.0.0.1&quot;, 7005).sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端handler： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.lxg.netty.dubborpc.netty;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import java.util.concurrent.Callable;public class NettyClientHandler extends ChannelInboundHandlerAdapter implements Callable &#123; private ChannelHandlerContext context; //上下文 private String result; //返回的结果 private String para; //客户端调用方法时，传入的参数 //与服务器的连接创建后，就会被调用，这个方法是第一个被调用(1) @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot; channelActive 被调用 &quot;); context=ctx; //因为我们在其它方法会使用到ctx &#125; //收到服务器的数据后，调用方法(4) @Override public synchronized void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(&quot; channelRead 被调用 &quot;); result=msg.toString(); notify(); //唤醒等待的线程 &#125; //发生异常后，关闭通道(5) @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; //被代理对象调用，发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果(3) @Override public synchronized Object call() throws Exception &#123; System.out.println(&quot; call1 被调用 &quot;); context.writeAndFlush(para); //进行wait wait(); //等待channelRead 方法获取到服务器的结果后，唤醒 System.out.println(&quot; call2 被调用 &quot;); return result; //服务方返回的结果 &#125; //设置参数(2) void setPara(String para)&#123; System.out.println(&quot; setPara 被调用 &quot;); this.para=para; &#125;&#125; 客户端启动器： 12345678910111213141516171819202122232425262728package com.lxg.netty.dubborpc.customer;import com.lxg.netty.dubborpc.netty.NettyClient;import com.lxg.netty.dubborpc.publicinterface.HelloService;public class ClientBootstrap &#123; //这里定义协议头 public static final String providerName = &quot;我来啦#你好呀#&quot;; public static void main(String[] args) throws InterruptedException &#123; //创建一个消费者 NettyClient customer = new NettyClient(); //创建一个代理对象 HelloService service = (HelloService) customer .getBean(HelloService.class, providerName); for (;;)&#123; Thread.sleep(2*1000); //通过代理对象调用服务提供者的方法(服务) String res = service.hello(&quot;你好 dubbo~&quot;); System.out.println(&quot;调用的结果 res= &quot; + res); &#125; &#125;&#125;","tags":"netty"},{"title":"MySQL","url":"/2023/10/12/MySQL/","text":"MYSQL 什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？ 12345678数据库： 英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。 顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。数据库管理系统： DataBaseManagement，简称DBMS。 数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。常见的数据库管理系统： MySQL、Oracle、MS SqlServer、DB2、sybase等.... SQL：结构化查询语言 12345678910程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。三者之间的关系？ DBMS--执行--&gt; SQL --操作--&gt; DB先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。 在windows操作系统中，怎么使用命令来启动和关闭mysql服务呢？语法： ​ net stop 服务名称； ​ net start 服务名称； 其他服务也类似； 怎么使用客户端登录mysql数据库呢？使用bin目录下的mysql.exe命令来连接mysql数据库服务器 本地登录（显示密码形式）： ![image-20220507140042633](MySQL .assets&#x2F;image-20220507140042633.png) 本地登录（隐藏密码形式）： ![image-20220507140142750](MySQL .assets&#x2F;image-20220507140142750.png) 关于SQL语句的分类1234567891011121314151617181920212223242526272829303132SQL语句有很多，最好进行分门别类，这样更容易记忆。 分为： DQL： 数据查询语言（凡是带有select关键字的都是查询语句） select... DML： 数据操作语言（凡是对表当中的数据进行增删改的都是DML） insert delete update insert 增 delete 删 update 改 这个主要是操作表中的数据data。 DDL： 数据定义语言 凡是带有create、drop、alter的都是DDL。 DDL主要操作的是表的结构。不是表中的数据。 create：新建，等同于增 drop：删除 alter：修改 这个增删改和DML不同，这个主要是对表结构进行操作。 TCL： 是事务控制语言 包括： 事务提交：commit; 事务回滚：rollback; DCL： 是数据控制语言。 例如：授权grant、撤销权限revoke.... MySQL常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768退出mysql ：exit;查看mysql中有哪些数据库 : show databases; #注意：以分号结尾，分号是英文的分号。mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | test | +--------------------+ mysql默认自带了4个数据库。 怎么选择使用某个数据库:mysql&gt; use test;Database changed表示正在使用一个名字叫做test的数据库。怎么创建数据库:mysql&gt; create database bjpowernode;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bjpowernode | | mysql | | performance_schema | | test | +--------------------+ 查看某个数据库下有哪些表:mysql&gt; show tables;查看mysql数据库的版本号：mysql&gt; select version(); +-----------+ | version() | +-----------+ | 5.5.36 | +-----------+ 查看当前使用的是哪个数据库:mysql&gt; select database(); +-------------+ | database() | +-------------+ | bjpowernode | +-------------+导入一下提前准备好的数据：bjpowernode.sql 这个文件中是练习准备的数据库表。怎么将sql文件中的数据导入mysql&gt; source D:\\course\\03-MySQL\\document\\bjpowernode.sql #注意：路径中不要有中文！！！！查看表的结构：mysql&gt; desc dept; # describe缩写为：desc+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| DEPTNO | int(2) | NO | PRI | NULL | |部门编号| DNAME | varchar(14) | YES | | NULL | |部门名字| LOC | varchar(13) | YES | | NULL | |地理位置+--------+-------------+------+-----+---------+-------+#注意：mysql是不见“;”不执行的，\\c用来终止一条命令的输入 数据库表12345678910111213141516171819202122数据库当中最基本的单元是表：table 什么是表table？为什么用表来存储数据呢？ 姓名 性别 年龄(列：字段) --------------------------- 张三 男 20 -------&gt;行（记录） 李四 女 21 -------&gt;行（记录） 王五 男 22 -------&gt;行（记录） 数据库当中是以表格的形式表示数据的。因为表比较直观。 任何一张表都有行和列： 行（row）：被称为数据/记录。 列（column）：被称为字段。 姓名字段、性别字段、年龄字段。 了解一下： 每一个字段都有：字段名、数据类型、约束等属性。字段名可以理解，是一个普通的名字，见名知意就行。 数据类型：字符串，数字，日期等，后期讲。 约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。 查询：select简单查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485查询一个字段？select 字段名 from 表名; # 其中要注意：select和from都是关键字。# 字段名和表名都是标识符。强调：对于SQL语句来说，是通用的，所有的SQL语句以“;”结尾。 另外SQL语句不区分大小写，都行。查询两个字段，或者多个字段使用逗号隔开“,”查询部门编号和部门名select deptno,dname from dept; +--------+------------+ | deptno | dname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 查询所有字段第一种方式：可以把每个字段都写上 select a,b,c,d,e,f... from tablename;第二种方式：可以使用* select * from dept; +--------+------------+----------+ | DEPTNO | DNAME | LOC | +--------+------------+----------+ | 10 | ACCOUNTING | NEW YORK | | 20 | RESEARCH | DALLAS | | 30 | SALES | CHICAGO | | 40 | OPERATIONS | BOSTON | +--------+------------+----------+ 这种方式的缺点： 1、效率低 2、可读性差。 在实际开发中不建议，可以自己玩没问题。 你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。给查询的列起别名：使用as关键字起别名。 mysql&gt; select deptno,dname as deptname from dept; +--------+------------+ | deptno | deptname | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+ 注意：只是将显示的查询结果列名显示为deptname，原表列名还是叫：dname 记住：select语句是永远都不会进行修改操作的。（因为只负责查询） as关键字可以省略吗？可以的 mysql&gt; select deptno,dname deptname from dept; 假设起别名的时候，别名里面有空格，怎么办？ select deptno,dname &#x27;dept name&#x27; from dept; //加单引号select deptno,dname &quot;dept name&quot; from dept; //加双引号 +--------+------------+ | deptno | dept name | +--------+------------+ | 10 | ACCOUNTING | | 20 | RESEARCH | | 30 | SALES | | 40 | OPERATIONS | +--------+------------+注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。不看表中的数据，只看表的结构，有一个命令：desc 表名；mysql&gt; desc emp;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| EMPNO | int(4) | NO | PRI | NULL | || ENAME | varchar(10) | YES | | NULL | || JOB | varchar(9) | YES | | NULL | || MGR | int(4) | YES | | NULL | || HIREDATE | date | YES | | NULL | || SAL | double(7,2) | YES | | NULL | || COMM | double(7,2) | YES | | NULL | || DEPTNO | int(2) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+ 条件查询条件查询：不是将表中所有数据都查出来。是查询出来符合条件的。 1234567查询语法格式： select 字段1,字段2,字段3.... from 表名 where 条件; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596都有哪些条件？= 等于查询薪资等于800的员工姓名和编号？ select empno,ename from emp where sal = 800;查询SMITH的编号和薪资？ select empno,sal from emp where ename = &#x27;SMITH&#x27;; //字符串使用单引号&lt;&gt; 或!= 不等于查询薪资不等于800的员工姓名和编号？ select empno,ename from emp where sal != 800; select empno,ename from emp where sal &lt;&gt; 800; // 小于号和大于号组成的不等号 &lt; 小于查询薪资小于2000的员工姓名和编号？ mysql&gt; select empno,ename,sal from emp where sal &lt; 2000; +-------+--------+---------+ | empno | ename | sal | +-------+--------+---------+ | 7369 | SMITH | 800.00 | | 7499 | ALLEN | 1600.00 | | 7521 | WARD | 1250.00 | +-------+--------+---------+&lt;= 小于等于查询薪资小于等于3000的员工姓名和编号？ select empno,ename,sal from emp where sal &lt;= 3000;&gt; 大于查询薪资大于3000的员工姓名和编号？ select empno,ename,sal from emp where sal &gt; 3000;&gt;= 大于等于查询薪资大于等于3000的员工姓名和编号？ select empno,ename,sal from emp where sal &gt;= 3000;between … and …. 两个值之间, 等同于 &gt;= and &lt;=查询薪资在2450和3000之间的员工信息？包括2450和3000 第一种方式：&gt;= and &lt;= （and是并且的意思。） select empno,ename,sal from emp where sal &gt;= 2450 and sal &lt;= 3000; +-------+-------+---------+ | empno | ename | sal | +-------+-------+---------+ | 7566 | JONES | 2975.00 | | 7698 | BLAKE | 2850.00 | | 7782 | CLARK | 2450.00 | | 7788 | SCOTT | 3000.00 | | 7902 | FORD | 3000.00 | +-------+-------+---------+ 第二种方式：between … and … select empno,ename,sal from emp where sal between 2450 and 3000; 注意： 使用between and的时候，必须遵循左小右大。 between and是闭区间，包括两端的值。is null 为 null（is not null 不为空）注意：在数据库当中null不能使用等号进行衡量。需要使用is null因为数据库中的null代表什么也没有，它不是一个值，所以不能使用等号衡量。and 并且 or 或者and和or同时出现的话，有优先级问题吗？and和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”.以后在开发中，如果不确定优先级，就加小括号就行了。in 包含，相当于多个 or （not in 不在这个范围中）not 可以取非，主要用在 is 或 in 中like 称为模糊查询，支持%或下划线匹配# %匹配任意多个字符# 下划线_：任意一个字符。#（%是一个特殊的符号，_ 也是一个特殊符号）找出名字以T结尾的？ select ename from emp where ename like &#x27;%T&#x27;; 找出名字以K开始的？ select ename from emp where ename like &#x27;K%&#x27;;找出第二个字每是A的？ select ename from emp where ename like &#x27;_A%&#x27;;找出第三个字母是R的？ select ename from emp where ename like &#x27;__R%&#x27;;找出名字有下划线的？&#x27;%_%&#x27;;//这样不行应该写为&#x27;%\\_%&#x27;\\是转义字符 排序123456789101112131415161718192021222324252627282930313233343536371、查询所有员工薪资，排序？select ename,salfrom emporder by sal;//默认是升序！！！ 怎么降序？select ename,salfrom emporder by sal desc;ASC是升序！2、可以两字字段排序？或者说多个字段？查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排序。select ename,salfrom emporder by sal asc,ename asc;3.了解：根据字段的位置也可以排序select enmae,salfrom emporder by 2;//2表示第二列，第二列是sal不建议在开发中这样写，因为不健壮因为列的顺讯容易发生改变，列顺序修改之后，2就废了。4、语句的执行顺序是：fromwhereselectorder by 分组查询 什么是分组查询？ 在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一组的数据进行操作，这个时候我们需要使用分组查询。 123456789101112131415161718192021222324252627282930313233343536373839语法格式： select ... from ... group by ...注意:select ename,job,sum(sal) from emp group by job; +-------+-----------+----------+ | ename | job | sum(sal) | +-------+-----------+----------+ | SCOTT | ANALYST | 6000.00 | | SMITH | CLERK | 4150.00 | | JONES | MANAGER | 8275.00 | | KING | PRESIDENT | 5000.00 | | ALLEN | SALESMAN | 5600.00 | +-------+-----------+----------+以上语句在mysql中可以执行，但select后面添加ename字段没有意义。以上语句在oracle中执行报错。oracle的语法比mysql的语法严格。（mysql的语法相对来说松散一些！）重点结论：在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。找出“每个部门，不同工作岗位”的最高薪资？select deptno, job, max(sal)from empgroup by deptno, job;技巧：两个字段联合成1个字段看。（两个字段联合分组）使用having可以对分完组之后的数据进一步过滤。having不能单独使用，having不能代替where，having必须和group by联合使用。where和having，优先选择where，where实在完成不了了，再选择having。 补充一点 123456789101112131415161718192021将之前的关键字全部组合在一起，来看一下他们的执行顺序？ select ... from ... where ... group by ... having ... order by ...以上关键字的顺序不能颠倒，需要记忆。执行顺序是什么？ 1. from 2. where 3. group by 4. having 5. select 6. order by 排序：order by123456789101112131415161718语法格式： select ename,sal from emp order by sal; // 默认是升序！！指定降序： desc指定升序： asc以两个字段排序吗？或者说按照多个字段排序？查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。select ename,salfrom emporder by sal asc, ename asc; // sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。 数据处理函数 数据处理函数又被称为单行处理函数 单行处理函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546单行处理函数的特点：一个输入对应一个输出。单行处理函数常见:lower 转换小写 mysql&gt; select lower(ename) as ename from emp; upper 转换大写 mysql&gt; select upper(name) as name from t_student; substr 取子串（substr(被截取的字符串, 起始下标,截取的长度)） mysql&gt; select substr(ename, 1, 1) as ename from emp; #注意：起始下标从1开始concat函数进行字符串的拼接 mysql&gt; select concat(empno,ename) from emp;length 取长度 mysql&gt; select length(ename) enamelength from emp; trim 去空格 mysql&gt; select * from emp where ename = trim(&#x27; KING&#x27;); str_to_date 将字符串转换成日期date_format 格式化日期 format 设置千分位 case..when..then..when..then..else..end当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。 （注意：不修改数据库，只是将查询结果显示为工资上调）select ename,job, sal as oldsal, (case job when &#x27;MANAGER&#x27; then sal*1.1 when &#x27;SALESMAN&#x27; then sal*1.5 else sal end) as newsal from emp;round 四舍五入mysql&gt; select round(1236.567, 0) as result from emp; //保留整数位。mysql&gt; select round(1236.567, 1) as result from emp; //保留1个小数mysql&gt; select round(1236.567, 2) as result from emp; //保留2个小数mysql&gt; select round(1236.567, -1) as result from emp; // 保留到十位。(1240)mysql&gt; select round(1236.567, -2) as result from emp; // 保留到十位。（1200）rand() 生成随机数 mysql&gt; select round(rand()*100,0) from emp; // 100以内的随机数ifnull 可以将 null 转换成一个具体值ifnull是空处理函数。专门处理空的。在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。注意：NULL只要参与运算，最终结果一定是NULL。为了避免这个现象，需要使用ifnull函数。ifnull函数用法：ifnull(数据, 被当做哪个值)。如果“数据”为NULL的时候，把这个数据结构当做哪个值。 分组函数（多行处理函数）多行处理函数特点：多个输入，对应1个输出。 123456789101112131415count # 计数sum # 求和avg # 平均值max # 最大值min # 最小值注意： 1. 分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。 2. 分组函数自动忽略NULL，你不需要提前对NULL进行处理。 3. 分组函数中count(*)和count(具体字段)有什么区别？ count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。 count(*)：统计表当中的总行数。（只要有一行数据count则++） 因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。 4. 分组函数不能够直接使用在where子句中。 5. 所有的分组函数可以组合起来一起用。 distinct 把查询结果去除重复记录 distinct 注意：原表数据不会被修改，只是查询结果去重。 12345// distinct只能出现在所有字段的最前方。mysql&gt; select distinct job from emp;// distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。mysql&gt; select distinct job,deptno from emp; 分组查询 什么是分组查询？ 注意在实际的应用中，可能有这样的需求，需要先进行分组，然后对分组的数据进行操作，这个时候就需要使用分组查询。 1234567891011121314151617select ...from ...group by ... 执行顺序：fromwheregroup byselectorder by为什么分组函数不能直接使用在where后面？因为分组函数在使用的时候必须先分组之后才能使用。where执行的时候，还没有分组，所以where后面不能出现分组函数。#重点结论： 在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数，其他一律不能跟。 ![image-20220507195310609](MySQL .assets&#x2F;image-20220507195310609.png) 查询每个部门不同岗位的最高工资 ![image-20220507200159424](MySQL .assets&#x2F;image-20220507200159424.png) 123使用having可以对分组之后的数据进一步过滤having不能单独使用， having 不能代替 where， having 必须和 group by联合使用。 ![image-20220507220925174](MySQL .assets&#x2F;image-20220507220925174.png) ![image-20220507221136058](MySQL .assets&#x2F;image-20220507221136058.png) 优化策略：where和having，优先选择where，where实在完成不了，再选择having。 执行顺序：fromwheregroup byhavingselectorder by ![image-20220507222305553](MySQL .assets&#x2F;image-20220507222305553.png) 连接查询 多张表联合起来查询数据，被称为连接查询。 12345678910111213根据表连接的方式分类：内连接： 等值连接 非等值连接 自连接外连接： 左外连接（左连接） 右外连接（右连接）当两张表进行连接查询，如果没有添加任何条件，则查询结果条数是两张表的条数乘积，这种现象称为笛卡尔积现象。#表起别名select e.ename,d.dnamefrom emp e,dept dwhere e.deptno=d.deptno; 内连接：等值连接12345678910111213141516SQL99语法： select ... from a inner join b on a和b的连接条件 where 筛选条件# inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）sql92的缺点：结构不清晰，表的连接条件和后期进一步的筛选条件都放在了where后面。sql99的优点：表的连接条件是独立的，连接之后，如果还需要进一步筛选，再往后添加where语句。 内连接：非等值连接12345678select e.ename, e.sal, s.gradefrom emp ejoin salgrade son e.sal between s.losal and s.hisal; // 条件不是一个等量关系，称为非等值连接。 内连接：自连接1234567891011select a.ename as &#x27;员工名&#x27;, b.ename as &#x27;领导名&#x27;from emp ajoin emp bon a.mgr = b.empno; //员工的领导编号 = 领导的员工编号以上就是内连接中的：自连接，技巧：一张表看做两张表内连接的特点：完全能够匹配上这个条件的数据查询出来。 外连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// outer是可以省略的，带着可读性强。select e.ename,d.dnamefrom emp e right outer join dept don e.deptno = d.deptno; outer可以省略 right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了主次关系。带有right的是右外连接，又叫做右连接。带有left的是左外连接，又叫做左连接。任何一个右连接都有左连接的写法。任何一个左连接都有右连接的写法。思考：外连接的查询结果条数一定是 &gt;= 内连接的查询结果条数？ 正确。 三张表，四张表怎么连接？语法： select ... from a join b on a和b的连接条件 join c on a和c的连接条件 right join d on a和d的连接条件 一条SQL中内连接和外连接可以混合。都可以出现！ #案例： 找出每个员工的部门名称以及工资等级，（还有上级领导）要求显示员工名、（领导名）、部门名、薪资、薪资等级。 1. select a.ename,b.dname,a.sal,c.grade from emp a join dept b on a.deptno=b.deptno join salgrade c on a.sal between c.losal and c.hisal; +--------+------------+---------+-------+| ename | dname | sal | grade |+--------+------------+---------+-------+| SMITH | RESEARCH | 800.00 | 1 || ALLEN | SALES | 1600.00 | 3 || WARD | SALES | 1250.00 | 2 || JONES | RESEARCH | 2975.00 | 4 || MARTIN | SALES | 1250.00 | 2 || BLAKE | SALES | 2850.00 | 4 || CLARK | ACCOUNTING | 2450.00 | 4 || SCOTT | RESEARCH | 3000.00 | 4 || KING | ACCOUNTING | 5000.00 | 5 || TURNER | SALES | 1500.00 | 3 || ADAMS | RESEARCH | 1100.00 | 1 || JAMES | SALES | 950.00 | 1 || FORD | RESEARCH | 3000.00 | 4 || MILLER | ACCOUNTING | 1300.00 | 2 |+--------+------------+---------+-------+2.select a.ename,d.ename as lname,b.dname,a.sal,c.grade from emp a join dept b on a.deptno=b.deptno join salgrade c on a.sal between c.losal and c.hisal left join emp d on a.mgr=d.empno; +--------+-------+------------+---------+-------+| ename | lname | dname | sal | grade |+--------+-------+------------+---------+-------+| SMITH | FORD | RESEARCH | 800.00 | 1 || ADAMS | SCOTT | RESEARCH | 1100.00 | 1 || JAMES | BLAKE | SALES | 950.00 | 1 || WARD | BLAKE | SALES | 1250.00 | 2 || MARTIN | BLAKE | SALES | 1250.00 | 2 || MILLER | CLARK | ACCOUNTING | 1300.00 | 2 || ALLEN | BLAKE | SALES | 1600.00 | 3 || TURNER | BLAKE | SALES | 1500.00 | 3 || JONES | KING | RESEARCH | 2975.00 | 4 || BLAKE | KING | SALES | 2850.00 | 4 || CLARK | KING | ACCOUNTING | 2450.00 | 4 || SCOTT | JONES | RESEARCH | 3000.00 | 4 || FORD | JONES | RESEARCH | 3000.00 | 4 || KING | NULL | ACCOUNTING | 5000.00 | 5 |+--------+-------+------------+---------+-------+ 子查询 select语句中嵌套select语句，被嵌套的select语句称为子查询。 123456789101112131415161718192021222324252627282930子查询都可以出现在哪里呢？select ..(select).from ..(select).where ..(select). where子句中的子查询:第一步：查询最低工资是多少 select min(sal) from emp; +----------+ | min(sal) | +----------+ | 800.00 | +----------+第二步：找出&gt;800的 select ename,sal from emp where sal &gt; 800;第三步：合并 select ename,sal from emp where sal &gt; (select min(sal) from emp); from子句中的子查询: 注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。select后面出现的子查询（这个内容不需要掌握，了解即可！！！） 注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果 ![image-20220508095937164](MySQL .assets&#x2F;image-20220508095937164.png) ![image-20220508095958796](MySQL .assets&#x2F;image-20220508095958796.png) union合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657案例：查询工作岗位是MANAGER和SALESMAN的员工？select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename,job from emp where job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER || ALLEN | SALESMAN || WARD | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。a 连接 b 连接 ca 10条记录b 10条记录c 10条记录匹配次数是：1000a 连接 b一个结果：10 * 10 --&gt; 100次a 连接 c一个结果：10 * 10 --&gt; 100次使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）union在使用的时候有注意事项吗？//错误的：union在进行结果集合并的时候，要求两个结果集的列数相同。select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename from emp where job = &#x27;SALESMAN&#x27;;// MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename,sal from emp where job = &#x27;SALESMAN&#x27;; limit12345678910111213141516171819202122232425262728293031323334353637383940414243limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。百度默认：一页显示10条记录。分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。可以一页一页翻页看limit的使用完整用法：limit startIndex, length startIndex是起始下标，length是长度。 起始下标从0开始。缺省用法：limit 5; 这是取前5按照薪资排序，取出排名前五的员工。select ename,salfrom emporder by sal desclimit 5;注意：mysql当中limit在order by之后执行！！！！！！#分页每页显示3条记录第1页：limit 0,3 [0 1 2]第2页：limit 3,3 [3 4 5]第3页：limit 6,3 [6 7 8]第4页：limit 9,3 [9 10 11]每页显示pageSize条记录第pageNo页：limit (pageNo - 1) * pageSize , pageSizepublic static void main(String[] args)&#123; // 用户提交过来一个页码，以及每页显示的记录条数 int pageNo = 5; //第5页 int pageSize = 10; //每页显示10条 int startIndex = (pageNo - 1) * pageSize; String sql = &quot;select ...limit &quot; + startIndex + &quot;, &quot; + pageSize;&#125;记公式：limit (pageNo-1)*pageSize , pageSize 123456789101112131415161718192021222324关于DQL语句的大总结：select ...from ...where ...group by ...having ...order by ...limit ...执行顺序？ 1.from 2.where 3.group by 4.having 5.select 6.order by 7.limit.. 表的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。字段名：见名知意。表名和字段名都属于标识符。关于mysql中的数据类型很多数据类型，我们只需要掌握一些常见的数据类型即可。 varchar(最长255) 可变长度的字符串 比较智能，节省空间。 会根据实际的数据长度动态分配空间。 优点：节省空间 缺点：需要动态分配空间，速度慢。 char(最长255) 定长字符串 不管实际的数据长度是多少。 分配固定长度的空间去存储数据。 使用不恰当的时候，可能会导致空间的浪费。 优点：不需要动态分配空间，速度快。 缺点：使用不当可能会导致空间的浪费。 varchar 和 char 我们应该怎么选择？ 性别字段你选什么？因为性别是固定长度的字符串，所以选择char。 姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。 int(最长11) 数字中的整数型。等同于java的int。 bigint 数字中的长整型。等同于java中的long。 float 单精度浮点型数据 double 双精度浮点型数据 date 短日期类型 datetime 长日期类型 clob 字符大对象 最多可以存储4G的字符串。 比如：存储一篇文章，存储一个说明。 超过255个字符的都要采用CLOB字符大对象来存储。 Character Large OBject:CLOB blob 二进制大对象 Binary Large OBject 专门用来存储图片、声音、视频等流媒体数据。 往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等， 你需要使用IO流才行。 t_movie电影表（专门存储电影信息的） 编号no---bigint 名字name---varchar 描述信息description---clob 上映日期playtime---date 时长time---double 海报image---blob 类型type---char 创建一个学生表？ 学号、姓名、年龄、性别、邮箱地址 create table t_student( no int, name varchar(32), sex char(1), age int(3), email varchar(255) ); 删除表： drop table t_student; // 当这张表不存在的时候会报错！ // 如果这张表存在的话，删除 drop table if exists t_student; 插入数据insert123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118插入数据insert （DML） 语法格式： insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3); 注意：字段名和值要一一对应。什么是一一对应？ 数量要对应。数据类型要对应。 insert语句中的“字段名”可以省略吗？可以 insert into t_student values(2); //错误的 // 注意：前面的字段名省略的话，等于都写上了！所以值也要都写上！ insert into t_student values(2, &#x27;lisi&#x27;, &#x27;f&#x27;, 20, &#x27;lisi@123.com&#x27;); +------+------+------+------+--------------+ | no | name | sex | age | email | +------+------+------+------+--------------+ | 1 | NULL | m | NULL | NULL | | 2 | lisi | f | 20 | lisi@123.com | +------+------+------+------+--------------+一次可以插入多条记录： insert into t_user(id,name,birth,create_time) values (1,&#x27;zs&#x27;,&#x27;1980-10-11&#x27;,now()), (2,&#x27;lisi&#x27;,&#x27;1981-10-11&#x27;,now()), (3,&#x27;wangwu&#x27;,&#x27;1982-10-11&#x27;,now()); 语法：insert into t_user(字段名1,字段名2) values(),(),(),();insert插入日期 数字格式化：format 格式化数字：format(数字, &#x27;格式&#x27;) select ename,format(sal, &#x27;$999,999&#x27;) as sal from emp;str_to_date：将字符串varchar类型转换成date类型date_format：将date类型转换成具有一定格式的varchar字符串类型。插入数据？insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, &#x27;01-10-1990&#x27;); // 1990年10月1日出问题了：原因是类型不匹配。数据库birth是date类型，这里给了一个字符串varchar。怎么办？可以使用str_to_date函数进行类型转换。str_to_date函数可以将字符串转换成日期类型date？语法格式： str_to_date(&#x27;字符串日期&#x27;, &#x27;日期格式&#x27;)mysql的日期格式： %Y 年 %m 月 %d 日 %h 时 %i 分 %s 秒insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, str_to_date(&#x27;01-10-1990&#x27;,&#x27;%d-%m-%Y&#x27;));str_to_date函数可以把字符串varchar转换成日期date类型数据，通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，需要通过该函数将字符串转换成date。如果你提供的日期字符串是这个格式，str_to_date函数就不需要了！！！ %Y-%m-%dinsert into t_user(id,name,birth) values(2, &#x27;lisi&#x27;, &#x27;1990-10-01&#x27;);查询的时候可以以某个特定的日期格式展示吗？date_format这个函数可以将日期类型转换成特定格式的字符串。select id,name,date_format(birth, &#x27;%m/%d/%Y&#x27;) as birth from t_user;+------+----------+------------+| id | name | birth |+------+----------+------------+| 1 | zhangsan | 10/01/1990 || 2 | lisi | 10/01/1990 |+------+----------+------------+date_format函数怎么用？ date_format(日期类型数据, &#x27;日期格式&#x27;) 这个函数通常使用在查询日期方面。设置展示的日期格式。mysql&gt; select id,name,birth from t_user;+------+----------+------------+| id | name | birth |+------+----------+------------+| 1 | zhangsan | 1990-10-01 || 2 | lisi | 1990-10-01 |+------+----------+------------+以上的SQL语句实际上是进行了默认的日期格式化，自动将数据库中的date类型转换成varchar类型。并且采用的格式是mysql默认的日期格式：&#x27;%Y-%m-%d&#x27;select id,name,date_format(birth,&#x27;%Y/%m/%d&#x27;) as birth from t_user;java中的日期格式？ yyyy-MM-dd HH:mm:ss SSSdate和datetime两个类型的区别？ date是短日期：只包括年月日信息。 datetime是长日期：包括年月日时分秒信息。 mysql短日期默认格式：%Y-%m-%d mysql长日期默认格式：%Y-%m-%d %h:%i:%s 在mysql中怎么获取系统当前时间？now()函数，是datatime类型直接使用 快速创建表？create table 表名 as select * from 另一张表其实就是复制把查询结果插入一张表insert into 表名 select * from 另一张表也可添加条件选择某些字段某些数据 修改update1234567891011121314151617语法格式：update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3... where 条件;注意：没有条件限制会导致所有数据全部更新。update t_user set name = &#x27;jack&#x27;, birth = &#x27;2000-10-11&#x27; where id = 2;+------+----------+------------+---------------------+| id | name | birth | create_time |+------+----------+------------+---------------------+| 1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 || 2 | jack | 2000-10-11 | 2020-03-18 15:51:23 |+------+----------+------------+---------------------+update t_user set name = &#x27;jack&#x27;, birth = &#x27;2000-10-11&#x27;, create_time = now() where id = 2;更新所有？ update t_user set name = &#x27;abc&#x27;; 删除数据 delete1234567891011121314151617181920212223242526272829303132333435363738394041语法格式？ delete from 表名 where 条件;注意：没有条件，整张表的数据会全部删除！delete from t_user where id = 2;insert into t_user(id) values(2);delete from t_user; // 删除所有！快速删除表中的数据？【truncate比较重要，必须掌握】//删除dept_bak表中的数据delete from dept_bak; //这种删除数据的方式比较慢。mysql&gt; select * from dept_bak;Empty set (0.00 sec)delete语句删除数据的原理？（delete属于DML语句！！！） 表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！ 这种删除缺点是：删除效率比较低。 这种删除优点是：支持回滚，后悔了可以再恢复数据！！！truncate语句删除数据的原理？ 这种删除效率比较高，表被一次截断，物理删除。 这种删除缺点：不支持回滚。 这种删除优点：快速。用法：truncate table dept_bak; （这种操作属于DDL操作。）大表非常大，上亿条记录？？？？ 删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。 可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。 但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！ truncate是删除表中的数据，表还在！删除表操作？ drop table 表名; // 这不是删除表中的数据，这是把表删除。 约束1234567891011121314什么是约束？约束对应的英语单词： constraint在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！约束的作用就是为了保证：表中的数据有效！！约束包括哪些？非空约束：not null唯一性约束: unique主键约束: primary key （简称PK）外键约束：foreign key（简称FK）检查约束：check（mysql不支持，oracle支持）只学习前四个 非空约束：not null 非空约束not null约束的字段不能为NULL。 12345drop table if exists t_vip;create table t_vip( id int, name varchar(255) not null // not null只有列级约束，没有表级约束！); ![image-20220509213545013](MySQL .assets&#x2F;image-20220509213545013.png) 唯一性约束: unique 唯一性约束unique约束的字段不能重复，但是可以为NULL。 1234567891011121314151617181920212223242526272829唯一性约束unique约束的字段不能重复，但是可以为NULL。drop table if exists t_vip;create table t_vip( id int, name varchar(255) unique, email varchar(255));如何做到联合唯一约束create table t_vip( id int, name varchar(255) unique, email varchar(255) unique);这样只是分别具有唯一性。 drop table if exists t_vip;create table t_vip( id int, name varchar(255), email varchar(255), unique(name,email) // 约束没有添加在列的后面，这种约束被称为表级约束。);什么时候使用表级约束？需要要给多个字段联合起来添加某一个约束的时候，需要使用表级约束。name和email两个字段联合起来唯一在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样） 主键约束: primary key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859主键约束的相关术语？ 主键约束：就是一种约束。 主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段 主键值：主键字段中的每一个值都叫做：主键值。什么是主键？有啥用？ 主键值是每一行记录的唯一标识。 主键值是每一行记录的身份证号！！！记住：任何一张表都应该有主键，没有主键，表无效！！主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）怎么给一张表添加主键约束呢？ drop table if exists t_vip; // 1个字段做主键，叫做：单一主键 create table t_vip( id int primary key, //列级约束 name varchar(255) );表级约束主要是给多个字段联合起来添加约束？ drop table if exists t_vip; // id和name联合起来做主键：复合主键！！！！ create table t_vip( id int, name varchar(255), email varchar(255), primary key(id,name) ); 在实际开发中不建议使用：复合主键。建议使用单一主键！因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。复合主键比较复杂，不建议使用！！！主键约束只能添加一个主键值建议使用： int bigint char 等类型。不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！主键除了：单一主键和复合主键之外，还可以这样进行分类？ 自然主键：主键值是一个自然数，和业务没关系。 业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！在实际开发中使用业务主键多，还是使用自然主键多一些？ 自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。 业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候， 可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。 在mysql当中，有一种机制，可以帮助我们自动维护一个主键值？ drop table if exists t_vip; create table t_vip( id int primary key auto_increment, //auto_increment表示自增，从1开始，以1递增！ name varchar(255) ); 外键约束：foreign key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950外键约束涉及到的相关术语： 外键约束：一种约束（ foreign key） 外键字段：该字段上添加了外键约束 外键值：外键字段当中的每一个值。业务背景：请设计数据库表，来描述”班级和学生“的信息？第一种方案：班级和学生存储在同一张表t_studentno(pk) name classno classname-----------------------------------------------1 jack 100 2班2 lucy 100 2班3 lisi 100 2班4 ssh 100 2班5 zss 101 1班6 shq 101 1班7 dhq 101 1班8 dhw 101 1班分析以上方案的缺点： 数据冗余，空间浪费!!第二种方案：班级一张表，学生一张表t_class班级表classno(pk) classname----------------------100 2班101 1班t_student学生表no(pk) name cno(FK)-------------------------------1 jack 1002 lucy 1003 lisi 1004 ssh 1005 zss 1016 shq 1017 dhq 1018 dhw 101当cno字段没有任何约束时，可能会导致数据无效，可能出现一个102，但是102班级不存在，所有为了保证cno字段中的值都是100和101，需要给cno添加外键约束。那么：cno字段就是外键字段，cno字段中的每一个值都是外键值。注意：t_class是父类t_student是子类先删子，再删父（删表）先创父，再创子先删子，再删父（删数据）先插父，再插子外键可以为NULL思考：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗？不一定，但至少具有unique约束。 存储引擎 什么是存储引擎，有什么用呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）存储引擎这个名字高端大气上档次。实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。怎么给表添加/指定“存储引擎”呢？show create table t_student;可以在建表的时候给表指定存储引擎。CREATE TABLE `t_student` ( `no` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `cno` int(11) DEFAULT NULL, PRIMARY KEY (`no`), KEY `cno` (`cno`), CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8在建表的时候可以在最后小括号的&quot;)&quot;的右边使用： ENGINE来指定存储引擎。 CHARSET来指定这张表的字符编码方式。 结论： mysql默认的存储引擎是：InnoDB mysql默认的字符编码方式是：utf8 怎么查看mysql支持哪些存储引擎呢？命令： show engines \\G*************************** 1. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keysTransactions: YES XA: YES Savepoints: YES*************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tablesTransactions: NO XA: NO Savepoints: NO*************************** 3. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tablesTransactions: NO XA: NO Savepoints: NO*************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears)Transactions: NO XA: NO Savepoints: NO*************************** 5. row *************************** Engine: MyISAM Support: YES Comment: MyISAM storage engineTransactions: NO XA: NO Savepoints: NO*************************** 6. row *************************** Engine: CSV Support: YES Comment: CSV storage engineTransactions: NO XA: NO Savepoints: NO*************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: Archive storage engineTransactions: NO XA: NO Savepoints: NO*************************** 8. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance SchemaTransactions: NO XA: NO Savepoints: NO*************************** 9. row *************************** Engine: FEDERATED Support: NO Comment: Federated MySQL storage engineTransactions: NULL XA: NULL Savepoints: NULL9 rows in set (0.00 sec) select version();+------------+| version() |+------------+| 5.7.29-log |+------------+mysql支持九大存储引擎，当前5.7.29支持8个。版本不同支持情况也不同 MyISAM存储引擎12345678910111213141516它管理的表具有以下特征： 使用三个文件表示每个表： 格式文件 — 存储表结构的定义（mytable.frm） 数据文件 — 存储表行的内容（mytable.MYD） 索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩、只读表来节省空间 提示一下： 对于一张表来说，只要是主键， 或者加有unique约束的字段上会自动创建索引。 MyISAM存储引擎特点： 可被转换为压缩、只读表来节省空间 这是这种存储引擎的优势！！！！ MyISAM不支持事务机制，安全性低。 InnoDB存储引擎123456789101112131415161718这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。InnoDB支持事务，支持数据库崩溃后自动恢复机制。InnoDB存储引擎最主要的特点是：非常安全。它管理的表具有下列主要特征： – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示 – InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。） – 提供一组用来记录事务性活动的日志文件 – 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 – 提供全 ACID 兼容 – 在 MySQL 服务器崩溃后提供自动恢复 – 多版本（MVCC）和行级锁定 – 支持外键及引用的完整性，包括级联删除和更新InnoDB最大的特点就是支持事务： 以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读， 不能很好的节省存储空间。 MEMORY存储引擎12345678910111213使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。MEMORY 存储引擎管理的表具有下列特征： – 在数据库目录内，每个表均以.frm 格式的文件表示。 – 表数据及索引被存储在内存中。（目的就是快，查询快！） – 表级锁机制。 – 不能包含 TEXT 或 BLOB 字段。MEMORY 存储引擎以前被称为HEAP 引擎。MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。 事务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849什么是事务？一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。什么是一个完整的业务逻辑？ 假设转账，从A账户向B账户中转账10000. 将A账户的钱减去10000（update语句） 将B账户的钱加上10000（update语句） 这就是一个完整的业务逻辑。 以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。 这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。只有DML语句才会有事务这一说，其它语句和事务无关！！！insertdeleteupdate只有以上的三个语句和事务有关系，其它都没有关系。因为 只有以上的三个语句是数据库表中数据进行增、删、改的。只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。事物是怎么做到多条DML语句同时成功或者同时失败的呢？InnoDB存储引擎：提供一组用来记录事务性活动的日志文件事务开启了：insertinsertinsertdeleteupdateupdateupdate事务结束了！在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。在事务的执行过程中，我们可以提交事务，也可以回滚事务。提交事务？ 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。 提交事务标志着，事务的结束。并且是一种全部成功的结束。回滚事务？ 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件 回滚事务标志着，事务的结束。并且是一种全部失败的结束。 ![image-20220511113015276](MySQL .assets&#x2F;image-20220511113015276.png) 提交事务、回滚事务1234567891011121314151617提交事务：commit; 语句回滚事务：rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）事务对应的英语单词是：transaction测试一下，在mysql当中默认的事务行为是怎样的？ mysql默认情况下是支持自动提交事务的。（自动提交） 什么是自动提交？ 每执行一条DML语句，则提交一次！ 这种自动提交实际上是不符合我们的开发习惯，因为一个业务 通常是需要多条DML语句共同执行才能完成的，为了保证数据 的安全，必须要求同时成功之后再提交，所以不能执行一条 就提交一条。怎么将mysql的自动提交机制关闭掉呢？ 先执行这个命令：start transaction; 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182演示事务： ---------------------------------回滚事务---------------------------------------- mysql&gt; use bjpowernode; Database changed mysql&gt; select * from dept_bak; Empty set (0.00 sec) mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from dept_bak; +--------+-------+------+ | DEPTNO | DNAME | LOC | +--------+-------+------+ | 10 | abc | tj | | 10 | abc | tj | +--------+-------+------+ 2 rows in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from dept_bak; Empty set (0.00 sec) ---------------------------------提交事务---------------------------------------- mysql&gt; use bjpowernode; Database changed mysql&gt; select * from dept_bak; +--------+-------+------+ | DEPTNO | DNAME | LOC | +--------+-------+------+ | 10 | abc | bj | +--------+-------+------+ 1 row in set (0.00 sec) mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into dept_bak values(20,&#x27;abc Query OK, 1 row affected (0.00 sec) mysql&gt; insert into dept_bak values(20,&#x27;abc Query OK, 1 row affected (0.00 sec) mysql&gt; insert into dept_bak values(20,&#x27;abc Query OK, 1 row affected (0.00 sec) mysql&gt; commit; Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from dept_bak; +--------+-------+------+ | DEPTNO | DNAME | LOC | +--------+-------+------+ | 10 | abc | bj | | 20 | abc | tj | | 20 | abc | tj | | 20 | abc | tj | +--------+-------+------+ 4 rows in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from dept_bak; +--------+-------+------+ | DEPTNO | DNAME | LOC | +--------+-------+------+ | 10 | abc | bj | | 20 | abc | tj | | 20 | abc | tj | | 20 | abc | tj | +--------+-------+------+ 4 rows in set (0.00 sec) 事务四个特性123456789101112131415A：原子性 说明事务是最小的工作单元。不可再分。C：一致性 所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败， 以保证数据的一致性。I：隔离性 A事务和B事务之间具有一定的隔离。 教室A和教室B之间有一道墙，这道墙就是隔离性。 A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？D：持久性 事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据 保存到硬盘上！ 事务的隔离性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的隔离级别。这道墙越厚，表示隔离级别就越高。事务和事务之间的隔离级别有哪些呢？4个级别读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》 什么是读未提交？ 事务A可以读取到事务B未提交的数据。 这种隔离级别存在的问题就是： 脏读现象！(Dirty Read) 我们称读到了脏数据。 这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！读已提交：read committed《提交之后才能读到》 什么是读已提交？ 事务A只能读取到事务B提交之后的数据。 这种隔离级别解决了什么问题？ 解决了脏读的现象。 这种隔离级别存在什么问题？ 不可重复读取数据。 什么是不可重复读取数据呢？ 在事务开启之后，第一次读到的数据是3条，当前事务还没有 结束，可能第二次再读取的时候，读到的数据是4条，3不等于4 称为不可重复读取。 这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。 oracle数据库默认的隔离级别是：read committed可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》 什么是可重复读取？ 事务A开启之后，不管是多久，每一次在事务A中读取到的数据 都是一致的。即使事务B将数据已经修改，并且提交了，事务A 读取到的数据还是没有发生改变，这就是可重复读。 可重复读解决了什么问题？ 解决了不可重复读取数据。 可重复读存在的问题是什么？ 可以会出现幻影读。 每一次读取到的数据都是幻象。不够真实！ 早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！ 读到的是假象。不够绝对的真实。 mysql中默认的事务隔离级别就是这个！！！！！！！！！！！序列化/串行化：serializable（最高的隔离级别） 这是最高隔离级别，效率最低。解决了所有的问题。 这种隔离级别表示事务排队，不能并发！ synchronized，线程同步（事务同步） 每一次读取到的数据都是最真实的，并且效率是最低的。查看隔离级别：SELECT @@tx_isolation+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+mysql默认的隔离级别 验证隔离级别： 1.read uncommitted ![image-20220511120806176](MySQL .assets&#x2F;image-20220511120806176.png) 2.read committed ![image-20220511121102017](MySQL .assets&#x2F;image-20220511121102017.png) 3.repeatable read ![image-20220511121315245](MySQL .assets&#x2F;image-20220511121315245.png) 4.serializable ![image-20220511121736463](MySQL .assets&#x2F;image-20220511121736463.png) 事物B会卡住直到事物A提交结束，才执行。 索引（index）12345678910111213141516171819202122232425262728293031323334什么是索引？索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。对于一本字典来说，查找某个汉字有两种方式： 第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。 效率比较低。 第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个 位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过 索引检索，效率较高。 select * from t_user where name = &#x27;jack&#x27;;以上的这条SQL语句会去name字段上扫描，为什么？ 因为查询条件是：name=&#x27;jack&#x27;如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。MySQL在查询方面主要就是两种方式： 第一种方式：全表扫描 第二种方式：根据索引检索。注意： 在实际中，汉语字典前面的目录是排序的，按照a b c d e f....排序， 为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围 其实就是扫描某个区间罢了！） 在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet 数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。 遵循左小右大原则存放。采用中序遍历方式遍历取数据。 实现原理1234567891011121314151617181920假设有一张用户表：t_userid(PK) name 每一行记录在硬盘上都有物理存储编号----------------------------------------------------------------------------------100 zhangsan 0x1111120 lisi 0x222299 wangwu 0x888888 zhaoliu 0x9999101 jack 0x666655 lucy 0x5555130 tom 0x7777提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree） ![image-20220511153441061](MySQL .assets&#x2F;image-20220511153441061.png) 添加索引的条件1234567什么条件下，我们会考虑给字段添加索引呢？条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。 索引的创建和删除12345678创建索引： mysql&gt; create index emp_ename_index on emp(ename); 给emp表的ename字段添加索引，起名：emp_ename_index删除索引： mysql&gt; drop index emp_ename_index on emp; 将emp表上的emp_ename_index索引对象删除。 是否使用索引进行检索123456789101112131415161718191.5、在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？mysql&gt; explain select * from emp where ename = &#x27;KING&#x27;;+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+扫描14条记录：说明没有使用索引。type=ALLmysql&gt; create index emp_ename_index on emp(ename);mysql&gt; explain select * from emp where ename = &#x27;KING&#x27;;+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+| 1 | SIMPLE | emp | ref | emp_ename_index | emp_ename_index | 33 | const | 1 | Using where |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+ 索引失效的情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677索引有失效的时候，什么时候索引失效呢？失效的第1种情况： select * from emp where ename like &#x27;%T&#x27;; ename上即使添加了索引，也不会走索引，为什么？ 原因是因为模糊匹配当中以“%”开头了！ 尽量避免模糊查询的时候以“%”开始。 这是一种优化的手段/策略。 mysql&gt; explain select * from emp where ename like &#x27;%T&#x27;; +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第2种情况： 使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有 索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个 字段上的索引也会失效。所以这就是为什么不建议使用or的原因。 mysql&gt; explain select * from emp where ename = &#x27;KING&#x27; or job = &#x27;MANAGER&#x27;; +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+ | 1 | SIMPLE | emp | ALL | emp_ename_index | NULL | NULL | NULL | 14 | Using where | +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+失效的第3种情况： 使用复合索引的时候，没有使用左侧的列查找，索引失效 什么是复合索引？ 两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。 create index emp_job_sal_index on emp(job,sal); mysql&gt; explain select * from emp where job = &#x27;MANAGER&#x27;; +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+ | 1 | SIMPLE | emp | ref | emp_job_sal_index | emp_job_sal_index | 30 | const | 3 | Using where | +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+ mysql&gt; explain select * from emp where sal = 800; +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第4种情况： 在where当中索引列参加了运算，索引失效。 mysql&gt; create index emp_sal_index on emp(sal); explain select * from emp where sal = 800; +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+ | 1 | SIMPLE | emp | ref | emp_sal_index | emp_sal_index | 9 | const | 1 | Using where | +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+ mysql&gt; explain select * from emp where sal+1 = 800; +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第5种情况： 在where当中索引列使用了函数 explain select * from emp where lower(ename) = &#x27;smith&#x27;; +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ | 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | Using where | +----+-------------+-------+------+---------------+------+---------+------+------+-------------+ 索引分类12345678单一索引：一个字段上添加索引。复合索引：两个字段或者更多的字段上添加索引。主键索引：主键上添加索引。唯一性索引：具有unique约束的字段上添加索引。.....注意：唯一性比较弱的字段上添加索引用处不大。 视图 什么是视图？ 1视图：站在不同的角度去看待同一份数据。 视图创建和删除12345678创建视图对象： create view dept2_view as select * from dept2;删除视图对象： drop view dept2_view;注意：只有DQL语句才能以view的形式创建。 create view view_name as 这里的语句必须是DQL语句; 视图的用途12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152《方便，简化开发，利于维护》我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#x27;SALES&#x27;, &#x27;BEIJING&#x27;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON || 60 | SALES | BEIJING |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？ 可以把这条复杂的SQL语句以视图对象的形式新建。 在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。 并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。再提醒一下： 视图对应的语句只能是DQL语句。 但是视图对象创建完成之后，可以对视图进行增删改查等操作。小插曲： 增删改查，又叫做：CRUD。 CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。 一般都说CRUD。 C:Create（增） R:Retrieve（查：检索） U:Update（改） D:Delete（删） DBA常用命令12345678910111213141516重点掌握： 数据的导入和导出（数据的备份） 其它命令了解一下即可。数据导出？ 注意：在windows的dos命令窗口中： mysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123456 可以导出指定的表吗？ mysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot -p123456数据导入？ 注意：需要先登录到mysql数据库服务器上。 然后创建数据库：create database bjpowernode; 使用数据库：use bjpowernode 然后初始化数据库：source D:\\bjpowernode.sql 数据库设计三范式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143什么是数据库设计范式？数据库表的设计依据。教你怎么进行数据库表的设计。数据库设计范式共有？3个。第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。声明：三范式是面试官经常问的，所以一定要熟记在心！设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。第一范式最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。学生编号 学生姓名 联系方式------------------------------------------1001 张三 zs@gmail.com,13599999991002 李四 ls@gmail.com,136999999991001 王五 ww@163.net,13488888888以上是学生表，满足第一范式吗？ 不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话学生编号(pk) 学生姓名 邮箱地址 联系电话----------------------------------------------------1001 张三 zs@gmail.com 13599999991002 李四 ls@gmail.com 136999999991003 王五 ww@163.net 13488888888第二范式：建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。学生编号 学生姓名 教师编号 教师姓名----------------------------------------------------1001 张三 001 王老师1002 李四 002 赵老师1003 王五 001 王老师1001 张三 002 赵老师这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）这是非常典型的：多对多关系！分析以上的表是否满足第一范式？ 不满足第一范式。怎么满足第一范式呢？修改学生编号+教师编号(pk) 学生姓名 教师姓名----------------------------------------------------1001 001 张三 王老师1002 002 李四 赵老师1003 001 王五 王老师1001 002 张三 赵老师学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？ 不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。 产生部分依赖有什么缺点？ 数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。为了让以上的表满足第二范式，你需要这样设计： 使用三张表来表示多对多的关系！！！！ 学生表 学生编号(pk) 学生名字 ------------------------------------ 1001 张三 1002 李四 1003 王五 教师表 教师编号(pk) 教师姓名 -------------------------------------- 001 王老师 002 赵老师 学生教师关系表 id(pk) 学生编号(fk) 教师编号(fk) ------------------------------------------------------ 1 1001 001 2 1002 002 3 1003 001 4 1001 002背口诀： 多对多怎么设计？ 多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！第三范式第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。学生编号（PK） 学生姓名 班级编号 班级名称--------------------------------------------------------- 1001 张三 01 一年一班 1002 李四 02 一年二班 1003 王五 03 一年三班 1004 赵六 03 一年三班以上表的设计是描述：班级和学生的关系。很显然是1对多关系！一个教室中有多个学生。分析以上表是否满足第一范式？ 满足第一范式，有主键。分析以上表是否满足第二范式？ 满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。分析以上表是否满足第三范式？ 第三范式要求：不要产生传递依赖！ 一年一班依赖01，01依赖1001，产生了传递依赖。 不符合第三范式的要求。产生了数据的冗余。那么应该怎么设计一对多呢？ 班级表：一 班级编号(pk) 班级名称 ---------------------------------------- 01 一年一班 02 一年二班 03 一年三班 学生表：多 学生编号（PK） 学生姓名 班级编号(fk) ------------------------------------------- 1001 张三 01 1002 李四 02 1003 王五 03 1004 赵六 03 背口诀： 一对多，两张表，多的表加外键！！！！！！！！！！！！ 总结表的设计123456789101112131415161718192021222324252627282930313233一对多： 一对多，两张表，多的表加外键！！！！！！！！！！！！多对多： 多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！一对一：一对一放到一张表中不就行了吗？为啥还要拆分表？在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。一对一怎么设计？ 没有拆分表之前：一张表 t_user id login_name login_pwd real_name email address........ --------------------------------------------------------------------------- 1 zhangsan 123 张三 zhangsan@xxx 2 lisi 123 李四 lisi@xxx ... 这种庞大的表建议拆分为两张： t_login 登录信息表 id(pk) login_name login_pwd --------------------------------- 1 zhangsan 123 2 lisi 123 t_user 用户详细信息表 id(pk) real_name email address........ login_id(fk+unique) ----------------------------------------------------------------------------------------- 100 张三 zhangsan@xxx 1 200 李四 lisi@xxx 2 口诀：一对一，外键唯一！！！！！！！！！！ 嘱咐123456789101112数据库设计三范式是理论上的。实践和理论有的时候有偏差。最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。面试的时候把这句话说上：他就不会认为你是初级程序员了！ 练习1、取得每个部门最高薪水的人员名称第一步：取得每个部门最高薪水(按照部门编号分组，找出每一组最大值)mysql&gt; select deptno,max(sal) as maxsal from emp group by deptno;+——–+———+| deptno | maxsal |+——–+———+| 10 | 5000.00 || 20 | 3000.00 || 30 | 2850.00 |+——–+———+第二步：将以上的查询结果当做一张临时表t，t和emp表连接，条件：t.deptno &#x3D; e.deptno and t.maxsal &#x3D; e.salselect e.ename, t.*from emp ejoin (select deptno,max(sal) as maxsal from emp group by deptno) ton t.deptno &#x3D; e.deptno and t.maxsal &#x3D; e.sal; +——-+——–+———+| ename | deptno | maxsal |+——-+——–+———+| BLAKE | 30 | 2850.00 || SCOTT | 20 | 3000.00 || KING | 10 | 5000.00 || FORD | 20 | 3000.00 |+——-+——–+———+ 2、哪些人的薪水在部门的平均薪水之上第一步：找出每个部门的平均薪水select deptno,avg(sal) as avgsal from emp group by deptno;+——–+————-+| deptno | avgsal |+——–+————-+| 10 | 2916.666667 || 20 | 2175.000000 || 30 | 1566.666667 |+——–+————-+第二步：将以上查询结果当做t表，t和emp表连接条件：部门编号相同，并且emp的sal大于t表的avgsalselect t.*, e.ename, e.salfrom emp ejoin (select deptno,avg(sal) as avgsal from emp group by deptno) ton e.deptno &#x3D; t.deptno and e.sal &gt; t.avgsal;+——–+————-+——-+———+| deptno | avgsal | ename | sal |+——–+————-+——-+———+| 30 | 1566.666667 | ALLEN | 1600.00 || 20 | 2175.000000 | JONES | 2975.00 || 30 | 1566.666667 | BLAKE | 2850.00 || 20 | 2175.000000 | SCOTT | 3000.00 || 10 | 2916.666667 | KING | 5000.00 || 20 | 2175.000000 | FORD | 3000.00 |+——–+————-+——-+———+ 3、取得部门中（所有人的）平均的薪水等级 平均的薪水等级：先计算每一个薪水的等级，然后找出薪水等级的平均值。 平均薪水的等级：先计算平均薪水，然后找出每个平均薪水的等级值。 第一步：找出每个人的薪水等级 emp e和salgrade s表连接。 连接条件：e.sal between s.losal and s.hisal select e.ename,e.sal,e.deptno,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal; +--------+---------+--------+-------+ | ename | sal | deptno | grade | +--------+---------+--------+-------+ | CLARK | 2450.00 | 10 | 4 | | KING | 5000.00 | 10 | 5 | | MILLER | 1300.00 | 10 | 2 | | SMITH | 800.00 | 20 | 1 | | ADAMS | 1100.00 | 20 | 1 | | SCOTT | 3000.00 | 20 | 4 | | FORD | 3000.00 | 20 | 4 | | JONES | 2975.00 | 20 | 4 | | MARTIN | 1250.00 | 30 | 2 | | TURNER | 1500.00 | 30 | 3 | | BLAKE | 2850.00 | 30 | 4 | | ALLEN | 1600.00 | 30 | 3 | | JAMES | 950.00 | 30 | 1 | | WARD | 1250.00 | 30 | 2 | +--------+---------+--------+-------+ 第二步：基于以上的结果继续按照deptno分组，求grade的平均值。 select e.deptno,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and s.hisal group by e.deptno; +--------+--------------+ | deptno | avg(s.grade) | +--------+--------------+ | 10 | 3.6667 | | 20 | 2.8000 | | 30 | 2.5000 | +--------+--------------+ 4、不准用组函数（Max ），取得最高薪水 第一种：sal降序，limit 1select ename,sal from emp order by sal desc limit 1;+——-+———+| ename | sal |+——-+———+| KING | 5000.00 |+——-+———+ 第二种方案：select max(sal) from emp; 第三种方案：表的自连接select sal from emp where sal not in(select distinct a.sal from emp a join emp b on a.sal &lt; b.sal); +———+| sal |+———+| 5000.00 |+———+ select distinct a.salfrom emp ajoin emp bon a.sal &lt; b.sal a表+———+| sal |+———+| 800.00 || 1600.00 || 1250.00 || 2975.00 || 1250.00 || 2850.00 || 2450.00 || 3000.00 || 5000.00 || 1500.00 || 1100.00 || 950.00 || 3000.00 || 1300.00 |+———+ b表+———+| sal |+———+| 800.00 || 1600.00 || 1250.00 || 2975.00 || 1250.00 || 2850.00 || 2450.00 || 3000.00 || 5000.00 || 1500.00 || 1100.00 || 950.00 || 3000.00 || 1300.00 |+———+ 5、取得平均薪水最高的部门的部门编号 第一种方案：降序取第一个。 第一步：找出每个部门的平均薪水 select deptno,avg(sal) as avgsal from emp group by deptno; +--------+-------------+ | deptno | avgsal | +--------+-------------+ | 10 | 2916.666667 | | 20 | 2175.000000 | | 30 | 1566.666667 | +--------+-------------+ 第二步：降序选第一个。 select deptno,avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1; +--------+-------------+ | deptno | avgsal | +--------+-------------+ | 10 | 2916.666667 | +--------+-------------+ 第二种方案：max 第一步：找出每个部门的平均薪水 select deptno,avg(sal) as avgsal from emp group by deptno; +--------+-------------+ | deptno | avgsal | +--------+-------------+ | 10 | 2916.666667 | | 20 | 2175.000000 | | 30 | 1566.666667 | +--------+-------------+ 第二步：找出以上结果中avgsal最大的值。 select max(t.avgsal) from (select avg(sal) as avgsal from emp group by deptno) t; +---------------+ | max(t.avgsal) | +---------------+ | 2916.666667 | +---------------+ 第三步： select deptno,avg(sal) as avgsal from emp group by deptno having avgsal = (select max(t.avgsal) from (select avg(sal) as avgsal from emp group by deptno) t); +--------+-------------+ | deptno | avgsal | +--------+-------------+ | 10 | 2916.666667 | +--------+-------------+ 6、取得平均薪水最高的部门的部门名称 select d.dname,avg(e.sal) as avgsalfrom emp ejoin dept don e.deptno &#x3D; d.deptnogroup by d.dnameorder by avgsal desclimit 1; +————+————-+| dname | avgsal |+————+————-+| ACCOUNTING | 2916.666667 |+————+————-+ 7、求平均薪水的等级最低的部门的部门名称 平均薪水是800平均薪水是900那么他俩都是1级别。 第一步：找出每个部门的平均薪水select deptno,avg(sal) as avgsal from emp group by deptno;+——–+————-+| deptno | avgsal |+——–+————-+| 10 | 2916.666667 || 20 | 2175.000000 || 30 | 1566.666667 |+——–+————-+ 第二步：找出每个部门的平均薪水的等级以上t表和salgrade表连接，条件：t.avgsal between s.losal and s.hisal select t.*,s.gradefrom (select d.dname,avg(sal) as avgsal from emp e join dept d on e.deptno &#x3D; d.deptno group by d.dname) tjoin salgrade son t.avgsal between s.losal and s.hisal; +————+————-+——-+| dname | avgsal | grade |+————+————-+——-+| SALES | 1566.666667 | 3 || ACCOUNTING | 2916.666667 | 4 || RESEARCH | 2175.000000 | 4 |+————+————-+——-+ select t.*,s.gradefrom (select d.dname,avg(sal) as avgsal from emp e join dept d on e.deptno &#x3D; d.deptno group by d.dname) tjoin salgrade son t.avgsal between s.losal and s.hisalwhere s.grade &#x3D; (select grade from salgrade where (select avg(sal) as avgsal from emp group by deptno order by avgsal asc limit 1) between losal and hisal); +——-+————-+——-+| dname | avgsal | grade |+——-+————-+——-+| SALES | 1566.666667 | 3 |+——-+————-+——-+ 抛开之前的，最低等级你怎么着？ 平均薪水最低的对应的等级一定是最低的. select avg(sal) as avgsal from emp group by deptno order by avgsal asc limit 1; +————-+ | avgsal | +————-+ | 1566.666667 | +————-+ select grade from salgrade where (select avg(sal) as avgsal from emp group by deptno order by avgsal asc limit 1) between losal and hisal; +-------+ | grade | +-------+ | 3 | +-------+ 8、取得比普通员工(员工代码没有在 mgr 字段上出现的) 的最高薪水还要高的领导人姓名 比“普通员工的最高薪水”还要高的一定是领导！ 没毛病！！！！ mysql&gt; select distinct mgr from emp where mgr is not null;+——+| mgr |+——+| 7902 || 7698 || 7839 || 7566 || 7788 || 7782 |+——+员工编号没有在以上范围内的都是普通员工。 第一步：找出普通员工的最高薪水！not in在使用的时候，后面小括号中记得排除NULL。select max(sal) from emp where empno not in(select distinct mgr from emp where mgr is not null);+———-+| max(sal) |+———-+| 1600.00 |+———-+ 第二步：找出高于1600的select ename,sal from emp where sal &gt; (select max(sal) from emp where empno not in(select distinct mgr from emp where mgr is not null));+——-+———+| ename | sal |+——-+———+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+——-+———+ 9、取得薪水最高的前五名员工select ename,sal from emp order by sal desc limit 5;+——-+———+| ename | sal |+——-+———+| KING | 5000.00 || SCOTT | 3000.00 || FORD | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+——-+———+ 10、取得薪水最高的第六到第十名员工select ename,sal from emp order by sal desc limit 5, 5;+——–+———+| ename | sal |+——–+———+| CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 || MARTIN | 1250.00 |+——–+———+ 11、取得最后入职的 5 名员工日期也可以降序，升序。 select ename,hiredate from emp order by hiredate desc limit 5; +--------+------------+ | ename | hiredate | +--------+------------+ | ADAMS | 1987-05-23 | | SCOTT | 1987-04-19 | | MILLER | 1982-01-23 | | FORD | 1981-12-03 | | JAMES | 1981-12-03 | +--------+------------+ 12、取得每个薪水等级有多少员工分组count 第一步：找出每个员工的薪水等级select e.ename,e.sal,s.gradefrom emp ejoin salgrade son e.sal between s.losal and s.hisal;+——–+———+——-+| ename | sal | grade |+——–+———+——-+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+——–+———+——-+ 第二步：继续按照grade分组统计数量select s.grade ,count(*)from emp ejoin salgrade son e.sal between s.losal and s.hisalgroup by s.grade; +——-+———-+| grade | count(*) |+——-+———-+| 1 | 3 || 2 | 3 || 3 | 2 || 4 | 5 || 5 | 1 |+——-+———-+ 13、面试题：有 3 个表 S(学生表)，C（课程表），SC（学生选课表）S（SNO，SNAME）代表（学号，姓名）C（CNO，CNAME，CTEACHER）代表（课号，课名，教师）SC（SNO，CNO，SCGRADE）代表（学号，课号，成绩）问题：1，找出没选过“黎明”老师的所有学生姓名。2，列出 2 门以上（含2 门）不及格学生姓名及平均成绩。3，即学过 1 号课程又学过 2 号课所有学生的姓名。 14、列出所有员工及领导的姓名select a.ename ‘员工’, b.ename ‘领导’from emp aleft join emp bon a.mgr &#x3D; b.empno; +——–+——-+| 员工 | 领导 |+——–+——-+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+——–+——-+ 15、列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称emp a 员工表emp b 领导表a.mgr &#x3D; b.empno and a.hiredate &lt; b.hiredate select a.ename ‘员工’, a.hiredate, b.ename ‘领导’, b.hiredate, d.dnamefrom emp ajoin emp bon a.mgr &#x3D; b.empnojoin dept don a.deptno &#x3D; d.deptnowhere a.hiredate &lt; b.hiredate; +——-+————+——-+————+————+| 员工 | hiredate | 领导 | hiredate | dname |+——-+————+——-+————+————+| CLARK | 1981-06-09 | KING | 1981-11-17 | ACCOUNTING || SMITH | 1980-12-17 | FORD | 1981-12-03 | RESEARCH || JONES | 1981-04-02 | KING | 1981-11-17 | RESEARCH || ALLEN | 1981-02-20 | BLAKE | 1981-05-01 | SALES || WARD | 1981-02-22 | BLAKE | 1981-05-01 | SALES || BLAKE | 1981-05-01 | KING | 1981-11-17 | SALES |+——-+————+——-+————+————+ 16、 列出部门名称和这些部门的员工信息, 同时列出那些没有员工的部门 select e.*,d.dnamefrom emp eright join dept don e.deptno &#x3D; d.deptno; +——-+——–+———–+——+————+———+———+——–+————+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | dname |+——-+——–+———–+——+————+———+———+——–+————+| 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 | ACCOUNTING || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | ACCOUNTING || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 | ACCOUNTING || 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 | RESEARCH || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 | RESEARCH || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | RESEARCH || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 | RESEARCH || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 | RESEARCH || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 | SALES || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 | SALES || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 | SALES || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 | SALES || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 | SALES || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 | SALES || NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | OPERATIONS |+——-+——–+———–+——+————+———+———+——–+————+ 17、列出至少有 5 个员工的所有部门按照部门编号分组，计数，筛选出 &gt;&#x3D; 5 select deptnofrom empgroup by deptnohaving count(*) &gt;&#x3D; 5; +——–+| deptno |+——–+| 20 || 30 |+——–+ 18、列出薪金比”SMITH” 多的所有员工信息 select ename,sal from emp where sal &gt; (select sal from emp where ename &#x3D; ‘SMITH’);+——–+———+| ename | sal |+——–+———+| ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+——–+———+ 19、 列出所有”CLERK”( 办事员) 的姓名及其部门名称, 部门的人数select ename,job from emp where job &#x3D; ‘CLERK’;+——–+——-+| ename | job |+——–+——-+| SMITH | CLERK || ADAMS | CLERK || JAMES | CLERK || MILLER | CLERK |+——–+——-+ select e.ename,e.job,d.dnamefrom emp ejoin dept don e.deptno &#x3D; d.deptnowhere e.job &#x3D; ‘CLERK’; +——–+——-+————+| ename | job | dname |+——–+——-+————+| MILLER | CLERK | ACCOUNTING || SMITH | CLERK | RESEARCH || ADAMS | CLERK | RESEARCH || JAMES | CLERK | SALES |+——–+——-+————+ select e.ename,e.job,d.dname,d.deptnofrom emp ejoin dept don e.deptno &#x3D; d.deptnowhere e.job &#x3D; ‘CLERK’; +——–+——-+————+——–+| ename | job | dname | deptno |+——–+——-+————+——–+| MILLER | CLERK | ACCOUNTING | 10 || SMITH | CLERK | RESEARCH | 20 || ADAMS | CLERK | RESEARCH | 20 || JAMES | CLERK | SALES | 30 |+——–+——-+————+——–+ &#x2F;&#x2F;每个部门的人数？select deptno, count(*) as deptcount from emp group by deptno;+——–+———–+| deptno | deptcount |+——–+———–+| 10 | 3 || 20 | 5 || 30 | 6 |+——–+———–+ select t1.,t2.deptcountfrom (select e.ename,e.job,d.dname,d.deptno from emp e join dept d on e.deptno &#x3D; d.deptno where e.job &#x3D; ‘CLERK’) t1join (select deptno, count() as deptcount from emp group by deptno) t2on t1.deptno &#x3D; t2.deptno; +——–+——-+————+——–+———–+| ename | job | dname | deptno | deptcount |+——–+——-+————+——–+———–+| MILLER | CLERK | ACCOUNTING | 10 | 3 || SMITH | CLERK | RESEARCH | 20 | 5 || ADAMS | CLERK | RESEARCH | 20 | 5 || JAMES | CLERK | SALES | 30 | 6 |+——–+——-+————+——–+———–+ 20、列出最低薪金大于 1500 的各种工作及从事此工作的全部雇员人数按照工作岗位分组求最小值。select job,count(*) from emp group by job having min(sal) &gt; 1500; +———–+———-+| job | count(*) |+———–+———-+| ANALYST | 2 || MANAGER | 3 || PRESIDENT | 1 |+———–+———-+ 21、列出在部门”SALES”&lt; 销售部&gt; 工作的员工的姓名, 假定不知道销售部的部门编号. select ename from emp where deptno &#x3D; (select deptno from dept where dname &#x3D; ‘SALES’); +——–+| ename |+——–+| ALLEN || WARD || MARTIN || BLAKE || TURNER || JAMES |+——–+ 22、列出薪金高于公司平均薪金的所有员工, 所在部门, 上级领导, 雇员的工资等级. select e.ename ‘员工’,d.dname,l.ename ‘领导’,s.gradefrom emp ejoin dept don e.deptno &#x3D; d.deptnoleft join emp lon e.mgr &#x3D; l.empnojoin salgrade son e.sal between s.losal and s.hisalwhere e.sal &gt; (select avg(sal) from emp); +——-+————+——-+——-+| 员工 | dname | 领导 | grade |+——-+————+——-+——-+| JONES | RESEARCH | KING | 4 || BLAKE | SALES | KING | 4 || CLARK | ACCOUNTING | KING | 4 || SCOTT | RESEARCH | JONES | 4 || KING | ACCOUNTING | NULL | 5 || FORD | RESEARCH | JONES | 4 |+——-+————+——-+——-+ 23、 列出与”SCOTT” 从事相同工作的所有员工及部门名称select job from emp where ename &#x3D; ‘SCOTT’;+———+| job |+———+| ANALYST |+———+ select e.ename,e.job,d.dnamefrom emp ejoin dept don e.deptno &#x3D; d.deptnowhere e.job &#x3D; (select job from emp where ename &#x3D; ‘SCOTT’)and e.ename &lt;&gt; ‘SCOTT’; +——-+———+———-+| ename | job | dname |+——-+———+———-+| FORD | ANALYST | RESEARCH |+——-+———+———-+ 24、列出薪金等于部门 30 中员工的薪金的其他员工的姓名和薪金.select distinct sal from emp where deptno &#x3D; 30;+———+| sal |+———+| 1600.00 || 1250.00 || 2850.00 || 1500.00 || 950.00 |+———+ select ename,salfrom empwhere sal in(select distinct sal from emp where deptno &#x3D; 30)and deptno &lt;&gt; 30; Empty set (0.00 sec) 25、列出薪金高于在部门 30 工作的所有员工的薪金的员工姓名和薪金. 部门名称select max(sal) from emp where deptno &#x3D; 30;+———-+| max(sal) |+———-+| 2850.00 |+———-+ select e.ename,e.sal,d.dnamefrom emp ejoin dept don e.deptno &#x3D; d.deptnowhere e.sal &gt; (select max(sal) from emp where deptno &#x3D; 30); +——-+———+————+| ename | sal | dname |+——-+———+————+| KING | 5000.00 | ACCOUNTING || JONES | 2975.00 | RESEARCH || SCOTT | 3000.00 | RESEARCH || FORD | 3000.00 | RESEARCH |+——-+———+————+ 26、列出在每个部门工作的员工数量, 平均工资和平均服务期限 没有员工的部门，部门人数是0 select d.deptno, count(e.ename) ecount,ifnull(avg(e.sal),0) as avgsal, ifnull(avg(timestampdiff(YEAR, hiredate, now())), 0) as avgservicetimefrom emp eright join dept don e.deptno &#x3D; d.deptnogroup by d.deptno; +——–+——–+————-+—————-+| deptno | ecount | avgsal | avgservicetime |+——–+——–+————-+—————-+| 10 | 3 | 2916.666667 | 38.0000 || 20 | 5 | 2175.000000 | 35.8000 || 30 | 6 | 1566.666667 | 38.3333 || 40 | 0 | 0.000000 | 0.0000 |+——–+——–+————-+—————-+ 在mysql当中怎么计算两个日期的“年差”，差了多少年？ TimeStampDiff(间隔类型, 前一个日期, 后一个日期) timestampdiff(YEAR, hiredate, now()) 间隔类型： SECOND 秒， MINUTE 分钟， HOUR 小时， DAY 天， WEEK 星期 MONTH 月， QUARTER 季度， YEAR 年 27、 列出所有员工的姓名、部门名称和工资。select e.ename,d.dname,e.salfrom emp ejoin dept don e.deptno &#x3D; d.deptno; +——–+————+———+| ename | dname | sal |+——–+————+———+| CLARK | ACCOUNTING | 2450.00 || KING | ACCOUNTING | 5000.00 || MILLER | ACCOUNTING | 1300.00 || SMITH | RESEARCH | 800.00 || JONES | RESEARCH | 2975.00 || SCOTT | RESEARCH | 3000.00 || ADAMS | RESEARCH | 1100.00 || FORD | RESEARCH | 3000.00 || ALLEN | SALES | 1600.00 || WARD | SALES | 1250.00 || MARTIN | SALES | 1250.00 || BLAKE | SALES | 2850.00 || TURNER | SALES | 1500.00 || JAMES | SALES | 950.00 |+——–+————+———+ 28、列出所有部门的详细信息和人数 select d.deptno,d.dname,d.loc,count(e.ename)from emp eright join dept don e.deptno &#x3D; d.deptnogroup by d.deptno,d.dname,d.loc; +——–+————+———-+—————-+| deptno | dname | loc | count(e.ename) |+——–+————+———-+—————-+| 10 | ACCOUNTING | NEW YORK | 3 || 20 | RESEARCH | DALLAS | 5 || 30 | SALES | CHICAGO | 6 || 40 | OPERATIONS | BOSTON | 0 |+——–+————+———-+—————-+ 29、列出各种工作的最低工资及从事此工作的雇员姓名select job,min(sal) as minsalfrom empgroup by job; +———–+———-+| job | minsal |+———–+———-+| ANALYST | 3000.00 || CLERK | 800.00 || MANAGER | 2450.00 || PRESIDENT | 5000.00 || SALESMAN | 1250.00 |+———–+———-+ emp e和以上t连接 select e.ename,t.*from emp ejoin (select job,min(sal) as minsal from emp group by job) ton e.job &#x3D; t.job and e.sal &#x3D; t.minsal; +——–+———–+———+| ename | job | minsal |+——–+———–+———+| SMITH | CLERK | 800.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 || CLARK | MANAGER | 2450.00 || SCOTT | ANALYST | 3000.00 || KING | PRESIDENT | 5000.00 || FORD | ANALYST | 3000.00 |+——–+———–+———+ 30、列出各个部门的 MANAGER( 领导) 的最低薪金select deptno, min(sal)from empwhere job &#x3D; ‘MANAGER’group by deptno; +——–+———-+| deptno | min(sal) |+——–+———-+| 10 | 2450.00 || 20 | 2975.00 || 30 | 2850.00 |+——–+———-+ 31、列出所有员工的 年工资, 按 年薪从低到高排序 select ename,(sal + ifnull(comm,0)) * 12 as yearsalfrom emporder by yearsal asc; +——–+———-+| ename | yearsal |+——–+———-+| SMITH | 9600.00 || JAMES | 11400.00 || ADAMS | 13200.00 || MILLER | 15600.00 || TURNER | 18000.00 || WARD | 21000.00 || ALLEN | 22800.00 || CLARK | 29400.00 || MARTIN | 31800.00 || BLAKE | 34200.00 || JONES | 35700.00 || FORD | 36000.00 || SCOTT | 36000.00 || KING | 60000.00 |+——–+———-+ 32、求出员工领导的薪水超过3000的员工名称与领导 select a.ename ‘员工’,b.ename ‘领导’from emp ajoin emp bon a.mgr &#x3D; b.empnowhere b.sal &gt; 3000; +——-+——+| 员工 | 领导 |+——-+——+| JONES | KING || BLAKE | KING || CLARK | KING |+——-+——+ 33、求出部门名称中, 带’S’字符的部门员工的工资合计、部门人数 select d.deptno,d.dname,d.loc,count(e.ename),ifnull(sum(e.sal),0) as sumsalfrom emp eright join dept don e.deptno &#x3D; d.deptnowhere d.dname like ‘%S%’group by d.deptno,d.dname,d.loc; +——–+————+———+—————-+———-+| deptno | dname | loc | count(e.ename) | sumsal |+——–+————+———+—————-+———-+| 20 | RESEARCH | DALLAS | 5 | 10875.00 || 30 | SALES | CHICAGO | 6 | 9400.00 || 40 | OPERATIONS | BOSTON | 0 | 0.00 |+——–+————+———+—————-+———-+ 34、给任职日期超过 30 年的员工加薪 10%. update emp set sal &#x3D; sal * 1.1 where timestampdiff(YEAR, hiredate, now()) &gt; 30;","tags":"mysql"},{"title":"JSP","url":"/2023/10/12/JSP/","text":"JSP已经过时的技术，但是还是有必要了解一些，因为现在仍然有可能在维护以前的旧项目。 1、什么是jsp，他有什么用？1234567891011121314jsp全称是javaserverpages。java的服务器页面。jsp的主要作用是代替Servlet程序回传html页面的数据。因为Servlet程序回传html页面数据是一件非常繁琐的事情，开发成本和维护成本都极高。直接在webapp目录下创建jsp页面jsp页面和html页面一样，都是存放在webapp目录下，访问也跟访问html页面一样比如：在web目录下有如下的文件：web目录 a.html 访问地址是====&gt;http://ip:port/工程路径/a.html b.jsp 访问地址是====&gt;http://ip:port/工程路径/b.jsp 2、jsp的本质是什么？123jsp页面的本质是一个Servlet程序当我们第一次访问jsp页面的时候，Tomcat服务器会帮我们吧jsp页面翻译成为一个java源文件，并且对它进行翻译成为.class字节码程序，我们打开java源文件不难发现其里面内容是： 总结：通过翻译的java源代码我们就可以得到结果，jsp就是Servlet程序 大家也可以去观察翻译出来的Servlet程序的源代码，不难发现，其底层实现也是通过输出流，把html页面数据回传给客户端的。 3、jsp的三种语法a）jsp头部的page指令123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;jsp的page指令可以修改jsp页面中的一些重要属性，或者行为1、language属性：表示jsp翻译后是什么语言文件，暂时只支持java语言2、contentType属性，表示jsp返回的数据类型是什么，也是源码中response.setContentType()参数值3、pageEncoding属性：表示当前jsp页面文件本身的字符集4、import属性：跟java源代码一样，用于导包导类===================两个属性是给out输出流使用的===========================5、autoFlush属性：设置当out输出流缓冲区满了之后，是否自动刷新缓冲区，默认值是true56、buffer属性：设置缓冲区的大小，默认值是8kb不建议修改这两个属性，当out缓冲区满了之后不能自动刷新，就会报错---&gt;缓冲区溢出错误=================================================7、errorPage属性：设置当jsp页面运行时出错自动跳转到错误页面的路径&lt;!--errorPage表示错误后自动跳转去的路径&lt;br/&gt;这个路径一般都是以斜杠打头，它表示请求地址为http://ip:port/工程路径/映射到代码的webapp目录--&gt;8、isErrorPage属性：设置当前jsp页面是否错误信息页面，默认是false，如果是true可以获取异常信息。9、session属性：设置访问当前jsp页面，是否会创建HttpSession对象，默认是true。10、extends属性：设置jsp翻译出来的java类默认继承谁 b)jsp中的常用脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546一、声明脚本（极少使用）声明脚本的格式是：&lt;%! 声明java代码 %&gt;作用：可以给jsp翻译出来的java类定义属性和方法甚至是静态代码块，内部类等等。练习：1、声明类属性2、声明static静态代码块3、声明类方法4、声明内部类二、表达式脚本（常用） 表达式脚本的格式是：&lt;%=表达式%&gt; 表达式脚本的作用是：在jsp页面上输出数据 练习： 1、输出整型 2、输出浮点型 3、输出字符串 4、输出对象表达式脚本的特点：1、所以的表达式脚本都会被翻译到_jspService()方法中2、表达式脚本都会被翻译成为out.print()输出到页面上3、由于表达式脚本翻译的内容都在_jspService()方法中所以_jspService()方法中的对象都可以直接使用4、表达式脚本中的表达式不能以分号结束。 三、代码脚本代码脚本的格式是：&lt;% java 语句%&gt;代码脚本的作用是：可以在jsp页面中，编写我们自己需要的功能(写的是java语句)。练习： 1、代码脚本--if语句 2、代码脚本--for 循环语句 3、翻译后java文件中_jspService方法内的代码都可以写代码脚本的特点是：1、代码脚本翻译之后都在_jspService中2、代码脚本由于翻译到_jspService()方法中，所以在jspService()方法中的现有对象都可以直接使用3、还可以由多个代码脚本块组合完成一个完成的java语句4、代码脚本和表达式脚本可以结合使用 c）jsp中的三种注释1234567891011121314151617一、html注释&lt;!--这是html注释--&gt;html注释会被翻译到java源代码中。在_jspService方法里，以out.writer输出到客户端。二、java注释一般写在声明脚本或代码脚本中&lt;% //单行java注释 /* 多行java注释 */%&gt;java注释会被翻译到java源代码中三、jsp注释&lt;%--这是jsp注释--%&gt;jsp注释可以注掉jsp页面中的所有代码。 4、jsp九大内置对象jsp中的内置对象，是指tomcat在翻译jsp页面成为Servlet源代码后，内部提供的九大对象，叫内置对象。 123456789request 请求对象response 响应对象pageContext jsp的上下文对象session 会话对象application ServletContext对象config ServletConfig对象out jsp输出对象page 指向当前jsp的对象exception 异常对象 需要将isErrorPage设置为true 5、jsp四大域对象四个域对象分别是： request（HttpServletResquest类）一次请求内有效 application（ServletContext类）整个web工程范围内都有效（只要web工程不停止，数据都在） pageContext（PageContextImpl类）当前jsp页面范围内都有效 session（HttpSession类）一个会话范围内有效（打开浏览器范文服务器，直到关闭服务器） 123456域对象是可以像Map一样存取数据的对象，四个域对象功能一样，不同的是它们对数据的存储范围。虽然四个域对象都可以存取数据，但在使用上它们是有优先顺序的。四个域在使用的时候，优先顺序分别是，它们从小到大的范围的顺序pageContext--&gt;request--&gt;session--&gt;application scope页面 123456789101112131415161718192021222324252627282930&lt;%-- Created by IntelliJ IDEA. User: xiaolin Date: 2022/7/22 Time: 15:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;scope.jsp页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;scope.jsp页面&lt;/h1&gt;&lt;% //往四个域中都分别保存了数据 pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;); request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;);%&gt;pageContext是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;request是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;session是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;application是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;&lt;% request.getRequestDispatcher(&quot;/scope2.jsp&quot;).forward(request,response);%&gt;&lt;/body&gt;&lt;/html&gt; scope2页面 12345678910111213141516171819202122&lt;%-- Created by IntelliJ IDEA. User: xiaolin Date: 2022/7/22 Time: 15:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;scope.jsp2页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;scope.jsp2页面&lt;/h1&gt;pageContext是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;request是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;session是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;application是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 6、jsp中的out输出和response.getWriter输出的区别response中表示响应，我们经常用于设置返回给客户端的内容（输出） out也是给用户做输出使用的 由于jsp翻译之后，底层源代码都是使用out来进行输出，所以一般情况下，我们在jsp页面中统一使用out来进行输出，避免打乱页面输出内容的顺序。 out.write()输出字符串没有问题 out.print()输出任意数据没有问题（都可以转换为字符串后调用write输出） 深入源码，浅出结论：在jsp页面中，可以统一使用out.print()来进行输出 7、jsp的常用标签a)jsp静态包含123456789&lt;%--&lt;%@ include file=&quot;&quot;%&gt;就是静态包含file属性指定你要包含的jsp页面的路径地址中第一个斜杠/ 表示http://ip:port/工程路径/ 映射到代码中的webapp目录下静态包含的特点：1、静态包含不会翻译被包含的jsp页面2、静态包含其实是把包含jsp页面的代码拷贝到包含的位置执行输出。--%&gt; b）jsp动态包含底层原理 1234567891011&lt;%--&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;这是动态包含page属性是指定你要包含的jsp页面的路径动态包含也可以像静态包含一样，把被包含的内容执行输出到包含位置动态包含的特点：1、动态包含会翻译被包含的jsp页面为java代码2、动态包含底层代码使用如下代码去调用被包含的jsp页面执行输出：JSPRuntimeLibrary.include(request,response,&quot;/include/foot.jsp&quot;,out,false);3、动态包含，还可以传递参数--%&gt; c)jsp标签-转发12345&lt;%--&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;是请求装标签，他的功能是请求转换page属性设置请求转发的路径--%&gt;&lt;jsp:forward page=&quot;/scope2.jsp&quot;&gt;&lt;/jsp:forward&gt; jsp的练习题练习一、在jsp页面中输出九九乘法口诀表 练习二、jsp输出一个表格，里面有10个学生信息 9、什么是Listener监听器1231、Listener监听器是Javaweb的三大组件之一，Javaweb的三大组件：Servlet程序，Filter过滤器，Listener监听器2、Listener它是JavaEE的规范，就是接口3、监听器的作用是，监听某种事物的变化，然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ServletContextListener监听器 1234567891011121314它可以监听servletContext对象的创建和销毁ServletContext对象在web工程启动时创建，在web工程结束时销毁监听到创建和销毁之后都会分别调用ServletContextListener监听器的方法反馈两个方法分别是：public interface ServletContextListener extends EventListener &#123;//在ServletContext对象创建之后马上调用，执行初始化 default void contextInitialized(ServletContextEvent sce) &#123; &#125;//在ServletContext对象销毁之后调用 default void contextDestroyed(ServletContextEvent sce) &#123; &#125;&#125; 如何使用ServletContextListener监听器监听ServletContext对象。 步骤如下： 1231、编写一个类去实现ServletContextListener2、实现其两个回调方法3、到web.xml去配置监听器","tags":"jsp"},{"title":"JSON、AJAX、i18n","url":"/2023/10/12/JSON、AJAX、i18n/","text":"JSON、AJAX、i18n1、什么是JSON？ 1.1、JSON在JavaScript中的使用1.1.1、JSON的定义1json是由键值对组成，并且由花括号（大括号）包围，每个键由引号引起来，键和值之间使用冒号进行分割，多组键值对之间进行逗号分隔。 123456789101112131415161718// json的定义var jsonobj = &#123; &quot;key1&quot; : 12, &quot;key2&quot; : &quot;abc&quot;, &quot;key3&quot; : true, &quot;key4&quot; : [11,&quot;arr&quot;,false], &quot;key5&quot; : &#123; &quot;key5_1&quot; : 551, &quot;key5_2&quot; : &quot;key5_2value&quot; &#125;, &quot;key6&quot; : [&#123; &quot;key6_1_1&quot;: 6611, &quot;key6_1_2&quot;: 6612 &#125;,&#123; &quot;key6_2_1&quot;: 6621, &quot;key6_2_2&quot;: 6622 &#125;]&#125;; 1.1.2、json的访问json本身是一个对象，json中的key我们可以理解为是对象中的一个属性。json中的key访问就跟访问对象的属性一样，json对象.key 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // json的定义 var jsonobj = &#123; &quot;key1&quot; : 12, &quot;key2&quot; : &quot;abc&quot;, &quot;key3&quot; : true, &quot;key4&quot; : [11,&quot;arr&quot;,false], &quot;key5&quot; : &#123; &quot;key5_1&quot; : 551, &quot;key5_2&quot; : &quot;key5_2value&quot; &#125;, &quot;key6&quot; : [&#123; &quot;key6_1_1&quot;: 6611, &quot;key6_1_2&quot;: 6612 &#125;,&#123; &quot;key6_2_1&quot;: 6621, &quot;key6_2_2&quot;: 6622 &#125;] &#125;; //alert(typeof (jsonobj));//json就是一个对象 // json的访问 // alert(jsonobj.key1); // alert(jsonobj.key2); // alert(jsonobj.key3); // alert(jsonobj.key4); //数组 /*for (var i = 0; i&lt;jsonobj.key4.length;i++)&#123; alert(jsonobj.key4[i]); &#125;*/ //对象中的key //alert(jsonobj.key5.key5_1); //数组中的对象的值 //alert(jsonobj.key6); //取出来每一个都是json对象 var jsonItem = jsonobj.key6[0]; alert(jsonItem.key6_1_1); alert(jsonItem.key6_1_2); var jsonItem2 = jsonobj.key6[1]; alert(jsonItem2.key6_2_1); alert(jsonItem2.key6_2_2); // json对象转字符串 // json字符串转json对象 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1.1.3、json的两个常用方法json的存在有两种形式 一种是，对象的形式存在，我们叫他json对象 一种是，字符串的形式存在，我们叫他json字符串 12一般我们要操作json中的数据的时候，需要json对象的格式一般我们要在客户端和服务器端之间进行数据交换的时候，使用json字符串 JSON.stringify():把json对象转换成为json字符串 JSON.parse()：把json字符串转换成为json对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // json的定义 var jsonobj = &#123; &quot;key1&quot; : 12, &quot;key2&quot; : &quot;abc&quot;, &quot;key3&quot; : true, &quot;key4&quot; : [11,&quot;arr&quot;,false], &quot;key5&quot; : &#123; &quot;key5_1&quot; : 551, &quot;key5_2&quot; : &quot;key5_2value&quot; &#125;, &quot;key6&quot; : [&#123; &quot;key6_1_1&quot;: 6611, &quot;key6_1_2&quot;: 6612 &#125;,&#123; &quot;key6_2_1&quot;: 6621, &quot;key6_2_2&quot;: 6622 &#125;] &#125;; //alert(typeof (jsonobj));//json就是一个对象 // json的访问 // alert(jsonobj.key1); // alert(jsonobj.key2); // alert(jsonobj.key3); // alert(jsonobj.key4); //数组 /*for (var i = 0; i&lt;jsonobj.key4.length;i++)&#123; alert(jsonobj.key4[i]); &#125;*/ //对象中的key //alert(jsonobj.key5.key5_1); //数组中的对象的值 //alert(jsonobj.key6); //取出来每一个都是json对象 // var jsonItem = jsonobj.key6[0]; // alert(jsonItem.key6_1_1); // alert(jsonItem.key6_1_2); // var jsonItem2 = jsonobj.key6[1]; // alert(jsonItem2.key6_2_1); // alert(jsonItem2.key6_2_2); // json对象转字符串 // alert(jsonobj); var jsonObjString = JSON.stringify(jsonobj);//特别像java中对象的toString //alert(jsonObjString); // json字符串转json对象 var jsonStringObj = JSON.parse(jsonObjString); alert(jsonStringObj); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1.2、JSON在java中的使用一、javaBean和json的互转 二、List和json的互转 三、map和json的互转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.lxg.json;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;import com.lxg.pojo.Person;import org.junit.Test;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class JsonTest &#123;// 一、javaBean和json的互转 @Test public void test1()&#123; Person person = new Person(1,&quot;小林&quot;); //创建Gson对象实例 Gson gson = new Gson(); //toJson方法可以把java对象转换成为json字符串 String personJsonString = gson.toJson(person); System.out.println(personJsonString); //fromJson把json字符串转换回java对象 //第一个参数是json字符串，第二个参数是转换为的java实例类型 Person person1 = gson.fromJson(personJsonString, Person.class); System.out.println(person1); &#125;// 二、List和json的互转 @Test public void test2()&#123; List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(new Person(1,&quot;林&quot;)); personList.add(new Person(2,&quot;阿拉&quot;)); Gson gson = new Gson(); //把list转换为json字符串 String s = gson.toJson(personList); System.out.println(s); List&lt;Person&gt; list = gson.fromJson(s, new PersonListType().getType()); System.out.println(list); Person person = list.get(0); System.out.println(person); &#125;// 三、map和json的互转 @Test public void test3()&#123; Map&lt;Integer,Person&gt; map = new HashMap&lt;&gt;(); map.put(1,new Person(1,&quot;lin&quot;)); map.put(2,new Person(2,&quot;lin22&quot;)); Gson gson = new Gson(); String s = gson.toJson(map); System.out.println(s);// Map&lt;Integer,Person&gt; map1 = gson.fromJson(s, new PersonMapType().getType()); Map&lt;Integer,Person&gt; map1 = gson.fromJson(s, new TypeToken&lt;HashMap&lt;Integer,Person&gt;&gt;()&#123;&#125;.getType()); System.out.println(map1); Person p = map1.get(1); System.out.println(p); &#125;&#125; 2、AJAX请求2.1、什么是AJAX请求AJAX即”Asynchronous JavaScript And XML“（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。 ajax是一种浏览器通过js异步发起请求，局部更新页面的技术。 12局部：地址栏不变，原有的组件也不变，只是添加了一些新的内容异步：互不干扰，先执行 2.2、原生AJAX请求的示例：12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //在这里使用JavaScript语言发起Ajax请求，访问服务器AjaxServlet中JavaScriptAjax function ajaxRequest() &#123;// 1、我们首先要创建XMLHttpRequest var xmlhttprequest = new XMLHttpRequest ();// 2、调用open方法设置请求参数 xmlhttprequest.open(&quot;GET&quot;,&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet?action=javaScriptAjax&quot;,true); //4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 xmlhttprequest.onreadystatechange = function () &#123; if(xmlhttprequest.readyState==4 &amp;&amp; xmlhttprequest.status == 200)&#123; var jsonObj = JSON.parse(xmlhttprequest.responseText); //把响应的数据显示在页面上 document.getElementById(&quot;div01&quot;).innerHTML = &quot;编号：&quot;+ jsonObj.id + &quot;,姓名：&quot;+ jsonObj.name; //alert(xmlhttprequest.responseText); &#125; &#125;// 3、调用send方法发送请求 xmlhttprequest.send();// &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt; &lt;div id=&quot;div01&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.3、jQuery中的AJAX请求一、$.ajax 方法 url 表示请求的地址 type 表示请求的类型GET或POST请求 data 表示发送给服务器的数据 格式有两种： name&#x3D;vallue&amp;name&#x3D;value {key:value} success 请求成功，响应的回调函数 dataType 响应的数据类型 常用的数据类型有： text表示纯文本 xml表示xml数据 json表示json对象 1234567891011121314151617// ajax请求$(&quot;#ajaxBtn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;, //data:&quot;action=jQueryAjax&quot;, data:&#123;action : &quot;jQueryAjax&quot;&#125;, type:&quot;GET&quot;, success:function (data) &#123; //alert(&quot;服务器返回的数据是：&quot;+data); //var jsonObj = JSON.parse(data); $(&quot;#msg&quot;).html(&quot;编号：&quot;+data.id+&quot;,姓名：&quot;+data.name); &#125;, dataType:&quot;json&quot; &#125;); alert(&quot;ajax btn&quot;);&#125;); 二、$.get 方法 url 表示请求的地址 type 返回的数据类型 data 表示发送给服务器的数据 callback 成功的回调函数 12345678910111213141516171819202122232425262728// ajax--get请求$(&quot;#getBtn&quot;).click(function()&#123; $.get( &quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;, &quot;action=jQueryGet&quot;, function (data) &#123; $(&quot;#msg&quot;).html(&quot;get编号：&quot;+data.id+&quot;,姓名：&quot;+data.name); &#125;, &quot;json&quot; ); alert(&quot; get btn &quot;); &#125;);// ajax--post请求$(&quot;#postBtn&quot;).click(function()&#123; // post请求 $.post( &quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;, &quot;action=jQueryPost&quot;, function (data) &#123; $(&quot;#msg&quot;).html(&quot;post编号：&quot;+data.id+&quot;,姓名：&quot;+data.name); &#125;, &quot;json&quot; ); alert(&quot;post btn&quot;); &#125;); 三、$.getJson url data callback 1234567891011// ajax--getJson请求$(&quot;#getJSONBtn&quot;).click(function()&#123; // 调用 $.getJSON( &quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;, &quot;action=jQueryGetJSON&quot;, function (data) &#123; $(&quot;#msg&quot;).html(&quot;JSON编号：&quot;+data.id+&quot;,姓名：&quot;+data.name); &#125;); alert(&quot;getJSON btn&quot;);&#125;); 表单序列化serialize() 这个方法可以把表单中所有表单项的内容都获取到，并以name&#x3D;value&amp;name&#x3D;value的形式进行拼接 1234567891011121314 // ajax请求 $(&quot;#submit&quot;).click(function()&#123; // 把参数序列化 //alert($(&quot;#form01&quot;).serialize()); $.getJSON( &quot;http://localhost:8080/16_json_ajax_i18n/ajaxServlet&quot;, &quot;action=jQuerySerialize&amp;&quot;+$(&quot;#form01&quot;).serialize(), function (data) &#123; $(&quot;#msg&quot;).html(&quot;Serialize编号：&quot;+data.id+&quot;,姓名：&quot;+data.name); &#125;); alert(&quot;serialize()&quot;); &#125;); &#125;); 3、i18n国际化（了解内容）3.1、什么是i18n国际化？","tags":"ajax json i18n"},{"title":"jQuery-动画","url":"/2023/10/12/JQuery动画/","text":"12、JQuery动画12.1、基本动画show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 123以上动画都可以添加参数 1、第一个参数是动画执行时长，以毫秒为单位 2、第二个参数是动画的回调函数（动画完成后自动调用的函数） 12.2、淡入淡出动画fadeln() 淡入，慢慢可见 fadeOut() 淡出，慢慢消失 fadeTo() 在指定时长内慢慢的将透明度修改到指定的值，0透明，1可见，0.5半透明。 fadeToggle() 淡入&#x2F;淡出 切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) */ $(function()&#123; //显示 show() $(&quot;#btn1&quot;).click(function()&#123; $(&quot;#div1&quot;).show(2000,function () &#123; alert(&quot;show动画完毕&quot;); &#125;); &#125;); //隐藏 hide() $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#div1&quot;).hide(1000,function () &#123; alert(&quot;hide动画完毕&quot;); &#125;); &#125;); //切换 toggle() $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#div1&quot;).toggle(1000,function () &#123; alert(&quot;toggle动画完毕&quot;); &#125;); &#125;); /*var abc = function () &#123; $(&quot;#div1&quot;).toggle(1000,abc); &#125; abc();*/ //淡入 fadeIn() $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeIn(2000,function () &#123; alert(&quot;fadeIn动画完毕&quot;); &#125;); &#125;); //淡出 fadeOut() $(&quot;#btn5&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeOut(2000,function () &#123; alert(&quot;fadeOut动画完毕&quot;); &#125;); &#125;); //淡化到 fadeTo() $(&quot;#btn6&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(2000,0.5,function () &#123; alert(&quot;fadeTo动画完毕&quot;); &#125;); &#125;); //淡化切换 fadeToggle() $(&quot;#btn7&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeToggle(2000,function () &#123; alert(&quot;fadeToggle动画完毕&quot;); &#125;); &#125;); &#125;);&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table style=&quot;float: left;&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn1&quot;&gt;显示show()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn2&quot;&gt;隐藏hide()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn3&quot;&gt;显示/隐藏切换 toggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn4&quot;&gt;淡入fadeIn()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn5&quot;&gt;淡出fadeOut()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn6&quot;&gt;淡化到fadeTo()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id=&quot;btn7&quot;&gt;淡化切换fadeToggle()&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;div1&quot; style=&quot;float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;&quot;&gt; jquery动画定义了很多种动画效果，可以很方便的使用这些动画效果 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 13、CSS_动画 品牌展示1234需求： 1.点击按钮的时候，隐藏和显示卡西欧之后的品牌 2.当显示全部内容的时候，按钮文本为“显示精简品牌”然后，小三角形向上，所有品牌产品为默认颜色 3.当只显示精简品牌的时候，要隐藏卡西欧之后的品牌，按钮文本为“显示全部品牌”，然后小三角形向下，并且把佳能，尼康的品牌颜色改为红色（给li标签添加promoted样式即可） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;品牌展示练习&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123; margin: 0; padding: 0;&#125;body &#123; font-size: 12px; text-align: center;&#125;a &#123; color: #04D; text-decoration: none;&#125;a:hover &#123; color: #F50; text-decoration: underline;&#125;.SubCategoryBox &#123; width: 600px; margin: 0 auto; text-align: center; margin-top: 40px;&#125;.SubCategoryBox ul &#123; list-style: none;&#125;.SubCategoryBox ul li &#123; display: block; float: left; width: 200px; line-height: 20px;&#125;.showmore , .showless&#123; clear: both; text-align: center; padding-top: 10px;&#125;.showmore a , .showless a&#123; display: block; width: 120px; margin: 0 auto; line-height: 24px; border: 1px solid #AAA;&#125;.showmore a span &#123; padding-left: 15px; background: url(img/down.gif) no-repeat 0 0;&#125;.showless a span &#123; padding-left: 15px; background: url(img/up.gif) no-repeat 0 0;&#125;.promoted a &#123; color: #F50;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; //基本初始状态 $(&quot;li:gt(5):not(:last)&quot;).hide(); $(&quot;div div a&quot;).click(function()&#123; //alert(&quot;事件&quot;); //让某些品牌显示或者隐藏 $(&quot;li:gt(5):not(:last)&quot;).toggle(); //按钮上的文本：1显示全部品牌==角标向下 //2显示精简品牌==角标向上 //切换按钮的文本 /*if($(this).text()==&quot;显示全部品牌&quot;)&#123; $(this).text(&quot;显示精简品牌&quot;); &#125;else&#123; $(this).text(&quot;显示全部品牌&quot;); &#125;*/ //判断品牌当前是否显示 if($(&quot;li:gt(5):not(:last)&quot;).is(&quot;:hidden&quot;))&#123; $(&quot;div div a span&quot;).text(&quot;显示全部品牌&quot;); //改变图标 $(&quot;div div&quot;).removeClass(); $(&quot;div div&quot;).addClass(&quot;showmore&quot;); //取消高亮 $(&quot;li:contains(&#x27;索尼&#x27;)&quot;).removeClass(&quot;promoted&quot;); &#125;else&#123; $(&quot;div div a span&quot;).text(&quot;显示精简品牌&quot;); $(&quot;div div&quot;).removeClass(); $(&quot;div div&quot;).addClass(&quot;showless&quot;); //给一些品牌添加高亮 $(&quot;li:contains(&#x27;索尼&#x27;)&quot;).addClass(&quot;promoted&quot;); &#125; return false; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;SubCategoryBox&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;佳能&lt;/a&gt;&lt;i&gt;(30440) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;索尼&lt;/a&gt;&lt;i&gt;(27220) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;三星&lt;/a&gt;&lt;i&gt;(20808) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;尼康&lt;/a&gt;&lt;i&gt;(17821) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;松下&lt;/a&gt;&lt;i&gt;(12289) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;卡西欧&lt;/a&gt;&lt;i&gt;(8242) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;富士&lt;/a&gt;&lt;i&gt;(14894) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;柯达&lt;/a&gt;&lt;i&gt;(9520) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;宾得&lt;/a&gt;&lt;i&gt;(2195) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;理光&lt;/a&gt;&lt;i&gt;(4114) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;奥林巴斯&lt;/a&gt;&lt;i&gt;(12205) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;明基&lt;/a&gt;&lt;i&gt;(1466) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;爱国者&lt;/a&gt;&lt;i&gt;(3091) &lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其它品牌相机&lt;/a&gt;&lt;i&gt;(7275) &lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;showmore&quot;&gt; &lt;a href=&quot;more.html&quot;&gt;&lt;span&gt;显示全部品牌&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 14、JQuery事件操作14.1、页面加载操作1234567891011121314$(function()&#123;&#125;);和window.onload=function()&#123;&#125;的区别？他们分别是在什么时候触发？ 1.JQuery的页面加载完成之后是浏览器的内核解析完页面的标签创建好DOM对象之后就会马上执行。 2.原生js的页面加载完成之后，除了要等浏览器内核解析完标签创建好DOM对象，还要等标签显示时需要的内容加载完成。他们触发的顺序？ 1.JQuery页面加载完成之后先执行 2.原生js的页面加载完成之后他们执行的次数？ 1.原生js的页面加载完成之后，只会执行最后一次赋值函数 2.JQuery的页面加载完成之后是把全部注册的Function函数，依次顺序执行。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; alert(&quot;原生js的页面加载完成之后1&quot;) &#125; window.onload = function () &#123; alert(&quot;原生js的页面加载完成之后2&quot;) &#125; window.onload = function () &#123; alert(&quot;原生js的页面加载完成之后3&quot;) &#125; //jquery的页面加载完成之后 $(function () &#123; alert(&quot;jquery的页面加载完成之后1&quot;) &#125;); $(function () &#123; alert(&quot;jquery的页面加载完成之后2&quot;) &#125;); $(function () &#123; alert(&quot;jquery的页面加载完成之后3&quot;) &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;iframe src=&quot;http://localhost:8080&quot;&gt;&lt;/iframe&gt; &lt;img src=&quot;http://localhost:8080/1.jpg&quot; alt=&quot;&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 14.2、JQuery中其他的事件处理方法 12345678js是onclick、onblur、onchangeclick() 它可以绑定单击事件，以及触发单击事件mouseover() 鼠标移入事件mouseout() 鼠标移出事件bind() 可以给元素一次性绑定一个或多个事件one() 使用跟bind一样，但是one方法绑定的事件只会响应一次live() 也是用来绑定事件的，它可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态创建出来的也有效。unbind() 跟bind相反的操作，解除事件的绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //1.通常绑定事件的方式 $(&quot;h5&quot;).click(function()&#123; //传function是绑定事件 alert(&quot;h5被点击了&quot;); &#125;); $(&quot;button&quot;).click(function()&#123; $(&quot;h5&quot;).click();//不传function是触发事件 &#125;) //2.jQuery提供的绑定方式：bind()函数 /*$(&quot;h5&quot;).bind(&quot;click mouseover mouseout&quot;,function()&#123; $(this).css(&quot;background-color&quot;,&quot;blue&quot;); &#125;);*/ $(&quot;h5&quot;).live(&quot;click mouseover mouseout&quot;,function()&#123; $(this).css(&quot;color&quot;,&quot;blue&quot;); &#125;); /*$(&quot;h5&quot;).unbind(&quot;mouseover mouseout&quot;); $(&quot;h5&quot;).mouseover(function()&#123; $(this).css(&quot;color&quot;,&quot;red&quot;); &#125;); $(&quot;h5&quot;).mouseout(function()&#123; $(this).css(&quot;color&quot;,&quot;black&quot;); &#125;); */ $(&#x27;&lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;&#x27;).appendTo(&quot;#panel&quot;); //3.合并“鼠标移入”和“鼠标移出”事件 //4.合并单击事件 //5.切换元素可见状态 //6.只绑定一次 &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;panel&quot;&gt; &lt;h5 class=&quot;head&quot;&gt;什么是jQuery?&lt;/h5&gt; &lt;div class=&quot;content&quot;&gt; jQuery是继Prototype之后又一个优秀的JavaScript库，它是一个由 John Resig 创建于2006年1月的开源项目。jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。它独特而又优雅的代码风格改变了JavaScript程序员的设计思路和编写程序的方式。 &lt;/div&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 14.3、事件的冒泡12345什么是事件的冒泡？事件的冒泡是指，父子元素同时监听同一个事件，当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去响应。那么如何阻止事件冒泡呢？在子元素事件函数体内，return false 可以阻止事件的冒泡传递。 14.5、JavaScript事件对象12345678910111213141516171819事件对象，是封装有触发的事件信息的一个JavaScript对象。我们重点关心的是怎么拿到这个JavaScript的事件对象以及使用。如何获取JavaScript事件对象呢？在给元素绑定事件的时候，在事件的function(event)参数列表中添加一个参数，这个参数名，我们习惯取名为event，这个event就是JavaScript传递参数事件处理函数的事件对象。比如： //1.原生javascript获取 事件对象 /*window.onload = function()&#123; document.getElementById(&quot;areaDiv&quot;).onclick = function(event)&#123; console.log(event); &#125; &#125;*/ //2.JQuery代码获取 事件对象 $(function()&#123; $(&quot;#areaDiv&quot;).click(function(event)&#123; console.log(event); &#125;); &#125;); 12345678910111213那么这个对象有什么作用--&gt;实现多种操作：//3.使用bind同时对多个事件绑定同一个函数。怎么获取当前操作是什么事件。$(function()&#123; $(&quot;#areaDiv&quot;).bind(&quot;mouseout mouseover&quot;,function(event)&#123; //console.log(event.type); if(event.type == &quot;mouseover&quot;)&#123; $(this).css(&quot;background-color&quot;,&quot;red&quot;); &#125;else&#123; $(this).css(&quot;background-color&quot;,&quot;blue&quot;); &#125; &#125;);&#125;); 练习07事件 图片跟随1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; text-align: center; &#125; #small &#123; margin-top: 150px; &#125; #showBig &#123; position: absolute; display: none; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#small&quot;).bind(&quot;mouseover mouseout mousemove&quot;,function (event) &#123; if(event.type == &quot;mouseover&quot;)&#123; $(&quot;#showBig&quot;).show(); &#125;else if(event.type == &quot;mouseout&quot;)&#123; $(&quot;#showBig&quot;).hide(); &#125;else if(event.type == &quot;mousemove&quot;)&#123; var x = event.pageX+10; var y = event.pageY+10; $(&quot;#showBig&quot;).css(&#123; left:x, top:y &#125;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;small&quot; src=&quot;img/small.jpg&quot; /&gt; &lt;div id=&quot;showBig&quot;&gt; &lt;img src=&quot;img/big.jpg&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":"jquery"},{"title":"jQuery","url":"/2023/10/12/jQuery/","text":"三、jQuery1、jQuery介绍什么是jQuery？** jQuery，顾名思义，就是js和查询（Query），它就是辅助JavaScript开发的js类库。 jQuery核心思想！！！ 它的核心思想是write less，do more（写得更少，做得更多），所以它实现了很多浏览器的兼容问题。 jQuery流行程度： jQuery现在已经成为最流行的JavaScript类库，在世界前10000个访问最多的网站中，有超过百分之五十五在使用jQuery。 jQuery的好处！！！ jQuery是免费的、开源的，jQuery的语法设计可以使开发者更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。 2、jQuery的初体验！！！需求：使用jQuery给一个按钮绑定单击事件。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*window.onload = function()&#123; var btnObj=document.getElementById(&quot;btn&quot;); alert(btnObj);//dom对象 btnObj.onclick=function()&#123; alert(&quot;js原生的单击事件&quot;); &#125; &#125;*/ $(function() &#123; //表示当页面加载完成后执行，相当于window.onload=function()&#123;&#125; var $btnObj=$(&quot;#btnId&quot;);//表示通过id获取到的dom对象 $btnObj.click(function()&#123; alert(&quot;jQuery的单击事件&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnId&quot;&gt;SayHello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123456常见问题1.使用jQuery一定要引入jQuery库吗？ 是的，必须2.jQuery中的$到底是什么？ 它是一个函数3.怎么为按钮添加点击响应函数的？①使用jQuery查询到标签对象②使用标签对象.click(function()&#123;&#125;); 3、jQuery核心函数1$是jQuery的核心函数，能完成jQuery的很多功能。 $()就是调用$这个函数 传入参数为[函数]时：在文档加载完成后执行这个函数,相当于window.onload&#x3D;function(){} 传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象 传入参数为[选择器字符串]时： 123$(&quot;#id属性值&quot;); id选择器，根据id查询标签对象$(&quot;标签名&quot;); 标签名选择器，根据指定的标签名查询标签对象$(&quot;.class属性值&quot;); 类型选择器，可以根据class属性查询标签对象 传入参数为 [DOM对象]时：会把这个DOM对象转换成jQuery对象 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //核心函数的4个作用 //传入参数为[函数]时：在文档加载完成后执行这个函数 $(function ()&#123; alert(&quot;文档加载完成之后自动执行&quot;); $(&quot;&lt;div&gt;&quot; + &quot; &lt;span&gt;这是一个SPAN1&lt;/span&gt;&quot; + &quot; &lt;span&gt;这是一个SPAN2&lt;/span&gt;&quot; + &quot; &lt;/div&gt;&quot;).appendTo(&quot;body&quot;); //alert($(&quot;button&quot;).length); var btnObj = document.getElementsByTagName(&quot;button&quot;); //alert(btnObj); alert($(btnObj)); &#125;); //传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象 //传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象 //传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--&lt;div&gt; &lt;span&gt;这是一个SPAN1&lt;/span&gt; &lt;span&gt;这是一个SPAN2&lt;/span&gt; &lt;/div&gt;--&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 4、jQuery对象和dom对象区分4.1、什么是jQuery对象，什么是dom对象dom对象 通过getElementById查询出来的标签对象是dom对象 通过getElementsByName查询出来的标签对象是dom对象 通过getElementsByTagName查询出来的标签对象是dom对象 通过createElement()方法创建的对象，是dom对象 jQuery对象 通过jQuery提供的API创建的对象，是jQuery对象 提供jQuery包装的dom对象，也是jQuery对象 提供jQuery提供的API查询到的对象，也是jQuery对象 4.2、 JQuery对象的本质是什么？JQuery对象是DOM对象的数组 + JQuery提供的一系列功能函数。 4.3、 JQuery对象和Dom对象使用的区别？JQuery对象不能使用DOM对象的属性和方法 DOM对象也不能使用JQuery对象的属性和方法 4.4、DOM对象和JQuery对象互相转换 DOM对象转化为JQuery对象（重点） 先有DOM对象 $(DOM对象)就可以转换成为JQuery对象 JQuery对象转化为DOM对象（重点） 先有JQuery对象 JQuery对象[下标取出相应的DOM对象] 5、JQuery选择器（重点）5.1、基本选择器（重点） #id id选择器：根据id查找标签对象 .class class选择器：根据class查找标签对象 element element选择器：根据标签名查找标签对象 *选择器：表示任意的，所有的元素 selector1，selector2 组合选择器：合并选择器 1，选择器2的结果并返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot; $(&quot;#btn1&quot;).click(function () &#123; //css()方法：可以设置和获取样式 $(&quot;#one&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择 class 为 mini 的所有元素 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;.mini&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择 元素名是 div 的所有元素 $(&quot;#btn3&quot;).click(function () &#123; $(&quot;div&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择所有的元素 $(&quot;#btn4&quot;).click(function () &#123; $(&quot;*&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;); &#125;); //5.选择所有的 span 元素和id为two的元素 $(&quot;#btn5&quot;).click(function () &#123; $(&quot;span,#two&quot;).css(&quot;background-color&quot;, &quot;#bbffaa&quot;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;div&gt; &lt;h1&gt;基本选择器&lt;/h1&gt; &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 class 为 mini 的所有元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 元素名是 div 的所有元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 所有的 span 元素和id为two的元素&quot; id=&quot;btn5&quot; /&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span class=&quot;one&quot; id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 5.2、层级选择器（重点） ancestor descendant 后代选择器：在给定的祖先元素下匹配所有的后代元素 parent &gt; child 子元素选择器：在给定的父元素下匹配所有的子元素 prev + next 相邻元素选择器：匹配所有紧接在prev元素后的next元素 prev ~ siblings 之后的兄弟元素选择器：匹配prev元素之的所有siblings元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; //1.选择 body 内的所有 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.在 body 内, 选择div子元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择 id 为 one 的下一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择 id 为 two 的元素后面的所有 div 兄弟元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; &lt;h1&gt;层级选择器:根据元素的层级关系选择元素&lt;/h1&gt; ancestor descendant ： parent &gt; child ： prev + next ： prev ~ siblings ： &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择 body 内的所有 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;在 body 内, 选择div子元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 one 的下一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择 id 为 two 的元素后面的所有 div 兄弟元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span&quot;&gt;^^span元素^^&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 5.3、过滤选择器基本过滤器： ：first 获取第一个元素 ：last 获取最后一个元素 ：not(selector) 取出所有与给定选择器匹配的元素 ：even 匹配所有索引值为偶数的元素，从0开始计数 ：odd 匹配所有索引值为奇数的元素，从0开始计数 ：eq(index) 匹配一个给定索引值的元素 ：gt(index) 匹配所有大于给定索引值的元素 : It(index) 匹配所有小于给定索引值的元素 ：header 匹配如h1,h2,h3之类的标题元素 ：animated 匹配所有正在执行动画效果的元素 ：focus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); $(document).ready(function()&#123; //1.选择第一个 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择最后一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择class不为 one 的所有 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择索引值为偶数的 div 元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选择索引值为奇数的 div 元素 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选择索引值为大于 3 的 div 元素 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.选择索引值为等于 3 的 div 元素 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选择索引值为小于 3 的 div 元素 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //9.选择所有的标题元素 $(&quot;#btn9&quot;).click(function()&#123; $(&quot;*:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //10.选择当前正在执行动画的所有元素 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;div:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //11.选择当前没有正在执行动画的元素的最后一个 $(&quot;#btn11&quot;).click(function()&#123; $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; :first :last :not(selector) :even :odd :eq(index) :gt(index) :lt(index) :header :animated &lt;/div&gt; --&gt; &lt;input type=&quot;button&quot; value=&quot;选择第一个 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择最后一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择class不为 one 的所有 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为偶数的 div 元素&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为奇数的 div 元素&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为大于 3 的 div 元素&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为等于 3 的 div 元素&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择索引值为小于 3 的 div 元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有的标题元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择当前正在执行动画的所有元素&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择没有执行动画的最后一个div&quot; id=&quot;btn11&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 内容过滤器： ：contains(test) 匹配包含给定文本的元素 ：empty 匹配所有不包含子元素或者文本的空元素 ：parent 匹配含有子元素或者文本的元素 ：has(selector) 匹配含有选择器所匹配的元素的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); /** :contains(text) :empty :has(selector) :parent */ $(document).ready(function()&#123; //1.选择 含有文本 &#x27;di&#x27; 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:contains(&#x27;di&#x27;)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择不包含子元素(或者文本元素) 的 div 空元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:empty&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择含有 class 为 mini 元素的 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:has(.mini)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选择含有子元素(或者文本元素)的div元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:parent&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选择 含有文本 &#x27;di&#x27; 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择不包含子元素(或者文本元素) 的 div 空元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有 class 为 mini 元素的 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择含有子元素(或者文本元素)的div元素&quot; id=&quot;btn4&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5.4 可见性过滤器 :hidden 匹配所有不可见元素，或者type为hidden的元素 :visible 匹配所有的可见元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); /** :hidden :visible */ $(document).ready(function()&#123; //1.选取所有可见的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:visible&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选择所有不可见的 div 元素 //不可见：display属性设置为none，或visible设置为hidden $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:hidden&quot;).show(&quot;slow&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选择所有不可见的 input 元素 $(&quot;#btn3&quot;).click(function()&#123; alert($(&quot;input:hidden&quot;).attr(&quot;value&quot;)); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选取所有可见的 div 元素&quot; id=&quot;btn1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有不可见的 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选择所有不可见的 input 元素&quot; id=&quot;btn3&quot; /&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; value=&quot;123456789&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5.5、属性过滤器 [attribute] 匹配包含给定属性的元素 [attribute&#x3D;value] 匹配给定的属性是某个特定值的元素 [attribute!&#x3D;value] 匹配所有不包含指定的属性，或者属性不等于特定值的元素 [attribute^&#x3D;value] 匹配给定的属性是以某些值开始的元素 [attribute$&#x3D;value] 匹配给定的属性是以某些值结尾的元素 [attribute*&#x3D;value] 匹配给定的属性是包含某些值的元素 [ attrSel1 ][ attrSel2 ][attrSelN] 复合属性选择器，需要同时满足多个条件时使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div,span,p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana;&#125;div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px;&#125;div.hide &#123; display: none;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /**[attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] */ $(function() &#123; //1.选取含有 属性title 的div元素 $(&quot;#btn1&quot;).click(function() &#123; $(&quot;div[title]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //2.选取 属性title值等于&#x27;test&#x27;的div元素 $(&quot;#btn2&quot;).click(function() &#123; $(&quot;div[title=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //3.选取 属性title值不等于&#x27;test&#x27;的div元素(*没有属性title的也将被选中) $(&quot;#btn3&quot;).click(function() &#123; $(&quot;div[title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //4.选取 属性title值 以&#x27;te&#x27;开始 的div元素 $(&quot;#btn4&quot;).click(function() &#123; $(&quot;div[title^=&#x27;te&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //5.选取 属性title值 以&#x27;est&#x27;结束 的div元素 $(&quot;#btn5&quot;).click(function() &#123; $(&quot;div[title$=&#x27;est&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //6.选取 属性title值 含有&#x27;es&#x27;的div元素 $(&quot;#btn6&quot;).click(function() &#123; $(&quot;div[title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //7.首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素 $(&quot;#btn7&quot;).click(function() &#123; $(&quot;div[id][title*=&#x27;es&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); //8.选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素 $(&quot;#btn8&quot;).click(function() &#123; $(&quot;div[title][title!=&#x27;test&#x27;]&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;选取含有 属性title 的div元素.&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值等于&#x27;test&#x27;的div元素.&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值不等于&#x27;test&#x27;的div元素(没有属性title的也将被选中).&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;te&#x27;开始 的div元素.&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 以&#x27;est&#x27;结束 的div元素.&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 属性title值 含有&#x27;es&#x27;的div元素.&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有&#x27;es&#x27;的 div 元素.&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.&quot; id=&quot;btn8&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class为mini,title为other&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display: none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; value=&quot;123456789&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.6、子元素过滤器 ：nth-child 12345匹配其父元素下的第N个子或奇偶元素&#x27;:eq(index)&#x27; 只匹配一个元素，而这个将为每一个父元素匹配子元素。:nth-child从1开始的，而:eq()是从0算起的！可以使用:&lt;br&gt;nth-child(even)&lt;br&gt;:nth-child(odd)&lt;br&gt;:nth-child(3n)&lt;br&gt;:nth-child(2)&lt;br&gt;:nth-child(3n+1)&lt;br&gt;:nth-child(3n+2) ：first-child 匹配第一个子元素 ‘:first’ 只匹配一个元素，而此选择符将为每个父元素匹配一个子元素 : last-child 匹配最后一个子元素 ‘:last’只匹配一个元素，而此选择符将为每个父元素匹配一个子元素 : only-child 如果某个元素是父元素中唯一的子元素，那将会被匹配 如果父元素中含有其他元素，那将不会被匹配。 5.7、表单过滤器： ：input 匹配所有 input, textarea, select 和 button 元素 ：text 匹配所有的单行文本框 ：password 匹配所有的密码框 ：radio 匹配所有单选按钮 ：checkbox 匹配所有复选框 ：submit 匹配所有提交按钮 ：image 匹配所有图像域 ：reset 匹配所有重置按钮 ：button 匹配所有按钮 ：file 匹配所有文件域 ：hidden 匹配所有不可见元素，或者type为hidden的元素 ：enabled 匹配所有可用元素 ：disabled 匹配所有不可用元素 ：checked 匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option) ：selected 匹配所有选中的option元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; /** :input :text :password :radio :checkbox :submit :image :reset :button :file :hidden 表单对象的属性 :enabled :disabled :checked :selected */ //1.对表单内 可用input 赋值操作 $(&quot;#btn1&quot;).click(function () &#123; //val()可以操作表单项的value属性值 $(&quot;:input:enabled&quot;).val(&quot;我是万能的程序员&quot;); &#125;); //2.对表单内 不可用input 赋值操作 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;:input:disabled&quot;).val(&quot;管你可不可用，我是万能程序员&quot;); &#125;); //3.获取多选框选中的个数 使用size()方法获取选取到的元素集合的元素个数 $(&quot;#btn3&quot;).click(function () &#123; alert($(&quot;:checkbox:checked&quot;).size()) &#125;); //4.获取多选框，每个选中的value值 $(&quot;#btn4&quot;).click(function () &#123; //获取全部选中的复选框标签对象 var $checkboxs = $(&quot;:checkbox:checked&quot;); //遍历获取每个选中的value值 /*for(var i=0;i&lt;$checkboxs.size();i++)&#123; alert($checkboxs[i].value); &#125;*/ //使用JQuery提供的each()方法遍历获取每个选中的value值 //在遍历的函数中，this指向当前遍历的元素 $checkboxs.each(function () &#123; //alert($(this).val()); alert(this.value); &#125;); &#125;); //5.获取下拉框选中的内容 $(&quot;#btn5&quot;).click(function () &#123; //获取选中的option标签对象 var $options = $(&quot;select option:selected&quot;); //遍历获取选中的option标签对象的value值 $options.each(function () &#123; alert(this.innerHTML); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表单对象属性过滤选择器&lt;/h3&gt; &lt;button id=&quot;btn1&quot;&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn3&quot;&gt;获取多选框选中的个数.&lt;/button&gt; &lt;button id=&quot;btn4&quot;&gt;获取多选框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=&quot;btn5&quot;&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;form id=&quot;form1&quot; action=&quot;#&quot;&gt; 可用元素: &lt;input name=&quot;add&quot; value=&quot;可用文本框1&quot;/&gt;&lt;br&gt; 不可用元素: &lt;input name=&quot;email&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; 可用元素: &lt;input name=&quot;che&quot; value=&quot;可用文本框2&quot;/&gt;&lt;br&gt; 不可用元素: &lt;input name=&quot;name&quot; disabled=&quot;disabled&quot; value=&quot;不可用文本框&quot;/&gt;&lt;br&gt; &lt;br&gt; 多选框: &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test1&quot; /&gt;test1 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test2&quot; /&gt;test2 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test3&quot; /&gt;test3 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; checked=&quot;checked&quot; value=&quot;test4&quot; /&gt;test4 &lt;input type=&quot;checkbox&quot; name=&quot;newsletter&quot; value=&quot;test5&quot; /&gt;test5 &lt;br&gt;&lt;br&gt; 下拉列表1: &lt;br&gt; &lt;select name=&quot;test&quot; multiple=&quot;multiple&quot; style=&quot;height: 100px&quot; id=&quot;sele1&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;辽宁&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 下拉列表2: &lt;br&gt; &lt;select name=&quot;test2&quot;&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;辽宁&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 6、JQuery元素筛选 eq()获取给定索引的元素，功能和:eq()一样 first()获取第一个元素，功能和:first一样 last()获取最后一个元素，功能和:last一样 filter(exp)留下匹配的元素 is()判断是否匹配给定的选择器，只要有一个匹配就返回true has(exp)返回包含有匹配选择器的元素的元素，功能跟:has一样 not(exp)删除匹配选择器的元素，功能与:not()一样 children(exp) 返回匹配给定选择器的子元素，功能和parent&gt;child一样 find(exp)返回匹配给定选择器的后代元素，功能跟ancestor descendant一样 next()返回当前元素的下一个兄弟元素，功能跟prev+next一样 nextAll()返回当前元素后面所有的兄弟元素，功能跟prev~sibling一样 nextUntil()返回当前元素到指定匹配的元素为止的后面元素，往后数的区间 parent() 返回父元素 prev(exp)返回当前元素的上一个兄弟元素 prevall()返回当前元素前面所有的兄弟元素 prevUntil(exp)返回当前元素到指定匹配的元素为止的前面元素，往前数的区间 sibling(exp)返回所有兄弟元素，无论前后 add()把add匹配的选择器的元素添加到当前JQuery对象中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;DOM查询&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); /** 过滤 eq(index|-index) first() last() hasClass(class) filter(expr|obj|ele|fn) is(expr|obj|ele|fn)1.6* has(expr|ele) not(expr|ele|fn) slice(start,[end]) 查找 children([expr]) closest(expr,[con]|obj|ele)1.6* find(expr|obj|ele) next([expr]) nextall([expr]) nextUntil([exp|ele][,fil])1.6* parent([expr]) parents([expr]) parentsUntil([exp|ele][,fil])1.6* prev([expr]) prevall([expr]) prevUntil([exp|ele][,fil])1.6* siblings([expr]) 串联 add(expr|ele|html|obj[,con]) */ //(1)eq() 选择索引值为等于 3 的 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div&quot;).eq(3).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(2)first()选择第一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; //first() 选取第一个元素 $(&quot;div&quot;).first().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(3)last()选择最后一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; //last() 选取最后一个元素 $(&quot;div&quot;).last().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(4)filter()在div中选择索引为偶数的 $(&quot;#btn4&quot;).click(function()&#123; //filter() 过滤 传入的是选择器字符串 $(&quot;div&quot;).filter(&quot;:even&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(5)is()判断#one是否为:empty或:parent //is用来检测jq对象是否符合指定的选择器 $(&quot;#btn5&quot;).click(function()&#123; alert($(&quot;#one&quot;).is(&quot;:empty&quot;)); &#125;); //(6)has()选择div中包含.mini的 $(&quot;#btn6&quot;).click(function()&#123; //has(selector) 选择器字符串 是否包含selector $(&quot;div&quot;).has(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(7)not()选择div中class不为one的 $(&quot;#btn7&quot;).click(function()&#123; //not(selector) 选择不是selector的元素 $(&quot;div&quot;).not(&quot;.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(8)children()在body中选择所有class为one的div子元素 $(&quot;#btn8&quot;).click(function()&#123; //children() 选出所有的子元素 $(&quot;body&quot;).children(&quot;div.one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(9)find()在body中选择所有class为mini的div元素 $(&quot;#btn9&quot;).click(function()&#123; //find() 选出所有的后代元素 $(&quot;body&quot;).find(&quot;div.mini&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(10)next() #one的下一个div $(&quot;#btn10&quot;).click(function()&#123; //next() 选择下一个兄弟元素 $(&quot;#one&quot;).next(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(11)nextAll() #one后面所有的span元素 $(&quot;#btn11&quot;).click(function()&#123; //nextAll() 选出后面所有的元素 $(&quot;#one&quot;).nextAll(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(12)nextUntil() #one和span之间的元素 $(&quot;#btn12&quot;).click(function()&#123; // $(&quot;#one&quot;).nextUntil(&quot;span&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(13)parent() .mini的父元素 $(&quot;#btn13&quot;).click(function()&#123; $(&quot;.mini&quot;).parent().css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); //(14)prev() #two的上一个div $(&quot;#btn14&quot;).click(function()&#123; //prev() $(&quot;#two&quot;).prev().css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(15)prevAll() span前面所有的div $(&quot;#btn15&quot;).click(function()&#123; //prevAll() 选出前面所有的元素 $(&quot;span&quot;).prevAll(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(16)prevUntil() span向前直到#one的元素 $(&quot;#btn16&quot;).click(function()&#123; //prevUntil(exp) 找到之前所有的兄弟元素直到找到exp停止 $(&quot;span&quot;).prevUntil(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(17)siblings() #two的所有兄弟元素 $(&quot;#btn17&quot;).click(function()&#123; //siblings() 找到所有的兄弟元素，包括前面的和后面的 $(&quot;#two&quot;).siblings().css(&quot;background-color&quot;,&quot;#bfa&quot;) &#125;); //(18)add()选择所有的 span 元素和id为two的元素 $(&quot;#btn18&quot;).click(function()&#123; // $(&quot;span,#two,.mini,#one&quot;) $(&quot;span&quot;).add(&quot;#two&quot;).css(&quot;background-color&quot;,&quot;#bfa&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;eq()选择索引值为等于 3 的 div 元素&quot; id=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;first()选择第一个 div 元素&quot; id=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;last()选择最后一个 div 元素&quot; id=&quot;btn3&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;filter()在div中选择索引为偶数的&quot; id=&quot;btn4&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;is()判断#one是否为:empty或:parent&quot; id=&quot;btn5&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;has()选择div中包含.mini的&quot; id=&quot;btn6&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;not()选择div中class不为one的&quot; id=&quot;btn7&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;children()在body中选择所有class为one的div子元素&quot; id=&quot;btn8&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;find()在body中选择所有class为mini的div后代元素&quot; id=&quot;btn9&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;next()#one的下一个div&quot; id=&quot;btn10&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextAll()#one后面所有的span元素&quot; id=&quot;btn11&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;nextUntil()#one和span之间的元素&quot; id=&quot;btn12&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;parent().mini的父元素&quot; id=&quot;btn13&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prev()#two的上一个div&quot; id=&quot;btn14&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevAll()span前面所有的div&quot; id=&quot;btn15&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;prevUntil()span向前直到#one的元素&quot; id=&quot;btn16&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;siblings()#two的所有兄弟元素&quot; id=&quot;btn17&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;add()选择所有的 span 元素和id为two的元素&quot; id=&quot;btn18&quot; /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br /&gt;&lt;br /&gt; 文本框&lt;input type=&quot;text&quot; name=&quot;account&quot; disabled=&quot;disabled&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;&lt;b&gt;class为mini,title为other&lt;/b&gt;&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt; &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;/div&gt; &lt;div class=&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;/div&gt; &lt;span id=&quot;span1&quot;&gt;^^span元素 111^^&lt;/span&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt; &lt;/div&gt; &lt;span id=&quot;span2&quot;&gt;^^span元素 222^^&lt;/span&gt; &lt;div id=&quot;mover&quot;&gt;正在执行动画的div元素.&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 7、JQuery的属性操作 123html()：它可以设置和获取起始标签和结束标签中的内容，跟dom属性innerHTML一样text()：它可以设置和获取起始标签和结束标签中的文本，跟dom属性innerText一样val()：它可以设置和获取表单项的value属性值，跟dom属性value一样 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type = &quot;text/javascript&quot;&gt; $(function () &#123; //不传参数是获取，传参数是设置 //alert($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;); //不传参数是获取，传参数是设置 // alert($(&quot;div&quot;).text()); //$(&quot;div&quot;).text(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;); //不传参数是获取，传参数是设置 $(&quot;button&quot;).click(function () &#123; alert($(&quot;#username&quot;).val()); $(&quot;#username&quot;).val(&quot;我是程序员&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是div标签&lt;span&gt;我是div中的span标签&lt;/span&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;/&gt; &lt;button&gt;操作输入框&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 注意： val方法可以同时设置多个表单项的选中状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123;/* // 批量操作单选 $(&quot;:radio&quot;).val([&quot;radio2&quot;]); // 批量操作筛选框的选中状态 $(&quot;:checkbox&quot;).val([&quot;checkbox3&quot;,&quot;checkbox2&quot;]); // 批量操作多选的下拉框选中状态 $(&quot;#multiple&quot;).val([&quot;mul2&quot;,&quot;mul3&quot;,&quot;mul4&quot;]); // 操作单选的下拉框选中状态 $(&quot;#single&quot;).val([&quot;sin2&quot;]);*/ //一次性操作 $(&quot;#multiple,#single,:radio,:checkbox&quot;).val([&quot;radio2&quot;,&quot;checkbox1&quot;,&quot;checkbox3&quot;,&quot;mul1&quot;,&quot;mul4&quot;,&quot;sin3&quot;]); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;body&gt; 单选： &lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio1&quot; /&gt;radio1 &lt;input name=&quot;radio&quot; type=&quot;radio&quot; value=&quot;radio2&quot; /&gt;radio2 &lt;br/&gt; 多选： &lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox1&quot; /&gt;checkbox1 &lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox2&quot; /&gt;checkbox2 &lt;input name=&quot;checkbox&quot; type=&quot;checkbox&quot; value=&quot;checkbox3&quot; /&gt;checkbox3 &lt;br/&gt; 下拉多选 ： &lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot; size=&quot;4&quot;&gt; &lt;option value=&quot;mul1&quot;&gt;mul1&lt;/option&gt; &lt;option value=&quot;mul2&quot;&gt;mul2&lt;/option&gt; &lt;option value=&quot;mul3&quot;&gt;mul3&lt;/option&gt; &lt;option value=&quot;mul4&quot;&gt;mul4&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 下拉单选 ： &lt;select id=&quot;single&quot;&gt; &lt;option value=&quot;sin1&quot;&gt;sin1&lt;/option&gt; &lt;option value=&quot;sin2&quot;&gt;sin2&lt;/option&gt; &lt;option value=&quot;sin3&quot;&gt;sin3&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; attr() 可以设置和获取属性值，不推荐操作checked、readonly、selected、disabled等等。 attr方法设置和获取自定义的属性值。 prop() 可以设置和获取属性的值，只推荐操作checked、readonly、selected、disabled等等。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type = &quot;text/javascript&quot;&gt; $(function () &#123; //attr // alert($(&quot;:checkbox:first&quot;).attr(&quot;name&quot;)); // $(&quot;:checkbox:first&quot;).attr(&quot;name&quot;,&quot;abc&quot;); //alert($(&quot;:checkbox:first&quot;).attr(&quot;checked&quot;));//官方觉得返回undefined是个错误 //alert($(&quot;:checkbox:first&quot;).prop(&quot;checked&quot;)); $(&quot;:checkbox:first&quot;).prop(&quot;checked&quot;,true); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;br/&gt; 多选: &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; value=&quot;1&quot; /&gt;checkbox1 &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; value=&quot;2&quot; /&gt;checkbox2&lt;/body&gt;&lt;/html&gt; 8、JQuery练习一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //全选 function checkAll()&#123; //让所有复选框都选中 //document.getElementsByName();是根据指定的name属性值查询返回多个标签对象集合 //这个集合的操作跟数组一样 //集合中每一个元素都是dom对象 var hobbies = document.getElementsByName(&quot;hobby&quot;); //alert(habbies[2].value); //checked表示是否选中，如果选中，则为true，否则为false //这个属性是读，可写的 for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = true; &#125; &#125; //全不选 function checkNo()&#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = false; &#125; &#125; //反选 function checkReverse()&#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = !hobbies[i].checked; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt; &lt;button onclick=&quot;checkNo()&quot;&gt;全不选&lt;/button&gt; &lt;button onclick=&quot;checkReverse()&quot;&gt;反选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 9、DOM的增删改 9.1、内部插入appendTo()：a.appendTo(b)把a插入到b资源末尾，成为最后一个子元素 prependTo()：a.appendTo(b)把a插入到b资源末尾，成为第一个子元素 9.2、外部插入insertAfter()：a.insertAfter(b),得到ba，两者是平级 insertBefore()：a.insertAfter(b),得到ab，两者是平级 9.3、替换replaceWith()：a.replaceWith(b)用b替换掉a replaceAll()：a.replaceAll(b)用a替换掉所有的b 9.4、删除remove()：a.remove()删除a标签 empty()：a.empty()清空a标签里的内容 10、JQuery练习二1、从左到右练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; select &#123; width: 100px; height: 140px; &#125; div &#123; width: 130px; float: left; text-align: center; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //页面加载完成 $(function()&#123; //第一个按钮，选中添加到右边 $(&quot;button:eq(0)&quot;).click(function () &#123; $(&quot;select:eq(0) option:selected&quot;).appendTo(&quot;select:eq(1)&quot;); &#125;); //第二个按钮，全部添加到左边 $(&quot;button:eq(1)&quot;).click(function () &#123; $(&quot;select:eq(0) option&quot;).appendTo(&quot;select:eq(1)&quot;); &#125;); //第三个按钮，选中删除到左边 $(&quot;button:eq(2)&quot;).click(function () &#123; $(&quot;select:eq(1) option:selected&quot;).appendTo(&quot;select:eq(0)&quot;); &#125;); //第四个按钮，全部删除到左边 $(&quot;button:eq(3)&quot;).click(function () &#123; $(&quot;select:eq(1) option&quot;).appendTo(&quot;select:eq(0)&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;left&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel01&quot;&gt; &lt;option value=&quot;opt01&quot;&gt;选项1&lt;/option&gt; &lt;option value=&quot;opt02&quot;&gt;选项2&lt;/option&gt; &lt;option value=&quot;opt03&quot;&gt;选项3&lt;/option&gt; &lt;option value=&quot;opt04&quot;&gt;选项4&lt;/option&gt; &lt;option value=&quot;opt05&quot;&gt;选项5&lt;/option&gt; &lt;option value=&quot;opt06&quot;&gt;选项6&lt;/option&gt; &lt;option value=&quot;opt07&quot;&gt;选项7&lt;/option&gt; &lt;option value=&quot;opt08&quot;&gt;选项8&lt;/option&gt; &lt;/select&gt; &lt;button&gt;选中添加到右边&lt;/button&gt; &lt;button&gt;全部添加到右边&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;rigth&quot;&gt; &lt;select multiple=&quot;multiple&quot; name=&quot;sel02&quot;&gt; &lt;/select&gt; &lt;button&gt;选中删除到左边&lt;/button&gt; &lt;button&gt;全部删除到左边&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、动态添加、删除表格记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Untitled Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; //创建一个用于复用的删除的Function函数 var deleteFun = function () &#123; //alert(&quot;删除操作函数的&quot;+this); //在事件响应函数中，有一个this对象，这个this对象是当前正在响应事件的dom对象 var $trobj= $(this).parent().parent(); var name = $trobj.find(&quot;td:first&quot;).text(); /* *confirm(&quot;&quot;)是Js语言提供的一个却提示框函数，你给它传什么，它就提示什么 * 如果你点击了确定，返回true，如果你点击了取消，返回false */ if(confirm(&quot;确定删除[&quot;+ name +&quot;]吗？&quot;))&#123; //行对象.remove() $trobj.remove(); &#125; //return可以阻止元素的默认行为 return false; &#125;; // 添加记录 $(&quot;#addEmpButton&quot;).click(function()&#123; //获取输入框，姓名，邮箱，工资的内容 var name = $(&quot;#empName&quot;).val(); var email = $(&quot;#email&quot;).val(); var salary = $(&quot;#salary&quot;).val(); //创建一个新的tr var $trobj= $(&quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&lt;a href=\\&quot;deleteEmp?id=001\\&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot; + &quot;&lt;/tr&gt;&quot;); //将新的tr添加到显示数据的表格中 $trobj.appendTo($(&quot;#employeeTable&quot;)); //给添加的行的a标签绑定删除事件 $trobj.find(&quot;a&quot;).click(deleteFun); &#125;); //alert($(&quot;a&quot;).length); //删除记录 //给a标签绑定事件 $(&quot;a&quot;).click(deleteFun); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 11、CSS样式操作12345addClass()添加样式removeClass()删除样式toggleClass()有就删除，没有就添加样式。offset()获取和设置元素的坐标。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; div&#123; width:100px; height:260px; &#125; div.whiteborder&#123; border: 2px white solid; &#125; div.redDiv&#123; background-color: red; &#125; div.blueBorder&#123; border: 5px blue solid; &#125; &lt;/style&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var $divEle = $(&#x27;div:first&#x27;); $(&#x27;#btn01&#x27;).click(function()&#123; //addClass() - 向被选元素添加一个或多个类 $divEle.addClass(&#x27;redDiv blueBorder&#x27;); &#125;); $(&#x27;#btn02&#x27;).click(function()&#123; //removeClass() - 从被选元素删除一个或多个类 $divEle.removeClass(&#x27;redDiv&#x27;); &#125;); $(&#x27;#btn03&#x27;).click(function()&#123; //toggleClass() - 对被选元素进行添加/删除类的切换操作 $divEle.toggleClass(&#x27;redDiv&#x27;); &#125;); $(&#x27;#btn04&#x27;).click(function()&#123; //offset() - 返回第一个匹配元素相对于文档的位置。 var offset = $divEle.offset(); //alert(offset.left); console.log(offset); $divEle.offset(&#123; top:100, left:20 &#125;); &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;border&quot;&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div class=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;addClass()&quot; id=&quot;btn01&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;removeClass()&quot; id=&quot;btn02&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;toggleClass()&quot; id=&quot;btn03&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;offset()&quot; id=&quot;btn04&quot;/&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;/body&gt;&lt;/html&gt;","tags":"jquery"},{"title":"Jenkins","url":"/2023/10/12/Jenkins/","text":"# Jenkins Jenkins，原名 Hudson，2011 年改为现在的名字。它是一个开源的实现持续集成的软件工具。 官方网站 https://www.jenkins.io/ https://www.jenkins.io/zh/ GitLab安装使用官方网站：https://about.gitlab.com/ 安装所需最小配置,太小容易502到你吐血 内存至少4G https://docs.gitlab.cn/jh/install/requirements.html 在ssh下安装官方安装文档：https://gitlab.cn/install/?version=ce 1 安装依赖123sudo yum install -y curl policycoreutils-python openssh-server perlsudo systemctl enable sshdsudo systemctl start sshd 2 配置镜像1curl -fsSL https://packages.gitlab.cn/repository/raw/scripts/setup.sh | /bin/bash 3 开始安装1sudo EXTERNAL_URL=&quot;http://192.168.44.103&quot; yum install -y gitlab-jh 除非您在安装过程中指定了自定义密码，否则将随机生成一个密码并存储在 /etc/gitlab/initial_root_password 文件中(出于安全原因，24 小时后，此文件会被第一次 gitlab-ctl reconfigure 自动删除，因此若使用随机密码登录，建议安装成功初始登录成功之后，立即修改初始密码）。使用此密码和用户名 root 登录。 gitlab常用命令12345678gitlab-ctl start # 启动所有 gitlab 组件；gitlab-ctl stop # 停止所有 gitlab 组件；gitlab-ctl restart # 重启所有 gitlab 组件；gitlab-ctl status # 查看服务状态；gitlab-ctl reconfigure # 启动服务；vi /etc/gitlab/gitlab.rb # 修改默认的配置文件；gitlab-ctl tail # 查看日志； 在docker下安装https://docs.gitlab.cn/jh/install/docker.html 安装所需最小配置 内存至少4G 系统内核至少在3.10以上 uname -r 命令可查看系统内核版本 安装docker 更新yum源 ​ yum update 安装依赖 ​ yum install -y yum-utils device-mapper-persistent-data lvm2 添加镜像 12345//国外镜像yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo//阿里镜像https://mirrors.aliyun.com/docker-ce/linux/centos/gpgyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 查看源中可使用版本 1yum list docker-ce --showduplicates | sort -r 安装指定版本 1yum install docker 配置开机启动项 123systemctl start dockersystemctl enable dockerdocker version 使用容器安装gitlab1.添加容器 12345678910docker run --detach \\ --hostname 192.168.131.134\\ --publish 443:443 --publish 80:80 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab:Z \\ --volume $GITLAB_HOME/logs:/var/log/gitlab:Z \\ --volume $GITLAB_HOME/data:/var/opt/gitlab:Z \\ --shm-size 256m \\ registry.gitlab.cn/omnibus/gitlab-jh:latest 2.启动容器 1docker start gitlab 3.查看已存在的容器 1docker ps -a 4.进入容器 1docker exec -it gitlab /bin/bash 访问http://192.168.131.134 当首次运行出现502错误的时候排查两个原因 虚拟机内存至少需要4g 稍微再等等刷新一下可能就好了 管理员账号登录用户名：root 密码存在下面文件中，登录后需要改密码不然24小时之后会失效 1cat /etc/gitlab/initial_root_password Jenkins安装官方文档介绍非常详细 https://www.jenkins.io 安装需求 12345678910111213机器要求：256 MB 内存，建议大于 512 MB10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）需要安装以下软件：Java 8 ( JRE 或者 JDK 都可以)Docker （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载） 安装JDK1 检索可用包 1yum search java|grep jdk 2 安装 1yum install java-1.8.0-openjdk 安装Jenkins直接java -jar jenkins.war 首次启动war包会在/root/.jenkins生成配置文件 待完全启动成功后 访问服务器8080端口完成配置 初始化后的密码： 12345678Jenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:4e67bbe261da476abdc63c5b51311646This may also be found at: /root/.jenkins/secrets/initialAdminPassword 密码文件使用后会自动删除 访问：ip:8080输入密码登录 选择安装推荐的插件 19aff54f66b04b88aa621bce8bf7a245 Maven安装官网 https://maven.apache.org/ 下载后复制到Jenkins所在服务器解压缩即可 Jenkins上安装Maven插件 服务器安装Gityum install -y git 遇到的问题yum仓库为空 可以http://mirrors.aliyun.com/repo/Centos-7.repo下载仓库 然后放到&#x2F;etc&#x2F;yum.repos.d目录下 执行yum clean all yum makecache 即可 Jenkins + Git + Maven 自动化部署配置 1 Git配置 由于是公开的，所以不需要填写凭证 最好使用yum安装git，不然得另外配置git地址，如果没有就好报错 2 Maven配置 3 Pom.xml配置 javahome配置(可选)1234567891011/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64export JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATHjdk/etc/alternatives/jre_openjdksource /etc/profile 立即生效 报错找不到jdk？12默认yum安装java的时候会显示安装的是openjdk1.8 实则实际上只安装了jreyum install -y java-devel Maven阿里云镜像修改/usr/local/maven/conf/settings.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they&#x27;re all using the same Maven | installation). It&#x27;s normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the &#x27;id&#x27; attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;ali&lt;/username&gt; &lt;password&gt;ali&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;Snapshots&lt;/id&gt; &lt;username&gt;ali&lt;/username&gt; &lt;password&gt;ali&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots1&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots1&lt;/mirrorOf&gt; &lt;url&gt;https://artifacts.alfresco.com/nexus/content/repositories/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;development&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!--this profile will allow snapshots to be searched when activated--&gt; &lt;id&gt;public-snapshots&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public-snapshots&lt;/id&gt; &lt;url&gt;http://public-snapshots&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public-snapshots&lt;/id&gt; &lt;url&gt;http://public-snapshots&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;development&lt;/activeProfile&gt; &lt;activeProfile&gt;public-snapshots&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt; publish over ssh 配置1 安装插件 在Configure System菜单里 往下来 2 添加一台目标服务器 3 修改配置 超时机制输出命令时一定要注意不要让窗口卡主，不然Jenkins会认为认为一直没完成 shell的日志输出1nohup java -jar /root/xxoo/demo*.jar &gt;mylog.log 2&gt;&amp;1 &amp; 数据流重定向数据流重定向就是将某个命令执行后应该要出现在屏幕上的数据传输到其他地方 标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;;标准输出（stdout）：代码为1，使用&gt;或&gt;&gt;;标准错误输出（stderr）：代码为2，使用2&gt;或2&gt;&gt; &gt; 覆盖写&gt;&gt; 追加写 运行前清理配置杀死之前运行的进程 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash#删除历史数据rm -rf xxooappname=$1#获取传入的参数echo &quot;arg:$1&quot;#获取正在运行的jar包pidpid=`ps -ef | grep $1 | grep &#x27;java -jar&#x27; | awk &#x27;&#123;printf $2&#125;&#x27;`echo $pid#如果pid为空，提示一下，否则，执行kill命令if [ -z $pid ];#使用-z 做空值判断 then echo &quot;$appname not started&quot; else kill -9 $pid echo &quot;$appname stoping....&quot;check=`ps -ef | grep -w $pid | grep java`if [ -z $check ]; then echo &quot;$appname pid:$pid is stop&quot; else echo &quot;$appname stop failed&quot;fifi 几种构建方式 快照依赖构建&#x2F;Build whenever a SNAPSHOT dependency is built 当依赖的快照被构建时执行本job 触发远程构建 (例如,使用脚本) 远程调用本job的restapi时执行本job http://192.168.131.102:8080/buildByToken/build?job=first&amp;token=123123 job依赖构建&#x2F;Build after other projects are built 当依赖的job被构建时执行本job 父子项目 定时构建&#x2F;Build periodically 使用cron表达式定时构建本job 向GitHub提交代码时触发Jenkins自动构建&#x2F;GitHub hook trigger for GITScm polling Github-WebHook出发时构建本job 定期检查代码变更&#x2F;Poll SCM 使用cron表达式定时检查代码变更，变更后构建本job 触发远程构建&#x2F;gitlab上改动自动构建代码改动自动可以使用gitlab的webhook回调钩子调起Jenkins的启动任务接口 在构建触发器中配置接口和token 定时构建Jenkins cron表达式标准cron https://crontab.guru Jenkins cron不是标准的cron表达式 123456789101112131415161718第一个 * 表示每个小时的第几分钟，取值0~59H * * * *H：每小时执行一次第二颗 * 表示小时，取值0~23* 15 * * * 表示每天下午3点* 1 * * * 表示每天凌晨1点第三颗 * 表示一个月的第几天，取值1~31* 1 5 * * 表示每月5日凌晨1点第四颗 * 表示第几月，取值1~12* 15 5 1 * 表示每年几月执行第五颗 * 表示一周中的第几天，取值0~7，其中0和7代表的都是周日 “&#x2F;” 表示每隔多长时间，比如 *&#x2F;10 * * * * 表示 每隔10分钟 “H” hash散列值，以job名取值，获取到以job名为入参的唯一值，相同名称值也相同，这个偏移量会和实际时间相加，获得一个真实的运行时间 意义在于：不同的项目在不同的时间运行，即使配置的值是一样的，比如 都是15 * * * * ，表示每个小时的第15分钟开始执行任务，那么会造成同一时间内在Jenkins中启动很多job，换成H/15 * * * *,那么在首次启动任务时，会有随机值参与进来，有的会在17分钟启动 有的会在19分钟启动，随后的启动时间也是这个值。这样就能错开相同cron值的任务执行了。 H的值也可以设置范围 H * * * *表示一小时内的任意时间 */10 * * * *每10分钟 H/10 * * * *每10分钟,可能是7,17,27，起始时间hash，步长不变 45 3 * * 1-6 每个周一至周六，凌晨3点45 执行1次 45 3-5 * * 1-6 每个周一至周六，凌晨3点45 ，凌晨4点45，凌晨5点45 各执行1次 H(40-48) 3-5 * * 1-6 在40~48之间取值 其他同上 45 3-5/2 * * 1-6 每个周一至周六，凌晨3点45 ，凌晨5点45 各执行1次 45 0-6/2 * * 1-6 * * 1-6 0点开始，每间隔2小时执行一次 0:45、2:45、4:45 源码变更构建使用Poll SCM 方式与Build periodically一样 会主动定期检查代码托管服务器上是否有变化，一旦发生变化执行job构建 测试报告邮件通知使用163免费邮箱发送邮件时注意密码填认证码，也就是发送手机短信后给的那个，不要用登录邮箱的密码 类似下面。。 1UFOMAPYZRVAEFUEQ 自动化部署到docker容器中两种方式： 第三种：云原生方式 会将镜像推送到k8s集群，再由k8s一次启动多个docker容器 直接docker外挂目录执行jar包1docker run -d -p 8888:8888 --privileged=true --name demo2 -v /root/jarfile/Jenkins-demo-0.0.1-SNAPSHOT.jar:/app.jar docker.io/openjdk:11 java -jar app.jar Jenkins配置： 前提（先在服务器上run一遍） 更换测试服务器地址 修改pre-steps 修改post-steps 打包到容器内 准备一台测试服务器 docker环境 准备支持jdk的镜像 12345FROM openjdk:11COPY . /usr/src/myappWORKDIR /usr/src/myappRUN javac Main.javaCMD [&quot;java&quot;, &quot;Main&quot;] 把jar包打包到容器内 dockerfile 1234567FROM openjdk:11EXPOSE 8888WORKDIR /rootADD jarfile/Jenkins*.jar /root/app.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/root/app.jar&quot;] 打包构建镜像 1docker build -t jenkinsdemo:1.0 . 配置国内镜像 修改/etc/docker/daemon.json文件，没有的话创建一个 写入 1234567&#123; &quot;registry-mirrors&quot;: [ &quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://registry.aliyuncs.com&quot; ]&#125; 重启服务 12systemctl daemon-reloadsystemctl restart docker jenkins操作： pre-step： post-step： Jenkins集群&#x2F;并发构建集群化构建可以有效提升构建效率，尤其是团队项目比较多或是子项目比较多的时候，可以并发在多台机器上执行构建。 流水线 pipeline流水线既能作为任务的本身，也能作为Jenkinsfile 使用流水线可以让我们的任务从ui手动操作，转换为代码化，像docker的dockerfile一样，从shell命令到配置文件，更适合大型项目，可以让团队其他开发者同时参与进来，同时也可以编辑开发Jenkinswebui不能完成的更复杂的构建逻辑，作为开发者可读性也更好。 完整语法5个必备的组成部分 12345pipeline：整条流水线agent：指定执行器stages：所有阶段stage：某一阶段，可有多个steps：阶段内的每一步，可执行命令 测试脚本基础框架123456789101112131415161718192021222324252627282930313233343536pipeline &#123; agent any stages &#123; stage(&#x27;拉取代码&#x27;) &#123; steps &#123; echo &#x27;拉取代码完成&#x27; &#125; &#125; stage(&#x27;执行构建&#x27;) &#123; steps &#123; echo &#x27;执行构建完成&#x27; &#125; &#125; &#125; post &#123; always &#123; echo &quot;完成&quot; &#125; failure &#123; echo &quot;失败&quot; &#125; &#125;&#125; 阶段视图 Stage Viewblue ocean可视化界面全新的流水线控制ui，可重复执行某阶段代码 插件中心搜索blue ocean安装即可 post流水线完成后可执行的任务 always 无论流水线或者阶段的完成状态。 changed 只有当流水线或者阶段完成状态与之前不同时。 failure 只有当流水线或者阶段状态为”failure”运行。 success 只有当流水线或者阶段状态为”success”运行。 unstable 只有当流水线或者阶段状态为”unstable”运行。例如：测试失败。 aborted 只有当流水线或者阶段状态为”aborted “运行。例如：手动取消。 agent可以指定执行节点 label 指定运行job的节点标签 any 不指定，由Jenkins分配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pipeline &#123; agent &#123; node &#123; label &quot;jenkins-02&quot; &#125; &#125; stages &#123; stage(&#x27;拉取代码&#x27;) &#123; steps &#123; sh &quot;&quot;&quot; sleep 10 &quot;&quot;&quot; echo &#x27;拉取代码完成&#x27; &#125; &#125; stage(&#x27;执行构建&#x27;) &#123; steps &#123; echo &#x27;执行构建完成&#x27; &#125; &#125; &#125; post &#123; always &#123; echo &quot;完成&quot; &#125; failure &#123; echo &quot;失败&quot; &#125; &#125;&#125; pipeline中执行自动化构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pipeline &#123; agent any tools&#123; maven &quot;maven3.9&quot; &#125; stages &#123; stage(&#x27;拉取代码&#x27;) &#123; steps &#123; git branch: &#x27;main&#x27;, credentialsId: &#x27;gitlab&#x27;, url: &#x27;http://192.168.131.134/root/java-project.git&#x27; echo &#x27;拉取成功&#x27; &#125; &#125; stage(&#x27;执行构建&#x27;) &#123; steps &#123; // sh &quot;mvn --version&quot; // sh &quot;&quot;&quot; // cd xxx // &quot;&quot;&quot; sh &quot;mvn clean package&quot; echo &#x27;构建完成&#x27; &#125; &#125; stage(&#x27;clean test server&#x27;)&#123; steps&#123; sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;testserver&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &#x27;&#x27;&#x27;rm -rf *docker stop demodocker rm demodocker rmi demo&#x27;&#x27;&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;/root&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;&#x27;, sourceFiles: &#x27;&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) &#125; &#125; stage(&#x27;发送jar包到测试服务器&#x27;) &#123; steps &#123; sshPublisher(publishers: [sshPublisherDesc(configName: &#x27;testserver&#x27;, transfers: [sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &#x27;&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;/jarfile&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;target&#x27;, sourceFiles: &#x27;**/Jenkins*.jar&#x27;), sshTransfer(cleanRemote: false, excludes: &#x27;&#x27;, execCommand: &#x27;&#x27;&#x27;docker build -t demo .docker run -d -p 8888:8888 --name demo demo&#x27;&#x27;&#x27;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#x27;[, ]+&#x27;, remoteDirectory: &#x27;/&#x27;, remoteDirectorySDF: false, removePrefix: &#x27;docker&#x27;, sourceFiles: &#x27;docker/dockerfile&#x27;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) echo &#x27;发送成功&#x27; &#125; &#125; &#125;&#125; 声明式流水线好处 更像是在Jenkins web ui中的操作 可读性比较高 可以使用blue ocean自动生成 支持语法检查 坏处 代码逻辑能力比脚本式弱，不能完成特别复杂的任务 脚本式流水线好处 更少的代码和弱规范要求 更灵活的自定义代码操作 不受约束，可以构建特别复杂的工作流和流水线 坏处 读写对编程要求比较高 比声明式流水线代码更复杂","tags":"jenkins"},{"title":"JavaScript","url":"/2023/10/12/JavaScript/","text":"二、JavaScript1、JavaScript介绍JavaScript语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行JavaScript代码。JS是Netscape网景公司的产品，最早取名为LiveScript；为了吸引更多java程序员，更名为JavaScript。 JS是弱类型，Java是强类型。 弱类型就是类型可变。 强类型，就是定义变量的时候，类型已确定，而且不可变。 特点： 交互性（它可以做的就是信息的动态交互） 安全性（不允许直接访问本地硬盘） 跨平台性（只要是可以解析JS的浏览器都可以执行，和平台无关） 2、JavaScript和html代码的结合方式2.1、第一种方式只需要在head标签中或者在body标签中，使用script标签来书写JavaScript代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //alert是JavaScript语言提供的一个警告框函数 //它可以接受任意类型的参数，这个参数就是警告框中显示的内容 alert(&quot;Hello JavaScript!&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 2.2、第二种方式使用script标签引入单独的JavaScript代码文件 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 现在需要使用script标签来引入js文件来执行， src属性专门用来引入js文件路径（可以是相对路径，也可以是绝对路径） script标签可以用来定义js代码，也可以用来引入js文件， 但是不能同时使用两种方式，否则会报错。 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;1.js&quot;&gt; &lt;/script&gt; &lt;script&gt; alert(&quot;现在可以执行了&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、变量什么是变量？变量是可以存放某些值的内存的命名。 JavaScript的变量类型： ​ 数值类型：number​ 字符串类型：string​ 对象类型：object​ 布尔类型：boolean​ 函数类型：function JavaScript里特殊的值： ​ undefined 未定义，所有js变量未赋于初始值的时候，默认值都是undefined​ null 空值​ NAN 全称是：Not a Number。非数字。非数值。 JavaScript的定义变量格式： ​ var 变量名；​ var 变量名 &#x3D; 值； 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var i ; //alert(i);//udefined i=12; //typeof()是JavaScript语言提供的一个函数 //它可以取变量的数据类型返回 //alert(typeof (i));//number i=&quot;abc&quot;; alert(typeof (i));//string var a = 12; var b = &quot;abc&quot;; alert(a*b);//NaN是非数字，非数值。 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 4、关系（比较）运算等于：&#x3D;&#x3D; 等于是简单的数字面值的比较 全等于：&#x3D;&#x3D;&#x3D; 除了数字面值的比较之外，还好比较两个变量的数据类型 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script typeof=&quot;text/javascript&quot;&gt; // 关系运算 var a = 10; var b=&quot;10&quot;; alert(a == b); // true alert(a === b); // false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 5、逻辑运算且运算：&amp;&amp; 或运算：|| 取反运算：！ 在JavaScript语言中，所有的变量，都可以作为一个boolean类型的变量去使用。 注意：0、null、undefined、””（空串），都认为是false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*&amp;&amp; 且运算有两种情况：第一种：当表达式全为真的时候，返回最后一个表达式的值。第二种：当表达式中，有一个为假的时候，返回第一个为假的表达式的值|| 或运算第一种情况：当表达式全为假的时候，返回最后一个表达式的值第二种情况：只要有一个表达式为真。就会把第一个为真的表达式的值返回并且&amp;&amp; 与运算 和 ||或运算 有短路。短路就是说，当这个&amp;&amp;或||运算有结果了之后。后面的表达式不再执行*/&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*在JavaScript语言中，所有的变量，都可以作为一个boolean类型的变量去使用。 注意：0、null、undefined、&quot;&quot;（空串），都认为是false*/ /*var a = 0; if(a)&#123; alert(&quot;a是true&quot;); &#125;else &#123; alert(&quot;a是false&quot;); &#125; var b = null; if(b)&#123; alert(&quot;b是true&quot;); &#125;else &#123; alert(&quot;b是false&quot;); &#125; var c = undefined; if(c)&#123; alert(&quot;c是true&quot;); &#125;else &#123; alert(&quot;c是false&quot;); &#125; var d = &quot;&quot;; if(d)&#123; alert(&quot;d是true&quot;); &#125;else &#123; alert(&quot;d是false&quot;); &#125;*/ /* &amp;&amp; 且运算 有两种情况： 第一种：当表达式全为真的时候，返回最后一个表达式的值。 第二种：当表达式中，有一个为假的时候，返回第一个为假的表达式的值 || 或运算 第一种情况：当表达式全为假的时候，返回最后一个表达式的值 第二种情况：只要有一个表达式为真。就会把第一个为真的表达式的值返回 并且&amp;&amp; 与运算 和 ||或运算 有短路。 短路就是说，当这个&amp;&amp;或||运算有结果了之后。后面的表达式不再执行 */ var a = &quot;abc&quot;; var b = true; var d = false; var c = null; //alert(a &amp;&amp; b);//true //alert(b &amp;&amp; a);//abc //alert(a &amp;&amp; d);//false //alert(a&amp;&amp;c);//null //alert(a&amp;&amp;d&amp;&amp;c);//false //alert(d||c);//null //alert(c||d);//false //alert(a||c);//abc //alert(b||c);//true &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 6、数组（重点）6.1、数组定义方式js中数组的定义： 格式： var 数组名 &#x3D; [];&#x2F;&#x2F;空数组 var 数组名 &#x3D; [1,’abc’,true];&#x2F;&#x2F;定义数组的同时赋值给元素 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var arr = [true,1];//定义一个空数组 //alert(arr.length);//0 arr[0] = 12; //alert(arr[0]);//12 //alert(arr.length);//1 //JavaScript数组的长度是可变的， //只要我们通过数组下标赋值，那么最大的下标值， //就会自动给数组做扩容操作 arr[2] = &quot;abc&quot;; //alert(arr.length);//3 //alert(arr[1]);//undefined for (var i = 0; i &lt; arr.length ; i++) &#123; alert(arr[i]); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 7、函数（重点）7.1、函数的两种定义方式第一种，可以使用function关键字来定义函数。 使用的格式如下： 12345function 函数名(形参列表)&#123; 函数体&#125;在JavaScript语言中，如何定义带有返回值的函数？只需要在函数体内直接使用return语句返回值即可！ 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义一个无参数的函数 function show()&#123; alert(&quot;这是一个无参数的函数&quot;); &#125; //函数调用才会执行 //show(); function show2(a,b)&#123; alert(&quot;这是一个有参数的函数，参数a的值是&quot;+a+&quot;，参数b的值是&quot;+b); &#125; //show2(1,2); //定义一个有返回值的函数 function show3(num1,num2)&#123; var sum=num1+num2; return &quot;这是一个有返回值的函数，参数num1的值是&quot;+num1+&quot;，参数num2的值是&quot;+num2+&quot;，返回值是&quot;+sum; &#125; alert(show3(1,2)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 函数的第二种定义方式，格式如下： 1234使用格式如下：var 函数名 = function(形参列表)&#123; 函数体&#125; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var fun = function() &#123; alert(&quot;无参数函数&quot;); &#125; //fun(); var fun2 = function(a, b) &#123; alert(&quot;有参数函数a=&quot; + a + &quot;,b=&quot; + b); &#125; //fun2(1, 2); var fun3 = function(a, b) &#123; return a + b; &#125; //alert(fun3(1, 2)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意：在Java中函数允许重载，但是在js中函数的重载会直接覆盖上一次的定义。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function a() &#123; alert(&quot;第一次定义a函数&quot;); &#125; function a(a,b) &#123; alert(&quot;第二次定义a函数&quot;); &#125; a(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 7.2、函数的arguments隐形参数（只在funtion函数内）就是在function函数中不需要定义，但却可以直接用来获取所有参数的变量，我们管它叫做隐形参数。 隐形参数特别像java基础的可变长参数一样。 public void fun(Object…args); 可变长参数其实是一个数组。 那么js中的隐形参数也跟java的可变参数一样，操作类似数组。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun()&#123; //alert(arguments.length); /*alert(arguments[0]); alert(arguments[1]); alert(arguments[2]);*/ alert(&quot;无参函数fun()&quot;) for(var i=0;i&lt;arguments.length;i++)&#123; alert(arguments[i]); &#125; &#125; //fun(1,&quot;a&quot;,true); //需求：编写一个函数，用于计算所有参数相加的和并返回。 function sum(num1,num2) &#123; var result = 0; for(var i=0;i&lt;arguments.length;i++)&#123; if(typeof arguments[i] == &quot;number&quot;)&#123; result += arguments[i]; &#125; &#125; return result; &#125; alert(sum(1,2,3,4,&quot;abc&quot;,5,6,7,8,9,10)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 8、JS中的自定义对象（扩展内容） Object形式的自定义对象 var 变量名 &#x3D; new Object(); &#x2F;&#x2F;对象实例（空对象） 变量名.属性名&#x3D;值；&#x2F;&#x2F;定义一个属性 变量名.函数名&#x3D;function(){}&#x2F;&#x2F;定义一个函数 对象的访问： ​ 变量名.属性&#x2F;函数名(); 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var obj = new Object(); obj.name = &quot;张三&quot;; obj.age = 18; obj.fun = function()&#123; alert(&quot;姓名：&quot;+this.name+&quot;\\n年龄：&quot;+this.age); &#125; //对象的访问 alert(obj.name); obj.fun(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; {}花括号形式的自定义对象 12345678对象的定义：var 变量名 = &#123; //空对象 属性名：值， //定义一个属性 属性名：值， //定义一个属性 函数名：function()&#123;&#125; //定义一个函数&#125;；对象的访问： 变量名.属性/函数名(); 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; name: &quot;张三&quot;, age: 18, fun: function () &#123; alert(&quot;我的名字是&quot; + this.name + &quot;，我今年&quot; + this.age + &quot;岁了&quot;); &#125; &#125;; alert(obj.name); obj.fun(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 9、js中的事件什么是事件？事件是电脑输入设备与页面进行交互的响应，我们称之为事件。 常用事件： onload加载完成事件； 页面加载完成之后，常用于做页面js代码初始化操作 onclick单击事件； 常用于按钮的点击响应事件 onblur失去焦点事件 常用于输入框失去焦点后验证输入内容是否合法 onchange内容发生改变事件 常用于下拉列表和输入框内容发生改变后操作 onsubmit表单提交事件； 常用于表单提交前，验证所有表单项是否合法。 事件的注册又分静态注册和动态注册两种： 12什么是事件的注册（绑定）？其实就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。 静态注册事件： 通过html标签的事件属性直接赋予事件响应后的代码，这种方式就是静态注册 动态注册事件： 指的是先通过js代码得到标签的dom对象，然后再通过dom 对象.事件名 &#x3D; function(){}这种形式赋予事件响应后的代码，叫动态注册。 动态注册的基本步骤： 获取标签对象 标签对象.事件名 &#x3D; function(){} 9.1、onload事件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //onload事件的方法 function onloadFun()&#123; alert(&#x27;静态注册onload事件,所有代码&#x27;); &#125; //onload事件动态注册，是固定的写法 window.onload = function ()&#123; alert(&#x27;动态注册onload事件,所有代码&#x27;); &#125;; &lt;/script&gt;&lt;/head&gt; &lt;!--静态注册onload事件 onload事件是浏览器解析完页面之后就会自动触发的事件 &lt;body onload=&quot;onloadFun()&quot;&gt; --&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 9.2、onclick事件123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function onclickFun() &#123; alert(&quot;静态注册onclick事件&quot;); &#125; //动态注册onclick事件 window.onload = function () &#123; //获取标签对象 /* *document是js语言提供的一个对象（文档） * get 获取 * Element 元素（就是标签） * By 通过。。由。。经。。 * Id id属性 */ var btn = document.getElementById(&quot;btn01&quot;); //通过标签对象注册onclick事件 //alert(btn); btn.onclick = function () &#123; alert(&quot;动态注册onclick事件&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 静态注册click事件 --&gt; &lt;button onclick=&quot;onclickFun()&quot;&gt;按钮1&lt;/button&gt; &lt;button id=&quot;btn01&quot;&gt;按钮2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 9.3、onblur事件123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //静态注册onblur事件 function onblurFun()&#123; //console是控制台对象，是由js语言提供，专门用于来向浏览器的控制台打印输出，用于测试使用 //log()是打印的方法 console.log(&quot;静态注册onblur事件&quot;); &#125; //动态注册onblur事件 window.onblur = function()&#123; //获取标签对象 var obj = document.getElementById(&quot;password&quot;); //alert(obj); //通过标签对象.事件名 = function()&#123;&#125;来注册事件 obj.onblur = function()&#123; console.log(&quot;动态注册onblur事件&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;onblurFun()&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;password&quot; &gt;&lt;br/&gt; &lt;button onclick=&quot;check()&quot;&gt;登录&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 9.4、onchange事件12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function onchangeFun() &#123; alert(&quot;女神已经改变了！&quot;); &#125; window.onload = function () &#123; var oSelect = document.getElementById(&quot;男神&quot;); //alert(oSelect); oSelect.onchange = function () &#123; alert(&quot;男神已经改变了！&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 请选择你们心中的女神： &lt;!--静态注册onchange事件--&gt; &lt;select onchange=&quot;onchangeFun()&quot;&gt; &lt;option&gt;--女神1--&lt;/option&gt; &lt;option&gt;--女神2--&lt;/option&gt; &lt;option&gt;--女神3--&lt;/option&gt; &lt;option&gt;--女神4--&lt;/option&gt; &lt;option&gt;--女神5--&lt;/option&gt; &lt;/select&gt; 请选择你们心中的男神： &lt;!--动态注册onchange事件--&gt; &lt;select id=&quot;男神&quot;&gt; &lt;option&gt;--男神1--&lt;/option&gt; &lt;option&gt;--男神2--&lt;/option&gt; &lt;option&gt;--男神3--&lt;/option&gt; &lt;option&gt;--男神4--&lt;/option&gt; &lt;option&gt;--男神5--&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 9.5、onsubmit表单提交事件12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //静态注册表单提交请求 function onsubmitFun() &#123; //要验证所有表单项是否合法，如果有一个不合法就要阻止表单提交 alert(&quot;静态注册表单提交请求----发现不合法&quot;); return false; &#125; window.onload = function () &#123; //获取标签对象 var form = document.getElementById(&quot;form01&quot;); //alert(form); //给表单对象添加onsubmit事件 form.onsubmit = function () &#123; //要验证所有表单项是否合法，如果有一个不合法就要阻止表单提交 alert(&quot;动态注册表单提交请求----发现不合法&quot;); return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8080&quot; method=&quot;get&quot; onsubmit=&quot;return onsubmitFun()&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;静态提交&quot;/&gt; &lt;/form&gt; &lt;form action=&quot;http://localhost:8080&quot; id=&quot;form01&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;动态提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10、DOM模型DOM全称是Document Object Model 文档对象模型 大白话，就是把文档中的标签，属性，文本，转换成为对象来管理。 那么它们是如何实现把标签，属性，文本转换成为对象来管理的呢？这就是下面学习的重点。 10.1、Document对象（重点） Document对象的理解： Document它管理了所有的HTML文档内容。 Document它是一种树结构的文档，有层级关系。 它让我们把所有的标签 都 对象化 我们可以通过Document访问所有的标签对象 123456789什么是对象化？举例：有一个人年龄18岁，性别女，名字小李我们要把这个人的信息对象化怎么办？class Person&#123; private int age; private String sex; private String name;&#125; 1234&lt;!--那么html标签要对象化怎么办--&gt;&lt;body&gt; &lt;div id=&quot;div01&quot;&gt;div01&lt;/div&gt;&lt;/body&gt; 12345678模拟对象化。相当于：class Dom&#123; private String id;//id属性 private String tagName;//表示标签名 private Dom parentNode;//父亲 private List&lt;Dom&gt;children;//孩子结点 private String innerHTML;//起始标签和结束标签中间的内容&#125; 10.2、Document对象中的方法介绍（重点）document.getElementById(elementId) 通过标签的id属性查找标签dom对象，elementId是标签的id属性值 document.getElementsByName(elementName) 通过标签的name属性查找标签dom对象，elementName是标签的name属性值 document.getElementsByTagName(tagName) 通过标签名查找标签dom对象，tagName是标签名 document.createElement(tagName) 方法，通过给定的标签名，创建一个标签对象，tagName是要创建的标签名 getElementById方法示例代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /** * 需求：当用户点击了校验按钮，要获取输出框中的内容，然后做验证其是否合法。&lt;br/&gt; * 验证的规则是：必须由字母，数字，下划线组成，且长度不能小于6位，不能大于20位。&lt;br/&gt; */ function onclickFun()&#123; //1.当我们要操作一个标签的时候，我们需要先获取标签的对象。 var usernameObj=document.getElementById(&quot;username&quot;); //alert(usernameObj); //[object HTMLInputElement]它就是dom对象 //alert(usernameObj.type); //alert(usernameObj.value);//value值是用户输入的内容 var usernameText=usernameObj.value; //2.验证用户输入的内容是否合法。 //需要用到正则表达式 var reg=/^\\w&#123;6,20&#125;$/; /* * test()方法：用于测试一个字符串是否匹配我的规则 * 匹配就返回true，不匹配就返回false。 */ if(reg.test(usernameText))&#123; alert(&quot;用户名合法！&quot;); &#125;else&#123; alert(&quot;用户名不合法！&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;aaa&quot;&gt; &lt;button onclick=&quot;onclickFun()&quot;&gt;校验&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; getElementsByName方法示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //全选 function checkAll()&#123; //让所有复选框都选中 //document.getElementsByName();是根据指定的name属性值查询返回多个标签对象集合 //这个集合的操作跟数组一样 //集合中每一个元素都是dom对象 var hobbies = document.getElementsByName(&quot;hobby&quot;); //alert(habbies[2].value); //checked表示是否选中，如果选中，则为true，否则为false //这个属性是读，可写的 for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = true; &#125; &#125; //全不选 function checkNo()&#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = false; &#125; &#125; //反选 function checkReverse()&#123; var hobbies = document.getElementsByName(&quot;hobby&quot;); for(var i=0;i&lt;hobbies.length;i++)&#123; hobbies[i].checked = !hobbies[i].checked; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt; &lt;button onclick=&quot;checkNo()&quot;&gt;全不选&lt;/button&gt; &lt;button onclick=&quot;checkReverse()&quot;&gt;反选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; getElementByTagName： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //全选 function checkAll() &#123; //document.getElementsByTagName(&quot;input&quot;)返回一个数组 //这个集合的操作方法和数组的操作方法一样 //集合中都是dom对象 //集合中元素顺序 是他们在页面中从上到下的顺序 var inputs = document.getElementsByTagName(&quot;input&quot;); for(var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].checked = true; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; value=&quot;cpp&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button onclick=&quot;checkAll()&quot;&gt;全选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123注意：document对象的三个查询方法，如果有id属性优先使用getElementId方法来进行查询，如果没有id属性，则优先使用getElementsByName方法来进行查询，如果id属性和name属性都没有，最后再按标签名查getElementsByTagName以上三个方法，代码一定要在页面加载完成之后执行，才能查询到标签对象 10.3、正则表达式123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //表示字符串中是否包含e // var patt = new RegExp(&quot;e&quot;); //var patt = /e/;//更简单的写法 //var patt = /[abcd]/;//匹配a或b或c或d //var patt = /[a-z]/;//匹配a-z的任意一个字符 //var patt = /[A-Z]/;//匹配A-Z的任意一个字符 //var patt = /[0-9]/;//匹配0-9的任意一个字符 //var patt = /\\w/;//匹配任意一个字符，包括字母、数字、下划线 //var patt = /\\W/;//匹配任意一个非字母、数字、下划线的字符 //var patt = /a+/;//匹配a的至少一次 //var patt = /a*/;//匹配a的0次或者多次 //var patt = /a?/;//匹配a的0次或者1次 //var patt = /a&#123;2&#125;/;//匹配a连续2次 //var patt = /a&#123;2,4&#125;/;//匹配a连续2-4次 //var patt = /[^a-z]/;//匹配除a-z以外的任意一个字符 //var patt = /a&#123;2,&#125;/;//匹配a连续2次以上 //var patt = /a$/;//匹配a的最后一个字符 //var patt = /^a/;//匹配a的第一个字符 //alert(patt); var patt = /\\w&#123;6,20&#125;/; var str = &quot;bbaaaaa&quot;; alert(patt.test(str)); //问题：var patt = /a&#123;2,4&#125;/;//最多什么时候有用？ //var patt = /^a&#123;2,4&#125;$/; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 10.4、两种常见的验证提示效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /** * 需求：当用户点击了校验按钮，要获取输出框中的内容，然后做验证其是否合法。&lt;br/&gt; * 验证的规则是：必须由字母，数字，下划线组成，且长度不能小于6位，不能大于20位。&lt;br/&gt; */ function onclickFun()&#123; //1.当我们要操作一个标签的时候，我们需要先获取标签的对象。 var usernameObj=document.getElementById(&quot;username&quot;); //alert(usernameObj); //[object HTMLInputElement]它就是dom对象 //alert(usernameObj.type); //alert(usernameObj.value);//value值是用户输入的内容 var usernameText=usernameObj.value; //2.验证用户输入的内容是否合法。 //需要用到正则表达式 var reg=/^\\w&#123;6,20&#125;$/; /* * test()方法：用于测试一个字符串是否匹配我的规则 * 匹配就返回true，不匹配就返回false。 */ var usernameSpanObj = document.getElementById(&quot;usernameSpan&quot;); //innerHTML起始标签和结束标签之间的内容 //这个属性可读可写 //alert(usernameSpanObj.innerHTML); usernameSpanObj.innerHTML=&quot;666&quot;; if(reg.test(usernameText))&#123; //alert(&quot;用户名合法！&quot;); //usernameSpanObj.innerHTML=&quot;*用户名合法！&quot;; usernameSpanObj.innerHTML=&quot;&lt;img src=\\&quot;right.png\\&quot; width=\\&quot;15px\\&quot; height=\\&quot;15px\\&quot;&gt;&quot; &#125;else&#123; //alert(&quot;用户名不合法！&quot;); //usernameSpanObj.innerHTML=&quot;*用户名不合法！&quot;; usernameSpanObj.innerHTML=&quot;&lt;img src=\\&quot;wrong.png\\&quot; width=\\&quot;15px\\&quot; height=\\&quot;15px\\&quot;&gt;&quot; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;aaa&quot;&gt; &lt;span id=&quot;usernameSpan&quot; style=&quot;color: red;&quot;&gt; &lt;/span&gt;&lt;br/&gt; &lt;button onclick=&quot;onclickFun()&quot;&gt;校验&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 10.5、节点的常用属性和方法节点就是标签对象 方法： 通过具体的元素节点调用getElementsByTagName()方法，获取当前节点的指定标签名孩子节点 appendChild(oChildNode)方法，可以添加啊一个子节点，oChildNode是要添加的孩子节点。 注意： 文本也是一个节点。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; //现在需要我们使用js代码来创建html标签，并显示在页面上 //标签的内容就是：&lt;div&gt;666真厉害&lt;/div&gt; var divObj=document.createElement(&quot;div&quot;);//在内存中，&lt;div&gt;&lt;/div&gt; var textNodeObj = document.createTextNode(&quot;666真厉害&quot;);//有一个文本节点 divObj.appendChild(textNodeObj);//将文本节点添加到标签中 //divObj.innerHTML=&quot;666真厉害&quot;;//在内存中，&lt;div&gt;666真厉害&lt;/div&gt; //添加子节点 document.body.appendChild(divObj);//将divObj添加到body中 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 属性： childNodes属性，获取当前节点的所有子节点。 firstChild属性，获取当前节点的第一个子节点。 lastChild属性，获取当前节点的最后一个子节点。 parentNode属性，获取当前节点的父节点。 nextSibling属性，获取当前节点的下一个节点。 previousSibling属性，获取当前节点的是一个节点。 className属性，用于获取或设置标签的class属性值。 innerHTML属性，表示获取&#x2F;设置起始标签和结束标签之间的内容。 innerText属性，表示获取&#x2F;设置起始标签和结束标签之间的文本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;dom查询&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; //1.查找#bj节点 var btn01Ele= document.getElementById(&quot;btn01&quot;); btn01Ele.onclick = function()&#123; var bjObj=document.getElementById(&quot;bj&quot;); alert(bjObj.innerHTML); &#125; //2.查找所有li节点 var btn02Ele = document.getElementById(&quot;btn02&quot;); btn02Ele.onclick = function()&#123; var lis=document.getElementsByTagName(&quot;li&quot;); alert(lis.length); &#125;; //3.查找name=gender的所有节点 var btn03Ele = document.getElementById(&quot;btn03&quot;); btn03Ele.onclick = function()&#123; var genders=document.getElementsByName(&quot;gender&quot;); alert(genders.length); &#125;; //4.查找#city下所有li节点 var btn04Ele = document.getElementById(&quot;btn04&quot;); btn04Ele.onclick = function()&#123; //第一获取id为city的节点 //第二通过city节点，getElementsByTagName获取所有的li节点 var cityObj=document.getElementById(&quot;city&quot;); var lis=cityObj.getElementsByTagName(&quot;li&quot;); alert(lis.length); &#125;; //5.返回#city的所有子节点 var btn05Ele = document.getElementById(&quot;btn05&quot;); btn05Ele.onclick = function()&#123; var cityObj=document.getElementById(&quot;city&quot;); var lis=cityObj.childNodes; alert(lis.length); &#125;; //6.返回#phone的第一个子节点 var btn06Ele = document.getElementById(&quot;btn06&quot;); btn06Ele.onclick = function()&#123; var phoneObj=document.getElementById(&quot;phone&quot;); var firstChild=phoneObj.firstChild; alert(firstChild.innerHTML); &#125;; //7.返回#bj的父节点 var btn07Ele = document.getElementById(&quot;btn07&quot;); btn07Ele.onclick = function()&#123; var bjObj=document.getElementById(&quot;bj&quot;); var parentNode=bjObj.parentNode; alert(parentNode.innerHTML); &#125;; //8.返回#android的前一个兄弟节点 var btn08Ele = document.getElementById(&quot;btn08&quot;); btn08Ele.onclick = function()&#123; var androidObj=document.getElementById(&quot;android&quot;); var previousSibling=androidObj.previousSibling; alert(previousSibling.innerHTML); &#125;; //9.读取#username的value属性值 var btn09Ele = document.getElementById(&quot;btn09&quot;); btn09Ele.onclick = function()&#123; var usernameObj=document.getElementById(&quot;username&quot;); var value=usernameObj.value; alert(value); &#125;; //10.设置#username的value属性值 var btn10Ele = document.getElementById(&quot;btn10&quot;); btn10Ele.onclick = function()&#123; var usernameObj=document.getElementById(&quot;username&quot;); usernameObj.value=&quot;小明&quot;; &#125;; //11.返回#bj的文本值 var btn11Ele = document.getElementById(&quot;btn11&quot;); btn11Ele.onclick = function()&#123; var bjObj=document.getElementById(&quot;bj&quot;); //var text=bjObj.innerHTML; var text=bjObj.innerText; alert(text); &#125;; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;total&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt; 你喜欢哪款单机游戏? &lt;/p&gt; &lt;ul id=&quot;game&quot;&gt; &lt;li id=&quot;rl&quot;&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt; 你手机的操作系统是? &lt;/p&gt; &lt;ul id=&quot;phone&quot;&gt;&lt;li&gt;IOS&lt;/li&gt;&lt;li id=&quot;android&quot;&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot;&gt; gender: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt; Male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt; Female &lt;br&gt; &lt;br&gt; name: &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;username&quot; value=&quot;abcde&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;btnList&quot;&gt; &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn08&quot;&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn09&quot;&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn10&quot;&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn11&quot;&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":"js"},{"title":"HTML和CSS","url":"/2023/10/12/html和css/","text":"Web第一天 一、html和CSS1.B&#x2F;S 软件的结构 JavaSE： C&#x2F;S Client Server B&#x2F;S Browser Server 2.前段开发流程 3.网页的组成部分页面由三部分组成！ 分别是内容（结构）、表现、行为。 内容（结构），是我们在页面中可以看到的数据。我们称之为内容。一般内容我们使用html技术来展示。 表现，指的是这些内容在页面上的展示形式。比如说，布局、颜色、大小等等。一般使用CSS技术实现。 行为，指的是页面中元素与输入设备交互的响应，一般使用JavaScript技术实现。 4.HTML简介Hyper Text Markup Language（超文本标记语言） 简写：HTML HTML通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画面如何安排，图片如何显示等） 5.创建HTML文件 创建一个web工程（静态的web工程） 在工程下创建html页面 选择执行的浏览器 12345678910&lt;!DOCTYPE html&gt;&lt;!-- 约束，声明 --&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;!-- html 标签标示html的开始 lang=&quot;zh_CN&quot;表示中文 html标签中一般分为两部分，分别是：head和body--&gt;&lt;head&gt;&lt;!-- 表示头部信息，一般包含三部分内容，title标签，css样式，js代码--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--表示当前页面使用UTF-8字符值--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--表示当前页面的标题--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--body标签表示整个页面显示的主体内容--&gt; hello&lt;/body&gt;&lt;/html&gt; 6.HTML文件的书写规范12345678&lt;html&gt; 表示整个html页面的开始 &lt;head&gt; 头信息 &lt;title&gt;标题&lt;/title&gt; 标题 &lt;/head&gt; &lt;body&gt; body是页面的主体内容 页面主体内容 &lt;/body&gt;&lt;/html&gt; 表示整个html页面的结束 html中的代码注释： 7.HTML标签介绍 标签的格式： ​ &lt;标签名&gt;封装的数据&lt;&#x2F;标签名&gt; 标签名大小写不敏感 标签拥有自己的属性 分为基本属性：bgcolor&#x3D;”red” 可以修改简单的样式效果 事件属性：onclick&#x3D;”alert(‘你好’);” 可以直接设置时间响应后的代码 标签又分为：单标签和双标签 单标签格式：&lt;标签名 &#x2F;&gt; br 换行，hr水平线 双标签格式：&lt;标签名&gt; …封装的数据…&lt;&#x2F;标签名&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;!-- 约束，声明 --&gt;&lt;html lang=&quot;zh_CN&quot;&gt;&lt;!-- html 标签标示html的开始 lang=&quot;zh_CN&quot;表示中文 html标签中一般分为两部分，分别是：head和body--&gt;&lt;head&gt;&lt;!-- 表示头部信息，一般包含三部分内容，title标签，css样式，js代码--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--表示当前页面使用UTF-8字符值--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--表示当前页面的标题--&gt;&lt;/head&gt;&lt;!-- bgcolor表示背景颜色属性 onclick表示单击（点击）事件 alert()是javaScript语言提供的一个警告框函数 它可以接收任意参数，参数就是警告框的函数信息 --&gt;&lt;body onclick=&quot;alert(&#x27;真牛逼&#x27;)&quot;&gt;&lt;!--body标签表示整个页面显示的主体内容--&gt; hello&lt;button onclick=&quot;alert(&#x27;真牛逼&#x27;)&quot;&gt;按钮&lt;/button&gt;&lt;hr/&gt;学web的第一天&lt;br/&gt;哈哈哈哈&lt;/body&gt;&lt;/html&gt; 标签的语法： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;0-标签语法.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ①标签不能交叉嵌套 --&gt; 正确：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/span&gt;&lt;/div&gt; 错误：&lt;div&gt;&lt;span&gt;早安，尚硅谷&lt;/div&gt;&lt;/span&gt; &lt;hr /&gt; &lt;!-- ②标签必须正确关闭 --&gt; &lt;!-- i.有文本内容的标签： --&gt; 正确：&lt;div&gt;早安，尚硅谷&lt;/div&gt; 错误：&lt;div&gt;早安，尚硅谷 &lt;hr /&gt; &lt;!-- ii.没有文本内容的标签： --&gt; 正确：&lt;br /&gt;1 错误：&lt;br&gt;2 &lt;hr /&gt; &lt;!-- ③属性必须有值，属性值必须加引号 --&gt; 正确：&lt;font color=&quot;blue&quot;&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color=blue&gt;早安，尚硅谷&lt;/font&gt; 错误：&lt;font color&gt;早安，尚硅谷&lt;/font&gt; &lt;hr /&gt; &lt;!-- ④注释不能嵌套 --&gt; 正确：&lt;!-- 注释内容 --&gt; &lt;br/&gt; 错误：&lt;!-- 注释内容 &lt;!-- 注释内容 --&gt;--&gt; &lt;hr /&gt;&lt;/body&gt;&lt;/html&gt; 8.常用标签介绍参考： 文档：w3cschool.CHM 8.1、font字体标签需求1：在网页上显示我是字体标签，并修改字体为宋体，颜色为红色。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;1.font标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 字体标签 需求1：在网页上显示我是字体标签，并修改字体为宋体，颜色为红色。 --&gt; &lt;font face=&quot;宋体&quot; color=&quot;red&quot;&gt;我是字体标签&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 1font标签是字体标签，它可以来修改文本的字体、字号、字形、颜色等。 8.2、特殊字符需求1：把&lt; br&#x2F; &gt;换行符标签变成文本转换成字符显示在页面上。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;2.特殊字符.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 特殊字符 需求1：把&lt;br/&gt;换行符标签变成文本转换成字符显示在页面上。 常用的特殊字符： &lt; ***&gt;&gt;&gt;&gt; &amp;lt; &gt; ***&gt;&gt;&gt;&gt; &amp;gt; 空格 ***&gt;&gt;&gt;&gt; &amp;nbsp; --&gt; 我是&amp;lt;br&amp;gt;标签&lt;br/&gt; 学习web&amp;nbsp;&amp;nbsp;开发 &lt;/body&gt;&lt;/html&gt; 8.3、标题标签标题标签是 h1 到 h6 需求1：演示标题1到标题6 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;3.标题标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 标题标签 需求1：演示标题1到标题6 h1 - h6 都是标题标签 h1是最大的标题，h6是最小的标题 align 属性可以设置标题的对齐方式 标题的对齐方式： left：左对齐 right：右对齐 center：居中 --&gt; &lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt; &lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt; &lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 8.4、超链接（重点）在网页中所有点击之后可以跳转的内容都是超链接 需求1：普通的超链接。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;4.超链接.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 超链接 a标签：超链接 href属性：超链接的目标地址 target属性：超链接的目标地址 _blank：在新窗口中打开 _self：在当前窗口中打开 默认：在当前窗口中打开 --&gt; &lt;a href=&quot;http://www.baidu.com&quot; &gt;百度&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_self&quot;&gt;百度&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_parent&quot;&gt;百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 8.5、列表标签无序列表、有序列表、定义列表 需求1：使用无序列表方式，把四大天王：刘德华、郭富城、黎明、张学友展示出来。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用无序列表方式， 把四大天王：刘德华、郭富城、黎明、张学友展示出来。 ul是无序列表，li是列表项 type属性可以修改列表项前面的符号 --&gt; &lt;ul type=&quot;none&quot;&gt; &lt;li&gt;刘德华&lt;/li&gt; &lt;li&gt;郭富城&lt;/li&gt; &lt;li&gt;黎明&lt;/li&gt; &lt;li&gt;张学友&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;刘德华&lt;/li&gt; &lt;li&gt;郭富城&lt;/li&gt; &lt;li&gt;黎明&lt;/li&gt; &lt;li&gt;张学友&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 8.6、img标签img标签可以在html页面上显示图片。 需求1：使用img标签显示一张美女的照片，并修改宽高，和边框属性。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;5.img标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：使用img标签显示一张美女的照片，并修改宽高，和边框属性。 img标签是图片标签，用来显示图片的，它的属性有： src属性是图片的路径 width属性是图片的宽度 height属性是图片的高度 border属性是图片的边框宽度 alt属性是图片的替代文字,如果图片加载失败，则显示该文字 在JavaSE中路径也分为两种： 相对路径：从工程名开始算 绝对路径：盘符:/目录/文件名 在Web中路径也分为两种： 相对路径： . 表示当前文件所在的目录 .. 表示当前文件所在的目录的上一级目录 文件名 表示当前文件所在的目录的文件，相当于 ./文件名 ./可以省略 绝对路径： 正确格式是：http://ip:port/工程名/资源路径 错误格式是：盘符:/目录/文件名 --&gt; &lt;img src=&quot;../imgs/0.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/1.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/2.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/3.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/4.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/5.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/6.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/7.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/8.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/9.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/10.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;img src=&quot;../imgs/11.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot;&gt; &lt;/body&gt;&lt;/html&gt; 8.7、表格标签（重点）需求1：做一个带表头的，三行，三列的表格，并显示边框 需求2：修改表格的宽高，表格的对齐方式，单元格间距。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;表格标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--需求1：做一个带表头的，三行，三列的表格，并显示边框 需求2：修改表格的宽高，表格的对齐方式，单元格间距。 table标签是表格标签 border属性：设置表格边框宽度 width属性：设置表格宽度 height属性：设置表格高度 align属性：设置表格相对于页面的对齐方式 cellspacing属性：设置表格单元格间距 tr标签是行标签 th标签是表头标签 td标签是列标签 align属性：设置单元格文本的对齐方式 b标签是加粗标签 --&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot; width=&quot;300px&quot; height=&quot;300px&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;b&gt;姓名&lt;/b&gt;&lt;/td&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;40&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 8.8、跨行跨列表格（次重点） 需求1：新建一个五行五列的表格，第一行，第一列的单元格要跨两列，第二行第一列的单元格要跨两行，第四行第四列的单元格要跨两行两列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;7.表格的跨行跨列&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--需求1： 新建一个五行五列的表格， 第一行，第一列的单元格要跨两列， 第二行第一列的单元格要跨两行， 第四行第四列的单元格要跨两行两列。 colspan属性设置跨列数， rowspan属性设置跨行数。 --&gt; &lt;table width=&quot;500&quot; height=&quot;500&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;td&gt;1.4&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;td&gt;2.4&lt;/td&gt; &lt;td&gt;2.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;td&gt;3.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4.1&lt;/td&gt; &lt;td&gt;4.2&lt;/td&gt; &lt;td&gt;4.3&lt;/td&gt; &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;4.4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5.1&lt;/td&gt; &lt;td&gt;5.2&lt;/td&gt; &lt;td&gt;5.3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 8.9、了解iframe框架标签（内嵌窗口）iframe标签它可以在一个html页面上，打开一个小窗口去加载一个单独的页面 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;8.iframe标签.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我是一个单独的完整的页面&lt;br/&gt;&lt;br/&gt; &lt;!--iframe标签可以在页面上开辟一个小区域显示一个单独的页面 iframe和a标签组合使用的步骤： 1.在iframe标签中使用name属性指定一个名称 2.在a标签中使用target属性指定一个名称 --&gt; &lt;iframe src=&quot;5.img标签.html&quot; width=&quot;500&quot; height=&quot;600&quot; name=&quot;abc&quot;&gt;&lt;/iframe&gt; &lt;br/&gt; &lt;br/&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;0-标签语法.html&quot; target=&quot;abc&quot;&gt;0-标签语法.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;5.img标签.html&quot; target=&quot;abc&quot;&gt;5.img标签.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;6.表格标签.html&quot; target=&quot;abc&quot;&gt;6.表格标签.html&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 8.10、表单标签（重点） 什么是表单？** 表单就是html页面中，用来收集用户信息的所有元素集合，然后把这些信息发送给服务器。 需求1：创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉下表）。隐藏域，自我评价（多行文本域）。重置，提交。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求1：创建一个个人信息注册的表单界面。包含用户名，密码，确认密码。性别（单选），兴趣爱好（多选），国籍（下拉下表）。隐藏域，自我评价（多行文本域）。重置，提交。--&gt; &lt;&lt;!-- form标签就是表单 input标签就是输入框 type属性：表示输入框的类型 type=&quot;text&quot;：文本输入框 type=&quot;password&quot;：密码输入框 type=&quot;radio&quot;：单选框 type=&quot;checkbox&quot;：多选框 type=&quot;reset&quot;：重置按钮 value属性：表示按钮的值 type=&quot;submit&quot;：提交按钮 value属性：表示按钮的值 type=&quot;button&quot;：按钮 type=&quot;file&quot;：文件上传框 type=&quot;hidden&quot;：隐藏域，当我们需要发送某些信息，而这些不需要用户参与可以使用隐藏域。（提交的时候同时发送给服务器） value属性：设置显示的默认值 name属性：可以对其进行分组 checked属性：设置默认选中 select标签：下拉框 option标签：下拉框的选项 selected属性：设置默认选中 textarea标签：多行文本域（起始标签和结束标签中的内容是默认值） rows属性：行数 cols属性：列数 --&gt; &lt;form&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;默认值&quot;/&gt; &lt;td/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 确认密码：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 &lt;td/&gt; &lt;tr&gt; &lt;td&gt;兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt;Java &lt;input type=&quot;checkbox&quot;/&gt;JavaScript &lt;input type=&quot;checkbox&quot;/&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择国籍&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt; &lt;textarea rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; &lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单的显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- form标签是表单标签 action属性是表单提交的地址 method属性是表单提交的方式（get为默认值或post） 表单提交的时候，数据没有发送给服务器的三种情况： 1.表单项没有name属性值 2.单选，复选（下拉列表） 3.表单项不在提交的form标签内 GET请求的特点 1.浏览器地址栏中的地址是：action属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value 2.不安全 3.它有数据长度的限制 POST请求的特点 1.浏览器地址栏中的地址是：action属性 2.相对于GET请求安全 3.理论上没有数据长度的限制 --&gt; &lt;form action=&quot;http://www.baidu.com&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot;&gt; &lt;h1 align=&quot;center&quot;&gt;用户注册&lt;/h1&gt; &lt;table align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名称：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;默认值&quot;/&gt; &lt;td/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 用户密码：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 确认密码：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name=&quot;Surepassword&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; checked=&quot;checked&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt;女 &lt;td/&gt; &lt;tr&gt; &lt;td&gt;兴趣爱好：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;Java&quot;/&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;JavaScript&quot;/&gt;JavaScript &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;C++&quot;/&gt;C++ &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;国籍：&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;country&quot;&gt; &lt;option value=&quot;none&quot;&gt;--请选择国籍&lt;/option&gt; &lt;option value=&quot;CN&quot; selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;USA&quot;&gt;美国&lt;/option&gt; &lt;option value=&quot;JP&quot;&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我评价：&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;desc&quot; rows=&quot;10&quot; cols=&quot;20&quot;&gt;我才是默认值&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; &lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 8.11其他标签需求1：div、span、p标签的演示 练习：创建登录的表单，包含用户名，密码框输入。并结合标签排版。让它看上去整齐一点。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;其他标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- div标签默认独占一行 span标签它的长度就是封装数据的长度 p段落标签，默认会在段落的上方或下方空出一行（若已有则不再空） --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;p&gt;p段落标签1&lt;/p&gt; &lt;p&gt;p段落标签2&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 9.CSS技术参考文档：CSS2.0.chm 9.1、CSS技术介绍css是【层叠样式表单】。是用于（增强）控制网页样式并允许将样式信息与内容分离的一种标记性语言。 9.2、CSS语法规则： 选择器：浏览器根据“选择器”决定受CSS样式影响的HTML元素（标签）。 属性：是你要改变的样式名，并且每个属性都有一个值，属性和值被冒号分开，并由花括号包围，这样就组成了一个完整的样式声明，例如：p{color:blue} **多个声明:**如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明组最后可以不加分号（但尽量在每条声明的末尾都加上分号） 例如： p{ color:red; font-size:30px;} 注意：一般每行只描述一个属性 CSS注释：&#x2F; * 注释内容 *&#x2F; 9.3、CSS和HTML的结合方式9.3.1、第一种在标签的style属性上设置”key:value value”,修改标签样式。 需求1：分别定义两个div、span标签，分别修改每个div标签的样式为：边框1个像素，实线，红色。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;border: 1px solid red&quot;&gt;div标签1&lt;/div&gt; &lt;div style=&quot;border: 1px solid red&quot;&gt;div标签2&lt;/div&gt; &lt;span style=&quot;border: 1px solid red&quot;&gt;span标签1&lt;/span&gt; &lt;span style=&quot;border: 1px solid red&quot;&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 问题：这种方式的缺点？ 如果标签多了，样式多了，代码量非常庞大。 可读性非常差。 CSS代码没什么复用性可言。 9.3.2、第二种：在head标签中，使用style标签来定义各种自己需要的css样式。 格式如下： xxx{ key : value value;} 需求1：分别定义两个div、span标签，分别修改每个div标签的样式为：边框1个像素，实线，红色。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--style标签专门用来定义css样式代码--&gt; &lt;style type=&quot;text/css&quot;&gt; /*定义一个全局的样式*/ div&#123; border: 1px solid red; &#125; span&#123; border: 1px solid blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 问题：这种方式的缺点。 只能在同一页面内复用代码，不能在多个页面中复用css代码。 维护起来不方便，实际的项目中会有成千上万的页面，要到每个页面中去修改。工作量太大了。 9.3.3、第三种：把css样式 1使用html的&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./styles.css&quot;/&gt;标签导入css样式文件 123456div&#123; border: 1px solid red;&#125;span&#123; border: 1px solid blue;&#125; 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--link标签专门用来引入css样式代码--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 9.4、CSS选择器9.4.1、标签名选择器标签名选择器的格式是： ​ 标签名{​ 属性：值；​ } ​ 标签名选择器，可以决定哪些标签被动地使用这些样式 12需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*选择器*/ div&#123; border: 1px solid yellow; color: blue; font-size: 30px; &#125; /*选择器*/ span&#123; border: 5px dashed blue; color: yellow; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：在所有div标签上修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 并且修改所有span 标签的字体颜色为黄色，字体大小20个像素。边框为5像素蓝色虚线。 --&gt; &lt;div&gt;div标签1&lt;/div&gt; &lt;div&gt;div标签2&lt;/div&gt; &lt;span&gt;span标签1&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 9.4.2、id选择器123456789id选择器的格式是： #id属性值&#123; 属性:值; &#125; id选择器，可以让我们通过id属性选择性地去使用这个样式。 需求1：分别定义两个div标签， 第一个div标签定义id为id001，然后根据id属性定义css样式，修改字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 第二个div标签定义id为id002，然后根据id属性定义css样式，修改字体颜色为红色，字体大小20个像素。边框为5像素蓝色点线。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ID选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #id001&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; #id002 &#123; color: red; font-size: 20px; border: 5px dotted blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：分别定义两个 div 标签， 第一个div 标签定义 id 为 id001 ，然后根据id 属性定义css样式修改字体颜色为蓝色， 字体大小30个像素。边框为1像素黄色实线。 第二个div 标签定义 id 为 id002 ，然后根据id 属性定义css样式 修改的字体颜色为红色，字体大小20个像素。边框为5像素蓝色点线。 --&gt; &lt;div id=&quot;id001&quot;&gt;div标签1&lt;/div&gt; &lt;div id=&quot;id002&quot;&gt;div标签2&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 9.4.3、class选择器（类选择器）12345class类型选择器的格式是： .class属性值&#123; 属性:值；&#125;class类型选择器，可以通过class属性有效的选择性地的使用这个样式。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;class类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; .class02&#123; color: grey; font-size: 26px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class 属性值为 class01的 span 或 div 标签，字体颜色为蓝色，字体大小30个像素。边框为1像素黄色实线。 需求2：修改 class 属性值为 class02的 div 标签，字体颜色为灰色，字体大小26个像素。边框为1像素红色实线。 --&gt; &lt;div class=&quot;class01&quot;&gt;div标签class01&lt;/div&gt; &lt;div class=&quot;class02&quot;&gt;div标签&lt;/div&gt; &lt;span class=&quot;class01&quot;&gt;span标签class01&lt;/span&gt; &lt;span&gt;span标签2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 9.4.4、组合选择器12345组合选择器的格式是： 选择器1，选择器2，选择器n&#123; 属性:值; &#125;组合选择器可以让多个选择器共用一个css样式代码。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;组合类型选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .class01,#id001&#123; color: blue; font-size: 20px; border: 1px solid yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求1：修改 class=&quot;class01&quot; 的div 标签 和 id=&quot;id01&quot; 所有的span标签， 字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。 --&gt; &lt;div class=&quot;class01&quot;&gt;div标签class01&lt;/div&gt; &lt;br /&gt; &lt;span id=&quot;id01&quot;&gt;span 标签&lt;/span&gt; &lt;br /&gt; &lt;div id=&quot;id001&quot;&gt;div标签&lt;/div&gt; &lt;br /&gt; &lt;div&gt;div标签id01&lt;/div&gt; &lt;br /&gt;&lt;/body&gt;&lt;/html&gt; 9.5、CSS常用样式1、颜色 ​ color:red; ​ 颜色可以写颜色名如：black,blue,red,green等 ​ 颜色也可以写rgb值和十六进制表示值，如rgb(255,0,0),#00F6DE,如果写十六进制必须加# 2、宽度 ​ width:19px； 宽度可以写像素值：19px；也可以写百分比值：20%； 3、高度 ​ height：20px； 宽度可以写像素值：19px；也可以写百分比值：20%； 4、背景颜色 background-color:#0F2D4C 5、字体样式 color:#FF0000;字体颜色红色 font-size:20px；字体大小 6、红色1像素实线边框 border：1px solid red; 7、DIV居中 margin-left：auto；margin-right:auto; 8、文本居中 text-align：center； 9、超链接去下划线 text-decoration：none； 10、表格细线 1234567table&#123; border:1px solid black; border-collapse:collapse;&#125;td,th&#123; border:1px solid black;&#125; 11、列表去除修饰 ul{ list-style: none;} 常用样式的使用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06-css常用样式.html&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; color: red; border: 1px solid yellow; width: 200px; height: 200px; background-color: green; font-size: 30px; margin-left: auto; margin-right: auto; text-align: center; &#125; a&#123; text-decoration: none; &#125; table&#123; border: 1px solid red; border-collapse: collapse; &#125; td&#123; border: 1px solid blue; &#125; ul&#123; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;22&lt;/li&gt; &lt;li&gt;33&lt;/li&gt; &lt;li&gt;44&lt;/li&gt; &lt;li&gt;55&lt;/li&gt; &lt;/ul&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div&gt;我是div标签&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":"html、css"},{"title":"Git学习笔记","url":"/2023/10/12/Git/","text":"Git一、需要掌握的知识点1.1、Git1、Git介绍，分布式版本控制工具 VS 集中式版本控制工具 2、Git安装，基于官网发布的最新版本2.31.1安装讲解 3、Git命令，基于开发案例，详细讲解git的常用命令 4、Git分支，分支特性，分支创建，分支转换，分支合并，代码合并冲突解决 5、Idea集成Git 1.2、GitHub1、创建远程库 2、代码推送Push 3、代码拉取Pull 4、代码克隆Clone 5、SSH免密登录 6、Idea集成GitHub 1.3、Gitee码云1、码云创建远程库 2、Idea集成Gitee码云 3、码云连接GitHub进行代码的复制和迁移 1.4、GitLab1、GitLab服务器的搭建和部署 2、Idea集成GitLab 二、课程目标五小时熟练掌握Git GitHub GitLab Gitee码云的使用 三、正式学习1、Git概述123456Git是一个免费的、开源的分布式版本控制系统，可以快速高效的处理从小型到大型的各种项目。Git易于学习，占地面积小，性能极快，它有廉价的本地库，方便的暂存区域和多个工作流分支等特性，其性能优于Subversion、CVS、Perforce和ClearCase等版本控制工具。何为版本控制？版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。 为什么需要版本控制？进了公司将从个人开发过渡到团队协作 版本控制工具：1、集中式版本控制工具 CVS、SVN（Subversion)、VSS…. 2、分布式版本控制工具 每个客户端要连接远程库实现共同版本控制 Git简史： Git工作机制 本地库代码还可以推送到远程库。 工作区和暂存区可以随时删除，但提交到本地库之后，要删除就只能是删库跑路了。。 Git和代码托管中心代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。 局域网： ​ GitLab 互联网： ​ GitHub（外网） ​ Gitee码云（国内网站） 2、Git安装官网地址：https://git-scm.com/ 高速下载链接：https://npm.taobao.org/mirrors/git-for-windows/ 3、Git常用命令 1、设置用户签名 配置文件保存在C盘&#x2F;用户&#x2F;xiaolin&#x2F;下 2、初始化本地库1、语法 git init 2、案例实操 3、查看本地库状态1、语法 git status 2、案例实操 新建文件 vim hello.txt 按a,i,o,键进入insert模式 yy是复制 p是粘贴 按esc退出insert模式 :进入行模式 输入wq保存并退出 cat hello.txt 查看文件内容 tail -n 1 hello.txt 查看文件末尾第一行内容 4、添加到暂存区1、语法 git add 从暂存区删除 git rm –cached hello.txt 5、提交到本地库1、语法 git commit -m “日志信息” 6、查看历史记录，版本日志信息1、语法 git reflog 查看普通版本信息 git log 查看详细版本日志信息 7、修改文件再次进入到编辑模式 vim hello.txt 修改完 8、版本穿梭1、语法 git reset –hard 版本号 4、Git 分支操作 1、什么是分支1在版本控制过程中，同时推进每个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用） 2、分支的好处12同时并行推进多个功能开发，提高开发效率各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可。 3、分支的操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 1、查看分支1、语法 git branch 2、案例实操 2、创建分支1、语法 git branch 分支名 2、案例实操 3、修改分支1、语法 在所在分支下： vim 文件名，修改文件内容并保存 然后git add 文件名 添加到暂存区 git commit -m 版本信息 文件名 添加到本地库 4、切换分支git checkout 分支名 git switch 分支名 5、合并分支1、语法 git merge 分支名 把指定的分支合并到当前分支上 2、案例实操 3、冲突合并 原因： 合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，Git无法替我们决定使用哪一个，必须人为决定新代码内容。 需要进入到vim编辑模式人为修改 然后重新git add 但是注意git commit -m “版本信息” 后不再加文件名 dd删除行 4、创建分支和切换分支图解123master、hot-fix其实都是指向具体版本记录的指针，当前所在的分支，其实是由head决定的，所以创建分支的实质就是多创建一个指针。Head如果指向master，那么我们现在就在master分支上...所以切换分支的本质就是在移动head指针。 5、Git团队协作机制1、团队内协作 岳不群：push推送到代码托管中心（远程库） 令狐冲：clone完整克隆到本地库 令狐冲：修改后push回代码托管中心（远程库），需要获得岳不群的授权。 岳不群：pull拉取令狐冲修改后的代码，同步本地库 2、跨团队协作 6、GitHub操作GitHub网址：https://github.com/ 创建三个账号，模拟团队协作 账号 姓名 验证邮箱 linXiao01 小林001 &#x31;&#56;&#52;&#57;&#x35;&#x36;&#x39;&#54;&#x39;&#x35;&#x40;&#113;&#113;&#46;&#x63;&#111;&#109; linXiao02 小林002 &#50;&#x33;&#x37;&#x31;&#49;&#x31;&#x39;&#x30;&#x32;&#51;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d; linXiao03 小林003 &#54;&#x32;&#51;&#x37;&#49;&#x38;&#x61;&#97;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109; 1、创建远程库linXiao01远程库链接： https://github.com/linXiao01/git-demo.git 2、远程仓库操作 1、创建远程库别名1、语法 git remove add 别名 远程库地址 git remove -v 查看当前远程库别名 2、推送本地分支到本地库1、语法 git push 远程库名 分支名 第一次push会弹出登录github窗口 拉取远程库代码到本地库git pull 远程库别名 分支名 会自动提交到本地库 3、克隆远程仓库到本地1、语法 git clone 代码链接 2、案例实操 克隆不需要登录账号 克隆完成的操作： 拉取代码 初始化本地仓库 创建别名&#x3D;&#x3D;&gt;orign 4、邀请加入团队 5、拉取远程仓库内容1、语法 git pull 远程库别名 分支名 3、跨团队协作1、将远程仓库的地址复制发给邀请跨团队协作的人 被邀请人只需要打开链接，点击右上角fork按钮即可 可在本地库修改也可以在线修改 修改完点击pull requests 创建完pull requests 主人一方可以收到，然后进行审核 还可以进行对话 4、SSH免密登录在远程仓库中还有一个SSH的地址，也就是说我们还可以使用SSH进行访问。 具体操作如下： –进入当前用户的家目录 cd –删除.ssh 目录 rm -rvf .ssh 生成.ssh目录 ssh-keygen -t rsa -C 邮箱号 敲3次回车键 读取公共密钥并复制 打开GitHub&#x3D;&gt;设置&#x3D;&gt;SSH and GPG keys 设置完 验证pull和push 7、IDEA 集成 Git1、配置Git忽略文件1、Eclipse特定文件 2、idea特定文件 3、Maven工程的target目录 为什么要忽略这些？ 1与项目的实际功能无关，不参与服务器上部署运行，把他们忽略掉能够屏蔽IDEA工具之间的差异。 如何忽略？ 121、创建忽略规则文件，xxxx.ignore(前缀名随便起，建议是git.ignore)这个文件的存放位置原则上在哪里都可以，为了便于让~/gitconfig文件引用，建议也放在用户家目录下 git.ignore文件模板： 12345678910111213141516171819202122232425# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml 2）在.gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中） 123456[user] name = Layne email = Layne@atguigu.com [core] excludesfile = C:/Users/asus/git.ignore注意：这里要使用“正斜线（/）”，不要使用“反斜线（\\） 2、定位Git程序 3、初始化本地库打开项目、菜单栏VCS&#x3D;&gt;VCS操作&#x3D;&gt;创建Git仓库 4、添加到暂存区 5、提交到本地库 6、切换版本 7、创建分支 8、切换分支 9、合并分支 10、解决冲突 8、IDEA集成GitHub1、设置GitHub账号 2、分享工程到GitHub 3、push推送本地库到远程库 4、pull拉取远程库到本地库 5、clone克隆远程库到本地 9、国内代码托管中心-码云1、简介GitHub服务器在国外，使用GitHub作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会登录不上。针对这个情况，我们可以使用国内的项目托管网站-码云。 网址：https://gitee.com/ 使用方式和GitHub一样，是中文网站 2、码云账号注册并登录账号：15219374123 密码：******** 3、码云创建远程库 4、IDEA集成码云1、IDEA安装码云插件 2、IDEA连接码云 5、码云复制GitHub项目新建仓库-》选择导入-》输入GitHub项目http链接-》创建 如何同步？ 点击刷新按钮 10、自建代码托管平台GitLab1、GitLab简介 2、GitLab官网地址官网地址：https://about.gitlab.com/ 安装说明：https://about.gitlab.com/installation/ 3、GitLab安装1、服务器准备 2、安装包准备 3、编写安装脚本 。。。。","tags":"git"},{"title":"Filter","url":"/2023/10/12/Filter/","text":"Filter1、Filter，什么是过滤器？123456781、Filter过滤器是JavaWeb的三大组件之一，三大组件分别是：Servlet程序、Listener监听器、Filter过滤器2、Filter过滤器它是JavaEE的规范，也就是接口3、Filter过滤器它的作用数：拦截请求、过滤响应。4、拦截请求常见的应用场景有：*权限检查*日记操作*事务管理*……等等 2、Filter的初体验1、要求在你的web工程下，有一个admin目录下的所有资源（html页面、jpg图片、jsp文件、等等）都必须是用户登录之后才允许访问。 12345678910111213@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpSession session = ((HttpServletRequest) servletRequest).getSession(); Object user = session.getAttribute(&quot;user&quot;); if (user != null) &#123; servletRequest.getRequestDispatcher(&quot;/login.jsp&quot;).forward(servletRequest, servletResponse); servletResponse.getWriter().write(&quot;请先登录!&quot;); return; &#125;else&#123; //让程序继续往下访问用户的目标资源 filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; 2、Filter过滤器的使用步骤： 12341、编写一个类去实现filter接口2、实现过滤方法doFilter()3、到web.xml中配置Filter的拦截路径 3、Filter的生命周期12345678Filter的生命周期包含几个方法1、构造器方法2、int初始化方法第一二步，在web工程启动的时候执行（Filter已经创建）3、doFilter过滤方法第三步，每次拦截到请求，就会执行4、destroy销毁第四步，停止web工程的时候，就会执行（停止web工程，也会销毁Filter过滤器） 4、FilterConfig类1234561、FilterConfig类见名知义，它是Filter过滤器的配置文件类2、Tomcat每次创建Filter的时候也会同时创建一个FilterConfig类，这里包含了Filter配置文件的配置信息。3、FIlterConfig类的作用使获取Filter过滤器的配置内容*获取Filter的名称filter-name的内容*获取在filter中配置的int-param初始化参数*获取ServletContext对象 12345678910111213 @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;2、Filter初始化方法init()&quot;);// *获取Filter的名称filter-name的内容 System.out.println(&quot;filter-name:&quot; + filterConfig.getFilterName());// *获取在filter中配置的int-param初始化参数 System.out.println(&quot;初始化参数username的值是:&quot; + filterConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数password的值是:&quot; + filterConfig.getInitParameter(&quot;password&quot;));// *获取ServletContext对象 System.out.println(&quot;ServletContext对象的值是:&quot; + filterConfig.getServletContext()); &#125; 5、FilterChain过滤器链123Filter 过滤器Chain 链，链条FilterChain 就是过滤器链（多个过滤器如何一起工作） 6、Filter的拦截路径1、精确匹配 1&lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt; 2、目录匹配 1&lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; 3、后缀名匹配 1&lt;url-pattern&gt;*.html&lt;/url-pattern&gt; Filter过滤器它只关心请求的地址是否匹配，不关心请求资源是否存在。","tags":"filter"},{"title":"EL表达式","url":"/2023/10/12/EL表达式/","text":"EL表达式1、什么是El表达式，他有什么作用？1234EL表达式的全称是：Expression Language。是表达式语言El表达式的作用是：El表达式主要是替代jsp页面中的表达式脚本在jsp页面中进行数据的输出。因为EL表达式在输出数据是，要比jsp的表达式脚本简洁得很多。 1234567&lt;body&gt; &lt;% request.setAttribute(&quot;key&quot;,&quot;值&quot;); %&gt; 表达式脚本输出key的值是：&lt;%=request.getAttribute(&quot;key&quot;)==null?&quot;&quot;:request.getAttribute(&quot;key&quot;)%&gt;&lt;br&gt; EL表达式输出key的值是：$&#123;key&#125;&lt;/body&gt; EL表达式的格式是：${表达式} EL表达式在输出null值的时候，输出的是空串。jsp表达式脚本输出null值的时候，输出的是null字符串。 2、EL表达式搜索域数据的顺序EL表达式主要是在jsp页面中输出数据。 主要是输出域对象中的数据。 123456789&lt;% //往四个域中都保存了相同的key的数据 request.setAttribute(&quot;key&quot;,&quot;request&quot;); session.setAttribute(&quot;key&quot;,&quot;session&quot;); application.setAttribute(&quot;key&quot;,&quot;application&quot;); pageContext.setAttribute(&quot;key&quot;,&quot;pageContext&quot;);%&gt;$&#123;key&#125; 当四个域中都有 相同key的数据的时候，EL表达式会按照四个域从小到大的顺序去进行搜索，找到就输出 3、EL表达式输出Bean的普通属性，数组属性。List集合属性，map集合属性12需求--输出Person类中的普通属性，数组属性，list集合和map集合属性。 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;% Person person = new Person(); person.setName(&quot;林&quot;); person.setPhones(new String[]&#123;&quot;10086&quot;,&quot;110&quot;,&quot;666&quot;&#125;); List&lt;String&gt; cities= new ArrayList&lt;&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;湖南&quot;); cities.add(&quot;重庆&quot;); person.setCities(cities); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); person.setMap(map); pageContext.setAttribute(&quot;p&quot;,person); %&gt; 输出Person：$&#123;p&#125;&lt;br/&gt; 输出Person的name属性:$&#123;p.name&#125;&lt;br/&gt; 输出Person的phones数组属性值：$&#123;p.phones[1]&#125;&lt;br/&gt; 输出Person的cities集合中的元素值：$&#123;p.cities&#125;&lt;br&gt; 输出Person的List集合中个别的元素值：$&#123;p.cities[1]&#125; 输出Person的map集合：$&#123;p.map&#125;&lt;br&gt; 输出Person的map集合中某个key的值：$&#123;p.map.key1&#125;&lt;br&gt; 输出Person的age属性：$&#123;p.age&#125;&lt;br&gt;&lt;/body&gt;都是通过属性名找到相对应的get方法获取数据 4、EL表达式—–运算语法：${运算表达式}，EL表达式支持如下运算符 一、关系运算 二、逻辑运算 三、算数运算 四、empty运算 1234567empty运算是可以判断一个数据是否为空，如果为空，则输出true，反之输出FALSE以下几种情况为空：1、值为null2、值为空串3、值是Object类型数据，但是长度为04、list集合，元素个数为05、map集合，元素个数为0 五、三元运算 表达式1？表达式2：表达式3 1如果表达式1的值为真，返回表达式2，如果表达式1的值为假，返回表达式3的值 六、点运算和[]中括号运算 .点运算，可以输出Bean对象中某个属性的值 []中括号运算，可以输出有序集合中某个元素的值 并且还可以输出map集合中key里包含有特殊字符的key的值 5、El表达式的11个隐含对象EL表达式中的11个隐含对象是El表达式自己定义的，可以直接使用 123456789101112变量 类型 作用pageContext PageContextImpl 它可以获取jsp中的九大内置对象PageScope Map&lt;String,Object&gt; 它可以获取pageContext域中的数据requestScope Map&lt;String,Object&gt; 它可以获取Request域中的数据sessionScope Map&lt;String,Object&gt; 它可以获取Session域中的数据applicationScope Map&lt;String,Object&gt; 它可以获取ServletContext域中的数据param Map&lt;String,String&gt; 它可以获取请求参数的值paramValues Map&lt;String,String[]&gt; 它可以获取请求参数的值，获取多个值的时候使用header Map&lt;String,String&gt; 它可以获取请求头的信息headerValues Map&lt;String,String[]&gt; 它可以获取请求头的信息，可以获取多个值的情况cookie Map&lt;String,Cookie&gt; 它可以获取当前请求的Cookie信息initParam Map&lt;String,String&gt; 它可以获取在web.xml中配置的&lt;content-param&gt;上下文参数 一、EL获取四个特定域中的属性 123456789&lt;% pageContext.setAttribute(&quot;key1&quot;,&quot;pageContext1&quot;); pageContext.setAttribute(&quot;key2&quot;,&quot;pageContext2&quot;); request.setAttribute(&quot;key2&quot;,&quot;request2&quot;); session.setAttribute(&quot;key2&quot;,&quot;session2&quot;); application.setAttribute(&quot;key2&quot;,&quot;application2&quot;);%&gt;$&#123;requestScope.key2&#125; 二、pageContext对象的使用 12345671、协议2、服务器ip3、服务器端口号4、获取工程路径5、获取请求方法6、获取客户端ip地址7、获取会话的id编号 1234567891011121314151617181920&lt;%-- request.getScheme()它可以获取请求的协议 request.getServerName()获取请求的服务器的ip或域名 request.getServerPort()获取请求的服务器的端口号 request.getContextPath()获取当前工程路径 request.getMethod()获取请求的方式 request.getRemoteHost()获取客户端的ip地址 session.getId()获取会话的唯一标识--%&gt;&lt;% pageContext.setAttribute(&quot;req&quot;,request);%&gt;&lt;%=session.getId()%&gt;&lt;br&gt;1、协议:$&#123;req.scheme&#125;&lt;br&gt;2、服务器ip:$&#123;pageContext.request.serverName&#125;&lt;br&gt;3、服务器端口号:$&#123;pageContext.request.serverPort&#125;&lt;br&gt;4、获取工程路径:$&#123;pageContext.request.contextPath&#125;&lt;br&gt;5、获取请求方法:$&#123;pageContext.request.method&#125;&lt;br&gt;6、获取客户端ip地址:$&#123;pageContext.request.remoteHost&#125;&lt;br&gt;7、获取会话的id编号:$&#123;pageContext.session.id&#125;&lt;br&gt; 三、EL表达式其他隐含对象的使用 param Map&lt;String,String&gt; 它可以获取请求参数的值paramValues Map&lt;String,String[]&gt; 它可以获取请求参数的值，获取多个值的时候使用 1234输出请求参数username的值：$&#123;param.username&#125;&lt;br&gt;输出请求参数username的值$&#123;paramValues.username[0]&#125;&lt;br&gt;输出请求参数hobby值：$&#123;paramValues.hobby[0]&#125;&lt;br&gt;输出请求参数hobby值：$&#123;paramValues.hobby[1]&#125;&lt;br&gt; header Map&lt;String,String&gt; 它可以获取请求头的信息headerValues Map&lt;String,String[]&gt; 它可以获取请求头的信息，可以获取多个值的情况 12输出请求头【User-Agent】的值：$&#123;header[&#x27;User-Agent&#x27;]&#125;&lt;br&gt;输出请求头【User-Agent】的值：$&#123;headerValues[&#x27;User-Agent&#x27;][0]&#125;&lt;br&gt; cookie Map&lt;String,Cookie&gt; 它可以获取当前请求的Cookie信息 12获取cookie的名称：$&#123;cookie.JSESSIONID.name&#125;获取cookie的值：$&#123;cookie.JSESSIONID.value&#125; initParam Map&lt;String,String&gt; 它可以获取在web.xml中配置的上下文参数 1输出&amp;lt;Context-param&amp;gt;username的值：$&#123;initParam.username&#125; JSTL标签库（次重点）JSTL标签库，全称是JSP Standard Tag Library ，JSP标准标签库。是一个不断完善的开发源代码的JSP标签库。 EL表达式主要是为了替换jsp中的表达式脚本，而标签库则是为了替换代码脚本，这样使得整个jsp页面变得更加简洁。 JSP由五个不同功能的标签库组成： JSTL标签库的使用步骤 1、先导入jstl标签库的jar包 12taglibs-standard-spec-1.2.1.jartaglibs-standard-impl-1.2.1.jar 2、使用taglib指令引入标签库 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 1、core核心库的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172一、&lt;c:set/&gt;作用：set标签可以往域中保存数据&lt;%--一、&lt;c:set/&gt;作用：set标签可以往域中保存数据域对象.setAttribute(key,value);scope属性设置保存到哪个域page表示pageContext域(默认值)request表示Request域session表示Session域application表示ServletContext域var属性设置key是多少value设置value是多少--%&gt;保存之前：$&#123;requestScope.abc&#125;&lt;c:set scope=&quot;request&quot; var=&quot;abc&quot; value=&quot;666&quot;/&gt;保存之后：$&#123;requestScope.abc&#125;二、&lt;c:if/&gt;if标签用来做if判断&lt;%--二、&lt;c:if/&gt;if标签用来做if判断test属性表示判断的条件（使用EL表达式输出）--%&gt;&lt;c:if test=&quot;$&#123; 12 == 12 &#125;&quot;&gt; &lt;h1&gt;12等于12&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123; 12 != 12 &#125;&quot;&gt; &lt;h1&gt;12不等于12&lt;/h1&gt;&lt;/c:if&gt;没有else判断三、&lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt;标签作用：多路判断，跟Switch...case...default非常接近&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;190&#125;&quot;&gt; &lt;h2&gt;小巨人&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;180&#125;&quot;&gt; &lt;h2&gt;很高&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&gt;170&#125;&quot;&gt; &lt;h2&gt;还可以&lt;/h2&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;剩余小于170的情况&lt;/h2&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;requestScope.height&lt;160&#125;&quot;&gt; &lt;h2&gt;矮&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&lt;150&#125;&quot;&gt; &lt;h2&gt;很矮&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;requestScope.height&lt;130&#125;&quot;&gt; &lt;h2&gt;非常矮&lt;/h2&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h2&gt;小孩子&lt;/h2&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;四、&lt;c:forEach/&gt;作用：遍历输出1、遍历1到10，输出2、遍历Object数组3、遍历List集合---list中存放Person类，有属性：编号，姓名，密码，年龄，电话。4、遍历map集合 VarStatus属性的功能","tags":"el表达式"},{"title":"dubbo","url":"/2023/10/12/Dubbo/","text":"# dubbo 一、基础知识1、分布式基础理论1.1）、什么是分布式系统？《分布式系统原理与范型》定义： “分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统” 分布式系统（distributed system）是建立在网络之上的软件系统。 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 1.2）、发展演变 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1、性能扩展比较难 2、协同开发问题 3、不利于升级维护 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点： 公用模块无法重复利用，开发性的浪费 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 1.3）、RPC什么叫RPCRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 RPC基本原理 RPC两个核心模块：通讯，序列化。 2、dubbo核心概念2.1）、简介Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 官网： http://dubbo.apache.org/ 2.2）、基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3、dubbo环境搭建3.1）、【windows】-安装zookeeper 1、下载zookeeper 网址 https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/Apache Downloads 2、解压zookeeper解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 3、修改zoo.cfg配置文件 将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。注意几个重要位置：dataDir&#x3D;.&#x2F; 临时数据存储的目录（可写相对路径）clientPort&#x3D;2181 zookeeper的端口号 修改完成后再次启动zookeeper 4、使用zkCli.cmd测试 ls &#x2F;：列出zookeeper根下保存的所有节点create –e &#x2F;atguigu 123：创建一个atguigu节点，值为123 get &#x2F;atguigu：获取&#x2F;atguigu节点的值 3.2）、【windows】-安装dubbo-admin管理控制台dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。 1、下载dubbo-admin https://github.com/apache/incubator-dubbo-ops 2、进入目录，修改dubbo-admin配置 修改 src\\main\\resources\\application.properties 指定zookeeper地址 3、打包dubbo-admin mvn clean package -Dmaven.test.skip&#x3D;true 4、运行dubbo-admin java -jar dubbo-admin-0.0.1-SNAPSHOT.jar注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】默认使用root&#x2F;root登录 新版：选择master或develop分支下载 3.3）、【linux】-安装zookeeper1、安装jdk 1、下载jdk http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误 2、上传到服务器并解压 3、设置环境变量 &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171 文件末尾加入下面配置 export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jreexport CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH 4、使环境变量生效&amp;测试JDK 2、安装zookeeper 1、下载zookeeper 网址 https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/ wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz 2、解压 3、移动到指定位置并改名为zookeeper 3、开机启动zookeeper12345678910111213141）-复制如下脚本#!/bin/bash#chkconfig:2345 20 90#description:zookeeper#processname:zookeeperZK_PATH=/usr/local/zookeeperexport JAVA_HOME=/usr/local/java/jdk1.8.0_171case $1 in start) sh $ZK_PATH/bin/zkServer.sh start;; stop) sh $ZK_PATH/bin/zkServer.sh stop;; status) sh $ZK_PATH/bin/zkServer.sh status;;restart) sh $ZK_PATH/bin/zkServer.sh restart;; *) echo &quot;require start|stop|status|restart&quot; ;;esac 2）-把脚本注册为Service 3）-增加权限 4、配置zookeeper1、初始化zookeeper配置文件 拷贝&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;conf&#x2F;zoo_sample.cfg 到同一个目录下改个名字叫zoo.cfg 2、启动zookeeper 3.4）、【linux】-安装dubbo-admin管理控制台1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat） 1、下载Tomcat8并解压 https://tomcat.apache.org/download-80.cgi wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz 2、解压移动到指定位置 3、开机启动tomcat8 复制如下脚本 #!&#x2F;bin&#x2F;bash #chkconfig:2345 21 90 #description:apache-tomcat-8 #processname:apache-tomcat-8 CATALANA_HOME&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.5.32 export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_171 case $1 in start) echo “Starting Tomcat…” $CATALANA_HOME&#x2F;bin&#x2F;startup.sh ;; stop) echo “Stopping Tomcat…” $CATALANA_HOME&#x2F;bin&#x2F;shutdown.sh ;; restart) echo “Stopping Tomcat…” $CATALANA_HOME&#x2F;bin&#x2F;shutdown.sh sleep 2 echo echo “Starting Tomcat…” $CATALANA_HOME&#x2F;bin&#x2F;startup.sh ;; *) echo “Usage: tomcat {start|stop|restart}” ;; esac 4、注册服务&amp;添加权限 5、启动服务&amp;访问tomcat测试 2、安装dubbo-admindubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。 1、下载dubbo-admin https://github.com/apache/incubator-dubbo-ops 2、进入目录，修改dubbo-admin配置 修改 src\\main\\resources\\application.properties 指定zookeeper地址 3、打包dubbo-admin mvn clean package -Dmaven.test.skip&#x3D;true 4、运行dubbo-admin java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 默认使用root&#x2F;root 登陆 4、dubbo-helloworld4.1）、提出需求某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址； 我们现在 需要创建两个服务模块进行测试 模块 功能 订单服务web模块 创建订单等 用户服务service模块 查询用户地址等 测试预期结果： 订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。 4.2）、工程架构根据 dubbo《服务化最佳实践》 1、分包建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。 如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com&#x2F;alibaba&#x2F;china&#x2F;xxx&#x2F;dubbo-reference.xml。 2、粒度服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。 服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。 不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。 4.3）、创建模块1、gmall-interface：公共接口层（model，service，exception…） 作用：定义公共接口，也可以导入公共依赖 1、Bean模型 public class UserAddress implements Serializable{ private Integer id; private String userAddress; private String userId; private String consignee; private String phoneNum; private String isDefault; } 3、Service接口 UserService public List getUserAddressList(String userId) 2、gmall-user：用户模块（对用户接口的实现）1、pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.dubbo&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、Service 1234567public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; // TODO Auto-generated method stub return userAddressDao.getUserAddressById(userId); &#125; &#125; 3、gmall-order-web：订单模块（调用用户模块）1、pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.dubbo&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、测试 1234567891011public class OrderService &#123; UserService userService; /** * 初始化订单，查询用户的所有地址并返回 * @param userId * @return */ public List&lt;UserAddress&gt; initOrder(String userId)&#123; return userService.getUserAddressList(userId); &#125; &#125; 现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。 4.4）、使用dubbo改造1、改造gmall-user作为服务提供者123456789101112131415161718192021221、引入dubbo&lt;!-- 引入dubbo --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper,dubbo 2.6以前的版本引入zkclient操作zookeeper dubbo 2.6及以后的版本引入curator操作zookeeper下面两个zk客户端根据dubbo版本2选1即可--&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- curator-framework --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031最新3.x版引入：&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper-curator5&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;3.1.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-reload4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 12345678910111213141516172、配置提供者(resource下新建provider.xml)&lt;!-- 1. 指定当前服务/应用的名称（同样的服务名字相同，不要和别的服务同名）--&gt; &lt;dubbo:application name=&quot;user-service-provider&quot;&gt;&lt;/dubbo:application&gt; &lt;!-- 2. 指定注册中心的位置 --&gt;&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;--&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; &lt;!-- 3. 指定通信规则，当前服务的协议信息，端口 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt; &lt;!-- 4. 指定暴露的服务接口，以及实现类 ref:指向服务的真正实现对象--&gt; &lt;dubbo:service interface=&quot;com.lxg.gmall.service.UserService&quot; ref=&quot;userServiceImpl&quot;&gt;&lt;/dubbo:service&gt; &lt;!-- 5. 指定服务的实现类 --&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.lxg.gmall.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt; 123456789101112131415161718package com.lxg.gmall;import java.io.IOException;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApplication &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;); ioc.start(); System.in.read(); &#125;&#125; 2、改造gmall-order-web作为服务消费者12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.lxg.gmall&lt;/groupId&gt; &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper-curator5&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;3.1.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-reload4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213141516171819202122232、配置消费者信息&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 扫描包 --&gt; &lt;context:component-scan base-package=&quot;com.lxg.gmall.service.impl&quot;/&gt; &lt;!-- 定义应用名 --&gt; &lt;dubbo:application name=&quot;order-service-consumer&quot;/&gt; &lt;!-- 定义注册中心地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; &lt;!-- 定义订阅信息，Dubbo 会在 Spring Context 中创建对应的 bean --&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.lxg.gmall.service.UserService&quot;/&gt;&lt;/beans&gt; 3、测试调用访问gmall-order-web的initOrder请求，会调用UserService获取用户地址； 调用成功。说明我们order已经可以调用远程的UserService了； 4、注解版123456789101112131415161718191、服务提供方 &lt;dubbo:application name=&quot;user-service-provider&quot;&gt;&lt;/dubbo:application&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt;&lt;dubbo:annotation package=&quot;com.lxg.gmall.service.impl&quot;/&gt; import com.alibaba.dubbo.config.annotation.Service;import com.lxg.gmall.bean.UserAddress;import com.lxg.gmall.service.UserService;import com.lxg.gmall.user.mapper.UserAddressMapper;@DubboService //新版@Service //使用dubbo提供的service注解，注册暴露服务public class UserServiceImpl implements UserService &#123; @Autowired UserAddressMapper userAddressMapper; 12345678910112、服务消费方&lt;dubbo:application name=&quot;order-service-consumer&quot;&gt;&lt;/dubbo:application&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;&lt;dubbo:annotation package=&quot;com.lxg.gmall.order.controller&quot;/&gt;@Controllerpublic class OrderController &#123; @DubboReference //新版 @Reference //使用dubbo提供的reference注解引用远程服务 UserService userService; 5、监控中心5.1）、dubbo-admin图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者&#x2F;消费者进行配置管理 5.2）、dubbo-monitor-simple(新版已经没有这个了)简单的监控中心； 1、安装1、下载 dubbo-ops https://github.com/apache/incubator-dubbo-ops 2、修改配置指定注册中心地址 进入 dubbo-monitor-simple\\src\\main\\resources\\conf 修改 dubbo.properties文件 3、打包dubbo-monitor-simple mvn clean package -Dmaven.test.skip&#x3D;true 4、解压 tar.gz 文件，并运行start.bat 如果缺少servlet-api，自行导入servlet-api再访问监控中心 5、启动访问8080 2、监控中心配置1234所有服务配置连接监控中心，进行监控统计 &lt;!-- 监控中心协议，如果为protocol=&quot;registry&quot;，表示从注册中心发现监控中心地址，否则直连监控中心 --&gt; &lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt; Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。 Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。 6、整合SpringBoot1、引入spring-boot-starter以及dubbo和curator的依赖12345678老版这个：&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627新版这个：&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper-curator5&lt;/artifactId&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;3.1.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-reload4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt;--&gt; SpringBoot版本不要太高，我的为2.3.1.RELEASE 2、配置application.properties提供者 123456789101112131415dubbo.application.name=boot-user-service-providerdubbo.registry.address=127.0.0.1:2181dubbo.registry.protocol=zookeeperdubbo.protocol.name=dubbodubbo.protocol.port=20880dubbo.monitor.protocol=registry#application.name就是服务名，不能跟别的dubbo提供端重复#registry.protocol 是指定注册中心协议#registry.address 是注册中心的地址加端口号#protocol.name 是分布式固定是dubbo,不要改。#base-package 注解方式要扫描的包 消费者 12345server.port=8081dubbo.application.name=boot-order-service-consumerdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.monitor.protocol=registrydubbo.scan.base-package=com.lxg.gmall 3、dubbo注解123@Service、@Reference @DubboService @DubboReference【如果没有在配置中写dubbo.scan.base-package,还需要使用@EnableDubbo注解】 二、dubbo配置1、配置原则 JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。 XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。 Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。 新版有四种方式： 1、API配置 12345678910public static void main(String[] args) throws IOException &#123; ServiceConfig&lt;GreetingsService&gt; service = new ServiceConfig&lt;&gt;(); service.setApplication(new ApplicationConfig(&quot;first-dubbo-provider&quot;)); service.setRegistry(new RegistryConfig(&quot;multicast://224.5.6.7:1234&quot;)); service.setInterface(GreetingsService.class); service.setRef(new GreetingsServiceImpl()); service.export(); System.out.println(&quot;first-dubbo-provider is running.&quot;); System.in.read();&#125; 2、XML配置 1234567891011&lt;!-- dubbo-provier.xml --&gt; &lt;dubbo:application name=&quot;demo-provider&quot;/&gt; &lt;dubbo:config-center address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; simplified=&quot;true&quot;/&gt; &lt;dubbo:metadata-report address=&quot;redis://127.0.0.1:6379&quot;/&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;bean id=&quot;demoService&quot; class=&quot;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&quot;/&gt; &lt;dubbo:service interface=&quot;org.apache.dubbo.samples.basic.api.DemoService&quot; ref=&quot;demoService&quot;/&gt; 3、Annotation配置 12345678910// AnnotationService服务实现 @DubboService public class AnnotationServiceImpl implements AnnotationService &#123; @Override public String sayHello(String name) &#123; System.out.println(&quot;async provider received: &quot; + name); return &quot;annotation: hello, &quot; + name; &#125; &#125; 123456## dubbo.propertiesdubbo.application.name=annotation-providerdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.protocol.name=dubbodubbo.protocol.port=20880 4、Spring Boot + Annotation 配置 123456789101112131415161718192021## application.properties# Spring boot applicationspring.application.name=dubbo-externalized-configuration-provider-sample# Base packages to scan Dubbo Component: @com.alibaba.dubbo.config.annotation.Servicedubbo.scan.base-packages=com.alibaba.boot.dubbo.demo.provider.service# Dubbo Application## The default value of dubbo.application.name is $&#123;spring.application.name&#125;## dubbo.application.name=$&#123;spring.application.name&#125;# Dubbo Protocoldubbo.protocol.name=dubbodubbo.protocol.port=12345## Dubbo Registrydubbo.registry.address=N/A## DemoService versiondemo.service.version=1.0.0 配置读取顺序： vm选项-&gt;xml配置或注解-&gt;api方式-&gt;application.properties-&gt;dubbo.proerties 2、Check1234567&lt;!-- &lt;dubbo:reference id=&quot;userService&quot; check=&quot;false&quot; interface=&quot;com.lxg.gmall.service.UserService&quot;/&gt;--&gt; &lt;!--配置当前消费者的统一规则:所有的服务都不检查--&gt; &lt;dubbo:consumer check=&quot;false&quot;&gt;&lt;/dubbo:consumer&gt; &lt;dubbo:registry check=&quot;false&quot; address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; 3、重试次数失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries&#x3D;&quot;2&quot; 来设置重试次数(不含第一次)。 123456789重试次数配置如下：&lt;dubbo:service retries=&quot;2&quot; /&gt;或&lt;dubbo:reference retries=&quot;2&quot; /&gt;或&lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt; 4、超时时间由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。 1、Dubbo消费端12345678全局超时配置&lt;dubbo:consumer timeout=&quot;5000&quot; /&gt;指定接口以及特定方法超时配置&lt;dubbo:reference interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt; &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;&lt;/dubbo:reference&gt; 2、Dubbo服务端12345678全局超时配置&lt;dubbo:provider timeout=&quot;5000&quot; /&gt;指定接口以及特定方法超时配置&lt;dubbo:provider interface=&quot;com.foo.BarService&quot; timeout=&quot;2000&quot;&gt; &lt;dubbo:method name=&quot;sayHello&quot; timeout=&quot;3000&quot; /&gt;&lt;/dubbo:provider&gt; 3、配置原则dubbo推荐在Provider上尽量多配置Consumer端属性： 121、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的 配置的覆盖规则： 1) 方法级配置别优于接口级别，即小Scope优先 2) Consumer端配置 优于 Provider配置 优于 全局配置， 3) 最后是Dubbo Hard Code的配置值（见配置文档） 5、版本号当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。 可以按照以下的步骤进行版本迁移： 在低压力时间段，先升级一半提供者为新版本 再将所有消费者升级为新版本 然后将剩下的一半提供者升级为新版本 123456789101112131415老版本服务提供者配置：&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;新版本服务提供者配置：&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;老版本服务消费者配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;新版本服务消费者配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;如果不需要区分版本，可以按照以下的方式配置：&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt; 6、本地存根远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑。 使用场景做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。 配置1&lt;dubbo:consumer interface=&quot;com.foo.BarService&quot; stub=&quot;true&quot; /&gt; 或 1&lt;dubbo:consumer interface=&quot;com.foo.BarService&quot; stub=&quot;com.foo.BarServiceStub&quot; /&gt; 7、spingboot整合dubbo的方式123456SpringBoot与dubbo整合的三种方式：1）、导入dubbo-starter，在application.properties配置属性，使用@Service / @DubboService暴露服务，使用@DubboRefence / @Reference引用服务2）、保留dubbo.xml配置文件 导入dubbo-starter及相关依赖，在application.properties配置属性，使用@ImportResource导入dubbo的配置文件即可3）、使用注解API的方式：将每一个组件手动创建到容器中,让dubbo扫描到这些组件 三、高可用1、zookeeper宕机与dubbo直连现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。 原因： 12345678健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 高可用：通过设计，减少系统不能提供服务的时间； 1@DubboReference(url = &quot;dubbo://localhost:20882&quot;) //dubbo直连 2、集群下dubbo负载均衡配置在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。 负载均衡策略 123456789101112131415161718192021222324Random LoadBalance随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。RoundRobin LoadBalance轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。LeastActive LoadBalance最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。ConsistentHash LoadBalance一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;ShortestResponse加权最短响应优先，在最近一个滑动窗口中，响应时间越短，越优先调用。相同响应时间的进行加权随机。使得响应时间越快的提供者，处理更多的请求。缺点：可能会造成流量过于集中于高性能节点的问题。这里的响应时间 = 某个提供者在窗口时间内的平均响应时间，窗口时间默认是 30s。 配置属性： loadbalance&#x3D;”xxx” 3、整合hystrix，服务熔断与降级处理1、服务降级什么是服务降级？当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。 向注册中心写入动态配置覆盖规则： 123RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;)); 其中： mock&#x3D;force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 还可以改为 mock&#x3D;fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 使用方式 1、mock&#x3D;true 1&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;true&quot; /&gt; 2、mock&#x3D;”com.xxx.service.DemoServiceMock” 1&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;com.xxx.service.DemoServiceMock&quot; /&gt; 3、mock&#x3D;”[fail|force]return|throw xxx” fail 或 force 关键字可选，表示调用失败或不调用强制执行 mock 方法，如果不指定关键字默认为 fail return 表示指定返回结果，throw 表示抛出指定异常 xxx 根据接口的返回类型解析，可以指定返回值或抛出自定义的异常 1234567891011&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;return&quot; /&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;return null&quot; /&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;fail:return aaa&quot; /&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;force:return true&quot; /&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;fail:throw&quot; /&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.xxx.service.DemoService&quot; mock=&quot;force:throw java.lang.NullPointException&quot; /&gt; 2、集群容错在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。 各节点关系： 这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息 Directory 代表多个 Invoker，可以把它看成 List&lt;Invoker&gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更 Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个 Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选 通过使用服务注册表和负载平衡，可以提高集群提供的容错能力，服务注册表用于存储有关可用服务及其位置的信息，负载平衡用于确保请求均匀分布在集群中的所有服务器上，如果一台服务器发生故障，负载将转移到其他可用服务器。 配置监视集群中服务器运行状况的运行状况检查，如果服务器未通过运行状况检查，则可以将其从集群中删除，并将负载转移到其余服务器，确保集群正常运行，并且用户可以使用应用程序。 集群容错模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Failover Cluster失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。重试次数配置如下：&lt;dubbo:service retries=&quot;2&quot; /&gt;或&lt;dubbo:reference retries=&quot;2&quot; /&gt;或&lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;&lt;/dubbo:reference&gt;Failfast Cluster快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。Failback Cluster失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。Broadcast Cluster广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。现在广播调用中，可以通过 broadcast.fail.percent 配置节点调用失败的比例，当达到这个比例后，BroadcastClusterInvoker 将不再调用其他节点，直接抛出异常。 broadcast.fail.percent 取值在 0～100 范围内。默认情况下当全部调用失败后，才会抛出异常。 broadcast.fail.percent 只是控制的当失败后是否继续调用其他节点，并不改变结果(任意一台报错则报错)。broadcast.fail.percent 参数 在 dubbo2.7.10 及以上版本生效。Broadcast Cluster 配置 broadcast.fail.percent。broadcast.fail.percent=20 代表了当 20% 的节点调用失败就抛出异常，不再调用其他节点。@reference(cluster = &quot;broadcast&quot;, parameters = &#123;&quot;broadcast.fail.percent&quot;, &quot;20&quot;&#125;)Available Cluster调用目前可用的实例（只调用一个），如果当前没有可用的实例，则抛出异常。通常用于不需要负载均衡的场景。Mergeable Cluster将集群中的调用结果聚合起来返回结果，通常和group一起配合使用。通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。ZoneAware Cluster多注册中心订阅的场景，注册中心集群间的负载均衡。对于多注册中心间的选址策略有如下四种1、指定优先级：preferred=&quot;true&quot;注册中心的地址将被优先选择&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; preferred=&quot;true&quot; /&gt;2、同中心优先：检查当前请求所属的区域，优先选择具有相同区域的注册中心&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; zone=&quot;beijing&quot; /&gt;3、权重轮询：根据每个注册中心的权重分配流量&lt;dubbo:registry id=&quot;beijing&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; weight=&quot;100&quot; /&gt;&lt;dubbo:registry id=&quot;shanghai&quot; address=&quot;zookeeper://127.0.0.1:2182&quot; weight=&quot;10&quot; /&gt;4、缺省值：选择一个可用的注册中心集群模式示例按照以下示例在服务提供方和消费方配置集群模式&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;或&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt; 3、整合hystrixHystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能 1、配置spring-cloud-starter-netflix-hystrixspring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 然后在Application类上增加@EnableHystrix来启用hystrix starter： 123@SpringBootApplication@EnableHystrixpublic class ProviderApplication &#123; 2、配置Provider端在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。 12345678910111213@Service(version = &quot;1.0.0&quot;)public class HelloServiceImpl implements HelloService &#123; @HystrixCommand(commandProperties = &#123; @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;) @Override public String sayHello(String name) &#123; // System.out.println(&quot;async provider received: &quot; + name); // return &quot;annotation: hello, &quot; + name; throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;); &#125;&#125; 3、配置Consumer端对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod &#x3D; &quot;reliable&quot;的调用里。 1234567891011@Reference(version = &quot;1.0.0&quot;)private HelloService demoService;@HystrixCommand(fallbackMethod = &quot;reliable&quot;)public String doSayHello(String name) &#123; return demoService.sayHello(name);&#125;public String reliable(String name) &#123; return &quot;hystrix fallback value&quot;;&#125; 四、dubbo原理1、RPC原理 1234567891011一次完整的RPC调用流程（同步调用，异步另说）如下： 1）服务消费方（client）调用以本地调用方式调用服务； 2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 3）client stub找到服务地址，并将消息发送到服务端； 4）server stub收到消息后进行解码； 5）server stub根据解码结果调用本地的服务； 6）本地服务执行并将结果返回给server stub； 7）server stub将返回结果打包成消息并发送至消费方； 8）client stub接收到消息，并进行解码； 9）服务消费方得到最终结果。RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。 2、netty通信原理Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。 BIO：(Blocking IO) NIO (Non-Blocking IO) Selector 一般称 为选择器 ，也可以翻译为 多路复用器， Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪） Netty基本原理： 3、dubbo原理1、dubbo原理 -框架设计 config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 2、dubbo原理 -启动解析、加载配置信息 3、dubbo原理 -服务暴露 4、dubbo原理 -服务引用 5、dubbo原理 -服务调用","tags":"dubbo"},{"title":"Docker","url":"/2023/10/12/Docker/","text":"# Docker 一、基础篇1、Docker简介1.1、是什么1.1.1、问题：为什么会有docker出现假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。请问？您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？ 答案就是使用容器。Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案—–系统平滑移植，容器虚拟化技术。 环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java&#x2F;RabbitMQ&#x2F;MySQL&#x2F;JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。传统上认为，软件编码开发&#x2F;测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker的出现使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。 1.1.2、docker理念Docker是基于Go语言实现的云开源项目。Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。 Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。 1.1.3、一句话解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 1.2、容器与虚拟机比较1.2.1、容器发展简史 1.2.2、传统虚拟机技术虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 1.2.3、容器虚拟化技术由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：Linux容器(Linux Containers，缩写为 LXC)Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 1.2.5、对比 比较了 Docker 和传统虚拟化方式的不同之处：传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 1.3、能干嘛1.3.1、技术职级变化coder-&gt;programmer-&gt;software engineer 1.3.2、开发&#x2F;运维（DevOps)新一代开发工程师一次构建、随处运行： 更快速的应用交付和部署 传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。 更便捷的升级和扩缩容 随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。 更简单的系统运维 应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。 更高效的计算资源利用 Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。 Docker应用场景： 1.3.3、哪些企业在使用新浪： 美团： 蘑菇街： 1.4、去哪下官网：docker官网：http://www.docker.com 仓库：Docker Hub官网: https://hub.docker.com/ 2、Docker安装2.1、前提说明 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x 查看自己的内核uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 2.2、Docker的基本组成 Docker平台架构图解(入门版)： Docker工作原理： Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解 2.2.1、镜像(image)Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。 2.2.2、容器(container)1 从面向对象角度Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台 2 从镜像容器角度可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 2.2.3、仓库(repository)仓库（Repository）是集中存放镜像文件的场所。 类似于Maven仓库，存放各种jar包的地方；github仓库，存放各种git项目的地方；Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等 2.2.4、小总结需要正确的理解仓库&#x2F;镜像&#x2F;容器这几个概念:Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 镜像文件 image 文件生成的容器实例，本身也是一个文件，称为镜像文件。容器实例 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器仓库 就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。 2.3、Docker平台架构图解(架构版)先有大概轮廓，混个眼熟 整体架构及底层通信原理简述： Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 12345671用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。2 Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client的请求。3 Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。4Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。5当需要为Docker创建网络环境时，通过网铬管理驱动Network driver创建并配置Docker容器网铬环境。6当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。7 Libcontainer是一项独立的容器管理包，Network driverl以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。 2.4、安装步骤官方文档：Install Docker Engine on CentOS 2.4.1、确保centos版本为7及以上（本次7.9）cat &#x2F;etc&#x2F;redhat-release 2.4.2、卸载旧版本 2.4.3、yum安装gcc相关包保证系统能上外网 yum -y install gcc yum -y install gcc-c++ 2.4.4、安装需求的软件包官网要求： 执行命令：yum install -y yum-utils 2.4.5、设置stable镜像仓库注意：如果使用官网的可能会很慢或报错（访问外网速度很慢） yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo 推荐：使用阿里云镜像仓库 yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 2.4.6、更新yum软件包索引yum makecache fast 2.4.7、安装DOCKER CEsudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 官网要求： 执行结果： 2.4.8、启动dockersystemctl start docker 查看启动状态：systemctl status docker 2.4.9、测试是否安装成功docker version docker run hello-world 2.4.10、卸载 systemctl stop docker sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras sudo rm -rf &#x2F;var&#x2F;lib&#x2F;dockersudo rm -rf &#x2F;var&#x2F;lib&#x2F;containerd 2.5、阿里云镜像加速2.5.1、是什么容器镜像服务_镜像构建_镜像授权_镜像托管-阿里云 (aliyun.com) 2.5.2、获得加速地址链接 登陆阿里云开发者平台 进入控制台 选择容器镜像服务 获取加速器地址 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://hiw2bgd0.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 2.5.3、重启服务器systemctl daemon-reload systemctl restart docker 2.6、永远的helloworld启动Docker后台容器(测试运行 hello-world) 2.6.1、docker run hello-world： 输出这段提示以后，hello world就会停止运行，容器自动终止。 2.6.2、run干了什么： 2.7、底层原理为什么Docker会比VM虚拟机快 (1)docker有着比虚拟机更少的抽象层 由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核 当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。 3、Docker常用命令3.1、帮助启动类命令启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息： docker info 查看docker总体帮助文档： docker –help 查看docker命令帮助文档： docker 具体命令 –help 3.2、镜像命令3.2.1、docker images列出本地主机上的镜像 各个选项说明:REPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 OPTIONS说明： -a :列出本地所有的镜像（含历史映像层） -q :只显示镜像ID。 3.2.2、docker search 某个XXX镜像名字网站：https://hub.docker.com 命令：docker search [OPTIONS] 镜像名字 OPTIONS说明：–limit : 只列出N个镜像，默认25个 docker search –limit 5 redis 3.2.3、docker pull 某个XXX镜像名字下载镜像 docker pull 镜像名字[:TAG] docker pull 镜像名字： 没有TAG就是最新版 等价于 docker pull 镜像名字:latest docker pull ubuntu 3.2.4、docker system df 查看镜像&#x2F;容器&#x2F;数据卷所占的空间 3.2.5、docker rmi 某个XXX镜像名字ID删除镜像 删除单个：docker rmi -f 镜像ID 删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部：docker rmi -f $(docker images -qa) 3.2.6、面试题：谈谈docker虚悬镜像是什么？是什么：仓库名、标签都是的镜像，俗称虚悬镜像dangling image 长什么样： 后续Dockerfile章节再介绍 3.2.7、思考结合我们Git的学习心得，大家猜猜是否会有docker commit &#x2F;docker push？？ 3.3、容器命令有镜像才能创建容器，这是根本前提(下载一个CentOS或者ubuntu镜像演示) docker pull centos docker pull ubuntu 3.3.1、新建+启动容器docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS说明： OPTIONS说明（常用）：有些是一个减号，有些是两个减号 –name&#x3D;”容器新名字” 为容器指定一个名称；-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)； -i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即启动交互式容器(前台有伪终端，等待交互)； -P: 随机端口映射，大写P-p: 指定端口映射，小写p 启动交互式容器(前台命令行)： #使用镜像centos:latest以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令。docker run -it centos &#x2F;bin&#x2F;bash 参数说明：-i: 交互式操作。-t: 终端。centos : centos 镜像。&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。要退出终端，直接输入 exit: 3.3.2、列出当前所有正在运行的容器docker ps [OPTIONS] OPTIONS说明： OPTIONS说明（常用）： -a :列出当前所有正在运行的容器+历史上运行过的-l :显示最近创建的容器。-n：显示最近n个创建的容器。-q :静默模式，只显示容器编号。 3.3.3、退出容器两种退出方式: exit :run进去容器，exit退出，容器停止 ctrl+p+q:run进去容器，ctrl+p+q退出，容器不停止 3.3.4、启动已停止运行的容器docker start 容器ID或者容器名 3.3.5、重启容器docker restart 容器ID或者容器名 3.3.6、停止容器docker stop 容器ID或者容器名 3.3.7、强制停止容器docker kill 容器ID或容器名 3.3.8、删除已停止的容器docker rm 容器ID 一次性删除多个容器实例： docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 3.3.9、重要有镜像才能创建容器，这是根本前提(下载一个Redis6.0.8镜像演示) 启动守护式容器(后台服务器)： 在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的后台运行模式。 docker run -d 容器名 12345678910111213#使用镜像centos:latest以后台模式启动一个容器docker run -d centos 问题：然后docker ps -a 进行查看, 会发现容器已经退出很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~ redis 前后台启动演示case: 前台交互式启动: docker run -it redis:6.0.8 后台守护式启动:docker run -d redis:6.0.8 查看容器日志 docker logs 容器ID 查看容器内运行的进程 docker top 容器ID 查看容器内部细节 docker inspect 容器ID 进入正在运行的容器并以命令行交互 docker exec -it 容器ID bashShell 重新进入docker attach 容器ID 上述两个区别： attach 直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。 exec 是在容器中打开新的终端，并且可以启动新的进程用exit退出，不会导致容器的停止。 推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。 用之前的redis容器实例进入试试： 进入redis服务 docker exec -it 容器ID &#x2F;bin&#x2F;bash docker exec -it 容器ID redis-cli 一般用-d后台启动的程序，再用exec进入对应容器实例 从容器内拷贝文件到主机上 容器→主机 docker cp 容器ID:容器内路径 目的主机路径 导入和导出容器 export 导出容器的内容留作为一个tar归档文件[对应import命令] import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export] docker export 容器ID &gt; 文件名.tar cat 文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本号 3.4、小总结常用命令 attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files&#x2F;folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同 run，但不启动容器diff Inspect changes on a container’s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images # 列出系统当前镜像import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器logout Log out from a Docker registry server # 从当前 Docker registry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 4、Docker images4.1、是什么4.1.1、概念镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。 只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 4.1.2、分层的镜像以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载 4.1.3、UnionFS（联合文件系统）UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 4.1.4、 Docker镜像加载原理 Docker镜像加载原理： docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 4.1.5、为什么 Docker 镜像要采用这种分层结构呢镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 4.2、重点理解Docker镜像层都是只读的，容器层是可写的当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 4.3、Docker镜像commit操作案例docker commit提交容器副本使之成为一个新的镜像、 docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名] 4.3.1、案例演示ubuntu安装vim从Hub上下载ubuntu镜像到本地并成功运行： docker pull ubuntu 原始的默认Ubuntu镜像是不带着vim命令的： 外网连通的情况下，安装vim： docker容器内执行上述两条命令：apt-get updateapt-get -y install vim 安装完成后，commit我们自己的新镜像： 启动我们的新镜像并和原来的对比： 1 官网是默认下载的Ubuntu没有vim命令2我们自己commit构建的镜像，新增加了vim功能，可以成功使用。 4.3.2、小总结Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层 5、本地镜像发布到阿里云5.1、本地镜像发布到阿里云流程 5.2、镜像的生成方法基于当前容器创建一个新的镜像，新功能增强docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] 后面的DockerFile章节，有第2种方法 5.3、将本地镜像推送到阿里云5.3.1、素材原型 5.3.2、阿里云开发者平台https://www.aliyun.com/ 5.3.3、创建仓库镜像 选择控制台，进入容器镜像服务 选择个人实例 进入命名空间： 创建命名空间： 仓库名称： 进入管理界面获得脚本： 5.3.4、将镜像推送到阿里云将镜像推送到阿里云registry 5.4、将阿里云上的镜像下载到本地 1docker pull registry.cn-hangzhou.aliyuncs.com/xiao-lin/myubuntu:[镜像版本号] 6、将本地镜像推送到私有仓库6.1、本地镜像发布到私有库流程 6.2、是什么1 官方Docker Hub地址：https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。 2 Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。 Docker Registry是官方提供的工具，可以用于构建私有镜像仓库 6.3、将本地镜像推送到私有库6.3.1、下载镜像Docker Registrydocker pull registry 6.3.2、运行私有库Registry，相当于本地有个私有Docker hubdocker run -d -p 5000:5000 -v &#x2F;zzyyuse&#x2F;myregistry&#x2F;:&#x2F;tmp&#x2F;registry –privileged&#x3D;true registry默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便于宿主机联调 6.3.3、案例演示创建一个新镜像，ubuntu安装ifconfig命令从Hub上下载ubuntu镜像到本地并成功运行: docker pull ubuntu docker run -it ubuntu &#x2F;bin&#x2F;bash 原始的Ubuntu镜像是不带着ifconfig命令的: 外网连通的情况下，安装ifconfig命令并测试通过: docker容器内执行上述两条命令：apt-get updateapt-get install net-tools 安装完成后，commit我们自己的新镜像: 公式：docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]命令：在容器外执行，记得docker commit -m&#x3D;”ifconfig cmd add” -a&#x3D;”zzyy” a69d7c825c4f zzyyubuntu:1.2 启动我们的新镜像并和原来的对比: 1 官网是默认下载的Ubuntu没有ifconfig命令2我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。 6.3.4、curl验证私服库上有什么镜像 curl -XGET http://8.130.115.225:5000/v2/_catalog 可以看到，目前私服库没有任何镜像上传过 6.3.5、将新镜像zzyyubuntu:1.2修改符合私服规范的Tag按照公式： docker tag 镜像:Tag Host:Port&#x2F;Repository:Tag自己host主机IP地址，填写自己的，不要粘贴错误，O(∩_∩)O使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000&#x2F;zzyyubuntu:1.2 docker tag zzyyubuntu:1.2 192.168.111.162:5000&#x2F;zzyyubuntu:1.2 6.3.6、修改配置文件使之支持http 别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。2个配置中间有个逗号 ‘,’别漏了，这个配置是json格式的。vim命令新增如下红色内容：vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 1234&#123; &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;8.130.115.225:5000&quot;]&#125; 上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker systemctl restart docker 6.3.7、push推送到私服库docker push 8.130.115.225:5000&#x2F;xiaolinubuntu:1.2 6.3.8、curl验证私服库上有什么镜像2curl -XGET http://8.130.115.225:5000/v2/_catalog 6.3.9、pull到本地并运行docker pull 8.130.115.225:5000&#x2F;xiaolinubuntu:1.2 docker run -it 镜像ID &#x2F;bin&#x2F;bash 7、Docker 容器数据卷 7.1、坑：容器卷记得加入 –privileged&#x3D;true ：why： Docker挂载主机目录访问如果出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可 如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。 7.2、上节的参数v 7.3、是什么卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷 一句话：有点类似我们Redis里面的rdb和aof文件 将docker容器内的数据保存进宿主机的磁盘中 运行一个带有容器卷存储功能的容器实例 docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名 7.4、能干嘛 将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。 特点：1：数据卷可在容器之间共享或重用数据2：卷中的更改可以直接实时生效，爽3：数据卷中的更改不会包含在镜像的更新中4：数据卷的生命周期一直持续到没有容器使用它为止 7.5、数据卷案例7.5.1、宿主vs容器之间映射添加容器卷直接命令添加： 公式：docker run -it -v &#x2F;宿主机目录:&#x2F;容器内目录 ubuntu &#x2F;bin&#x2F;bash 1docker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名 查看数据卷是否挂载成功: docker inspect 容器ID 容器和宿主机之间数据共享: 1 docker修改，主机同步获得2 主机修改，docker同步获得3 docker容器stop，主机修改，docker容器重启看数据是否同步。 7.5.2、读写规则映射添加说明读写(默认) rw &#x3D; read + write docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:rw 镜像名 默认同上案例，默认就是rw 只读：容器实例内部被限制，只能读取不能写 &#x2F;容器目录:ro 镜像名 就能完成功能，此时容器自己只能读取不能写 ro &#x3D; read only 此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。 docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名 7.5.3、卷的继承和共享容器1完成和宿主机的映射： docker run -it –privileged&#x3D;true -v &#x2F;mydocker&#x2F;u:&#x2F;tmp –name u1 ubuntu 容器2继承容器1的卷规则： docker run -it –privileged&#x3D;true –volumes-from 父类 –name u2 ubuntu 此时的u1和u2只是规则相同，u1和u2存活与否互不干涉 8、Docker常规安装简介8.1、总体步骤 搜索镜像 拉取镜像 查看镜像 启动镜像-服务端口映射 停止容器 移除容器 8.2、安装tomcat8.2.1、docker hub上面查找tomcat镜像docker search tomcat 8.2.2、从docker hub上拉取tomcat镜像到本地docker pull tomcat 8.2.3、docker images查看是否有拉取到的tomcat 8.2.4、使用tomcat镜像创建容器实例(也叫运行镜像)docker run -it -p 8080:8080 tomcat -p 小写，主机端口:docker容器端口 -P 大写，随机分配端口 i:交互 t:终端 d:后台 8.2.5、访问猫首页问题： 解决： ①可能没有映射端口或者没有关闭防火墙 ②把webapps.dist目录换成webapps： 先成功启动tomcat 查看webapps 文件夹查看为空 8.2.6、免修改版说明docker pull billygoo&#x2F;tomcat8-jdk8 docker run -d -p 8080:8080 –name mytomcat8 billygoo&#x2F;tomcat8-jdk8 8.3、安装mysql8.3.1、docker hub上面查找mysql镜像 8.3.2、从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.7 8.3.3、使用mysql5.7镜像创建容器(也叫运行镜像)命令出处，哪里来的？ 简单版: 使用mysql镜像 1234docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7docker psdocker exec -it 容器ID /bin/bashmysql -uroot -p 建库建表插入数据: 外部主机也来连接运行在dokcer上的mysql容器实例服务 问题： 插入中文数据试试 为什么报错? ①docker上默认字符集编码隐患 docker里面的mysql容器实例查看，内容如下： SHOW VARIABLES LIKE ‘character%’； 删除容器后，里面的mysql数据如何办 ②容器实例一删除，你还有什么？删容器到跑路。。。。。？ 实战版： 新建mysql容器实例： 1docker run -d -p 3306:3306 --privileged=true -v /xiaolin/mysql/log:/var/log/mysql -v /xiaolin/mysql/data:/var/lib/mysql -v /xiaolin/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 新建my.cnf： 通过容器卷同步给mysql容器实例 12345[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8 重新启动mysql容器实例再重新进入并查看字符编码 再新建库新建表再插入中文测试: 结论: 之前的DB 无效 修改字符集操作+重启mysql容器实例 之后的DB 有效，需要新建 结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据 假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？trytry 因为挂载了容器卷，所以重新run一个实例时，数据会重新加载，不会丢失 8.4、安装redis8.4.1、从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8 8.4.2、入门命令 8.4.3、命令提醒：容器卷记得加入–privileged&#x3D;trueDocker挂载主机目录Docker访问出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可 8.4.4、在CentOS宿主机下新建目录&#x2F;app&#x2F;redis 1 建目录 mkdir -p &#x2F;app&#x2F;redis 8.4.5、将一个redis.conf文件模板拷贝进&#x2F;app&#x2F;redis目录下 2 拷贝配置文件 将准备好的redis.conf文件放进&#x2F;app&#x2F;redis目录下 8.4.6、&#x2F;app&#x2F;redis目录下修改redis.conf文件3 &#x2F;app&#x2F;redis目录下修改redis.conf文件 3.1 开启redis验证 可选 requirepass 123 3.2 允许redis外地连接 必须 注释掉 # bind 127.0.0.1 3.3 daemonize no 将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败 3.4 开启redis数据持久化 appendonly yes 可选 默认出厂的原始redis.conf： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same. ################################## INCLUDES ################################### # Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf ################################## MODULES ##################################### # Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so ################################## NETWORK ##################################### # By default, if no &quot;bind&quot; configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the &quot;bind&quot; configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 loopback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#bind 127.0.0.1 # Protected mode is a layer of security protection, in order to avoid that# Redis instances left open on the internet are accessed and exploited.## When protected mode is on and if:## 1) The server is not binding explicitly to a set of addresses using the# &quot;bind&quot; directive.# 2) No password is configured.## The server only accepts connections from clients connecting from the# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain# sockets.## By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the &quot;bind&quot; directive.protected-mode no # Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379 # TCP listen() backlog.## In high requests-per-second environments you need an high backlog in order# to avoid slow clients connections issues. Note that the Linux kernel# will silently truncate it to the value of /proc/sys/net/core/somaxconn so# make sure to raise both the value of somaxconn and tcp_max_syn_backlog# in order to get the desired effect.tcp-backlog 511 # Unix socket.## Specify the path for the Unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 700 # Close the connection after a client is idle for N seconds (0 to disable)timeout 0 # TCP keepalive.## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence# of communication. This is useful for two reasons:## 1) Detect dead peers.# 2) Take the connection alive from the point of view of network# equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 300 seconds, which is the new# Redis default starting with Redis 3.2.1.tcp-keepalive 300 ################################# GENERAL ##################################### # By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize no # If you run Redis from upstart or systemd, Redis can interact with your# supervision tree. Options:# supervised no - no supervision interaction# supervised upstart - signal upstart by putting Redis into SIGSTOP mode# supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET# supervised auto - detect upstart or systemd method based on# UPSTART_JOB or NOTIFY_SOCKET environment variables# Note: these supervision methods only signal &quot;process is ready.&quot;# They do not enable continuous liveness pings back to your supervisor.supervised no # If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.pidfile /var/run/redis_6379.pid # Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice # Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile &quot;&quot; # To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,# and optionally update the other syslog parameters to suit your needs.# syslog-enabled no # Specify the syslog identity.# syslog-ident redis # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.# syslog-facility local0 # Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and &#x27;databases&#x27;-1databases 16 # By default Redis shows an ASCII art logo only when started to log to the# standard output and if the standard output is a TTY. Basically this means# that normally a logo is displayed only in interactive sessions.## However it is possible to force the pre-4.0 behavior and always show a# ASCII art logo in startup logs by setting the following option to yes.always-show-logo yes ################################ SNAPSHOTTING ################################## Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting out all &quot;save&quot; lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save &quot;&quot; save 900 1save 300 10save 60 10000 # By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes # Compress string objects using LZF when dump .rdb databases?# For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.# If you want to save some CPU in the saving child set it to &#x27;no&#x27; but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes # Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes # The filename where to dump the DBdbfilename dump.rdb # The working directory.## The DB will be written inside this directory, with the filename specified# above using the &#x27;dbfilename&#x27; configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./ ################################# REPLICATION ################################# # Master-Replica replication. Use replicaof to make a Redis instance a copy of# another Redis server. A few things to understand ASAP about Redis replication.## +------------------+ +---------------+# | Master | ---&gt; | Replica |# | (receive writes) | | (exact copy) |# +------------------+ +---------------+## 1) Redis replication is asynchronous, but you can configure a master to# stop accepting writes if it appears to be not connected with at least# a given number of replicas.# 2) Redis replicas are able to perform a partial resynchronization with the# master if the replication link is lost for a relatively small amount of# time. You may want to configure the replication backlog size (see the next# sections of this file) with a sensible value depending on your needs.# 3) Replication is automatic and does not need user intervention. After a# network partition replicas automatically try to reconnect to masters# and resynchronize with them.## replicaof &lt;masterip&gt; &lt;masterport&gt; # If the master is password protected (using the &quot;requirepass&quot; configuration# directive below) it is possible to tell the replica to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the replica request.## masterauth &lt;master-password&gt; # When a replica loses its connection with the master, or when the replication# is still in progress, the replica can act in two different ways:## 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will# still reply to client requests, possibly with out of date data, or the# data set may just be empty if this is the first synchronization.## 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with# an error &quot;SYNC with master in progress&quot; to all the kind of commands# but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,# SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,# COMMAND, POST, HOST: and LATENCY.#replica-serve-stale-data yes # You can configure a replica instance to accept writes or not. Writing against# a replica instance may be useful to store some ephemeral data (because data# written on a replica will be easily deleted after resync with the master) but# may also cause problems if clients are writing to it because of a# misconfiguration.## Since Redis 2.6 by default replicas are read-only.## Note: read only replicas are not designed to be exposed to untrusted clients# on the internet. It&#x27;s just a protection layer against misuse of the instance.# Still a read only replica exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only replicas using &#x27;rename-command&#x27; to shadow all the# administrative / dangerous commands.replica-read-only yes # Replication SYNC strategy: disk or socket.## -------------------------------------------------------# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY# -------------------------------------------------------## New replicas and reconnecting replicas that are not able to continue the replication# process just receiving differences, need to do what is called a &quot;full# synchronization&quot;. An RDB file is transmitted from the master to the replicas.# The transmission can happen in two different ways:## 1) Disk-backed: The Redis master creates a new process that writes the RDB# file on disk. Later the file is transferred by the parent# process to the replicas incrementally.# 2) Diskless: The Redis master creates a new process that directly writes the# RDB file to replica sockets, without touching the disk at all.## With disk-backed replication, while the RDB file is generated, more replicas# can be queued and served with the RDB file as soon as the current child producing# the RDB file finishes its work. With diskless replication instead once# the transfer starts, new replicas arriving will be queued and a new transfer# will start when the current one terminates.## When diskless replication is used, the master waits a configurable amount of# time (in seconds) before starting the transfer in the hope that multiple replicas# will arrive and the transfer can be parallelized.## With slow disks and fast (large bandwidth) networks, diskless replication# works better.repl-diskless-sync no # When diskless replication is enabled, it is possible to configure the delay# the server waits in order to spawn the child that transfers the RDB via socket# to the replicas.## This is important since once the transfer starts, it is not possible to serve# new replicas arriving, that will be queued for the next RDB transfer, so the server# waits a delay in order to let more replicas arrive.## The delay is specified in seconds, and by default is 5 seconds. To disable# it entirely just set it to 0 seconds and the transfer will start ASAP.repl-diskless-sync-delay 5 # Replicas send PINGs to server in a predefined interval. It&#x27;s possible to change# this interval with the repl_ping_replica_period option. The default value is 10# seconds.## repl-ping-replica-period 10 # The following option sets the replication timeout for:## 1) Bulk transfer I/O during SYNC, from the point of view of replica.# 2) Master timeout from the point of view of replicas (data, pings).# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-replica-period otherwise a timeout will be detected# every time there is low traffic between the master and the replica.## repl-timeout 60 # Disable TCP_NODELAY on the replica socket after SYNC?## If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and# less bandwidth to send data to replicas. But this can add a delay for# the data to appear on the replica side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select &quot;no&quot; the delay for data to appear on the replica side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and replicas are many hops away, turning this to &quot;yes&quot; may# be a good idea.repl-disable-tcp-nodelay no # Set the replication backlog size. The backlog is a buffer that accumulates# replica data when replicas are disconnected for some time, so that when a replica# wants to reconnect again, often a full resync is not needed, but a partial# resync is enough, just passing the portion of data the replica missed while# disconnected.## The bigger the replication backlog, the longer the time the replica can be# disconnected and later be able to perform a partial resynchronization.## The backlog is only allocated once there is at least a replica connected.## repl-backlog-size 1mb # After a master has no longer connected replicas for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last replica disconnected, for# the backlog buffer to be freed.## Note that replicas never free the backlog for timeout, since they may be# promoted to masters later, and should be able to correctly &quot;partially# resynchronize&quot; with the replicas: hence they should always accumulate backlog.## A value of 0 means to never release the backlog.## repl-backlog-ttl 3600 # The replica priority is an integer number published by Redis in the INFO output.# It is used by Redis Sentinel in order to select a replica to promote into a# master if the master is no longer working correctly.## A replica with a low priority number is considered better for promotion, so# for instance if there are three replicas with priority 10, 100, 25 Sentinel will# pick the one with priority 10, that is the lowest.## However a special priority of 0 marks the replica as not able to perform the# role of master, so a replica with priority of 0 will never be selected by# Redis Sentinel for promotion.## By default the priority is 100.replica-priority 100 # It is possible for a master to stop accepting writes if there are less than# N replicas connected, having a lag less or equal than M seconds.## The N replicas need to be in &quot;online&quot; state.## The lag in seconds, that must be &lt;= the specified value, is calculated from# the last ping received from the replica, that is usually sent every second.## This option does not GUARANTEE that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough replicas# are available, to the specified number of seconds.## For example to require at least 3 replicas with a lag &lt;= 10 seconds use:## min-replicas-to-write 3# min-replicas-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-replicas-to-write is set to 0 (feature disabled) and# min-replicas-max-lag is set to 10. # A Redis master is able to list the address and port of the attached# replicas in different ways. For example the &quot;INFO replication&quot; section# offers this information, which is used, among other tools, by# Redis Sentinel in order to discover replica instances.# Another place where this info is available is in the output of the# &quot;ROLE&quot; command of a master.## The listed IP and address normally reported by a replica is obtained# in the following way:## IP: The address is auto detected by checking the peer address# of the socket used by the replica to connect with the master.## Port: The port is communicated by the replica during the replication# handshake, and is normally the port that the replica is using to# listen for connections.## However when port forwarding or Network Address Translation (NAT) is# used, the replica may be actually reachable via different IP and port# pairs. The following two options can be used by a replica in order to# report to its master a specific set of IP and port, so that both INFO# and ROLE will report those values.## There is no need to use both the options if you need to override just# the port or the IP address.## replica-announce-ip 5.5.5.5# replica-announce-port 1234 ################################## SECURITY ################################### # Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands. This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared # Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG &quot;&quot;## Please note that changing the name of commands that are logged into the# AOF file or transmitted to replicas may cause problems. ################################### CLIENTS #################################### # Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## Once the limit is reached Redis will close all the new connections sending# an error &#x27;max number of clients reached&#x27;.## maxclients 10000 ############################## MEMORY MANAGEMENT ################################ # Set a memory usage limit to the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# according to the eviction policy selected (see maxmemory-policy).## If Redis can&#x27;t remove keys according to the policy, or if the policy is# set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU or LFU cache, or to# set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).## WARNING: If you have replicas attached to an instance with maxmemory on,# the size of the output buffers needed to feed the replicas are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of replicas is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have replicas attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for replica# output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).## maxmemory &lt;bytes&gt; # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select among five behaviors:## volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.# allkeys-lru -&gt; Evict any key using approximated LRU.# volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.# allkeys-lfu -&gt; Evict any key using approximated LFU.# volatile-random -&gt; Remove a random key among the ones with an expire set.# allkeys-random -&gt; Remove a random key, any key.# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)# noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.## LRU means Least Recently Used# LFU means Least Frequently Used## Both LRU, LFU and volatile-ttl are implemented using approximated# randomized algorithms.## Note: with any of the above policies, Redis will return an error on write# operations, when there are no suitable keys for eviction.## At the date of writing these commands are: set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction # LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs more CPU. 3 is faster but not very accurate.## maxmemory-samples 5 # Starting from Redis 5, by default a replica will ignore its maxmemory setting# (unless it is promoted to master after a failover or manually). It means# that the eviction of keys will be just handled by the master, sending the# DEL commands to the replica as keys evict in the master side.## This behavior ensures that masters and replicas stay consistent, and is usually# what you want, however if your replica is writable, or you want the replica to have# a different memory setting, and you are sure all the writes performed to the# replica are idempotent, then you may change this default (but be sure to understand# what you are doing).## Note that since the replica by default does not evict, it may end using more# memory than the one set via maxmemory (there are certain buffers that may# be larger on the replica, or data structures may sometimes take more memory and so# forth). So make sure you monitor your replicas and make sure they have enough# memory to never hit a real out-of-memory condition before the master hits# the configured maxmemory setting.## replica-ignore-maxmemory yes ############################# LAZY FREEING #################################### # Redis has two primitives to delete keys. One is called DEL and is a blocking# deletion of the object. It means that the server stops processing new commands# in order to reclaim all the memory associated with an object in a synchronous# way. If the key deleted is associated with a small object, the time needed# in order to execute the DEL command is very small and comparable to most other# O(1) or O(log_N) commands in Redis. However if the key is associated with an# aggregated value containing millions of elements, the server can block for# a long time (even seconds) in order to complete the operation.## For the above reasons Redis also offers non blocking deletion primitives# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and# FLUSHDB commands, in order to reclaim memory in background. Those commands# are executed in constant time. Another thread will incrementally free the# object in the background as fast as possible.## DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.# It&#x27;s up to the design of the application to understand when it is a good# idea to use one or the other. However the Redis server sometimes has to# delete keys or flush the whole database as a side effect of other operations.# Specifically Redis deletes objects independently of a user call in the# following scenarios:## 1) On eviction, because of the maxmemory and maxmemory policy configurations,# in order to make room for new data, without going over the specified# memory limit.# 2) Because of expire: when a key with an associated time to live (see the# EXPIRE command) must be deleted from memory.# 3) Because of a side effect of a command that stores data on a key that may# already exist. For example the RENAME command may delete the old key# content when it is replaced with another one. Similarly SUNIONSTORE# or SORT with STORE option may delete existing keys. The SET command# itself removes any old content of the specified key in order to replace# it with the specified string.# 4) During replication, when a replica performs a full resynchronization with# its master, the content of the whole database is removed in order to# load the RDB file just transferred.## In all the above cases the default is to delete objects in a blocking way,# like if DEL was called. However you can configure each case specifically# in order to instead release memory in a non-blocking way like if UNLINK# was called, using the following configuration directives: lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush no ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information. appendonly no # The name of the append only file (default: &quot;appendonly.aof&quot;) appendfilename &quot;appendonly.aof&quot; # The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log. Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between# speed and data safety. It&#x27;s up to you to understand if you can relax this to# &quot;no&quot; that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that&#x27;s snapshotting),# or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use &quot;everysec&quot;. # appendfsync alwaysappendfsync everysec# appendfsync no # When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it&#x27;s possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as &quot;appendfsync none&quot;. In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).## If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as# &quot;no&quot; that is the safest pick from the point of view of durability. no-appendfsync-on-rewrite no # Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature. auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb # An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can&#x27;t happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes # When rewriting the AOF file, Redis is able to use an RDB preamble in the# AOF file for faster rewrites and recoveries. When this option is turned# on the rewritten AOF file is composed of two different stanzas:## [RDB file][AOF tail]## When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;# string and loads the prefixed RDB file, and continues loading the AOF# tail.aof-use-rdb-preamble yes ################################ LUA SCRIPTING ############################### # Max execution time of a Lua script in milliseconds.## If the maximum execution time is reached Redis will log that a script is# still in execution after the maximum allowed time and will start to# reply to queries with an error.## When a long running script exceeds the maximum execution time only the# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be# used to stop a script that did not yet called write commands. The second# is the only way to shut down the server in the case a write command was# already issued by the script but the user doesn&#x27;t want to wait for the natural# termination of the script.## Set it to 0 or a negative value for unlimited execution without warnings.lua-time-limit 5000 ################################ REDIS CLUSTER ############################### # Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are# started as cluster nodes can. In order to start a Redis instance as a# cluster node enable the cluster support uncommenting the following:## cluster-enabled yes # Every cluster node has a cluster configuration file. This file is not# intended to be edited by hand. It is created and updated by Redis nodes.# Every Redis Cluster node requires a different cluster configuration file.# Make sure that instances running in the same system do not have# overlapping cluster configuration file names.## cluster-config-file nodes-6379.conf # Cluster node timeout is the amount of milliseconds a node must be unreachable# for it to be considered in failure state.# Most other internal time limits are multiple of the node timeout.## cluster-node-timeout 15000 # A replica of a failing master will avoid to start a failover if its data# looks too old.## There is no simple way for a replica to actually have an exact measure of# its &quot;data age&quot;, so the following two checks are performed:## 1) If there are multiple replicas able to failover, they exchange messages# in order to try to give an advantage to the replica with the best# replication offset (more data from the master processed).# Replicas will try to get their rank by offset, and apply to the start# of the failover a delay proportional to their rank.## 2) Every single replica computes the time of the last interaction with# its master. This can be the last ping or command received (if the master# is still in the &quot;connected&quot; state), or the time that elapsed since the# disconnection with the master (if the replication link is currently down).# If the last interaction is too old, the replica will not try to failover# at all.## The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform# the failover if, since the last interaction with the master, the time# elapsed is greater than:## (node-timeout * replica-validity-factor) + repl-ping-replica-period## So for example if node-timeout is 30 seconds, and the replica-validity-factor# is 10, and assuming a default repl-ping-replica-period of 10 seconds, the# replica will not try to failover if it was not able to talk with the master# for longer than 310 seconds.## A large replica-validity-factor may allow replicas with too old data to failover# a master, while a too small value may prevent the cluster from being able to# elect a replica at all.## For maximum availability, it is possible to set the replica-validity-factor# to a value of 0, which means, that replicas will always try to failover the# master regardless of the last time they interacted with the master.# (However they&#x27;ll always try to apply a delay proportional to their# offset rank).## Zero is the only value able to guarantee that when all the partitions heal# the cluster will always be able to continue.## cluster-replica-validity-factor 10 # Cluster replicas are able to migrate to orphaned masters, that are masters# that are left without working replicas. This improves the cluster ability# to resist to failures as otherwise an orphaned master can&#x27;t be failed over# in case of failure if it has no working replicas.## Replicas migrate to orphaned masters only if there are still at least a# given number of other working replicas for their old master. This number# is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica# will migrate only if there is at least 1 other working replica for its master# and so forth. It usually reflects the number of replicas you want for every# master in your cluster.## Default is 1 (replicas migrate only if their masters remain with at least# one replica). To disable migration just set it to a very large value.# A value of 0 can be set but is useful only for debugging and dangerous# in production.## cluster-migration-barrier 1 # By default Redis Cluster nodes stop accepting queries if they detect there# is at least an hash slot uncovered (no available node is serving it).# This way if the cluster is partially down (for example a range of hash slots# are no longer covered) all the cluster becomes, eventually, unavailable.# It automatically returns available as soon as all the slots are covered again.## However sometimes you want the subset of the cluster which is working,# to continue to accept queries for the part of the key space that is still# covered. In order to do so, just set the cluster-require-full-coverage# option to no.## cluster-require-full-coverage yes # This option, when set to yes, prevents replicas from trying to failover its# master during master failures. However the master can still perform a# manual failover, if forced to do so.## This is useful in different scenarios, especially in the case of multiple# data center operations, where we want one side to never be promoted if not# in the case of a total DC failure.## cluster-replica-no-failover no # In order to setup your cluster make sure to read the documentation# available at http://redis.io web site. ########################## CLUSTER DOCKER/NAT support ######################## # In certain deployments, Redis Cluster nodes address discovery fails, because# addresses are NAT-ted or because ports are forwarded (the typical case is# Docker and other containers).## In order to make Redis Cluster working in such environments, a static# configuration where each node knows its public address is needed. The# following two options are used for this scope, and are:## * cluster-announce-ip# * cluster-announce-port# * cluster-announce-bus-port## Each instruct the node about its address, client port, and cluster message# bus port. The information is then published in the header of the bus packets# so that other nodes will be able to correctly map the address of the node# publishing the information.## If the above options are not used, the normal Redis Cluster auto-detection# will be used instead.## Note that when remapped, the bus port may not be at the fixed offset of# clients port + 10000, so you can specify any port and bus-port depending# on how they get remapped. If the bus-port is not set, a fixed offset of# 10000 will be used as usually.## Example:## cluster-announce-ip 10.1.1.5# cluster-announce-port 6379# cluster-announce-bus-port 6380 ################################## SLOW LOG ################################### # The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).## You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands. # The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128 ################################ LATENCY MONITOR ############################## # The Redis latency monitoring subsystem samples different operations# at runtime in order to collect data related to possible sources of# latency of a Redis instance.## Via the LATENCY command this information is available to the user that can# print graphs and obtain reports.## The system only logs operations that were performed in a time equal or# greater than the amount of milliseconds specified via the# latency-monitor-threshold configuration directive. When its value is set# to zero, the latency monitor is turned off.## By default latency monitoring is disabled since it is mostly not needed# if you don&#x27;t have latency issues, and collecting data has a performance# impact, that while very small, can be measured under big load. Latency# monitoring can easily be enabled at runtime using the command# &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.latency-monitor-threshold 0 ############################# EVENT NOTIFICATION ############################## # Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/notifications## For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:## K Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.# E Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.# g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...# $ String commands# l List commands# s Set commands# h Hash commands# z Sorted set commands# x Expired events (events generated every time a key expires)# e Evicted events (events generated when a key is evicted for maxmemory)# A Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.## The &quot;notify-keyspace-events&quot; takes as argument a string that is composed# of zero or multiple characters. The empty string means that notifications# are disabled.## Example: to enable list and generic events, from the point of view of the# event name, use:## notify-keyspace-events Elg## Example 2: to get the stream of the expired keys subscribing to channel# name __keyevent@0__:expired use:# notify-keyspace-events Ex## By default all notifications are disabled because most users don&#x27;t need# this feature and the feature has some overhead. Note that if you don&#x27;t# specify at least one of K or E, no events will be delivered.#notify-keyspace-events &quot;&quot; ############################### ADVANCED CONFIG ############################### # Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512hash-max-ziplist-value 64 # Lists are also encoded in a special way to save a lot of space.# The number of entries allowed per internal list node can be specified# as a fixed maximum size or a maximum number of elements.# For a fixed maximum size, use -5 through -1, meaning:# -5: max size: 64 Kb &lt;-- not recommended for normal workloads# -4: max size: 32 Kb &lt;-- not recommended# -3: max size: 16 Kb &lt;-- probably not recommended# -2: max size: 8 Kb &lt;-- good# -1: max size: 4 Kb &lt;-- good# Positive numbers mean store up to _exactly_ that number of elements# per list node.# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),# but if your use case is unique, adjust the settings as necessary.list-max-ziplist-size -2 # Lists may also be compressed.# Compress depth is the number of quicklist ziplist nodes from *each* side of# the list to *exclude* from compression. The head and tail of the list# are always uncompressed for fast push/pop operations. Settings are:# 0: disable all list compression# 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,# going from either the head or tail&quot;# So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]# [head], [tail] will always be uncompressed; inner nodes will compress.# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]# 2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,# but compress all nodes between them.# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]# etc.list-compress-depth 0 # Sets have a special encoding in just one case: when a set is composed# of just strings that happen to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512 # Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64 # HyperLogLog sparse representation bytes limit. The limit includes the# 16 bytes header. When an HyperLogLog using the sparse representation crosses# this limit, it is converted into the dense representation.## A value greater than 16000 is totally useless, since at that point the# dense representation is more memory efficient.## The suggested value is ~ 3000 in order to have the benefits of# the space efficient encoding without slowing down too much PFADD,# which is O(N) with the sparse encoding. The value can be raised to# ~ 10000 when CPU is not a concern, but space is, and the data set is# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.hll-sparse-max-bytes 3000 # Streams macro node max size / items. The stream data structure is a radix# tree of big nodes that encode multiple items inside. Using this configuration# it is possible to configure how big a single node can be in bytes, and the# maximum number of items it may contain before switching to a new node when# appending new stream entries. If any of the following settings are set to# zero, the limit is ignored, so for instance it is possible to set just a# max entires limit by setting max-bytes to 0 and max-entries to the desired# value.stream-node-max-bytes 4096stream-node-max-entries 100 # Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation Redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into a hash table# that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.## The default is to use this millisecond 10 times every second in order to# actively rehash the main dictionaries, freeing memory when possible.## If unsure:# use &quot;activerehashing no&quot; if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply from time to time# to queries with 2 milliseconds delay.## use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but# want to free memory asap when possible.activerehashing yes # The client output buffer limits can be used to force disconnection of clients# that are not reading data from the server fast enough for some reason (a# common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the# publisher can produce them).## The limit can be set differently for the three different classes of clients:## normal -&gt; normal clients including MONITOR clients# replica -&gt; replica clients# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern## The syntax of every client-output-buffer-limit directive is the following:## client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;## A client is immediately disconnected once the hard limit is reached, or if# the soft limit is reached and remains reached for the specified number of# seconds (continuously).# So for instance if the hard limit is 32 megabytes and the soft limit is# 16 megabytes / 10 seconds, the client will get disconnected immediately# if the size of the output buffers reach 32 megabytes, but will also get# disconnected if the client reaches 16 megabytes and continuously overcomes# the limit for 10 seconds.## By default normal clients are not limited because they don&#x27;t receive data# without asking (in a push way), but just after a request, so only# asynchronous clients may create a scenario where data is requested faster# than it can read.## Instead there is a default limit for pubsub and replica clients, since# subscribers and replicas receive data in a push fashion.## Both the hard or the soft limit can be disabled by setting them to zero.client-output-buffer-limit normal 0 0 0client-output-buffer-limit replica 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60 # Client query buffers accumulate new commands. They are limited to a fixed# amount by default in order to avoid that a protocol desynchronization (for# instance due to a bug in the client) will lead to unbound memory usage in# the query buffer. However you can configure it here if you have very special# needs, such us huge multi/exec requests or alike.## client-query-buffer-limit 1gb # In the Redis protocol, bulk requests, that are, elements representing single# strings, are normally limited ot 512 mb. However you can change this limit# here.## proto-max-bulk-len 512mb # Redis calls an internal function to perform many background tasks, like# closing connections of clients in timeout, purging expired keys that are# never requested, and so forth.## Not all tasks are performed with the same frequency, but Redis checks for# tasks to perform according to the specified &quot;hz&quot; value.## By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when# Redis is idle, but at the same time will make Redis more responsive when# there are many keys expiring at the same time, and timeouts may be# handled with more precision.## The range is between 1 and 500, however a value over 100 is usually not# a good idea. Most users should use the default of 10 and raise this up to# 100 only in environments where very low latency is required.hz 10 # Normally it is useful to have an HZ value which is proportional to the# number of clients connected. This is useful in order, for instance, to# avoid too many clients are processed for each background task invocation# in order to avoid latency spikes.## Since the default HZ value by default is conservatively set to 10, Redis# offers, and enables by default, the ability to use an adaptive HZ value# which will temporary raise when there are many connected clients.## When dynamic HZ is enabled, the actual configured HZ will be used as# as a baseline, but multiples of the configured HZ value will be actually# used as needed once more clients are connected. In this way an idle# instance will use very little CPU time while a busy instance will be# more responsive.dynamic-hz yes # When a child rewrites the AOF file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.aof-rewrite-incremental-fsync yes # When redis saves RDB file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.rdb-save-incremental-fsync yes # Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good# idea to start with the default settings and only change them after investigating# how to improve the performances and how the keys LFU change over time, which# is possible to inspect via the OBJECT FREQ command.## There are two tunable parameters in the Redis LFU implementation: the# counter logarithm factor and the counter decay time. It is important to# understand what the two parameters mean before changing them.## The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis# uses a probabilistic increment with logarithmic behavior. Given the value# of the old counter, when a key is accessed, the counter is incremented in# this way:## 1. A random number R between 0 and 1 is extracted.# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).# 3. The counter is incremented only if R &lt; P.## The default lfu-log-factor is 10. This is a table of how the frequency# counter changes with a different number of accesses with different# logarithmic factors:## +--------+------------+------------+------------+------------+------------+# | factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits |# +--------+------------+------------+------------+------------+------------+# | 0 | 104 | 255 | 255 | 255 | 255 |# +--------+------------+------------+------------+------------+------------+# | 1 | 18 | 49 | 255 | 255 | 255 |# +--------+------------+------------+------------+------------+------------+# | 10 | 10 | 18 | 142 | 255 | 255 |# +--------+------------+------------+------------+------------+------------+# | 100 | 8 | 11 | 49 | 143 | 255 |# +--------+------------+------------+------------+------------+------------+## NOTE: The above table was obtained by running the following commands:## redis-benchmark -n 1000000 incr foo# redis-cli object freq foo## NOTE 2: The counter initial value is 5 in order to give new objects a chance# to accumulate hits.## The counter decay time is the time, in minutes, that must elapse in order# for the key counter to be divided by two (or decremented if it has a value# less &lt;= 10).## The default value for the lfu-decay-time is 1. A Special value of 0 means to# decay the counter every time it happens to be scanned.## lfu-log-factor 10# lfu-decay-time 1 ########################### ACTIVE DEFRAGMENTATION ######################### WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested# even in production and manually tested by multiple engineers for some# time.## What is active defragmentation?# -------------------------------## Active (online) defragmentation allows a Redis server to compact the# spaces left between small allocations and deallocations of data in memory,# thus allowing to reclaim back memory.## Fragmentation is a natural process that happens with every allocator (but# less so with Jemalloc, fortunately) and certain workloads. Normally a server# restart is needed in order to lower the fragmentation, or at least to flush# away all the data and create it again. However thanks to this feature# implemented by Oran Agra for Redis 4.0 this process can happen at runtime# in an &quot;hot&quot; way, while the server is running.## Basically when the fragmentation is over a certain level (see the# configuration options below) Redis will start to create new copies of the# values in contiguous memory regions by exploiting certain specific Jemalloc# features (in order to understand if an allocation is causing fragmentation# and to allocate it in a better place), and at the same time, will release the# old copies of the data. This process, repeated incrementally for all the keys# will cause the fragmentation to drop back to normal values.## Important things to understand:## 1. This feature is disabled by default, and only works if you compiled Redis# to use the copy of Jemalloc we ship with the source code of Redis.# This is the default with Linux builds.## 2. You never need to enable this feature if you don&#x27;t have fragmentation# issues.## 3. Once you experience fragmentation, you can enable this feature when# needed with the command &quot;CONFIG SET activedefrag yes&quot;.## The configuration parameters are able to fine tune the behavior of the# defragmentation process. If you are not sure about what they mean it is# a good idea to leave the defaults untouched. # Enabled active defragmentation# activedefrag yes # Minimum amount of fragmentation waste to start active defrag# active-defrag-ignore-bytes 100mb # Minimum percentage of fragmentation to start active defrag# active-defrag-threshold-lower 10 # Maximum percentage of fragmentation at which we use maximum effort# active-defrag-threshold-upper 100 # Minimal effort for defrag in CPU percentage# active-defrag-cycle-min 5 # Maximal effort for defrag in CPU percentage# active-defrag-cycle-max 75 # Maximum number of set/hash/zset/list fields that will be processed from# the main dictionary scan# active-defrag-max-scan-fields 1000 8.4.7、使用redis6.0.8镜像创建容器(也叫运行镜像)1docker run -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf 8.4.8、测试redis-cli连接上来 docker exec -it 运行着Rediis服务的容器ID redis-cli 8.4.9、证明docker启动使用了我们自己指定的配置文件修改前： 修改后: 记得重启服务 8.4.10、测试redis-cli连接上来第2次 8.5、安装NginxDocker 安装 Nginx 容器 (完整详细版)_docker nginx_Touch&amp;的博客-CSDN博客 8.5.1、搜索然后下载镜像并查看123docker search nginxdocker pull nginxdocker images 8.5.2、创建容器卷映射地址（保存nginx相关配置）12345# 创建挂载目录mkdir -p /xiaolin/nginx/confmkdir -p /xiaolin/nginx/logmkdir -p /xiaolin/nginx/html 8.5.3、把容器中的相关配置文件复制到宿主机12345678# 生成容器docker run --name my-nginx -p 9001:80 -d nginx# 将容器nginx.conf文件复制到宿主机docker cp my-nginx:/etc/nginx/nginx.conf /xiaolin/nginx/conf/nginx.conf# 将容器conf.d文件夹下内容复制到宿主机docker cp my-nginx:/etc/nginx/conf.d /xiaolin/nginx/conf/conf.d# 将容器中的html文件夹复制到宿主机docker cp my-nginx:/usr/share/nginx/html /xiaolin/nginx/ 8.5.4、运行nginx容器1234567891011# 直接执行docker rm nginx或者以容器id方式关闭容器# 找到nginx对应的容器iddocker ps -a# 关闭该容器docker stop my-nginx# 删除该容器docker rm my-nginx # 删除正在运行的nginx容器docker rm -f my-nginx 12345678docker run \\-p 80:80 \\--name my-nginx \\-v /xiaolin/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /xiaolin/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /xiaolin/nginx/log:/var/log/nginx \\-v /xiaolin/nginx/html:/usr/share/nginx/html \\-d nginx:latest 1docker run -p 80:80 --name my-nginx -v /xiaolin/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /xiaolin/nginx/conf/conf.d:/etc/nginx/conf.d -v /xiaolin/nginx/log:/var/log/nginx -v /xiaolin/nginx/html:/usr/share/nginx/html -d nginx:latest 8.5.5、访问8.130.115.225 8.5.6、修改内容进行展示vim &#x2F;xiaolin&#x2F;nginx&#x2F;html&#x2F;index.html 然后重启 二、高级篇1、Docker复杂安装详说1.1、安装mysql主从复制1.1.1、主从复制原理MySQL主从复制是指将一个MySQL数据库的数据复制到另一个MySQL数据库的过程。主库（master）是指数据源，从库（slave）是指数据接收方。主从复制的原理如下： 主库将数据变更记录到二进制日志（binlog）中。 从库连接主库，并请求从指定的位置开始获取主库的binlog。 主库将binlog传给从库，从库将binlog写入本地的中继日志（relay log）中。 从库读取中继日志，将其中的变更应用到本地的数据库中。 从库定期向主库发送心跳包，以便主库检测从库的状态。 当主库发生变更时，从库将会收到通知，然后根据通知的信息获取相应的binlog，并将其应用到本地的数据库中。 通过这种方式，主库和从库之间可以保持数据的同步，从而实现数据的备份、负载均衡等功能。 1.1.2、主从搭建步骤 新建主服务器容器实例3307 1234567 docker run -p 3307:3306 --name mysql-master \\-v /mydata/mysql-master/log:/var/log/mysql \\-v /mydata/mysql-master/data:/var/lib/mysql \\-v /mydata/mysql-master/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf vim my.cnf 12345678910111213141516[mysqld]## 设置server_id，同一局域网中需要唯一server_id=101 ## 指定不需要同步的数据库名称binlog-ignore-db=mysql ## 开启二进制日志功能log-bin=mall-mysql-bin ## 设置二进制日志使用内存大小（事务）binlog_cache_size=1M ## 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed ## 二进制日志过期清理时间。默认值为0，表示不自动清理。expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062 12345678910111213141516171819202122232425262728293031323334353637MySQL的my.cnf配置文件是MySQL服务器的主要配置文件，它包含了MySQL服务器的各种配置参数，可以通过修改配置参数来改变MySQL服务器的行为，从而满足不同的需求。下面是my.cnf配置文件中常用的配置参数及其详细解释：1. [client]：客户端配置参数，包括连接MySQL服务器的相关参数，如host、user、password等。2. [mysqld]：MySQL服务器配置参数，包括MySQL服务器的启动参数、缓存参数、日志参数、安全参数等。3. datadir：MySQL数据库文件存放的路径。4. port：MySQL服务器监听的端口号。5. server-id：MySQL服务器的唯一标识符，在主从复制中用于标识主库和从库。6. log-bin：启用二进制日志功能，用于主从复制和数据恢复。7. log-error：MySQL服务器错误日志文件的路径。8. max_connections：MySQL服务器最大连接数。9. character-set-server：MySQL服务器默认字符集。10. innodb_buffer_pool_size：InnoDB存储引擎缓存池大小。11. innodb_log_file_size：InnoDB存储引擎日志文件大小。12. innodb_flush_log_at_trx_commit：InnoDB存储引擎日志刷写策略。13. skip-name-resolve：禁止MySQL服务器进行DNS解析，提高性能。14. skip-external-locking：禁止MySQL服务器使用外部锁功能，提高性能。15. slow_query_log：启用慢查询日志功能，用于诊断慢查询。16. long_query_time：慢查询日志的阈值，超过该时间的查询将被记录。17. log-slow-queries：慢查询日志文件的路径。以上是my.cnf配置文件中常用的配置参数及其详细解释，根据实际需求可以灵活配置。 修改完配置后重启master实例 docker restart mysql-master 进入mysql-master容器 docker exec -it mysql-master &#x2F;bin&#x2F;bash mysql -uroot -proot master容器实例内创建数据同步用户 CREATE USER ‘slave‘@’%’ IDENTIFIED BY ‘123456’; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON . TO ‘slave‘@’%’; 新建从服务器容器实例3308 123456 docker run -p 3308:3306 --name mysql-slave \\-v /mydata/mysql-slave/log:/var/log/mysql \\-v /mydata/mysql-slave/data:/var/lib/mysql \\-v /mydata/mysql-slave/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf vim my.cnf 1234567891011121314151617181920212223[mysqld]## 设置server_id，同一局域网中需要唯一server_id=102## 指定不需要同步的数据库名称binlog-ignore-db=mysql ## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用log-bin=mall-mysql-slave1-bin ## 设置二进制日志使用内存大小（事务）binlog_cache_size=1M ## 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed ## 二进制日志过期清理时间。默认值为0，表示不自动清理。expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062 ## relay_log配置中继日志relay_log=mall-mysql-relay-bin ## log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1 ## slave设置为只读（具有super权限的用户除外）read_only=1 123456789101112131415MySQL支持三种二进制日志格式：statement、row和mixed。设置使用的二进制日志格式可以通过修改my.cnf配置文件中的binlog_format参数来实现。1. statement格式：记录SQL语句statement格式是最简单的二进制日志格式，它记录的是MySQL服务器接收到的SQL语句。这种格式的优点是记录量较小，缺点是不能记录数据变更前后的值，也不能记录一些特殊的SQL语句，如UUID()等。2. row格式：记录行数据row格式是最详细的二进制日志格式，它记录每一行数据的变更情况，包括变更前后的值。这种格式的优点是记录非常详细，可以用于数据恢复和主从复制，缺点是记录量较大，可能会影响性能。3. mixed格式：混合记录SQL语句和行数据mixed格式是statement格式和row格式的结合，它根据SQL语句的不同自动选择记录SQL语句或行数据。这种格式的优点是既能记录SQL语句，又能记录行数据，可以充分发挥两种格式的优点，缺点是可能会产生一些复杂的日志记录。综上所述，选择哪种二进制日志格式取决于实际需求。如果需要记录详细的数据变更信息，可以选择row格式；如果需要记录SQL语句并保证性能，可以选择statement格式；如果需要兼顾两者的优点，可以选择mixed格式。 修改完配置后重启slave实例 docker restart mysql-slave 在主数据库中查看主从同步状态 show master status; 进入mysql-slave容器 docker exec -it mysql-slave &#x2F;bin&#x2F;bash mysql -uroot -proot 在从数据库中配置主从复制 change master to master_host&#x3D;’宿主机ip’, master_user&#x3D;’slave’, master_password&#x3D;’123456’, master_port&#x3D;3307, master_log_file&#x3D;’mall-mysql-bin.000001’, master_log_pos&#x3D;617, master_connect_retry&#x3D;30; 主从复制命令参数说明: 1234567master_host：主数据库的IP地址；master_port：主数据库的运行端口；master_user：在主数据库创建的用于同步数据的用户账号；master_password：在主数据库创建的用于同步数据的用户密码；master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；master_connect_retry：连接失败重试的时间间隔，单位为秒。 在从数据库中查看主从同步状态 show slave status \\G; 在从数据库中开启主从同步 查看从数据库状态发现已经同步 主从复制测试 主机新建库-使用库-新建表-插入数据，ok 从机使用库-查看记录，ok ​ 1.2、安装redis集群(大厂面试题第4季-分布式存储案例真题)cluster(集群)模式-docker版哈希槽分区进行亿级数据存储 1.2.1、面试题1~2亿条数据需要缓存，请问如何设计这个存储案例 回答：单机单台100%不可能，肯定是分布式存储，用redis如何落地？ 上述问题阿里P6~P7工程案例和场景设计类必考题目，一般业界有3种解决方案： 哈希取余分区 2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。 优点： 简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。 缺点： 原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。 一致性哈希算法分区 是什么： 123一致性Hash算法背景 一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了 能干嘛: 提出一致性Hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系 3大步骤: 算法构建一致性哈希环 1234一致性哈希环 一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 = 2^32),这样让它逻辑上形成了一个环形空间。 它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。 服务器IP节点映射 123节点映射 将集群中各个IP节点映射到环上的某一个位置。 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： key落到服务器的落键规则 12当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 优点: 一致性哈希算法的容错性 12容错性假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。 一致性哈希算法的扩展性 123扩展性数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。 缺点： 一致性哈希算法的数据倾斜问题 123Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器： 小总结: 12345678910为了在节点数目发生改变时尽可能少的迁移数据 将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。 优点加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。 缺点 数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。 哈希槽分区 是什么 1 为什么出现 哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。 2 能干什么解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。 槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。 3 多少个hash槽一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。 哈希槽计算 Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上 1.2.2、3主3从redis集群扩缩容配置案例架构说明未命名文件-ProcessOn 1.2.3、开打步骤 3主3从redis集群配置 1、关闭防火墙+启动docker后台服务 注意启动服务：systemctl start docker 2、新建6个docker容器redis实例： 123456789101112docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381 docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382 docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383 docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384 docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385 docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386 效果如下： 命令分步解释: 123456789docker run:创建并运行docker容器实例--name redis-node-6:容器名字--net host:使用宿主机的IP和端口，默认--privileged=true:获取宿主机root用户权限-v /data/redis/share/redis-node-6:/data:容器卷，宿主机地址:docker内部地址redis:6.0.8:redis镜像和版本号--cluster-enabled yes:开启redis集群--appendonly yes:开启持久化--port 6386:redis端口号 3、进入容器redis-node-1并为6台机器构建集群关系: 进入容器：docker exec -it redis-node-1 &#x2F;bin&#x2F;bash 构建主从关系： 12//注意，进入docker容器后才能执行一下命令，且注意自己的真实IP地址redis-cli --cluster create 8.130.115.225:6381 8.130.115.225:6382 8.130.115.225:6383 8.130.115.225:6384 8.130.115.225:6385 8.130.115.225:6386 --cluster-replicas 1 –cluster-replicas 1 表示为每个master创建一个slave节点 一切OK的话，3主3从搞定 4、链接进入6381作为切入点，查看集群状态 链接进入6381作为切入点，查看节点状态 cluster info cluster nodes 主从容错切换迁移案例 1、数据读写存储 启动6机构成的集群并通过exec进入 对6381新增两个key 防止路由失效加参数-c并新增两个key 查看集群信息 redis-cli –cluster check 8.130.115.225:6381 2、容错切换迁移 主6381和从机切换，先停止主机6381 6381主机停了，对应的真实从机上位 6381作为1号主机分配的从机以实际情况为准，具体是几号机器就是几号 再次查看集群信息： 6381宕机了，6384上位成为了新的master。 先还原之前的3主3从：： 123docker start redis-node-1docker stop redis-node-4docker start redis-node-4 主从机器分配情况以实际情况为准 查看集群状态: redis-cli –cluster check 自己IP:6381 主从扩容案例 1、新建6387、6388两个节点+新建后启动+查看是否8节点 12345docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388docker ps 2、进入6387容器实例内部 1docker exec -it redis-node-7 /bin/bash 3、将新增的6387节点(空槽号)作为master节点加入原集群 1redis-cli --cluster add-node 8.130.115.225:6387 8.130.115.225:6381 4、检查集群情况第1次 1redis-cli --cluster check 真实ip地址:6381 此时没有槽号 5、重新分派槽号 1234重新分派槽号命令:redis-cli --cluster reshard IP地址:端口号redis-cli --cluster reshard 8.130.115.225:6381 6、检查集群情况第2次 redis-cli –cluster check 真实ip地址:6381 123槽号分派说明:为什么6387是3个新的区间，以前的还是连续？重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387 7、为主节点6387分配从节点6388 123命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID redis-cli --cluster add-node 8.130.115.225:6388 8.130.115.225:6387 --cluster-slave --cluster-master-id 7519e1479f230716f40ed365fe8a30d2a809fa2a-------这个是6387的编号，按照自己实际情况 8、检查集群情况第3次 redis-cli –cluster check 8.130.115.225:6381 主从缩容案例 目的：6387和6388下线 检查集群情况1获得6388的节点ID：redis-cli –cluster check 8.130.115.225:6381 将6388删除从集群中将4号从节点6388删除： 将6387的槽号清空，重新分配，本例将清出来的槽号都给6381： redis-cli –cluster reshard 8.130.115.225:6381 检查集群情况第二次： redis-cli –cluster check 8.130.115.225:6381 4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端 将6387删除: 命令：redis-cli –cluster del-node ip:端口 6387节点ID redis-cli –cluster del-node 192.168.111.147:6387 e4781f644d4a4e4d4b4d107157b9ba8144631451 检查集群情况第三次: redis-cli –cluster check 8.130.115.225:6381 2、DockeFile解析2.1、是什么Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 2.1.1、概述 2.1.2、官网https://docs.docker.com/engine/reference/builder/ 2.1.3、构建三步骤编写Dockerfile文件 docker build命令构建镜像 docker run依镜像运行容器实例 2.2、DockerFile构建过程解析2.2.1、Dockerfile内容基础知识1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数 2：指令按照从上到下，顺序执行 3：#表示注释 4：每条指令都会创建一个新的镜像层并对镜像进行提交 2.2.2、Docker执行Dockerfile的大致流程（1）docker从基础镜像运行一个容器 （2）执行一条指令并对容器作出修改 （3）执行类似docker commit的操作提交一个新的镜像层 （4）docker再基于刚提交的镜像运行一个新容器 （5）执行dockerfile中的下一条指令直到所有指令都执行完成 2.2.3、小总结从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段， Dockerfile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。 1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等; 2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务; 3 Docker容器，容器是直接提供服务的。 2.3、DockerFile常用保留字指令2.3.1、参考tomcat8的dockerfile入门https://github.com/docker-library/tomcat 2.3.2、FROM基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from 2.3.3、MAINTAINER镜像维护者的姓名和邮箱地址 已弃用，改用LABEL maintainer&#x3D;”xxxx” 2.3.4、RUN容器构建时需要运行的命令 两种格式： shell格式 RUN yum -y install vim exec格式 RUN是在 docker build时运行 2.3.5、EXPOSE当前容器对外暴露出的端口 2.3.6、WORKDIR指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点 docker exec -it xxx bash进入之后的目录。 2.3.7、USER指定该镜像以什么样的用户去执行，如果都不指定，默认是root 2.3.8、ENV用来在构建镜像过程中设置环境变量 ENV MY_PATH &#x2F;usr&#x2F;mytest这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量， 比如：WORKDIR $MY_PATH 2.3.9、ADD将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包 2.3.10、COPY类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置 COPY src dest或COPY [“src”, “dest”] &lt;src源路径&gt;：源文件或者源目录 &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 2.3.11、VOLUME容器数据卷，用于数据保存和持久化工作 2.3.12、CMD指定容器启动后的要干的事情 注意： Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换 参考官网Tomcat的dockerfile演示讲解 官网最后一行命令 我们演示自己的覆盖操作： 这样tomcat不会真正启动，只是启动了一个窗口 它和前面RUN命令的区别： CMD是在docker run 时运行。 RUN是在 docker build时运行。 2.3.13、ENTRYPOINT也是用来指定一个容器启动时要运行的命令 类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序 命令格式和案例说明： ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成 案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像： 优点：在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。 缺点：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 2.3.14、小总结 2.4、案例2.4.1、自定义镜像mycentosjava8要求： Centos7镜像具备vim+ifconfig+jdk11： JDK的下载镜像地址 下载地址：https://www.oracle.com/java/technologies/downloads/#java8 https://mirrors.yangxingzhen.com/jdk/ 编写：准备编写Dockerfile文件，注意是大写字母D 1234567891011121314151617181920212223242526FROM centos:7LABEL maintainer=&quot;xiaolin&quot; ENV MYPATH /usr/localWORKDIR $MYPATH #安装vim编辑器RUN yum -y install vim#安装ifconfig命令查看网络IPRUN yum -y install net-tools#安装java8及lib库RUN yum -y install glibc.i686RUN mkdir /usr/local/java#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置ADD jdk-17_linux-x64_bin.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk-17.0.6ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH EXPOSE 80 CMD echo $MYPATHCMD echo &quot;success--------------ok&quot;CMD /bin/bash 构建: docker build -t 新镜像名字:TAG . 注意，上面TAG后面有个空格，有个点 运行: docker run -it 新镜像名字:TAG 再体会下UnionFS（联合文件系统）: 123UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 2.4.2、虚悬镜像是什么：仓库名、标签都是的镜像，俗称dangling image Dockerfile写一个： 1 vim Dockerfile 12from ubuntuCMD echo &#x27;action is success&#x27; 2 docker build . 查看: docker image ls -f dangling&#x3D;true 删除: docker image prune 虚悬镜像已经失去存在价值，可以删除 2.4.3、自定义镜像myubuntujak11Dockerfile: 123456789101112131415161718192021222324252627FROM ubuntuLABEL maintainer=&quot;xiaolin&quot; ENV MYPATH /usr/localWORKDIR $MYPATH #安装vim编辑器RUN apt-get update#安装ifconfig命令查看网络IPRUN apt-get install net-tools#RUN apt-get install -y iproute2#RUN apt-get install -y inetutils-pingRUN mkdir /usr/local/java#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置ADD jdk-17_linux-x64_bin.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk-17.0.6ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH EXPOSE 80 CMD echo $MYPATHCMD echo &quot;success--------------ok&quot;CMD /bin/bash docker build -t myubuntujdk11:1.0 . docker run -it myubuntujdk11:1.0 2.5、小总结 3、Docker微服务实战3.1、通过IDEA新建一个普通微服务模块3.1.1、建Moduledocker_boot 3.1.2、改pom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu.docker&lt;/groupId&gt; &lt;artifactId&gt;docker_boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringBoot通用依赖模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.1.3、写ymlserver.port&#x3D;6001 3.1.4、主启动3.1.5、业务类1234567891011121314151617181920212223242526272829303132package com.lxg.docker.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;/** * @auther zzyy * @create 2021-10-25 17:43 */@RestControllerpublic class OrderController&#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String port; @RequestMapping(&quot;/order/docker&quot;) public String helloDocker() &#123; return &quot;hello docker&quot;+&quot;\\t&quot;+port+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125; @RequestMapping(value =&quot;/order/index&quot;,method = RequestMethod.GET) public String index() &#123; return &quot;服务端口号: &quot;+&quot;\\t&quot;+port+&quot;\\t&quot;+UUID.randomUUID().toString(); &#125;&#125; 3.2、通过dockerfile发布微服务部署到docker容器3.2.1、IDEA工具里面搞定微服务jar包 3.2.2、编写Dockerfile12345678910111213# 基础镜像使用javaFROM java:8# 作者MAINTAINER zzyy# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmpVOLUME /tmp# 将jar包添加到容器中并更名为zzyy_docker.jarADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar# 运行jar包RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]#暴露6001端口作为微服务EXPOSE 6001 3.2.3、将微服务jar包和Dockerfile文件上传到同一个目录下&#x2F;mydocker 3.2.4、构建镜像docker build -t zzyy_docker:1.6 . 打包成镜像文件 3.2.5、运行容器 docker run -d -p 6001:6001 zzyy_docker:1.6 3.2.6、访问测试 4、Docker网络4.1、是什么docker不启动，默认网络情况: ens33 lo virbr0 1234在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。 我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，yum remove libvirt-libs.x86_64 docker启动后，网络情况: 会产生一个名为docker0的虚拟网桥 查看docker网络模式命令 默认创建3大网络模式 4.2、常用基本命令4.2.1、All命令 4.2.2、查看网络docker network ls 4.2.3、查看网络源数据docker network inspect XXX网络名字 4.2.4、删除网络docker network rm XXX网络名字 4.2.5、案例 4.3、能干嘛容器间的互联和通信以及端口映射 容器IP变动时候可以通过服务名直接网络通信而不受到影响 4.5、网络模式4.5.1、总体介绍 bridge模式：使用–network bridge指定，默认使用docker0 host模式：使用–network host指定 none模式：使用–network none指定 container模式：使用–network container:NAME或者容器ID指定 4.5.2、容器实例内默认网络IP生产规则说明： 1 先启动两个ubuntu容器实例 2 docker inspect 容器ID or 容器名字 3 关闭u2实例，新建u3，查看ip变化 结论： docker容器内部的ip是有可能会发生改变的 4.5.3、案例说明1、bridge： 12Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。 查看 bridge 网络的详细信息，并通过 grep 获取名称项 docker network inspect bridge | grep name ifconfig 案例: 说明： 123456789101 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。 2 docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址 3 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）； 3.2 每个容器实例内部也有一块网卡，每个接口叫eth0； 3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。 代码: 12docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8 两两匹配验证: 2、host 是什么： 直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。 案例： 说明：容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。 代码： 警告： docker run -d -p 8083:8080 –network host –name tomcat83 billygoo&#x2F;tomcat8-jdk8 1234567问题： docke启动时总是遇见标题中的警告原因： docker启动时指定--network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。解决: 解决的办法就是使用docker的其他网络模式，例如--network=bridge，这样就可以解决问题，或者直接无视。。。。O(∩_∩)O哈哈~ 正确： docker run -d –network host –name tomcat83 billygoo&#x2F;tomcat8-jdk8 无之前的配对显示了，看容器实例内部 docker run -d –network host –name tomcat83 billygoo&#x2F;tomcat8-jdk8 没有设置-p的端口映射了，如何访问启动的tomcat83？？ 1234http://宿主机IP:8080/ 在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。 3、none 是什么： 在none模式下，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo需要我们自己为Docker容器添加网卡、配置IP等。 禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环) 案例： docker run -d -p 8084:8080 –network none –name tomcat84 billygoo&#x2F;tomcat8-jdk8 进入容器内部查看 在容器外部查看 4、container 是什么： container⽹络模式新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 错误案例： docker run -d -p 8085:8080 –name tomcat85 billygoo&#x2F;tomcat8-jdk8 docker run -d -p 8086:8080 –network container:tomcat85 –name tomcat86 billygoo&#x2F;tomcat8-jdk8 运行结果： 1234# 相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o 换一个镜像给大家演示 正确案例： Alpine操作系统是一个面向安全的轻型 Linux发行版 1Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。 docker run -it –name alpine1 alpine &#x2F;bin&#x2F;sh docker run -it –network container:alpine1 –name alpine2 alpine &#x2F;bin&#x2F;sh 运行结果，验证共用搭桥: 假如此时关闭alpine1，再看看alpine2 5、自定义网络 过时的link： 案例： 1、before： 案例 12docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8 上述成功启动并用docker exec进入各自容器实例内部 问题： 按照IP地址ping是OK的 按照服务名ping结果??? 2、after： 案例 自定义桥接网络,自定义网络默认使用的是桥接网络bridge 新建自定义网络 新建容器加入上一步新建的自定义网络 docker run -d -p 8081:8080 –network zzyy_network –name tomcat81 billygoo&#x2F;tomcat8-jdk8 docker run -d -p 8082:8080 –network zzyy_network –name tomcat82 billygoo&#x2F;tomcat8-jdk8 互相ping测试 问题结论: 自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通） 自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通） 自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通） 4.6、Docker平台架构图解4.6.1、整体说明从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 Docker 运行的基本流程为： 1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。 4.6.2、整体架构 5、Docker-compose容器编排 5.1、是什么Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器 Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 5.2、能干嘛 docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？ 如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具 例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。 Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。 5.3、去哪下官网：https://docs.docker.com/compose/compose-file/compose-file-v3/ 官网下载：https://docs.docker.com/compose/install/ 安装步骤： curl -L “https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)” -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composechmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composedocker-compose –version 新版的已经自带了，命令：docker compose version可以查看 卸载步骤： 5.4、Compose核心概念一文件：docker-compose.yml 两要素： 服务（service） 一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器 工程（project） 由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 5.5、Compose使用的三个步骤编写Dockerfile定义各个微服务应用并构建出对应的镜像文件 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。 最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线 5.6、Compose常用命令123456789101112131415Compose常用命令docker-compose -h # 查看帮助docker-compose up # 启动所有docker-compose服务docker-compose up -d # 启动所有docker-compose服务并后台运行docker-compose down # 停止并删除容器、网络、卷、镜像。docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bashdocker-compose ps # 展示当前docker-compose编排过的运行的所有容器docker-compose top # 展示当前docker-compose编排过的容器进程 docker-compose logs yml里面的服务id # 查看容器输出日志docker-compose config # 检查配置docker-compose config -q # 检查配置，有问题才有输出docker-compose restart # 重启服务docker-compose start # 启动服务docker-compose stop # 停止服务 5.7、Compose编排微服务5.7.1、改造升级微服务工程docker_boot以前的基础版： sql建表： 123456789101112 CREATE TABLE `t_user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, `password` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `sex` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, `deleted` tinyint(4) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27; 一键生成实体类mapper、service等 改pom： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxg.docker&lt;/groupId&gt; &lt;artifactId&gt;Docker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Docker&lt;/name&gt; &lt;description&gt;Docker&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--guava Google 开源的 Guava 中自带的布隆过滤器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;23.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redisson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.13.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger2--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot与Redis整合依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springCache--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springCache连接池依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot集成druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加springboot对amqp的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--通用基础配置junit/devtools/test/log4j/lombok/hutool--&gt; &lt;!--hutool--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--persistence--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Mysql数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 注意springboot版本可能会与swagger冲突 编写配置文件： 1234567891011121314151617181920212223server.port=6001# ========================alibaba.druid????=====================spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://8.130.115.225:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456spring.datasource.druid.test-while-idle=false# ========================redis????=====================spring.redis.database=0spring.redis.host=8.130.115.225spring.redis.port=6379spring.redis.password=spring.redis.lettuce.pool.max-active=8spring.redis.lettuce.pool.max-wait=-1msspring.redis.lettuce.pool.max-idle=8spring.redis.lettuce.pool.min-idle=0# ========================mybatis????===================mybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.lxg.docker.domain# ========================swagger=====================spring.swagger2.enabled=true 主启动类： 12345678910111213141516package com.lxg.docker;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.lxg.docker.mapper&quot;) // 扫描mapper接口public class DockerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DockerApplication.class, args); &#125;&#125; 业务类： config配置类: RedisConfig: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lxg.docker.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.io.Serializable;@Configuration@Slf4jpublic class RedisConfig&#123; /** * @param lettuceConnectionFactory * @return * * redis序列化的工具配置类，下面这个请一定开启配置 * 127.0.0.1:6379&gt; keys * * 1) &quot;ord:102&quot; 序列化过 * 2) &quot;\\xac\\xed\\x00\\x05t\\x00\\aord:102&quot; 野生，没有序列化过 */ @Bean public RedisTemplate&lt;String,Serializable&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) &#123; RedisTemplate&lt;String,Serializable&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(lettuceConnectionFactory); //设置key序列化方式string redisTemplate.setKeySerializer(new StringRedisSerializer()); //设置value的序列化方式json redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; SwaggerConfig: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lxg.docker.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.text.SimpleDateFormat;import java.util.Date;/** * @auther zzyy * @create 2021-05-01 16:18 */@Configuration@EnableSwagger2public class SwaggerConfig&#123; @Value(&quot;$&#123;spring.swagger2.enabled&#125;&quot;) private Boolean enabled; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(enabled) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.lxg.docker&quot;)) //你自己的package .paths(PathSelectors.any()) .build(); &#125; public ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;尚硅谷Java大厂技术&quot;+&quot;\\t&quot;+new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date())) .description(&quot;docker-compose&quot;) .version(&quot;1.0&quot;) .termsOfServiceUrl(&quot;https://www.atguigu.com/&quot;) .build(); &#125;&#125; 新建entity: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.lxg.docker.domain;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;@NoArgsConstructor@AllArgsConstructor@Data@ApiModel(value = &quot;用户信息&quot;)public class UserDTO implements Serializable&#123; @ApiModelProperty(value = &quot;用户ID&quot;) private Integer id; @ApiModelProperty(value = &quot;用户名&quot;) private String username; @ApiModelProperty(value = &quot;密码&quot;) private String password; @ApiModelProperty(value = &quot;性别 0=女 1=男 &quot;) private Byte sex; @ApiModelProperty(value = &quot;删除标志，默认0不删除，1删除&quot;) private Byte deleted; @ApiModelProperty(value = &quot;更新时间&quot;) private Date updateTime; @ApiModelProperty(value = &quot;创建时间&quot;) private Date createTime; /** * @return id */ public Integer getId() &#123; return id; &#125; /** * @param id */ public void setId(Integer id) &#123; this.id = id; &#125; /** * 获取用户名 * * @return username - 用户名 */ public String getUsername() &#123; return username; &#125; /** * 设置用户名 * * @param username 用户名 */ public void setUsername(String username) &#123; this.username = username; &#125; /** * 获取密码 * * @return password - 密码 */ public String getPassword() &#123; return password; &#125; /** * 设置密码 * * @param password 密码 */ public void setPassword(String password) &#123; this.password = password; &#125; /** * 获取性别 0=女 1=男 * * @return sex - 性别 0=女 1=男 */ public Byte getSex() &#123; return sex; &#125; /** * 设置性别 0=女 1=男 * * @param sex 性别 0=女 1=男 */ public void setSex(Byte sex) &#123; this.sex = sex; &#125; /** * 获取删除标志，默认0不删除，1删除 * * @return deleted - 删除标志，默认0不删除，1删除 */ public Byte getDeleted() &#123; return deleted; &#125; /** * 设置删除标志，默认0不删除，1删除 * * @param deleted 删除标志，默认0不删除，1删除 */ public void setDeleted(Byte deleted) &#123; this.deleted = deleted; &#125; /** * 获取更新时间 * * @return update_time - 更新时间 */ public Date getUpdateTime() &#123; return updateTime; &#125; /** * 设置更新时间 * * @param updateTime 更新时间 */ public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125; /** * 获取创建时间 * * @return create_time - 创建时间 */ public Date getCreateTime() &#123; return createTime; &#125; /** * 设置创建时间 * * @param createTime 创建时间 */ public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, sex=&quot; + sex + &#x27;&#125;&#x27;; &#125;&#125; Userservice: 1234567891011121314151617package com.lxg.docker.service;import com.lxg.docker.domain.User;import com.baomidou.mybatisplus.extension.service.IService;/*** @author xiaolin* @description 针对表【t_user(用户表)】的数据库操作Service* @createDate 2023-04-10 23:16:06*/public interface UserService extends IService&lt;User&gt; &#123; public void addUser(User user); public User findUserById(Integer id);&#125; UserServiceImpl: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.lxg.docker.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.lxg.docker.domain.User;import com.lxg.docker.service.UserService;import com.lxg.docker.mapper.UserMapper;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import javax.annotation.Resource;/*** @author xiaolin* @description 针对表【t_user(用户表)】的数据库操作Service实现* @createDate 2023-04-10 23:16:06*/@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123; public static final String CACHE_KEY_USER = &quot;user:&quot;; @Resource private UserMapper userMapper; @Resource private RedisTemplate redisTemplate; /** * addUser * @param user */ public void addUser(User user) &#123; //1 先插入mysql并成功 int i = userMapper.insert(user); if(i &gt; 0) &#123; //2 需要再次查询一下mysql将数据捞回来并ok user = userMapper.selectById(user.getId()); //3 将捞出来的user存进redis，完成新增功能的数据一致性。 String key = CACHE_KEY_USER+user.getId(); redisTemplate.opsForValue().set(key,user); &#125; &#125; /** * findUserById * @param id * @return */ public User findUserById(Integer id) &#123; User user = null; String key = CACHE_KEY_USER+id; //1 先从redis里面查询，如果有直接返回结果，如果没有再去查询mysql user = (User) redisTemplate.opsForValue().get(key); if(user == null) &#123; //2 redis里面无，继续查询mysql user = userMapper.selectById(id); if(user == null) &#123; //3.1 redis+mysql 都无数据 //你具体细化，防止多次穿透，我们规定，记录下导致穿透的这个key回写redis return user; &#125;else&#123; //3.2 mysql有，需要将数据写回redis，保证下一次的缓存命中率 redisTemplate.opsForValue().set(key,user); &#125; &#125; return user; &#125;&#125; UserController: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.lxg.docker.controller;import java.util.Date;import cn.hutool.core.util.IdUtil;import com.lxg.docker.domain.User;import com.lxg.docker.domain.UserDTO;import com.lxg.docker.service.UserService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.models.auth.In;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.Random;/** * @auther zzyy * @create 2021-05-01 15:02 */@Api(description = &quot;用户User接口&quot;)@RestController@Slf4jpublic class UserController&#123; @Resource private UserService userService; @ApiOperation(&quot;数据库新增3条记录&quot;) @RequestMapping(value = &quot;/user/add&quot;,method = RequestMethod.POST) public void addUser() &#123; for (int i = 1; i &lt;=3; i++) &#123; User user = new User(); user.setUsername(&quot;xiaolin&quot;+i); user.setPassword(IdUtil.simpleUUID().substring(0,6)); user.setSex(new Random().nextInt(2)); userService.addUser(user); &#125; &#125; /*@ApiOperation(&quot;删除1条记录&quot;) @RequestMapping(value = &quot;/user/delete/&#123;id&#125;&quot;,method = RequestMethod.POST) public void deleteUser(@PathVariable Integer id) &#123; userService.deleteUser(id); &#125; @ApiOperation(&quot;修改1条记录&quot;) @RequestMapping(value = &quot;/user/update&quot;,method = RequestMethod.POST) public void updateUser(@RequestBody UserDTO userDTO) &#123; User user = new User(); BeanUtils.copyProperties(userDTO,user); userService.updateUser(user); &#125;*/ @ApiOperation(&quot;查询1条记录&quot;) @RequestMapping(value = &quot;/user/find/&#123;id&#125;&quot;,method = RequestMethod.GET) public User findUserById(@PathVariable Integer id) &#123; return userService.findUserById(id); &#125;&#125; mvn package命令将微服务形成新的jar包并上传到Linux服务器&#x2F;mydocker目录下 编写Dockerfile 1234567891011121314# 基础镜像使用javaFROM java:8# 作者MAINTAINER xiaolin# VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmpVOLUME /tmp# 将jar包添加到容器中并更名为zzyy_docker.jarADD Docker-0.0.1-SNAPSHOT.jar xiaolin_docker.jar# 运行jar包RUN bash -c &#x27;touch /xiaolin_docker.jar&#x27;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/xiaolin_docker.jar&quot;]#暴露6001端口作为微服务EXPOSE 6001 构建镜像:docker build -t xiaolin_docker:3.0 . 5.7.2、不用Compose单独的mysql容器实例 新建mysql容器实例 docker run -p 3306:3306 –name mysql57 –privileged&#x3D;true -v &#x2F;zzyyuse&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;zzyyuse&#x2F;mysql&#x2F;logs:&#x2F;logs -v &#x2F;zzyyuse&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7 进入mysql容器实例并新建库db2021+新建表t_user 1234567891011121314151617docker exec -it mysql57 /bin/bashmysql -uroot -pcreate database db2021;use db2021;CREATE TABLE `t_user` ( `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;; 单独的redis容器实例 docker run -p 6379:6379 –name redis608 –privileged&#x3D;true -v &#x2F;app&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;app&#x2F;redis&#x2F;data:&#x2F;data -d redis:6.0.8 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf 微服务工程 docker run -d -p 6001:6001 xiaolin_docker:3.0 上面三个容器实例依次顺序启动成功 5.7.3、swagger测试http://8.130.115.225:6001/swagger-ui.html# 5.7.4、问题先后顺序要求固定，先mysql+redis才能微服务访问成功 多个run命令…… 容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错，要么生产IP写死(可以但是不推荐)，要么通过服务调用 5.7.5、使用Compose服务编排，一套带走，安排 编写docker-compose.yml文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647version: &quot;3&quot; services: microService: image: xiaolin_docker:3.0 container_name: ms01 ports: - &quot;6001:6001&quot; volumes: - /app/microService:/data networks: - xiaolin_net depends_on: - redis - mysql redis: image: redis:6.0.8 ports: - &quot;6379:6379&quot; volumes: - /app/redis/redis.conf:/etc/redis/redis.conf - /app/redis/data:/data networks: - xiaolin_net command: redis-server /etc/redis/redis.conf mysql: image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: &#x27;123456&#x27; MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27; MYSQL_DATABASE: &#x27;db2021&#x27; MYSQL_USER: &#x27;xiaolin&#x27; MYSQL_PASSWORD: &#x27;xiaolin123&#x27; ports: - &quot;3306:3306&quot; volumes: - /app/mysql/db:/var/lib/mysql - /app/mysql/conf/my.cnf:/etc/my.cnf - /app/mysql/init:/docker-entrypoint-initdb.d networks: - xiaolin_net command: --default-authentication-plugin=mysql_native_password #解决外部无法访问 networks: xiaolin_net: 第二次修改微服务工程docker_boot: 执行 docker-compose up或者执行 docker-compose up -d 新版本命令：docker compose up -d 进入mysql容器实例并新建库db2021+新建表t_user 1234567891011121314151617 docker exec -it 容器实例id /bin/bashmysql -uroot -pcreate database db2021;use db2021;CREATE TABLE `t_user` ( `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;, `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;, `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;; 测试通过 Compose常用命令 123456789101112131415161718Compose常用命令docker-compose -h # 查看帮助docker-compose up # 启动所有docker-compose服务docker-compose up -d # 启动所有docker-compose服务并后台运行docker-compose down # 停止并删除容器、网络、卷、镜像。docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bashdocker-compose ps # 展示当前docker-compose编排过的运行的所有容器docker-compose top # 展示当前docker-compose编排过的容器进程 docker-compose logs yml里面的服务id # 查看容器输出日志dokcer-compose config # 检查配置dokcer-compose config -q # 检查配置，有问题才有输出docker-compose restart # 重启服务docker-compose start # 启动服务docker-compose stop # 停止服务新版本统一使用 docker compose，没有中间一个杠 关停 6、Docker轻量级可视化工具Portainer6.1、是什么Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。 6.2、安装6.2.1、官网https://www.portainer.io/ Install Portainer CE with Docker on Linux - Portainer Documentation 6.2.2、步骤docker命令安装： 1docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 新版本： 12docker volume create portainer_datadocker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest –restart&#x3D;always 即类似开机自启动，docker启动或者重新启动就会跟着启动 第一次登录需创建admin，访问地址：ip:9000 或https://ip:9443 设置admin用户和密码后首次登陆 选择local选项卡后本地docker详细信息展示 上一步的图形展示，能想得起对应命令吗？ 7、Docker容器监控之CAdvisor+InfluxDB+Granfana7.1、原生命令 docker stats命令的结果 通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。 但是， docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能 7.2、是什么容器监控3剑客： 一句话 CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表 CAdvisor InfluxDB Granfana 总结 7.3、compose容器编排，一套带走新建目录 新建3件套组合的docker-compose.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051version: &#x27;3.1&#x27; volumes: grafana_data: &#123;&#125; services: influxdb: image: tutum/influxdb:0.9 restart: always environment: - PRE_CREATE_DB=cadvisor ports: - &quot;8083:8083&quot; - &quot;8086:8086&quot; volumes: - ./data/influxdb:/data cadvisor: image: google/cadvisor links: - influxdb:influxsrv command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086 restart: always ports: - &quot;8080:8080&quot; volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro grafana: user: &quot;104&quot; image: grafana/grafana #user: &quot;104&quot; restart: always links: - influxdb:influxsrv ports: - &quot;3000:3000&quot; volumes: - grafana_data:/var/lib/grafana environment: - HTTP_USER=admin - HTTP_PASS=admin - INFLUXDB_HOST=influxsrv - INFLUXDB_PORT=8086 - INFLUXDB_NAME=cadvisor - INFLUXDB_USER=root - INFLUXDB_PASS=root 启动docker-compose文件: docker compose up 查看三个服务容器是否启动: 测试: 浏览cAdvisor收集服务，http://ip:8080/ 第一次访问慢，请稍等 cadvisor也有基础的图形展现功能，这里主要用它来作数据采集 浏览influxdb存储服务，http://ip:8083/ 浏览grafana展现服务，http://ip:3000 ip+3000端口的方式访问,默认帐户密码（admin&#x2F;admin） 配置步骤: 配置数据源 选择influxdb数据源 配置细节 配置面板panel 到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了 8、最终总结进阶篇：k8s","tags":"docker"},{"title":"Cookie","url":"/2023/10/12/Cookie/","text":"Cookie1、Cookie1、什么是Cookie？ 123451、Cookie翻译过来就是饼干的意思。2、Cookiw是服务器通知客户端保存键值对的一种技术3、客户端有了Cookie后，每次请求都发送给服务器4、每个Cookie的大小不超过4kb5、保存在客户端 2、如何创建Cookie？ 1234567891011121314```![image-20220531165936796](typora图片资源/image-20220531165936796.png)&lt;!-- more --&gt;3、服务器如何获取Cookie？服务器获取客户端的Cookie只需要一行代码：req.getCookies();返回Cookies[]4、Cookie值的修改 方案一：1、先创建一个要修改的同名的Cookie对象2、在构造器中同时赋予新的Cookie值3、调用response.addCookie(Cookie); 12345678910```java// 方案一：// 1、先创建一个要修改的同名的Cookie对象// 2、在构造器中同时赋予新的Cookie值 Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newvalue&quot;);// 3、调用response.addCookie(Cookie);通知客户端，保存修改 resp.addCookie(cookie); resp.getWriter().write(&quot;key1的cookie值修改成功&quot;); 1234方案二：1、先查找需要修改的Cookie对象2、调用setValue()方法赋予新的值3、调用response.addCookie()通知客户端保存修改 5、Cookie生命控制 12345Cookie的生命控制指的是如何管理Cookie什么时候被销毁（删除）setMaxage(int x)x为正数：表示在指定的秒数后过期x为负数：表示浏览器一关，Cookie就会被删除（默认值是-1）x为0：表示马上删除Cookie 6、免用户名登录 SessionSession会话1、什么是Session会话？ 123451、Session就是一个接口。2、Session就是会话，它是用来维护一个客户端和服务器之间关联的一种技术3、每个客户端都有自己一个Session会话。4、Session会话中，我们经常用来保存用户登录后的信息。5、保存在服务器端 2、如何创建Session和获取（id号，是否为新） 1234567891、如何创建和获取Session，它们的API是一样的。request.getSession()*第一次调用是：创建Session会话*之后调用都是：获取前面创建好的Session会话对象2、isNew();判断到底是不是刚创建出来的（新的）true 表示刚创建false 表示获取之前创建的3、每个会话都有一个身份证号，也就是id值，而且这个id值是唯一的getId()得到Session会话的id值 3、Session域数据的存取 1234567891011121314151617181920212223/** * 往session中保存数据 * @param req * @param resp * @throws ServletException * @throws IOException */protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getSession().setAttribute(&quot;name&quot;,&quot;lxg&quot;); resp.getWriter().write(&quot;保存成功&quot;);&#125;/** * 往session中获取数据 * @param req * @param resp * @throws ServletException * @throws IOException */protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String name = (String) req.getSession().getAttribute(&quot;name&quot;); resp.getWriter().write(&quot;name:&quot;+name);&#125; 4、Session生命周期控制 1234567891011121314151617181920211、public void setMaxInactiveInterval(int interval);设置Session的超时时间（以秒为单位），超过指定时长，Session就会被销毁 值为正数，设置Session的超时时长 负数表示要不超时（很少使用）2、public int getMaxInactiveInteval()获取Session的超时时长3、Session的默认超时时长是多少？protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取session的默认生命周期 int maxInactiveInterval = req.getSession().getMaxInactiveInterval(); resp.getWriter().write(&quot;默认生命周期:&quot;+maxInactiveInterval); &#125;1800秒因为Tomcat服务器的配置文件web.xml中默认以下的配置，就表示当前Tomcat服务器下所有的Session的超时配置默认时长是30分钟 &lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt; &lt;/session-config&gt; 4、如果说希望你的web工程，默认的Session的超时时长为其他时长，你可以在web.xml配置文件中去修改 5、如果只想修改个别的Session的超时时长就得使用上面的方法 session. setMaxInactiveInterval(int interval);单独设置超时时长。 1234567protected void life3(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //先获取Session对象 HttpSession session = req.getSession(); //设置session的生命周期 session.setMaxInactiveInterval(3); resp.getWriter().write(&quot;设置生命周期成功&quot;);&#125; 123456786、public void invalidate()让当前的Session马上失效 protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取session HttpSession session = req.getSession(); //删除session session.invalidate(); resp.getWriter().write(&quot;删除session成功&quot;); &#125; 5、浏览器和Session之间关联的技术内幕 1Session技术，底层其实是基于Cookie技术来实现的。","tags":"cookie-session"},{"title":"Axios","url":"/2023/10/12/Axios/","text":"AxiosAxios是Ajax的一个框架，简化Ajax操作 Axios执行Ajax操作的步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591、添加并引入axios的js文件2-1、客户端向服务器端异步发送普通参数值 -基本格式：axios().then().catch() -示例： axios(&#123; method:&quot;POST&quot;, url:&quot;axios01.do&quot;, params:&#123; uname:vue.uname, pwd:vue.pwd &#125; &#125;) .then(function (value)&#123; //成功时响应执行的回调 //value.data可以获取到服务器响应内容 console.log(value); &#125;) .catch(function (reason)&#123;//有异常时执行的回调 //reason.response.data可以获取到响应的内容 //reason.message/reason.stack可以获取到错误的信息 console.log(reason); &#125;);2-2、客户端向服务器发送JSON格式的数据 JSON是一种数据格式 XML也是一种数据格式 XML格式：表示两个学生信息 &lt;students&gt; &lt;student sid=&quot;s001&quot;&gt; &lt;sname&gt;lxg&lt;/sname&gt; &lt;age&gt;18&lt;/age&gt; &lt;/student&gt; &lt;student sid=&quot;s002&quot;&gt; &lt;sname&gt;zs&lt;/sname&gt; &lt;age&gt;19&lt;/age&gt; &lt;/student&gt; &lt;/students&gt; 而JSON格式如下： [&#123;sid:&quot;s001&quot;,sname:&quot;lxg&quot;,age:18&#125;,&#123;sid:&quot;s002&quot;,sname:&quot;zs&quot;,age:19&#125;] JSON表达数据更简洁，更能节约网络带宽 客户端发送JSON格式的数据给服务器端 1、客户端中params需要修改成：data： 2、服务器获取参数值不再是req.getParameter() 变成： StringBuffer stringBuffer = new StringBuffer(&quot;&quot;); BufferedReader bufferedReader = req.getReader(); String str = null; while((str=bufferedReader.readLine())!=null)&#123; stringBuffer.append(str); &#125; str =stringBuffer.toString(); System.out.println(str); 3、我们会发送str的内容如下： &#123;&quot;uname&quot;:&quot;lin&quot;,&quot;pwd&quot;:&quot;ok&quot;&#125; 服务器端给客户端响应json格式的字符串，然后客户端需要将字符串转化成json Object 第十二章 Axios Ajax | 代码重工 (gitee.io)","tags":"axios"},{"title":"Ajax","url":"/2023/10/12/Ajax/","text":"Ajax1、原生Ajax1、Ajax简介Ajax全称为Asynchronous JavaScript And XML ，就是异步的JS和XML通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据，AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式 2、XML简介XML可扩展标记语言。 XML被设计用来传输和存储数据。 XML和HTML类似，不同的是HTML中都是预定义标签，而XML没有预定义标签，全是自定义标签，用来表示一些数据。 12345678比如说我有一个学生数据：name=&quot;孙悟空&quot;,age=18,gender=&quot;男&quot;;用XML表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 现在已经被JSON取代了 12用JSON表示：&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; 3、AJAX的特点1、优点12（1）可以无需刷新页面与服务器端进行通信（2）运行你根据用户事件来更新部分页面内容 2、缺点123（1）没有浏览历史，不能回退（2）存在跨域问题（同源）（3）SEO不友好 4、AJAX的使用1、HTTPHTTP（hypertext transport protocol）协议【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则 1、什么是Http协议 12341、什么是协议？协议就是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议2、所谓Http协议就是指客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫Http协议3、Http协议中的数据又叫报文。 2、请求的Http协议格式 1231、客户端给服务器发送数据叫请求2、服务器给客户端回传数据叫响应3、请求又分GET请求和POST请求两种。 12345671、GET请求（1）请求行*请求的方式 GET*请求的资源路径[+?+请求参数]*请求的协议的版本号 HTTP/1.1（2）请求头*key:value 组成，不同的键值对，表示不同的含义 123456789102、POST请求（1）请求行*请求的方式 POST*请求的资源路径[+?+请求参数]*请求的协议的版本号（2）请求头*key:value 不同的请求头，有不同的含义空行（3）请求体就是发送给服务器的数据 3、常用请求头的说明 1234Accept：表示客户端能够接受的数据类型Accept—Language：表示客户端可以接收的语言类型User-Agent：表示客户端浏览器的信息Host：表示请求时的服务器ip和端口号 4、哪些是GET请求和POST请求？ 12345678GET请求有哪些？1、form标签 method=get2、a标签3、link标签引入css4、Script 标签引入js文件5、img标签引入图片6、iframe标签引入html页面7、在浏览器地址栏中输入地址后回车 12POST请求有哪些？1、form标签 method=post 5、响应的HTTP协议格式 1234567891、响应行*响应的协议和版本号*响应状态码*响应状态描述符2、响应头*key:value 不同的响应头，有不同的含义空行3、响应体*就是回传给客户端的数据 6、常用的响应码说明 123456200 表示请求成功302 表示请求重定向403 表示禁止401 表示未授权404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）500 表示服务器已经收到请求，但是服务器内部错误（代码错误） 7、MIME类型说明 MIME是HTTP协议中的数据类型 MIME的英文全称是“Multipurpose Internet Mall Extensions”多功能Internet邮件扩充服务。MIME类型的格式是“大类型&#x2F;小类型”，并与一种文件的扩展名相对应。 常见的MIME类型： 文件 MIME类型 超文本标记语言文本 .html htm text&#x2F;html 普通文本 .txt text&#x2F;plain RTF文本 .rtf application&#x2F;trf GIF图形 .gif image&#x2F;gif JPEG图形 .jpeg .jpg image&#x2F;jpeg au声音文件 .au audio&#x2F;base MIDI音乐文件 mid,.midi audio&#x2F;midi,audio&#x2F;x-midi RealAudio音乐文件 .ra .ram audio&#x2F;x-pn-realaudio MPEG文件 .mpg .mpeg video&#x2F;mpeg AVI文件 .avi video&#x2F;x-msvideo GZIP文件 .gz application&#x2F;x-gzip TAR文件 .tar application&#x2F;x-tar 2、express框架写一个简易的服务器 12345678910111213141516171819// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/&quot;,(request,response)=&gt;&#123; // 设置响应 response.send(&#x27;HELLO EXPRESS&#x27;)&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 3、get请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX GET 请求&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px #90b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取button元素 const btn = document.getElementsByTagName(&#x27;button&#x27;)[0]; const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 btn.onclick=function()&#123; // console.log(&#x27;test&#x27;); // 1、创建对象 const xhr = new XMLHttpRequest(); // 2、初始化 设置请求方法和url xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/server?a=100&amp;b=200&amp;c=300&#x27;); // 3、发送 xhr.send(); // 4、事件绑定，处理服务端返回的结果 /* on when 当.....时候 readystate 是xhr对象中的属性，表示状态0,1,2,3,4 0--表示未初始化 1--open方法调用完毕 2--send方法调用完毕 3--服务端返回部分结果（正在解析） 4--服务端返回了全部结果（解析完成，可以在客户端使用） change 改变 */ xhr.onreadystatechange = function()&#123; // 判断(服务端返回了所有的结果) if(xhr.readyState===4)&#123; // 判断响应状态码 200 404 403 401 500 // 2xx 成功 if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt;=300)&#123; // 处理结果 行 头 空行 体 // 1、响应行 /* console.log(xhr.status);//状态码 console.log(xhr.statusText);//状态字符串 console.log(xhr.getAllResponseHeaders());//所有响应头 console.log(xhr.response);//响应体 */ // 设置result文本 result.innerHTML = xhr.response; &#125;else&#123; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 4、post请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX POSt 请求&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px #903; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取元素对象 const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 result.addEventListener(&#x27;mouseover&#x27;,()=&gt;&#123; // console.log(&#x27;test&#x27;); // 1、创建对象 const xhr = new XMLHttpRequest(); // 2、初始化请求方式 和url xhr.open(&#x27;POST&#x27;,&#x27;http://localhost:8000/server&#x27;); // 设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;); xhr.setRequestHeader(&#x27;name&#x27;,&#x27;xiaolin&#x27;); // 3、发送 // xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;); xhr.send(&#x27;1111&#x27;); // 4、事件绑定 xhr.onreadystatechange =function()&#123; // 判断 if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; // 处理服务端返回结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 5、json数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;JSON 响应&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px #89b; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; /获取元素对象 / const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 window.onkeydown = function()&#123; // console.log(&#x27;test&#x27;); // 1、创建对象 const xhr = new XMLHttpRequest(); // 设置响应体数据的类型 xhr.responseType = &#x27;json&#x27;; // 2、初始化请求方式 和url xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/json-server&#x27;); // 3、发送 xhr.send(); // 4、事件绑定 xhr.onreadystatechange =function()&#123; // 判断 if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; // 处理服务端返回结果 // console.log(xhr.response); // result.innerHTML = xhr.response; // 手动对数据进行转换 /* let data = JSON.parse(xhr.response); console.log(data); result.innerHTML = &quot;姓名：&quot;+data.name; */ // 自动转换 result.innerHTML=&quot;姓名：&quot;+xhr.response.name; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 7、服务器js代码重新启动问题下载nodemon 1npm install -g nodemon 运行 1nodemon server.js 若遇到禁止运行脚本，请以管理员身份打开vscode 在终端运行 1set-ExecutionPolicy RemoteSigned 8、ie浏览器缓存问题1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;IE缓存问题&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px #258; &#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; /获取元素对象 / const btn = document.getElementsByTagName(&#x27;button&#x27;)[0]; const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; // console.log(&#x27;test&#x27;); // 1、创建对象 const xhr = new XMLHttpRequest(); // 2、初始化请求方式 和url xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/ie?t=&#x27;+Date.now()); // 3、发送 xhr.send(); // 4、事件绑定 xhr.onreadystatechange =function()&#123; // 判断 if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; result.innerHTML=xhr.response; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 9、请求超时与网络异常1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;请求超时与网络异常&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #result&#123; width: 200px; height: 100px; border: solid 1px #90b; &#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const btn = document.getElementsByTagName(&#x27;button&#x27;)[0]; const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 btn.addEventListener(&#x27;click&#x27;,()=&gt;&#123; const xhr = new XMLHttpRequest(); // 超时设置 xhr.timeout = 2000; // 超时回调 xhr.ontimeout=()=&gt;&#123; alert(&#x27;网络异常，请稍后重试！&#x27;); &#125; // 网络异常回调 xhr.onerror = ()=&gt;&#123; alert(&quot;你的网络似乎出现了问题，请检查网络状态！&quot;); &#125; xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange =function()&#123; if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; result.innerHTML=xhr.response; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.get(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 10、取消请求12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;IE缓存问题&lt;/title&gt;&lt;/head&gt;&lt;style&gt;&lt;/style&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;button&gt;点击取消请求&lt;/button&gt; &lt;script&gt; const btns = document.getElementsByTagName(&#x27;button&#x27;); // 绑定事件 let xhr = null; btns[0].addEventListener(&#x27;click&#x27;,()=&gt;&#123; xhr = new XMLHttpRequest(); xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange =function()&#123; if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; alert(xhr.response); &#125; &#125; &#125; &#125;); // abort btns[1].addEventListener(&#x27;click&#x27;,()=&gt;&#123; xhr.abort(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11、重复请求问题123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;重复请求问题&lt;/title&gt;&lt;/head&gt;&lt;style&gt;&lt;/style&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;script&gt; const btns = document.getElementsByTagName(&#x27;button&#x27;); let xhr = null; // 标识变量 let isSending = false;//是否正在发送请求 // 绑定事件 btns[0].addEventListener(&#x27;click&#x27;,()=&gt;&#123; if(isSending) xhr.abort();//如果正在发送，则取消该请求，创建一个新的请求 xhr = new XMLHttpRequest(); // 修改标识变量值 isSending = true; xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange =function()&#123; if(xhr.readyState===4)&#123; // 修改标识变量 isSending = false; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; alert(xhr.response); &#125; &#125; &#125; &#125;); // abort btns[1].addEventListener(&#x27;click&#x27;,()=&gt;&#123; xhr.abort(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、jQuery中的AJAX1、jQuery发送AJAX请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;jQuery 发送 AJAX 请求&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; &gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;page-header&quot;&gt;jQuery发送AJAX请求&lt;/h2&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;GET&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;POST&lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt;通用型方法ajax&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $(&#x27;button&#x27;).eq(0).click(function()&#123; $.get(&#x27;http://localhost:8000/jQuery-server&#x27;,&#123;a:100,b:200&#125;,(data)=&gt;&#123; console.log(data); &#125;,&#x27;json&#x27;) &#125;) $(&#x27;button&#x27;).eq(1).click(function()&#123; $.post(&#x27;http://localhost:8000/jQuery-server&#x27;,&#123;a:100,b:200&#125;,(data)=&gt;&#123; console.log(data); &#125;) &#125;) $(&#x27;button&#x27;).eq(2).click(function()&#123; $.ajax(&#123; url: &#x27;http://localhost:8000/jQuery-server&#x27;, // 参数 data:&#123;a:100,b:200&#125;, // 请求类型 type:&#x27;GET&#x27;, // 响应体结果 dataType:&#x27;json&#x27;, // 成功回调 success:function(data)&#123; console.log(data); &#125;, // 超时时间 timeout:2000, // 失败的回调 error:function()&#123; console.log(&#x27;出错了&#x27;); &#125;, // 头信息 headers:&#123; c:300, d:400 &#125; &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 3、Axios中的AJAX1、axios发送ajax请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;axios 发送 AJAX 请求&lt;/title&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;GET&lt;/button&gt; &lt;button&gt;POST&lt;/button&gt; &lt;button&gt;AJAX&lt;/button&gt; &lt;script&gt; const btns = document.querySelectorAll(&#x27;button&#x27;); // 配置baseURL axios.defaults.baseURL = &#x27;http://localhost:8000&#x27;; btns[0].onclick = function()&#123; // GET请求 axios.get(&#x27;/axios-server&#x27;,&#123; // url参数 params:&#123; id:100, vip:999, &#125;, // 请求头信息 headers:&#123; name:&#x27;xiaolin&#x27;, age:21 &#125; &#125;).then(value=&gt;&#123; console.log(value); &#125;); &#125; btns[1].onclick = function()&#123; // GET请求 axios.post(&#x27;/axios-server&#x27;,&#123; username:&#x27;admin&#x27;, password:&#x27;admin&#x27; &#125;,&#123; // url参数 params:&#123; id:100, vip:999, &#125;, // 请求头信息 headers:&#123; class:&#x27;20ruaner&#x27;, sno:20251104260 &#125; &#125;).then(value=&gt;&#123; console.log(value); &#125;); &#125; btns[2].onclick = function()&#123; axios(&#123; // 请求方法 method : &#x27;POST&#x27;, url:&#x27;/axios-server&#x27;, // url参数 params:&#123; vip:10, level:30 &#125;, // 头信息 headers:&#123; a:100, b:200 &#125;, // 请求体参数 data:&#123; username:&#x27;admin&#x27;, password:&#x27;admin&#x27; &#125; &#125;).then((response)=&gt;&#123; console.log(response); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 4、fetch中的AJAX1、fetch发送ajax请求123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;fetch发送 ajax请求&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;AJAX请求&lt;/button&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;); btn.onclick = function()&#123; fetch(&#x27;http://localhost:8000/fetch-server?vip=10&#x27;,&#123; method:&#x27;POSt&#x27;, headers:&#123; name:&#x27;xiaolin&#x27; &#125;, // 请求体 body:&#x27;username=admin&amp;password=admin&#x27; &#125;).then(response=&gt;&#123; // return response.text(); return response.json(); &#125;).then(response=&gt;&#123; console.log(response); &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// fetch服务app.all(&quot;/fetch-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 5、跨域1、同源策略同源策略（Same-Origin Policy）最早由Netscape公司提出，是浏览器的一种安全策略。 同源：协议、域名、端口号、必须完全相同 违背同源策略就是跨域 2、如何解决跨域1、JSONP12345678910111、JSONP是什么？ JSONP（JSON with Padding），是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来的，只支持get请求2、JSONP怎么工作的？ 在网页有一些标签天生具有跨域的能力，比如：img link iframe script JSONP就是利用script标签的跨域能力来发送请求的3、JSON的使用 1、动态的创建一个script标签 var script = document.createElement(&quot;script&quot;); 2、设置script的src，设置回调函数 script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;; 原理1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;原理演示&lt;/title&gt; &lt;style&gt; #result&#123; width: 300px; height: 100px; border: solid 1px #78a; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; // 处理数据 function handle(data)&#123; // 获取result元素 const result = document.getElementById(&#x27;result&#x27;); result.innerHTML = data.name; &#125; &lt;/script&gt; &lt;!-- &lt;script src=&quot;http://127.0.0.1:5500/%E4%BB%A3%E7%A0%81/%E8%B7%A8%E5%9F%9F/2-JSONP/js/app.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;http://localhost:8000/jsonp-server&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.js 12345678910111213141516const data=&#123; name:&#x27;xiaolin&#x27;&#125;// console.log(data);// 处理数据/** function handle(data)&#123; // 获取result元素 const result = document.getElementById(&#x27;result&#x27;); result.innerHTML = data.name;&#125;**/handle(data); server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// fetch服务app.all(&quot;/fetch-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// jsonp服务app.all(&quot;/jsonp-server&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 案例123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; // 获取input元素 const input = document.getElementById(&#x27;username&#x27;); const p = document.querySelector(&#x27;p&#x27;); // 声明handle函数 function handle(data)&#123; input.style.border = &#x27;solid 1px #f00&#x27; // 修改p标签的提示文本 p.innerHTML = data.msg; &#125; // 绑定事件 input.onblur = function()&#123; // 获取用户输入值 let username = this.value; // 向服务端发送请求，检查用户名是否存在 // 1、创建一个script标签 const script = document.createElement(&#x27;script&#x27;); // 2、设置标签的src属性 script.src = &quot;http://localhost:8000/check-username&quot;; // 3、将srcipt插入文本中 document.body.appendChild(script) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// fetch服务app.all(&quot;/fetch-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// jsonp服务app.all(&quot;/jsonp-server&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 用户名检查是否存在app.all(&quot;/check-username&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; exist:1, msg:&#x27;用户名已经存在&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) jQuery发送jsonp请求1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;jquery-jsonp&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #result&#123; width: 300px; height: 100px; border: solid 1px #089; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送jsonp请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; $(&#x27;button&#x27;).eq(0).click(function()&#123; $.getJSON(&#x27;http://localhost:8000/jQuery-jsonp?callback=?&#x27;,function(data)&#123; console.log(data); $(&#x27;#result&#x27;).html(` 姓名:$&#123;data.name&#125;&lt;br/&gt; 学号:$&#123;data.sno&#125; `); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// fetch服务app.all(&quot;/fetch-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// jsonp服务app.all(&quot;/jsonp-server&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 用户名检查是否存在app.all(&quot;/check-username&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; exist:1, msg:&#x27;用户名已经存在&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 用户名检查是否存在app.all(&quot;/jQuery-jsonp&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27;, sno:20251104260 &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 接收callback参数 let cb = request.query.callback; // 返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;) 2、CORS1234567891、CORS是什么？ CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS是官方的跨域解法方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组HTTP首部字段，运行服务器声明哪些源站通过浏览器有权限访问哪些资源。2、CORS如何工作？ CORS是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行3、CORS的使用 主要是服务器端的设置： router.get(&quot;/testAJAX&quot;,function(req,res)&#123; &#125;) 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CORS&lt;/title&gt; &lt;style&gt; #result&#123; width: 200px; height: 100px; border: 1px solid #90b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;) btn.onclick=function()&#123; const xhr = new XMLHttpRequest(); xhr.open(&#x27;GET&#x27;,&#x27;http://localhost:8000/cors-server&#x27;); xhr.send(); xhr.onreadystatechange =function()&#123; if(xhr.readyState===4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; console.log(xhr.response); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// 引入expressconst express = require(&#x27;express&#x27;);// 创建应用对象// request是对请求报文的封装// response是对响应报文的封装const app = express();// 创建路由规则app.get(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO AJAX&#x27;);&#125;);// 可以接收任意类型的请求app.all(&quot;/server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);// json响应app.all(&quot;/json-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 响应一个数据 const data = &#123; name:&#x27;xiaolin&#x27; &#125;; // 将对象转换为json字符串 let str = JSON.stringify(data); // 设置响应 response.send(str);&#125;);// 针对ie缓存app.get(&quot;/ie&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // 设置响应 response.send(&#x27;HELLO IE&#x27;);&#125;);// 延时响应app.all(&quot;/delay&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) setTimeout(()=&gt;&#123; // 设置响应体 response.send(&#x27;延时响应&#x27;); &#125;,3000)&#125;);// jQuery服务app.all(&quot;/jQuery-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// axios服务app.all(&quot;/axios-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// fetch服务app.all(&quot;/fetch-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&quot;*&quot;) // 设置响应体 // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123;name:&#x27;xiaolin&#x27;&#125; response.send(JSON.stringify(data));&#125;);// jsonp服务app.all(&quot;/jsonp-server&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// 用户名检查是否存在app.all(&quot;/check-username&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; exist:1, msg:&#x27;用户名已经存在&#x27; &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);// jQuery-jsonpapp.all(&quot;/jQuery-jsonp&quot;,(request,response)=&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data=&#123; name:&#x27;xiaolin&#x27;, sno:20251104260 &#125;; // 将数据转换为字符串 let str = JSON.stringify(data); // 接收callback参数 let cb = request.query.callback; // 返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;);//CORSapp.all(&quot;/cors-server&quot;,(request,response)=&gt;&#123; // 设置响应头 设置运行跨域 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:5500&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Method&quot;,&quot;*&quot;); // 返回结果 response.send(&quot;Hello CORS&quot;);&#125;);// 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动，8000端口监听中.....&quot;);&#125;)","tags":"ajax"},{"title":"JavaScript高级篇","url":"/2022/11/02/javaScript高级/","text":"# js高级 [Toc] 一、基础总结深入1、数据类型112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_数据类型&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 分类 基本（值）类型 -String:任意字符串 -Number：任意数字 -boolean：true false -undefined：undefined -null：null 对象（引用）类型 -Object：任意对象 -Fucition：一种特别的对象（可以执行） -Array:一种特别的对象（数值下标,内部数据是有序的）2. 判断 1、typeof -可以判断undefined，数值,字符串，布尔值,function -不能判断null和Object，Object和array 2、instanceof -判断对象的具体类型 3、=== -可以判断undefined,null --&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 1、基本 var a; console.log(a,typeof a,typeof a===&#x27;undefined&#x27;,a===undefined);//undefined &#x27;undefined&#x27; true true console.log(undefined===&#x27;undefined&#x27;);//false a=3; console.log(typeof a===&#x27;number&#x27; );//true a=&#x27;xiaolin&#x27;; console.log(typeof a===&#x27;string&#x27;);//true a=true; console.log(typeof a===&#x27;boolean&#x27;);//true a=null; console.log(typeof a,a===null);//object,true console.log(&#x27;=====================&#x27;); var b1=&#123; b2:[1,&quot;abc&quot;,console.log], b3:function()&#123; console.log(&#x27;b3&#x27;); return function()&#123; return &#x27;xiaolin&#x27;; &#125; &#125; &#125;; console.log(b1 instanceof Object,b1 instanceof Array);//true false console.log(b1.b2 instanceof Array,b1.b2 instanceof Object);//true true console.log(b1.b3 instanceof Function,b1.b3 instanceof Object);//true true console.log(typeof b1.b2);//object console.log(typeof b1.b3,typeof b1.b3===&#x27;function&#x27;);// &#x27;fucction&#x27; true console.log(typeof b1.b2[2]===&#x27;function&#x27;);//true b1.b2[2](4);//4 console.log(b1.b3()());//xiaolin b1.b3();//b3 /* var obj = &#123; name:&quot;Tom&quot;, age:18 &#125;; function test()&#123; var a=3; &#125; var arr=[3,&quot;abc&quot;]; */ // alert(arr[1]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、数据类型2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_相关问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. undefined与null的区别? -undefined代表定义了未赋值 -null代表定义并赋值了，只是值为null2. 什么时候给变量赋值为null呢? -初始赋值，表明将要赋值为对象 -结束前赋值为null，让其成为垃圾对象（被垃圾回收器回收）3. 严格区别变量类型与数据类型? -数据的类型 1、基本类型 2、对象类型 -变量的类型(变量内存值的类型) -基本类型：保存的就是基本类型的数据 -引用类型：保存的是地址值--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //实例：实例对象 // 类型：类型对象 function Person(name,age)&#123; //构造函数 类型 this.name=name; this.age=age; &#125; var p = new Person(&#x27;tom&#x27;,18);//根据类型创建的实例对象 // Person(&#x27;jack&#x27;,12);//合法但不合理 //1. undefined与null的区别? var a; console.log(a);//undefined a=null; console.log(a);//null var b=null;//初始赋值为null，表明将要赋值为对象 //确定对象就赋值 b = [&#x27;xiaolin&#x27;,18]; // 最后 b=null;//切断指向对象的线，后会成为垃圾对象被回收期自动回收 // b=2; var c=function()&#123; &#125;; console.log(typeof c);//&#x27;function&#x27;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、数据、变量和内存1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_数据_变量_内存&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 什么是数据? -存储在内存中代表特定信息的东西，本质上是0101... -数据的特点：可传递，可运算 -一切皆数据 -内存中所有操作的目标：数据 -算数运算 -逻辑运算 -赋值运算 -运行函数2. 什么是内存? -内存条通电以后产生的可存储数据的空间（临时的） -内存产生和死亡：内存条（电路板）==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失 -一块小内存的2个数据 -内存存储的数据 -地址值 -内存分类 -栈内存：全局变量和局部变量 -堆内存：对象3. 什么是变量? -可变化的量，由变量名和变量值组成 -每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据4. 内存,数据, 变量三者之间的关系 -内存是用来存储数据的空间 -变量是内存的标识--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var age=18; var a =2; var obj = &#123; name:&#x27;tom&#x27; &#125;; console.log(obj.name); function fn()&#123; var obj =&#123;name:&#x27;tom&#x27;&#125;; &#125; var a =3; var b=a+2;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、数据、变量和内存21234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;关于赋值和内存的问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据，保存的就是这个基本数据 xxx是对象，保存的就是对象的地址值 xxx是变量，保存的xxx的内存内容（可能是基本数据，也可能是地址值） --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a = 3; var a =function()&#123; &#125;; var b=&quot;abc&quot;; a=b; b=&#123;&#125; a=b&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、数据、变量和内存312345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_关于引用变量赋值问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--关于引用变量赋值问题 多个引用变量指向同一个对象，通过其中一个变量修改对象内部数据 其他所有变量看到的是修改之后的数据 两个引用变量指向同一个对象，现在让其中一个引用变量指向另一个对象，另一个引用 变量仍然指向原来的对象,此时两个引用变量互不相关--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj1=&#123;name:&#x27;tom&#x27;&#125;; var obj2=obj1; obj1.name=&#x27;jack&#x27;; console.log(obj2.name);//&#x27;jack&#x27; function fun(obj)&#123; obj.name=&#x27;bob&#x27;; &#125; fun(obj1); console.log(obj2.name);//bob var a = &#123;age:12&#125;; var b = a; a = &#123;name:&#x27;bob&#x27;,age:13&#125;;//a断开原来的连接，指向新创建的一个对象了 console.log(b);//指向原来a指向的对象 b.age=14; console.log(b.age,a.name,a.age);//14 bob 13 function fun2(obj)&#123; obj = &#123;age:15&#125;; &#125; fun2(a); console.log(a.age);//13&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、数据变量和内存412345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_关于数据传递问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1：都是值（基本数据/地址值）传递 理解2：可能是值传递，也可能是引用传递（地址值）--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a=3; function fn(a)&#123; a=a+1; &#125; fn(a); console.log(a);//3 function fn2(obj)&#123; console.log(obj.name); &#125; var obj=&#123;name:&#x27;tom&#x27;&#125;; fn2(obj);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7、数据、变量和内存512345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_内存管理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--问题: JS引擎如何管理内存?1. 内存生命周期 -分配小内存空间，得到它的使用权 -存储数据，可以反复进行操作 -释放当前的小内存空间2. 释放内存 -局部变量：函数执行完自动释放 -对象：成为垃圾对象==&gt;垃圾回收器自动回收--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a=3; var obj = &#123;&#125;; obj=null; function fn()&#123; var b =&#123;&#125;; &#125; fn();//执行完，b自动释放，b所指向的对象是在后面的某个时刻由垃圾回收器回收的&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8、对象1123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 什么是对象? -多个数据的封装体 -用来保存多个数据的容器 -一个对象代表现实中的一个事物2. 为什么要用对象? -统一管理多个数据3. 对象的组成 -属性：属性名（字符串）和属性值（任意类型）组成 -方法：一种特别的属性（属性值是函数）4. 如何访问对象内部数据? -对象.属性名：编码简单，有时不能用 -对象[&#x27;属性名&#x27;]：编码麻烦，但是里面可以放变量，通用--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var tom = &#123; name:&#x27;tom&#x27;, age:18, setName:function(name)&#123; this.name=name; &#125;, setAge:function(age)&#123; this.age=age; &#125; &#125;;/* var name=&#x27;tom&#x27;; var age = 18; */ tom.setName(&#x27;bob&#x27;); tom[&#x27;setAge&#x27;](23); console.log(tom.name,tom[&#x27;age&#x27;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9、对象21234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_相关问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--问题: 什么时候必须使用[&#x27;属性名&#x27;]的方式? 1、属性名包含特殊字符： - 空格 2、属性名不确定--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var p =&#123;&#125;; // 1、给p对象添加一个属性：content-type:text/json // p.content-type:&#x27;text/json&#x27;; p[&#x27;content-type&#x27;]=&#x27;text/json&#x27;; console.log(p[&#x27;content-type&#x27;]); // 2、属性名不确定 var propName = &#x27;myAge&#x27;; var value = 18; // p.propName = value;//这样存储的属性名是propName // console.log(p); p[propName]=value; console.log(p[propName]);//18&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10、函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_函数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 什么是函数? -实现特定功能的n条语句的封装体 -只有函数是可以执行的，其他类型的数据不能执行2. 为什么要用函数? -提高代码复用 -便于阅读交流 3. 如何定义函数? -函数声明 -表达式4. 如何调用(执行)函数? -test():直接调用 -obj.test():通过对象调用 -new test():new调用 -test.call/apply(obj);//临时让test成为obj的方法被调用--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 编写程序实现以下功能需求: 1. 根据年龄输出对应的信息 2. 如果小于18, 输出: 未成年, 再等等! 3. 如果大于60, 输出: 算了吧! 4. 其它, 输出: 刚好! */ function showInfo(age)&#123; if(age&lt;18)&#123; console.log(&quot;未成年，再等等！&quot;); &#125;else if(age&gt;60)&#123; console.log(&quot;算了吧&quot;); &#125;else&#123; console.log(&#x27;刚好&#x27;); &#125; &#125; showInfo(17); showInfo(20); showInfo(65); function fn1()&#123;//函数声明 console.log(&#x27;fn1()&#x27;); &#125; var fn2 = function()&#123; //表达式 console.log(&#x27;fn2()&#x27;); &#125; fn1(); fn2(); var obj=&#123;&#125;; function test2()&#123; this.name =&#x27;xiaolin&#x27;; &#125; test2.call(obj);//obj.test2();//可以让一个函数成为指定任意对象的方法进行调用 console.log(obj.name);//xiaolin&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11、回调函数12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_回调函数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;测试点击事件&lt;/button&gt;&lt;!--1. 什么函数才是回调函数? -你定义的 -你没有调用 -但最终它执行了(在特殊条件或时刻)2. 常见的回调函数? -dom事件回调函数 -定时器回调函数 -ajax请求回调函数 生命周期回调函数--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn=document.getElementById(&quot;btn&quot;); btn.onclick=function()&#123;//dom事件回调函数 alert(this.innerHTML); &#125; // 定时器 // 超时定时器 // 循环定时器 setTimeout(function()&#123;//定时器回调函数 alert(&#x27;到点了&#x27;); &#125;,2000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12、IFFE立即执行函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06_IIFE&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 理解 * 全称: Immediately-Invoked Function Expression 立即执行函数2. 作用 -隐藏实现 -不会污染外部（全局）命名空间 -用它来编写js模块--&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function ()&#123; //匿名函数自调用 // console.log(&#x27;......&#x27;); var a =3; console.log(a+3); &#125;)(); var a =4; console.log(a); (function ()&#123; var a=1; function test()&#123; console.log(++a); &#125; function test2()&#123; console.log(&#x27;test2&#x27;); &#125; window.$=function()&#123; //向外暴漏一个函数 return &#123; test:test &#125; &#125; &#125;)(); console.log(typeof $()===&#x27;function&#x27;); $().test();//1、$是一个函数，2、$执行后返回的是一个对象&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 13、函数中的this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;07_函数中的this&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. this是什么? * 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window * 所有函数内部都有一个变量this * 它的值是调用函数的当前对象2. 如何确定this的值? * test(): window * p.test(): p * new test(): 新创建的对象 * p.call(obj): obj--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(color) &#123; console.log(this); this.color = color; this.getColor = function () &#123; console.log(this); return this.color; &#125;; this.setColor = function (color) &#123; console.log(this); this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yellow&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14、分号问题1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_分号问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. js一条语句的后面可以不加分号2. 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢3. 在下面2种情况下不加分号会有问题 * 小括号开头的前一条语句 * 中方括号开头的前一条语句4. 解决办法: 在行首加分号5. 强有力的例子: vue.js库6. 知乎热议: https://www.zhihu.com/question/20298345--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a = 3 ;(function () &#123; &#125;)() /* 错误理解 var a = 3(function () &#123; &#125;)(); */ var b = 4 ;[1, 3].forEach(function () &#123; &#125;) /* 错误理解 var b = 4[3].forEach(function () &#123; &#125;) */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、函数高级1、原型与原型链1、原型–prototype123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_原型(prototype)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 函数的prototype属性(图) * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) * 原型对象中有一个属性constructor, 它指向函数对象2. 给原型对象添加属性(一般都是方法) * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)--&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(Date.prototype,typeof Date.prototype);//Object function Fun()&#123; &#125; console.log(Fun.prototype);//默认指向一个object空对象（没有我们的属性） //原型对象中有一个属性constructor, 它指向函数对象 console.log(Date.prototype.construtor===Date);//true console.log(Fun.prototype.construtor===Fun);//true // 给原型对象添加了属性（一般是属性）==&gt;实例对象可以访问 Fun.prototype.test=function()&#123; console.log(&#x27;test()&#x27;); &#125; var fun = new Fun(); fun.test();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、显示原型和隐式原型123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_显式原型与隐式原型&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 每个函数function都有一个prototype，即显式原型2. 每个实例对象都有一个__proto__，可称为隐式原型3. 对象的隐式原型的值为其对应构造函数的显式原型的值4. 内存结构(图)5. 总结: * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象 * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 定义构造函数 function Fn()&#123; //内部语句：this.prototype=&#123;&#125; &#125; //1. 每个函数function都有一个prototype，即显式原型属性，，默认指向一个空的object对象 console.log(Fn.prototype); //2. 每个实例对象都有一个__proto__，可称为隐式原型 //创建实例对象 var fn = new Fn();//内部语句：fn.__proto__ = Fn.prototype; console.log(fn.__proto__); //3. 对象的隐式原型的值为其对应构造函数的显式原型的值 console.log(Fn.prototype===fn.__proto__);//true //给原型添加方法 Fn.prototype.test=function()&#123; console.log(&#x27;test()&#x27;); &#125;; //通过实例调用原型的方法 fn.test();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、原型链12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_原型链&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 原型链(图解) * 访问一个对象的属性时， * 先在自身属性中查找，找到返回 * 如果没有, 再沿着__proto__这条链向上查找, 找到返回 * 如果最终没找到, 返回undefined * 别名: 隐式原型链 * 作用: 查找对象的属性(方法)2. 构造函数/原型/实体对象的关系(图解)3. 构造函数/原型/实体对象的关系2(图解)--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // console.log(Object); // console.log(Object.prototype); console.log(Object.prototype.__proto__);//null function Fn()&#123; this.test1=function()&#123; console.log(&#x27;test1()&#x27;); &#125; &#125; console.log(Fn.prototype); Fn.prototype.test2=function()&#123; console.log(&#x27;test2()&#x27;); &#125; // console.log(Fn.prototype); var fn=new Fn(); fn.test1(); fn.test2(); console.log(fn.toString()); console.log(fn.test3);//undefined fn.test3(); /* 1、函数的显示原型指向的对象默认是空Object实例对象（但Object不满足） */ console.log(Fn.prototype instanceof Object);//true console.log(Object.prototype instanceof Object);//false console.log(Function.prototype instanceof Object);//true /* 2、所有函数都是Function的实例（包括它本身） */ console.log(Function.__proto__===Function.prototype); /* 3、Object的原型对象是原型链的尽头 */ console.log(Object.prototype.__proto__);//null &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、原型链–属性问题1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_原型链_属性问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 读取对象的属性值时: 会自动到原型链中查找2. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Fn()&#123; &#125; Fn.prototype.a =&quot;xxx&quot;; var fn1=new Fn(); console.log(fn1.a,fn1); var fn2=new Fn(); fn2.a=&#x27;yyy&#x27;;//在fn2自身定义了一个属性 console.log(fn1.a);//xxx console.log(fn2.a,fn2);//yyy function Person(name,age)&#123; this.name=name; this.age=age; &#125; Person.prototype.setName=function(name)&#123; this.name=name; &#125; var p1 = new Person(&#x27;tom&#x27;,12); p1.setName(&#x27;bob&#x27;); console.log(p1); var p2 = new Person(&#x27;jack&#x27;,12); p1.setName(&#x27;lili&#x27;); console.log(p2);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、探索instanceof12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_探索instanceof&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. instanceof是如何判断的? * 表达式: A instanceof B * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false2. Function是通过new自己产生的实例--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 案例1 */ function Foo()&#123; &#125; var f1=new Foo(); console.log(f1 instanceof Foo);//true console.log(f1 instanceof Object);//true /* 案例2 */ console.log(Object instanceof Function);//true console.log(Object instanceof Object);//true console.log(Function instanceof Function);//true console.log(Function instanceof Object);//true function Foo()&#123;&#125; console.log(Object instanceof Foo);//false&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06_面试题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 测试题1 */ var A = function() &#123; &#125; A.prototype.n = 1; var b = new A(); A.prototype = &#123; n: 2, m: 3 &#125; var c = new A(); console.log(b.n, b.m, c.n, c.m);//1,undefined,2,3 /* 测试题2 */ var F = function()&#123;&#125;; Object.prototype.a = function()&#123; console.log(&#x27;a()&#x27;); &#125;; Function.prototype.b = function()&#123; console.log(&#x27;b()&#x27;); &#125;; var f = new F(); f.a();//找到Object.prototype，输出a()// f.b();//找不到，报错not a function F.a();//找到Object.prototype，输出a() F.b();//找到Function.prototype，输出b() console.log(Object.prototype); console.log(Function.prototype);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、执行上下文与执行上下文栈1、变量提升与函数提升1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_变量提升与函数提升&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 变量声明提升 * 通过var定义(声明)的变量, 在定义语句之前就可以访问到 * 值: undefined2. 函数声明提升 * 通过function声明的函数, 在之前就可以直接调用 * 值: 函数定义(对象)3. 问题: 变量提升和函数提升是如何产生的?--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 面试题：输出undefined */ var a=3; function fn()&#123; console.log(a); var a =4; &#125; /* 上面函数等同于 */ /* function fn()&#123; var a ; console.log(a); a=4; &#125; */ fn();//因为，局部变量提升，先声明了，所以不找全局变量的a，但此时未赋值，所以输出undefined fn2();//可调用，函数提升 fn3();//不能调用，变量提升，认为fn3是变量，而不是一个函数，会报错 function fn2()&#123; console.log(&#x27;fn2()&#x27;); &#125; var fn3 =function()&#123; console.log(&#x27;fn3()&#x27;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、执行上下文12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_执行上下文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 代码分类(位置) * 全局代码 * 函数代码2. 全局执行上下文 * 在执行全局代码前将window确定为全局执行上下文 * 对全局数据进行预处理 * var定义的全局变量==&gt;undefined, 添加为window的属性 * function声明的全局函数==&gt;赋值(fun), 添加为window的方法 * this==&gt;赋值(window) * 开始执行全局代码3. 函数执行上下文 * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的，存在于栈中) * 对局部数据进行预处理 * 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 * arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 * var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 * function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 * this==&gt;赋值(调用函数的对象) * 开始执行函数体代码--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 全局执行上下文 console.log(a1,window.a1); a2(); console.log(this); var a1=3; function a2()&#123; console.log(&#x27;a2()&#x27;); &#125; console.log(a1); console.log(&quot;===========&quot;); //函数执行上下文 function fn(a1)&#123; console.log(a1);//2 console.log(a2);//undefined a3();//a3() console.log(this);//window console.log(arguments);//伪数组(2,3) var a2=3; function a3()&#123; console.log(&#x27;a3()&#x27;); &#125; &#125; fn(2,3);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、执行上下文栈123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_执行上下文栈&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)3. 在函数执行上下文创建后, 将其添加到栈中(压栈)4. 在当前函数执行完后,将栈顶的对象移除(出栈)5. 当所有的代码执行完后, 栈中只剩下window--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a=10; var bar = function(x)&#123; var b=5; foo(x+b); &#125; var foo=function(y)&#123; var c=5; console.log(a+c+y); &#125; bar(10);// bar(10);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4、执行上下文栈212345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_执行上下文栈2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 依次输出什么? gb:undefined ge:1 fb:1 fb:2 fb:3 fe:3 fe:2 fe:12. 整个过程中产生了几个执行上下文? 5个--&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(&#x27;global begin:&#x27;+i);//undefined var i=1; foo(1); function foo(i)&#123; if(i==4)&#123; return; &#125; console.log(&#x27;foo() begin:&#x27;+i); foo(i+1);//递归调用 console.log(&quot;foo() end:&quot;+i); &#125; console.log(&quot;global end:&quot;+i);//1&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、面试题1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_面试题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 测试题1:先执行变量提升，再执行函数提升？ 函数提升优先级高于变量提升，且不会被同名变量声明覆盖，但是会被变量赋值后覆盖。而且存在同名函数与同名变量时，优先执行函数。 */ function a()&#123;&#125; var a; console.log(typeof a);//function /* 测试题2 */ if(!(b in window))&#123; var b=1; &#125; console.log(b);//undefined /* 测试题3 */ var c=1; function c(c)&#123; console.log(c); &#125; /* var c; function c(c)&#123; console.log(c); &#125; c=1; */ c(2);//报错，not a function&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、作用域和作用域链1、作用域123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_作用域&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 理解 * 就是一块&quot;地盘&quot;, 一个代码段所在的区域 * 它是静态的(相对于上下文对象), 在编写代码时就确定了2. 分类 * 全局作用域 * 函数作用域 * 没有块作用域(ES6有了)3. 作用 * 隔离变量，不同作用域下同名变量不会有冲突--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* //没有块作用域 if(true)&#123; var c=3; &#125; console.log(c); */ var a=10; var b=20; function fn(x)&#123; var a=100; var c=300; console.log(&#x27;fn()&#x27;,a,b,c,x); function bar(x)&#123; var a=1000; var d=400; console.log(&#x27;bar()&#x27;,a,b,c,d,x); &#125; bar(100); bar(200); &#125; fn(10);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、作用域与执行上下文123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_作用域与执行上下文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 区别1 * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时 * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 * 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建2. 区别2 * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 * 执行上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会自动释放3. 联系 * 执行上下文环境(对象)是从属于所在的作用域 * 全局上下文环境==&gt;全局作用域 * 函数上下文环境==&gt;对应的函数使用域--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a=10; var b=20; function fn(x)&#123; var a=100; var c=300; console.log(&#x27;fn()&#x27;,a,b,c,x); function bar(x)&#123; var a=1000; var d=400; console.log(&#x27;bar()&#x27;,a,b,c,d,x); &#125; bar(100); bar(200); &#125; fn(10);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、作用域链1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_作用域链&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 理解 * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) * 查找变量时就是沿着作用域链来查找的2. 查找一个变量的查找规则 * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var a=1; function fn1()&#123; var b=2; function fn2()&#123; var c=3; console.log(c);//3 console.log(b);//2 console.log(a);//1 console.log(d);//not defined &#125; fn2(); &#125; fn1();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、作用域面试题1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_作用域_面试题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var x=10; function fn()&#123; console.log(x); &#125; function show(f)&#123; var x=20; f(); &#125; show(fn);//10&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、作用域面试题12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_作用域_面试题2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var fn=function()&#123; console.log(fn);//现在函数自身里面找，找不到，再到全局作用域找，找到fn &#125;; fn();//fn=function()&#123;console.log(fn);&#125;; var obj=&#123; fn2:function()&#123; // console.log(fn2); console.log(this.fn2); &#125; &#125;; obj.fn2();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、闭包1、引入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;00_引入&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;!--需求: 点击某个按钮, 提示&quot;点击的是第n个按钮&quot;--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btns=document.getElementsByTagName(&quot;button&quot;); var length = btns.length; // 遍历添加点击事件 /* for(var i=0;i&lt;length;i++)&#123; var btn=btns[i]; btn.onclick=function()&#123; alert(&quot;点击的是第&quot;+(i+1)+&quot;个按钮!&quot;);// &#125; &#125; */ // console.log(i);//3 /* for(var i=0;i&lt;length;i++)&#123; var btn=btns[i]; // 将btn所对应的下标保存到index属性上 btn.index=i; btn.onclick=function()&#123; alert(&quot;点击的是第&quot;+(this.index+1)+&quot;个按钮!&quot;);// &#125; &#125; */ // 利用了闭包 for(var i=0;i&lt;length;i++)&#123; (function (i)&#123; var btn=btns[i]; btn.onclick=function()&#123; alert(&quot;第&quot;+(i+1)+&quot;个&quot;); &#125; &#125;)(i) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、理解闭包1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_理解闭包&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 如何产生闭包? * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包2. 闭包到底是什么? * 使用chrome调试查看 * 理解一: 闭包是嵌套的内部函数(绝大部分人) * 理解二: 包含被引用变量(函数)的对象(极少数人) * 注意: 闭包存在于嵌套的内部函数中3. 产生闭包的条件? * 函数嵌套 * 内部函数引用了外部函数的数据(变量/函数)--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; var a=2; var b=&#x27;abc&#x27;; function fn2()&#123;//执行函数定义就好产生闭包（不用调用内部函数） console.log(a); &#125; fn2(); &#125; fn1();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、常见的闭包123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_常见的闭包&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 将函数作为另一个函数的返回值2. 将函数作为实参传递给另一个函数调用--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1、将函数作为另一个函数的返回值 function fn1()&#123; var a=2; function fn2()&#123; a++; console.log(a); &#125; return fn2; &#125; var f = fn1(); f();//3 f();//4 // fn1(); //2、将函数作为实参传递给另一个函数调用 function showDelay(msg,time)&#123; setTimeout(function()&#123; alert(msg); &#125;,time); &#125; showDelay(&#x27;xiaolin&#x27;,2000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、闭包的作用12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_闭包的作用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)问题: 1. 函数执行完后, 函数内部声明的局部变量是否还存在? 一般是不存在了，存在于闭包中的变量才可能存在 2. 在函数外部能直接访问函数内部的局部变量吗? 不能，但是我们可以通过闭包让外部操作它--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1、将函数作为另一个函数的返回值 function fn1()&#123; var a=2; function fn2()&#123; a++; console.log(a); &#125; function fn3()&#123; a--; console.log(a); &#125; return fn3; &#125; var f = fn1(); f();//1 f();//0 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5、闭包的生命周期123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_闭包的生命周期&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)2. 死亡: 在嵌套的内部函数成为垃圾对象时--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1、将函数作为另一个函数的返回值 function fn1()&#123; // 此时闭包就已经产生了（函数提升，内部函数对象已经创建了） var a=2; function fn2()&#123; a++; console.log(a); &#125; return fn2; &#125; var f = fn1(); f();//3 f();//4 f=null;//让闭包死亡（包含闭包的函数对象成为了垃圾对象）&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、闭包的应用—自定义js模块12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_闭包的应用_自定义JS模块&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--闭包的应用2 : 定义JS模块 * 具有特定功能的js文件 * 将所有的数据和功能都封装在一个函数内部(私有的) * 只向外暴露一个包信n个方法的对象或函数 * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能--&gt;&lt;script type=&quot;text/javaScript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var module = myModule(); module.doSomething();//doSomething() MY JAVASCRIPT module.doOtherthing();//doOtherthing() my javascript&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; myModule.js 1234567891011121314151617function myModule()&#123; // 私有数据 var msg=&quot;my JavaScript&quot;; // 操作数据的函数 function doSomething()&#123; console.log(&#x27;doSomething() &#x27;+msg.toUpperCase()); &#125; function doOtherthing()&#123; console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase()); &#125; // 向外暴露对象（给外部使用的方法） return &#123; doSomething:doSomething, doOtherthing:doOtherthing &#125;;&#125; 7、闭包的应用—自定义js模块12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_闭包的应用_自定义JS模块2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--闭包的应用2 : 定义JS模块 * 具有特定功能的js文件 * 将所有的数据和功能都封装在一个函数内部(私有的) * 只向外暴露一个包信n个方法的对象或函数 * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能--&gt;&lt;script src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;&lt;script&gt; myModule2.doSomething(); myModule2.doOtherthing();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; myModule2.js 12345678910111213141516(function(window)&#123; // 私有数据 var msg=&quot;my JavaScript&quot;; // 操作数据的函数 function doSomething()&#123; console.log(&#x27;doSomething() &#x27;+msg.toUpperCase()); &#125; function doOtherthing()&#123; console.log(&#x27;doOtherthing() &#x27;+msg.toLowerCase()); &#125; window.myModule2=&#123; doSomething:doSomething, doOtherthing:doOtherthing &#125;;&#125;)(window);//传入window可以实现代码压缩 8、闭包的缺点及解决1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06_闭包的缺点及解决&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 缺点 * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长 * 容易造成内存泄露2. 解决 * 能不用闭包就不用 * 及时释放--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; var arr=new Array(100000); function fn2()&#123; console.log(arr.length); &#125; return fn2; &#125; var f = fn1(); f();//100000 f=null;//让内部函数成为垃圾对象----&gt;回收闭包&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9、内存溢出和内存泄露123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_内存溢出与内存泄露&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 内存溢出 * 一种程序运行出现的错误 * 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误2. 内存泄露 * 占用的内存没有及时释放 * 内存泄露积累多了就容易导致内存溢出 * 常见的内存泄露: * 意外的全局变量 * 没有及时清理的计时器或回调函数 * 闭包--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 1. 内存溢出 var obj = &#123;&#125;; for (var i = 0; i &lt; 10000; i++) &#123; obj[i] = new Array(1000000); // console.log(&#x27;-----&#x27;); &#125; // 2. 内存泄露 // 意外的全局变量 function fn() &#123; a = new Array(10000000); console.log(a); &#125; fn(); // 没有及时清理的计时器或回调函数 var intervalId = setInterval(function () &#123; //启动循环定时器后不清理 console.log(&#x27;----&#x27;); &#125;, 1000); // clearInterval(intervalId) // 闭包 function fn1() &#123; var a = 4; function fn2() &#123; console.log(++a); &#125; return fn2; &#125; var f = fn1(); f(); // f = null;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10、面试题112345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;07_面试题1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //代码片段一 var name =&quot;The Window&quot;; var object = &#123; name: &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; // 没有使用闭包 // object.getNameFunc()得到的就是一个函数，函数()，里面的this就是window alert(object.getNameFunc()());//The Window // 代码片段二 var name2 =&quot;The Window&quot;; var object2 = &#123; name2: &quot;My Object&quot;, getNameFunc : function()&#123; var that=this; return function()&#123; return that.name2; &#125;; &#125; &#125;; // 使用了闭包 // object2.getNameFunc()得到一个函数，执行函数，把object2对象赋值给that，that指向object2 alert(object2.getNameFunc()());//My Object&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11、面试题21234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;07_面试题2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 关键点在于有没有产生新的闭包 function fun(n,o)&#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;; &#125; var a =fun(0);//undefined,返回一个对象，产生了闭包 a.fun(1);//0 m=1,n=0 ==&gt; 输出0 ，产生一个新的闭包，返回了一个对象，但是没有接收，闭包很快就消失了 a.fun(2);//0 m=2,n=0 同理 a.fun(3);//0 m=3，n=0 同理 var b = fun(0).fun(1).fun(2).fun(3);//undefined 0 1 2,返回的对象被接收了，产生了新的闭包 var c = fun(0).fun(1);//undefined 0 c.fun(2);//1 c.fun(3);//1&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三、对象高级1、对象创建模式1、Object构造函数模式12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_Object构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式一: Object构造函数模式 * 套路: 先创建空Object对象, 再动态添加属性/方法 * 适用场景: 起始时不确定对象内部数据 * 问题: 语句太多--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 一个人: name:&quot;Tom&quot;, age: 12 */ var p =new Object(); p.name=&#x27;tom&#x27;; p.age=12; p.setName=function(name)&#123; this.name=name; &#125;// 测试 p.setName(&#x27;jack&#x27;); console.log(p);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、对象字面量12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_对象字面量&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式二: 对象字面量模式 * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法 * 适用场景: 起始时对象内部数据是确定的 * 问题: 如果创建多个对象, 有重复代码--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var p=&#123; name:&#x27;tom&#x27;, age:12, setName:function(name)&#123; this.name=name; &#125; &#125;; // 测试 p.setName(&#x27;marry&#x27;); console.log(p.name); // 代码重复 var p2=&#123; name:&#x27;jack&#x27;, age:16, setName:function(name)&#123; this.name=name; &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_工厂模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式三: 工厂模式 * 套路: 通过工厂函数动态创建对象并返回 * 适用场景: 需要创建多个对象 * 问题: 对象没有一个具体的类型, 都是Object类型--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 返回一个对象的函数==&gt;工厂函数 function createPerson(name,age)&#123; var obj=&#123; name:name, age:age, setName:function(name)&#123; this.name=name; &#125; &#125;; return obj; &#125; function createStudent(name,sno)&#123; var obj=&#123; name:name, sno:sno, setSno:function(sno)&#123; this.name=sno; &#125; &#125;; return obj; &#125; // 创建2个人 var p1= createPerson(&#x27;tom&#x27;,12); var p2= createPerson(&#x27;jack&#x27;,15); var s = createStudent(&quot;zs&quot;,21281084); console.log(typeof p1===typeof s);//true&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、自定义构造模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_自定义构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式四: 自定义构造函数模式 * 套路: 自定义构造函数, 通过new创建对象 * 适用场景: 需要创建多个类型确定的对象 * 问题: 每个对象都有相同的数据, 浪费内存--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name=name; this.age=age; this.setName=function(name)&#123; this.name=name; &#125; &#125; function Student(name,sno)&#123; this.name=name; this.sno=sno; this.setName=function(name)&#123; this.name=name; &#125; &#125; var p = new Person(&#x27;zz&#x27;,18); p.setName(&#x27;jack&#x27;); console.log(p1.name,p.age); console.log(p instanceof Person);//true var s = new Student(&#x27;zs&#x27;,120310); console.log(s); console(s instanceof Student);//true var p2=new Person(&#x27;fs&#x27;,12); console.log(p1,p2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、构造函数+原型的组合模式1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_构造函数+原型的组合模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式六: 构造函数+原型的组合模式 * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 * 适用场景: 需要创建多个类型确定的对象--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name=name; this.age=age; &#125; Person.prototype.setName=function(name)&#123; this.name=name; &#125;; var p1= new Person(&#x27;zs&#x27;,19); var p2= new Person(&#x27;sd&#x27;,11); console.log(p1,p2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、继承模式1、原型链继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_原型链继承&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式1: 原型链继承 1. 套路 1. 定义父类型构造函数 2. 给父类型的原型添加方法 3. 定义子类型的构造函数 4. 创建父类型的对象赋值给子类型的原型 5. 将子类型原型的构造属性设置为子类型 6. 给子类型原型添加方法 7. 创建子类型的对象: 可以调用父类型的方法 2. 关键 1. 子类型的原型为父类型的一个实例对象--&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 父类型 function Supper()&#123; this.supProp=&quot;Super property&quot;; &#125; Supper.prototype.showSupperProp=function()&#123; console.log(this.supProp); &#125; // 子类型 function Sub()&#123; this.subProp =&quot;Sub property&quot;; &#125; // 子类型的原型是父类型的一个实例对象 Sub.prototype = new Supper(); // 让子类型的原型的constructor指向子类型 Sub.prototype.constructor=Sub; Sub.prototype.showSubProp=function()&#123; console.log(this.subProp); &#125; var sub=new Sub(); sub.showSupperProp(); // sub.toString(); sub.showSubProp(); console.log(sub.constructor);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、借用构造函数继承123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_借用构造函数继承&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式2: 借用构造函数继承(假的)1. 套路: 1. 定义父类型构造函数 2. 定义子类型构造函数 3. 在子类型构造函数中调用父类型构造2. 关键: 1. 在子类型构造函数中通用call()调用父类型构造函数--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name = name; this.age=age; &#125; function Student(name,age,price)&#123; Person.call(this,name,age);//相当于this.Person(name,age); /* this.name = name; this.age=age; */ this.price=price; &#125; var s=new Student(&quot;XiaoLin&quot;,21,14000); console.log(s.name,s.age,s.price);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、组合继承12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_组合继承&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式3: 原型链+借用构造函数的组合继承1. 利用原型链实现对父类型对象的方法继承2. 利用call()借用父类型构建函数初始化相同属性--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function Person(name,age)&#123; this.name = name; this.age=age; &#125; Person.prototype.setName=function(name)&#123; this.name=name; &#125;; function Student(name,age,price)&#123; Person.call(this,name,age);//为了得到属性 this.price=price; &#125; Student.prototype=new Person();//为了能看到父类型的方法 Student.prototype.constructor=Student;//修正constructor属性 Student.prototype.setPrice=function(price)&#123; this.price=price; &#125; var s=new Student(&quot;XiaoLin&quot;,21,14000); s.setName(&#x27;xiaolin&#x27;); s.setPrice(15000); console.log(s.name,s.age,s.price);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、线程机制与事件机制1、进程与线程1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_进程与线程&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 进程：程序的一次执行, 它占有一片独有的内存空间。分配资源的最小单位2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程，cpu调度的最小单位3. 进程与线程 * 应用程序必须运行在某个进程的某个线程上 * 一个进程中一般至少有一个运行的线程: 主线程，进程启动后自动创建的 * 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的 * 一个进程内的数据可以供其中的多个线程直接共享 * 多个进程之间的数据是不能直接共享的 * 线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用4. 浏览器运行是单进程还是多进程? * 有的是单进程 * firefox * 老版IE * 有的是多进程 * chrome * 新版IE5. 如何查看浏览器是否是多进程运行的呢? * 任务管理器==&gt;进程6. 浏览器运行是单线程还是多线程? * 都是多线程运行的7、 什么是多进程和多线程？ 多进程：一个应用程序可以同时启动多个实例运行 多线程：在一个进程内，同时有多个线程运行8、比较单线程和多线程 多线程： 优点：有效提升cpu的利用率 缺点：创建多线程开销、线程间切换开销（单核）、死锁与状态同步问题 单线程： 优点：顺序编程简单易懂 缺点：效率低9、 js是单线程还是多线程？ js是单线程运行的 但是使用Html5的Web Workes可以多线程运行--&gt;&lt;/body&gt;&lt;/html&gt; 2、浏览器内核12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_浏览器内核&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 什么是浏览器内核? * 支持浏览器运行的最核心的程序2. 不同的浏览器可能不太一样 * Chrome, Safari: webkit * firefox: Gecko * IE: Trident * 360,搜狗等国内浏览器: Trident + webkit3. 内核由很多模块组成 主 * js引擎模块：负责js程序的编译与运行 线 * html,css文档解析模块 : 负责页面文本的解析 程 *dom/css模块 : 负责dom/css在内存中的相关处理 * 布局和渲染模块 : 负责页面的布局和效果的绘制 分 * 定时器模块 : 负责定时器的管理 线 * 网络请求模块 : 负责服务器请求(常规/Ajax) 程 * 事件响应模块 : 负责事件的管理--&gt;&lt;/body&gt;&lt;/html&gt; 3、定时器引发的思考1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_定时器引发的思考&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;启动定时器&lt;/button&gt;&lt;!--1. 定时器真是定时执行的吗? * 定时器并不能保证真正定时执行 * 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)2. 定时器回调函数是在分线程执行的吗? * 在主线程执行的, js是单线程的3. 定时器是如何实现的? * 事件循环模型(后面讲)--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&#x27;btn&#x27;); btn.onclick=function()&#123; // var start = new Date.getTime(); var start = Date.now(); console.log(&#x27;启动定时器前...&#x27;); setTimeout(function()&#123; console.log(&#x27;定时器执行了&#x27;,Date.now()-start); &#125;,200); console.log(&#x27;启动定时器后...&#x27;); // 做一个长时间的工作 for(var i=0;i&lt;1000000000;i++)&#123; &#125; // 定时器执行时间延迟了 &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、js是单线程执行的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_JS是单线程的&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. 如何证明js执行是单线程的? * setTimeout()的回调函数是在主线程执行的 * 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行2. 为什么js要用单线程模式, 而不用多线程模式? * JavaScript的单线程，与它的用途有关。 * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 * 这决定了它只能是单线程，否则会带来很复杂的同步问题3. 代码的分类: * 初始化代码 * 回调代码4. js引擎执行代码的基本流程 * 先执行初始化代码: 包含一些特别的代码 回调函数（异步执行） * 设置定时器 * 绑定事件监听 * 发送ajax请求 * 后面在某个时刻才会执行回调代码--&gt;&lt;script type=&quot;text/javascript&quot;&gt; setTimeout(function()&#123; console.log(&#x27;timeout 2222&#x27;); alert(&#x27;22222&#x27;); &#125;,5000); setTimeout(function()&#123; console.log(&#x27;timeout 1111&#x27;); alert(&#x27;11111&#x27;); &#125;,3000); setTimeout(function()&#123; console.log(&#x27;timeout 0000&#x27;); &#125;,0);//alert----先输出 function fn()&#123; console.log(&#x27;fn()&#x27;); &#125; fn(); // 先输出1，再1111，再2222 console.log(&#x27;alert()之前&#x27;); alert(&#x27;------&#x27;);//暂停当前主线程的执行，也暂停了计时，点击确定后才恢复程序的执行和计时,现在2022并不会暂停计时 console.log(&#x27;alert()之后&#x27;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、浏览器的事件循环（轮询）模型123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_事件循环模型&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;测试&lt;/button&gt;&lt;!--1. 所有代码分类 * 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 * 回调执行代码(异步代码): 处理回调逻辑2. js引擎执行代码的基本流程: * 初始化代码===&gt;回调代码3. 模型的2个重要组成部分: * 事件(定时器/DOM事件/Ajax)管理模块 * 回调队列4. 模型的运转流程 * 执行初始化代码, 将事件回调函数交给对应模块管理 * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn1()&#123; console.log(&#x27;fn1()&#x27;); &#125; fn1(); var btn=document.getElementById(&#x27;btn&#x27;); btn.onclick=function()&#123; console.log(&#x27;点击了btn&#x27;); &#125;; setTimeout(function()&#123; console.log(&#x27;定时器执行了&#x27;); &#125;,2000); function fn2()&#123; console.log(&#x27;fn2()&#x27;); &#125; fn2(); // fn1(),fn2();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、H5 Web Workers（多线程）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06_Web Workers_测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--1. H5规范提供了js分线程的实现, 取名为: Web Workers2. 相关API * Worker: 构造函数, 加载分线程执行的js文件 * Worker.prototype.onmessage: 用于接收另一个线程的回调函数 * Worker.prototype.postMessage: 向另一个线程发送消息3. 不足 * worker内代码不能操作DOM(更新UI) * 不能跨域加载JS * 不是每个浏览器都支持这个新特性--&gt;&lt;input type=&quot;text&quot; placeholder=&quot;数值&quot;&gt;&lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 编程实现斐波那契数列（Fibonacc sequence）的计算 // F(0)=0,F(1)=1,....F(n)=F(n-1)+F(n-2); function fibonacci(n)&#123; return number&lt;=2 ? 1: fibonacci(number-1)+fibonacci(number-2); /* var res = [0, 1]; if(n &lt; 2) &#123; return res[n]; &#125; var first = 0; var second = 1; var fibn = 0; for(var i = 2; i &lt;= n; i++) &#123; fibn = first + second; first = second; second = fibn; &#125; return fibn; */ &#125; // 获取输入框中的内容 var input = document.getElementsByTagName(&quot;input&quot;)[0]; document.getElementById(&#x27;btn&#x27;).onclick=function()&#123; var num = input.value; var result = fibonacci(num); alert(result); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;&gt; &lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt; &lt;script&gt; var input = document.getElementById(&quot;number&quot;); document.getElementById(&#x27;btn&#x27;).onclick=function()&#123; var number = input.value; // 创建一个worker对象 var worker = new Worker(&#x27;worker.js&#x27;); // 绑定接收消息监听 worker.onmessage=function(event)&#123; console.log(&#x27;主线程接收分线程返回的数据：&#x27;+event.data); alert(event.data); &#125; // 向分线程发送数据 worker.postMessage(number); console.log(&#x27;主线程向分线程发送的数据：&#x27;+number); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930function fibonacci(number)&#123; return number&lt;=2 ? 1: fibonacci(number-1)+fibonacci(number-2); /* var res = [0, 1]; if(n &lt; 2) &#123; return res[n]; &#125; var first = 0; var second = 1; var fibn = 0; for(var i = 2; i &lt;= n; i++) &#123; fibn = first + second; first = second; second = fibn; &#125; return fibn; */&#125;var onmessage = function(event)&#123; var num = event.data; console.log(&quot;分线程接收到主线程发送来的数据:&quot;+num); // 计算 var result = fibonacci(num); postMessage(result); console.log(&#x27;分线程向主线程返回数据：&#x27;+result); // alert(result);//alert是window的方法。在分线程不能调用 // 分线程中的全局对象不再是window，所以分线程不可能更新线程 &#125;console.log(this);","tags":"js"},{"title":"JavaScript","url":"/2022/11/02/尚硅谷JavaScript/","text":"JavaScript[TOC] 一、简介1、什么是语言 2、起源 现在已经不局限于前端验证 3、简史 4、实现 5、特点 二、Day11、HelloWorld123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- JS代码需要编写到script标签中 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 控制浏览器弹出一个警告框 // alert(&quot;这是我的第一行JS代码&quot;); /* 让计算机在页面中输出一个内容 可以向body中输出一个内容 */ // document.write(&quot;我是你写的内容&quot;); // 向控制台输出一个内容 // console.log(&quot;我在控制台输出了&quot;); // 依次从上往下执行 alert(&quot;这是我的第一行JS代码&quot;); document.write(&quot;我是你写的内容&quot;); console.log(&quot;我在控制台输出了&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、JS代码编写位置12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 可以将js代码编写到外部js文件中，然后通过script标签引入 写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制 --&gt; &lt;!-- script标签一旦用于引入了外部文件了，就不能再标签内编写代码了 即使编写了浏览器也会忽略，如果需要则需要重新创建一个新的script标签用于编写内部代码 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt; // alert(&quot;我是引入js文件标签的内部的js代码&quot;); &lt;/script&gt; &lt;script&gt; alert(&quot;我是内部的js代码&quot;); &lt;/script&gt; &lt;!-- 也可以将js代码写到script标签中 &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;我是script标签中的代码&quot;); &lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 可以将js代码编写到标签的onclick属性中 当我们点击按钮时，js代码才会执行 虽然可以写在标签的属性中，但是他们属于结果和行为耦合，不方便维护，不推荐使用 --&gt; &lt;button onclick=&quot;alert(&#x27;讨厌，你点我干嘛！&#x27;);&quot;&gt;点我一下&lt;/button&gt; &lt;!-- 可以将js代码编写到超链接的href属性中 当我们点击超链接时，js代码才会执行 --&gt; &lt;a href=&quot;javascript:alert(&#x27;让你点你就点&#x27;);&quot;&gt;你也点我一下呗&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;你也点我一下呗&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 3、js基本语法123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // js注释 /* 多行注释 JS注释 多行注释，注释中内容不会被执行，但是可以在源代码查看 要养成良好的编写注释的习惯，也可以通过注释对代码进行一些简单的测试 */ // 单行注释 // alert(&quot;hello&quot;); // document.write(&quot;hello&quot;); console.log(&quot;hello&quot;);//该语句用于在控制台输出一个日志 /** * 1.JS中严格区分大小写 * 2.JS中每一条语句以分号(;)结尾 * 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 * 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 * 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 * * */ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、字面量和变量12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /** * 字面量，都是一些不可改变的值 * 比如： 1 2 3 4 5 * 字面量都是可以直接使用的，但是我们一般都不会直接使用字面量 * 1341494914 * 变量可以用来保存字面量，而且变量的值是可以任意改变的 * 变量更加方便我们使用，所以在开发中我们都是通过变量去保存一个字面量 * 可以使用变量名对变量进行描述 */ // alert(1494919); // 声明变量 // 在js中使用var关键字来声明一个变量 var a; // 为变量赋值 a=123; a=456; alert(a); // 声明和赋值同时进行 var b = 123; var c = 0; var age = 80; alert(age); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、标识符1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script text=&quot;javascript&quot;&gt; /** * 标识符 * -在js中所有可以由我们自主命名的都可以称为标识符 * -例如：变量名、函数名、属性名都属于标识符 * -命令一个标识符时需要遵守如下的规则 * 1.标识符中可以含有字母、数字、_、$ * 2.标识符不能以数字开头 * 3.标识符不能是ES中的关键字或保留字 * 4.标识符一般都采用驼峰命名法 * -首字母小写，每个单词开头字母大写，其余小写 * helloworld -&gt; helloWorld * * JS底层保存标识符时实际是采用的Unicode编码 * 所以理论上，所有的理论上讲所有的utf-8含有的内容都可以作为标识符 * */ var _good = 123 alert(_good); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、数据类型–String12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 数据类型指的就是字面量的类型 * 在JS中一共有六种数据类型 * String字符串 * Number 数值 * Boolean 布尔值 * Null 空值 * underfind 未定义 * Object 对象 * * 其中String Number Boolean Null Undefind属于基本数据类型 * 而Object属于引用数据类型 */ /** * String 字符串 * -在Js中字符串需要使用引号引起来 * -使用双引号或单引号都可以,但是不要混着用 * -引号不能嵌套，单引号里不能放单引号，双引号里不能放双引号 * */ // var str = &quot;hello&quot;; var str = &#x27;hello&#x27;; // str = &quot;我说:&quot; 今天真不错! &quot;&quot;; // 在字符串我们可以使用\\作为转义字符 // 当表示一些特殊符号时可以使用\\进行转义 // \\&quot; 表示 &quot; \\&#x27; 表示 &#x27; \\n 表示换行 \\t 表示制表符 \\\\ 表示 \\ str = &quot;我说:\\&quot;今天真不错!\\&quot;&quot;; // 输出字面量 alert(&quot;str&quot;); // 输出变量 alert(str); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、Number1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 在JS中所有数值都是Number类型， * 包括整数和浮点数（小数） * */ var a = 123; var b = &quot;123&quot;; // a = 41781.24290 /** * 可以使用一个运算符typeof * 来检查一个变量的类型 * 语法:typeof 变量 */ // console.log(a); // console.log(b); // console.log(typeof a); // console.log(typeof b); // JS中可以表示的数字的最大值 // Number.MAX_VALUE = 1.7976931348623157e+308 console.log(Number.MAX_VALUE); var a = Number.MAX_VALUE * Number.MAX_VALUE; // 如果使用Number的数字超过了最大值，则会返回一个Infinity表示正无穷 // Infinity表示正无穷，-Infinity表示负无穷，可以直接使用 // 使用typeof检查Infinity也会返回Number console(a); var c = Infinity; console(c); console(typeof c); // NaN是一个特殊数字表示Not A Number var d = &quot;abc&quot; * &quot;hhh&quot;; // 同样是字面量可以直接使用，使用typeof检查NaN也会返回Number d = NaN; alert(d);//NaN alert(typeof d);//Number // Number.MIN_VALUE表示大于0的最小值 var e = Number.MIN_VALUE; alert(e); // 在js中整数的运算基本可以保证精确 var f = 123 + 456; alert(f); // 如果使用JS进行浮点元素，可能得到一个不精确的结果 // 所以千万不要使用JS对精确度要求较高的计算 var g = 0.1 + 0.2; alert(g);// !=0.3 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 8、Boolean12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * Boolean 布尔值 * 布尔值只有两个，主要用来做逻辑判断 * true * 表示真 * false * 表示假 * 使用typeof检查一个布尔值时，返回boolean */ var b = true; alert(typeof b); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 9、null和undefined1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * Null类型的值只有一个，就是null * null这个值专门用来表示一个为空的对象 * 用typeof检查一个null值时，会返回object * * * Undefined类型的值只有一个，就是undefined * 当声明一个变量，但是不给变量赋值时，值就是undefined * 使用typeof检查一个undefined时也会返回undefined * */ var a = null; alert(typeof a); var b; //可以当字面量使用 b = undefined; alert(b);//undefined &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 10、强制类型转换—-转换为String12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 强制类型转换 * -指将一个数据类型强制转换为其他数据类型 * -类型转换主要指，将其他的数据类型转换为 * String Number Boolean * * */ // 将其他数据类型转换为String /** * 方式一: * -调用被转换数据类型的toString()方法 * -该方法不会影响到原变量，他会将转换的结果返回 * -但是注意：null和undefined没有toString()方法，不能够转换为其他数据类型 * 如果调用他们的方法会报错！ * 方式二： * -调用String()函数,并将转换的数据作为参数传给函数 * -使用String()函数做强制类型转换时， * 对于Number和Boolean实际上就是调用的toString()方法 * 但是对于null和undefined，就不会调用toString()方法 * 他会将null直接转换为&quot;null&quot; * 将undefined直接转换为&quot;undefined&quot; * */ var a = 123; // 调用a的toString()方法 a = a.toString(); a = true; a = a.toString(); a = null; // a = a.toStirng();报错 a = undefined; // a = a.toString();报错 a = 123; // 调用String()函数，来将a转换为字符串 a = String(a); a = null; a = String(a); a = undefined; a =String(a); alert(typeof a); alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 11、类型转换为Number1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 将其他数据类型转换为Number * 方式一： * 使用Number()函数 * -字符串转为数字 * 1.如果是纯数字的字符串，则直接将其转换为数字 * 2.如果字符串中有非数字的内容，则转换为NaN * 3.如果字符串是一个空串或者是一个全是空格的字符，则转换为0 * -布尔值转为数字 * true - 1 * false - 0 * -Null转为数字 - 0 * -undefined转为数字 - NaN * * 方式二： * 这种方式专门用来应对字符串 * -parseInt()把一个字符串转换为整数 * -parseFloat()把一个字符串转换为一个浮点数 * */ var a = &quot;123&quot;; // 调用Number()函数转换为Number类型 a = Number(a); var b =&quot;abc&quot;; b = Number(b);//转换不了 // alert(typeof b); var c =&quot;&quot;; c = Number(c); // alert(c);//0 var d = null; d = Number(d); // alert(d); var e = undefined; e = Number(e); // alert(e); // alert(typeof a); // alert(a); a = &quot;123px9200&quot;; // 调用parseInt()函数将a转换为Number // 可以将一个字符串中的有效整数内容取出来然后转换为Number // 从左往右读,当匹配到非数字字符后停止.如123a23 - 123 a = parseInt(a); alert(a);//123 // parseFloat()作用和praseInt()类似，但是他可以有效的获取到小数位 a = &quot;123.456px&quot;; a = a.parseFloat(a); alert(a);//123.456 // 如果对非String类型使用parseInt()或parseFloat()，他会先将其转换为String，然后再操作 a = true; a = a.parseInt(a); alert(a);//NaN &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 12、其他进制的数字123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var a = 123; /** * 在js中，如果需要表示16进制的数字，则需要以0x开头 * 如果需要表示8进制的数字，则需要以0开头 * 如果要表示2进制的数字，则需要以0b开头，但是不是所有浏览器都支持。 */ // 十六进制 a = 0x10; // 八进制数字 a = 080; // 二进制数字 a = 0b10; //像这种类型的字符串，有些浏览器会当成八进制解析，有些会当成十进制解析 var b = &quot;070&quot;; // 可以在parseInt()中传递一个第二个参数，来指定数字的进制 b = parseInt(b,10);//10表示使用十进制 alert(b);//70 alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 13、数据类型转换为Boolean12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 将其他数据类型转回为Boolean * 使用Boolean()函数 * 数字转布尔 * 除了0和NaN，其余都是true * 字符串转布尔 * 除了空串，其余都是true * null和undefined都会转换为false * 对象也会转换为true * 方式二： * 为任意类型取两次反即可转换为布尔类型，原理与Boolean()函数一样 */ var a =123;//true a = -123;//true a = 0;//false a = Infinity; //true a = NaN; // false a = &quot;hello&quot;;//true a = &quot;&quot;;//false a =&quot; &quot;;//true a = null;//false a = undefined;//false // 调用Boolean()函数来将a转换为布尔值 a = Boolean(a); alert(typeof a); alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 14、运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 运算符也叫操作符 * 通过运算符可以对一个或多个值进行计算，并获取运算结果 * 比如：typeof就是运算符，可以来获得一个值的类型 * 他会将该值的类型以字符串的形式返回 * 任何值和NaN做运算，得到的还是NaN * number string boolean undefined object * 算数运算符：不会对原变量影响 * 对非数字的数据类型，会先将他们转换为number类型后计算 * + 可以对两个值进行加法运算，并将结果返回 * 如果对两个字符串进行加法运算，则会拼串. * 任何值和字符串做加法运算，都会转换为字符串，然后再和字符串做拼串的操作 * - 可以对两个或多个值进行减法运算 * * 可以对两个或多个值进行乘法运算 * / 可以对两个或多个值进行除法运算 * % 取模运算，求余数 * */ var a = 123; var result = typeof a; // alert(result);//number // alert(typeof result);//string a = a + 1; // alert(a);//124 a = true + 1; // alert(a);//2 a = 1 + null; // alert(a);//2 a = 1 + NaN; // alert(NaN);//NaN a = &quot;123&quot; + &quot;456&quot;; // alert(a);//&quot;123456&quot; a = 123 + &quot;hello&quot;; // alert(a);//&quot;123hello&quot; // 可以利用这个特点，将数据类型转换为string var c = 123; //隐式的类型转换，实际上也是调用了String()函数 c = c + &quot;&quot;; // alert(typeof c);//String // alert(&quot;c=&quot;+c); a = 1 + 2 + &quot;3&quot;; // alert(&quot;a=&quot;+a);//33 a = &quot;1&quot; + 2 + 3; // alert(&quot;a=&quot;+a);//123 a = 100 - 5; // alert(a);//95 a = 100 - true; // alert(a);//99 a = 100 - &quot;1&quot;; // alert(a);//99 a = 2 * 2; // alert(a);//4 a = 2 * &quot;8&quot;; // alert(a);//16 a = 2 * undefined; // alert(a);//NaN a = 2 * null; // alert(a);//0 a = 2 / 2; // alert(a);//1 // 任何值做- * / 运算都会自动转换为Number var d = &quot;123&quot;; // 所以可以通过以下方法转换为number类型 // 原理和Number()函数一样，但是使用起来更加简单 d = d - 0; d = d * 1; d = d / 1; a = 9 % 3; // alert(a);//3 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 15、一元运算符1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 一元运算符，只需要一个操作数 * + 正号 不会对数字产生任何影响 * - 负号 对数值进行取反 * * 对于非Number类型的值。会先转换为number再计算 * 可以对一个其他的数据类型使用+，使其转换为Number类型 * 原理和Number()函数一样 */ var a = 123; a = +a; a = -a; // alert(a); var b = true; b = -b; // alert(b);//-1 var c = &quot;18&quot;; c = -c; c = +c; // alert(c);//18 var result = 1 + +&quot;2&quot; + 3; alert(result);//6 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 16、自增和自减123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 自增 * -通过自增可以使变量在自身的基础上增加1 * -对一个变量自增后，原变量的值会立即自增1 * -自增分为两种 * a++ * ++a * -无论是a++还是++a，都会立即使原变量的值自增1 * 不同的是a++和++a的值不同 * a++的值等于原变量的值（自增前的值） * ++a的值等于自增后的值 * * 自减 * -通过自减可以让变量在自身的基础人减少1 * -自减分成两种：a-- 和 --a * 无论是--a和a--都会立即使原变量的值立即减少1 * 不同的是--a和a--的值不同 * a--是变量的原值 * --a是自减后的值 * */ var a = 1; // a++; // ++a;//这个等同于a=a+1; // alert(++a); // alert(a++); // alert(a);//2 var c =10; // 使c自增1 c++; // alert(c++);//11 var d = 20; // alert(++d);//21 // var result = d++ + ++d + d; // alert(result);//20+22+22=64 d = d++; // alert(d);//20 var e = 10; // e--; // alert(e);//9 alert(--e);//9 alert(e--);//10 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 17、练习123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var n1 = 10,n2=20; var n = n1++; console.log(&#x27;n=&#x27;+n);//10 console.log(&#x27;n1=&#x27;+n1);//11 n = ++n1; console.log(&#x27;n=&#x27;+n);//12 console.log(&#x27;n1=&#x27;+n1);//12 n = n2--; console.log(&#x27;n=&#x27;+n);//20 console.log(&#x27;n2=&#x27;+n2);//19 n = --n2; console.log(&#x27;n=&#x27;+n);//18 console.log(&#x27;n2=&#x27;+n2);//18 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 18、逻辑运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * JS中为我们提供了三种逻辑运算符 * ！非 * -!可以用来对一个值进行非运算 * 所谓非运算就是指对一个布尔值进行取反操作 * true变false，false变true * 如果对非布尔值进行取反，则会先转换为布尔值再进行取反 * 所以我们可以利用这个特点将一个数据转换为布尔值 * 为任意数据类型取两次反，来将其转换为布尔值 * 原理和Boolean()函数一样 * &amp;&amp; 与 * -可以对符号两侧的值进行与运算并返回结果 * -运算规则：如果两端都是true返回true，只要有一个false就返回false * -JS中的与属于短路的与，如果第一个为false，则不会执行第二个 * * || 或 * -可以对符号两侧的值进行或运算并返回结果 * -运算规则：两个都是false返回false，只要有一个true就返回true * -JS中的或属于短路的或，如果第一个为true，则不会执行第二个 */ var a = true; a = !a; // console.log(a);//false var b = 10; b = !b; // console.log(b);//false // 如果两端都是true返回true，只要有一个false就返回false var result = true &amp;&amp; false; // console.log(result); result = false &amp;&amp; alert(&quot;我不会执行&quot;); // console.log(result);//false // 两个都是false返回false，只要有一个true就返回true var r = false || true; // console.log(r);//true r = true || alert(&quot;hello&quot;); console.log(r);//true &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 19、逻辑运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * &amp;&amp;和|| 非布尔值的情况 * 对于非布尔值进行与和或运算时，会现将数据转换为布尔类型，再进行运算，并且返回原值 * 注意返回的是原值！！！ * -与运算： * 如果第一个值为true，必然返回第二个值 * 如果第一个值为false，必然返回第一个值 * -或运算 * 如果第一个为true，直接返回第一个值 * 如果第一个值为false，则直接返回第二个值 */ // 如果两个都是true，则返回后边的 var result = 1 &amp;&amp; 2; // console.log(result);//不是true而是2 // 如果两个值都是false，则返回前边的 result = 0 &amp; NaN; // 如果第一个是false直接返回第一个 // 如果第一个为true，直接返回第一个值 result = 1 || 2; // console.log(result);//1 // 如果第一个值为false，则直接返回第二个值 result = 0 || 2; // console.log(result);//2 result = &quot;&quot; || &quot;hello&quot;; // console.log(result);//hello &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 20、赋值运算符12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * = * 可以将符号右侧的值赋值给符号左侧的变量 * += * a+=5 等价于 a = a + 5; * -= * a-=5 等价于 a = a-5; * *= * a*=5 等价于 a = a * 5; * /= * a/=5 等价于 a = a / 5; * %= * a%=5 等价于 a= a % 5; * */ var a =123; // console.log(a);//123 a +=5;//a=a+5; // console.log(a);//128 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 三、Day21、关系运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 通过关系运算符可以比较两个值之间的大小关系 * 如果关系成立会返回true，如果关系不成立则返回false * * &gt; 大于号 * -判断符号左边的值是否大于右边的值 * -如果关系成立会返回true，如果关系不成立则返回false * &gt;= 大于等于 * -判断符号左边的值是否大于等于右边的值 * -如果关系成立会返回true，如果关系不成立则返回false * * &lt; 小于号 * -判断符号左边的值是否小于右边的值 * -如果关系成立会返回true，如果关系不成立则返回false * &lt;= 小于等于 * -判断符号左边的值是否小于等于右边的值 * -如果关系成立会返回true，如果关系不成立则返回false * * * 非数值的情况 * -对于非数值情况会先转换成number再做运算 * -对于符号两侧都是字符串的情况，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码 * * */ var result = 5 &gt; 10;//false result = 5&gt;=5;//true result = 4&lt;5;//true result = 5&lt;=3;//false // console.log(result); console.log(1&gt;true);//false console.log(1&gt;=true);//true=1 console.log(1&gt;&quot;0&quot;);//true console.log(10&gt;null);//true //任何值和NaN做任何比较都是false console.log(10&lt;=&quot;hello&quot;);//false console.log(&quot;1&quot;&lt;&quot;5&quot;);//true console.log(&quot;11&quot;&lt;&quot;5&quot;);//true // 比较两个字符串时，比较的是字符串的编码 console.log(&quot;a&quot;&lt;&quot;b&quot;);//true // 比较两个字符时，是一位一位进行比较的 // 如果两位一样，则比较下一位，所以借用它对英文进行排序 console.log(&quot;abc&quot;&lt;&quot;b&quot;); console.log(&quot;abc&quot;&lt;&quot;bcd&quot;); // 比较中文时没有意义 // console.log(&quot;你&quot;&gt;&quot;我&quot;); // 如果比较的两个字符串型的数字，可能会得到不可预期的结果 // 注意：在比较两个字符串型的数字时，一定要转型 console.log(&quot;122114&quot;&lt; +&quot;5&quot;);//false &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、编码1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 在字符串中使用转义字符输入Unicode编码 // \\u四位编码 console.log(&quot;\\u2620&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在网页中使用Unicode编码 &amp;#编码; 这里的编码使用的是10进制编码 --&gt; &lt;h1 style=&quot;font-size: 200px&quot;&gt;&amp;#9760;&lt;/h1&gt; 66666&lt;/body&gt;&lt;/html&gt; 四、Day31、相等运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 相等运算符用来比较两个值是否相等 * 如果相等会返回true，否则返回false * * 使用==来做相等运算 * -当使用==来比较两个值时，如果值的类型不同， * 则会自动进行类型转换，将其转换为相同的类型再进行比较 * * 不相等 ，用来比较两个值是否不相等，不相等返回true，否则false * 使用！= 来做不相等运算 * 不相等也会对变量进行自动的类型转换，如果转换后相等则返回false * * === * 全等 * 用来判断两个值是否全等，和相等类似，不同的是不会自动转换类型 * 类型不同直接转换为false * * !== * 不全等 * 不会进行类型转换的不相等 */ var a = 10; console.log(a==4);//false console.log(&quot;1&quot;==1);//true console.log(true==&quot;1&quot;);//true,都是转为number console.log(null==0);//false // undefined 衍生自null // 所以这两个值做相等判断时，会返回true console.log(undefined==null);//true // NaN不和任何值相等，包括本身 console.log(NaN==NaN);//false var b = NaN; // 判断b的值是否是NaN console.log(b==NaN);//false // 可以通过isNaN()函数来判断 // 是则返回true，否则false console.log(isNaN(b)); console.log(&quot;1&quot;!= 1);//false console.log(&quot;1&quot;===1);//false console.log(null===undefined);//false console.log(&quot;1&quot; !== 1);//true &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、条件运算符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 条件运算符也叫三元运算符 * 语法： * 条件表达式?语句1:语句2 * 执行的流程： * 条件运算符在执行的时候，首先对表达式进行求值， * 如果该值为true，则执行语句1，并返回执行结果 * 如果该值为false，则执行语句2，并返回执行结果 * * 如果条件的表达式的求值结果是一个非布尔值，则 * 会将其转换为布尔值再进行运算 */ true?alert(&quot;666&quot;):alert(&quot;111&quot;);//666 var a = 10; var b = 20; a &gt; 20 ? alert(a):alert(b); // 获取a和b中的最大值 var max = a &gt; b ? a : b; // alert(max); // 获取a，b，c中的最大值 // 这种写法可读性极差，极不推荐 var max = a &gt; b ? (a &gt; c ? a : c) : ( b &gt; c ? b : c ) ; alert(max); &quot;hello&quot;?alert(&quot;666&quot;):alert(&quot;111&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、运算符的优先级12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * ,运算符 * 可以分割多个语句，一般在声明多个变量的时候使用 */ var a,b,c; //可以同时声明多个变量，也可同时赋值 var a=1,b=2,c=3; /** * 和数学中一样，在js中运算符也有优先级 * 比如：先乘除后加减 * * 在js中有一个运算符优先级的表， * 在表中越靠上优先级越高，优先级越高越优先计算 * 如果优先级一样，则从左往右计算 * 但是这个表我们并不需要记忆，如果遇到优先级不清楚的使用（）括起来 * */ // var result = 1 + 2 * 3; // 如果或的优先级高，或者两个一样高，则返回3 // 如果与的优先级高，则返回1 var result = 1 || 2 &amp;&amp; 3;//1 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、代码块12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 我们的程序是由一条一条语句构成的 * 语句是按照从上向下的顺序一条一条执行的 * 在JS中可以使用&#123;&#125;来为语句进行分组， * 同一个&#123;&#125;中的语句我们称为是一组语句 * 他们要么都执行，要么都不执行 * 一个&#123;&#125;中的语句我们也称为一个代码块 * * JS中的代码块，只具有分组的作用，没有其他的作用 * 代码块中的内容，在外部是完全可见的 */ &#123; var a = 10; alert(&quot;hello&quot;); console.log(&quot;你好&quot;); document.write(&quot;代码块&quot;); &#125; alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、流程控制语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 流程控制语句 * -JS中的程序是从上到下一行一行执行的 * -通过流程控制语句可以控制程序执行流程 * 使程序可以根据一定的条件来选择执行 * -语句的分类： * 1条件判断语句 * 2条件分支语句 * 3循环语句 * * 条件判断语句： * -使用条件判断语句可以在执行某个语句之前进行判断， * 如果条件成立才会执行语句，条件不成立则语句不执行 * -if语句 * -语法一： * if(条件表达式)&#123; * 语句1 * .... * &#125; * if语句在执行时，会先对条件表达式进行求值判断， * 如果条件表达式的值为true，则执行if后的语句 * 如果条件表达式的值为false，则不会执行if后的语句 * if语句执行控制紧随其后的那个语句 * 如果希望if语句可以控制多条语句，可以将这些语句统一放在代码块中 * if语句后代码块不是必须的，但是在开发中尽量写上代码块，即使if后只有一条语句 */ if(true) alert(&quot;你猜我出来吗？&quot;); var a = 10; if(a&gt;10) alert(&quot;a比10大&quot;); alert(&quot;谁也管不了我&quot;); if(a&gt;10)&#123; alert(&quot;a比10大&quot;); alert(&quot;现在有人管我了&quot;); &#125; var a = 15; if(a&gt;10 &amp;&amp; a&lt;=20)&#123; alert(&quot;a大于10,并且a小于等于20&quot;); &#125; if(a&gt;10 || a&lt;=20)&#123; alert(&quot;a大于10,并且a小于等于20&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 五、Day41、流程控制语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 流程控制语句 * -JS中的程序是从上到下一行一行执行的 * -通过流程控制语句可以控制程序执行流程 * 使程序可以根据一定的条件来选择执行 * -语句的分类： * 1条件判断语句 * 2条件分支语句 * 3循环语句 * * 条件判断语句： * -使用条件判断语句可以在执行某个语句之前进行判断， * 如果条件成立才会执行语句，条件不成立则语句不执行 * -if语句 * -语法一： * if(条件表达式)&#123; * 语句1 * .... * &#125; * if语句在执行时，会先对条件表达式进行求值判断， * 如果条件表达式的值为true，则执行if后的语句 * 如果条件表达式的值为false，则不会执行if后的语句 * if语句执行控制紧随其后的那个语句 * 如果希望if语句可以控制多条语句，可以将这些语句统一放在代码块中 * if语句后代码块不是必须的，但是在开发中尽量写上代码块，即使if后只有一条语句 */ if(true) alert(&quot;你猜我出来吗？&quot;); var a = 10; if(a&gt;10) alert(&quot;a比10大&quot;); alert(&quot;谁也管不了我&quot;); if(a&gt;10)&#123; alert(&quot;a比10大&quot;); alert(&quot;现在有人管我了&quot;); &#125; var a = 15; if(a&gt;10 &amp;&amp; a&lt;=20)&#123; alert(&quot;a大于10,并且a小于等于20&quot;); &#125; if(a&gt;10 || a&lt;=20)&#123; alert(&quot;a大于10,并且a小于等于20&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 六、Day51、if语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * if语句 * 语法二： * if(条件表达式)&#123; * 语句... * &#125;else&#123; * 语句... * &#125; * 当语句执行时，会先对if后的条件表达式进行求值判断， * 如该值为true，则执行if后的语句 * 如该值为false，则执行else后的语句 * * 语法三： * if(条件表达式)&#123; * 语句... * &#125;else if(条件表达式)&#123; * 语句... * &#125;else &#123; * 语句... * &#125; * * 从上到下依次对条件表达式进行求值判断 * 该语句只会有一个代码块执行 * 注意条件逻辑的顺序 */ var age = 50; if(age&gt;=60)&#123; alert(&quot;你该退休了&quot;); &#125;else&#123; alert(&quot;你还不用退休&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、if练习123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 从键盘输入小明的期末成绩 * 当成绩为100时，‘奖励一辆BMW’ * 当成绩为80-90时，奖励一台iphone14 * 当成绩为60-80时，奖励参考书 * 当其他时，奖励大嘴巴子 */ // var scode = 50; // prompt();可以弹出一个提示框，该提示框会带有一个文本框 // 用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数 // 该字符串将会作为提示框的提示文字 // 用户输入的内容将作为函数的返回值返回，可以定义一个变量来接收该内容 var score = prompt(&quot;请输入小明的期末成绩&quot;); if(score==100)&#123; alert(&quot;BWM&quot;); &#125;else if(score&gt;=80 &amp;&amp; score&lt;=90)&#123; alert(&quot;iphone14&quot;); &#125;else if(score&gt;=60 &amp;&amp; score&lt;80)&#123; alert(&quot;参考书&quot;); &#125;else&#123; alert(&quot;大嘴巴子&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、if练习12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 女方嫁女儿，条件： * 高：180cn以上，富：1000万以上，颜值：90以上 * 如果三个条件都满足，则“我一定要嫁给他” * 如果只有其中一个条件满足，则“嫁吧，比上不足比下有余” * 如果三个条件都不满足，则：&quot;不嫁&quot; */ var height = prompt(&quot;你多高啊？&quot;); var money = prompt(&quot;你有多少钱？&quot;); var appearance = prompt(&quot;你长什么样？&quot;); if(height&gt;=180&amp;&amp;money&gt;=1000&amp;&amp;appearance&gt;=90)&#123; alert(&quot;我要嫁给你！&quot;); &#125;else if(height&gt;=180||money&gt;=1000||appearance&gt;=90)&#123; alert(&quot;还行吧，就嫁你了&quot;); &#125;else&#123; alert(&quot;算了，不嫁了&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、if练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 键盘输入三个整数，对他们进行排序，并且从小到大输出 /** * 返回值是String类型的 */ var num1 = +prompt(&quot;请输入第一个整数&quot;); var num2 = +prompt(&quot;请输入第二个整数&quot;); var num3 = +prompt(&quot;请输入第三个整数&quot;); // 找到最小的 if(num1&lt;num2 &amp;&amp; num1&lt;num3)&#123; // num1最小，比较num2和num3 if(num2&lt;num3)&#123; // num2小 alert(num1+&quot;,&quot;+num2+&quot;,&quot;+num3); &#125;else&#123; alert(num1+&quot;,&quot;+num3+&quot;,&quot;+num2); &#125; &#125;else if(num2&lt;num1&amp;&amp;num2&lt;num3)&#123; // num2最小，比较num1和num3 if(num1&lt;num3)&#123; // num1小 alert(num2+&quot;,&quot;+num1+&quot;,&quot;+num3); &#125;else&#123; alert(num2+&quot;,&quot;+num3+&quot;,&quot;+num1); &#125; &#125;else&#123; // num3最小，比较num2和num1 if(num2&lt;num1)&#123; // num2小 alert(num3+&quot;,&quot;+num2+&quot;,&quot;+num1); &#125;else&#123; alert(num3+&quot;,&quot;+num1+&quot;,&quot;+num2); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、条件分支语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 条件分支语句也叫switch语句 // 根据num的值，输出对应的中文 /** * 语法： * switch(条件表达式)&#123; * case 条件表达式: * 语句 * break; * case 条件表达式: * 语句 * break; * case 条件表达式: * 语句 * break; * case 条件表达式: * 语句 * break; * defaukt: * 语句 * break; * &#125; * * 执行流程： * switch...case...语句 * 在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 * 如果比较结果为true，则从当前case处开始执行代码 * 如果比较结果为false，则继续向下比较 * 注意：如果case分支没有break，则会往下执行到代码结束 * 如果所有case语句条件都不满足。则执行default语句 */ var num = +prompt(&quot;请输入一个4以内的整数：&quot;); switch(num)&#123; case 1 : alert(&quot;一&quot;); break; case 2 : alert(&quot;二&quot;); break; case 3 : alert(&quot;三&quot;); break; case 4 : alert(&quot;四&quot;); break; default: alert(&quot;只能在4以内哦&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、switch语句练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 对于成绩大于60分的，输出“合格”，低于60分的，输出不合格 * 6x / 10 = 6 * 7x / 10 = 7 * ... */ /* var score = 60; switch(parseInt(score/10))&#123; case 10: case 9: case 8: case 7: case 6: alert(&quot;合格&quot;); break; default: alert(&quot;不合格&quot;); break; &#125; */ var score = 60; switch(true)&#123; case score&gt;=60: alert(&quot;合格&quot;); break; default: alert(&quot;不合格&quot;); break; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、循环语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 向网页中输出连续数字 */ document.write(1+&quot;&lt;br /&gt;&quot;); document.write(2+&quot;&lt;br /&gt;&quot;); document.write(3+&quot;&lt;br /&gt;&quot;); document.write(4+&quot;&lt;br /&gt;&quot;); /* 循环语句： 通过循环语句可以反复执行一段代码多次 while循环 -语法： while(条件表达式)&#123; 语句（循环体） ... &#125; - while语句在执行时， 先对条件表达式进行求值判断， 如果值为true，则执行循环体， 循环体执行完毕后，继续对表达式进行判断 如果为true则继续执行循环体，以此类推， 直到为false时退出 do...while循环 语法： do&#123; 语句... &#125;while(条件表达式) 执行流程： 在执行时，先执行循环体， 循环体执行完毕后，再对while的条件表达式进行判断 如果为true，继续执行循环体，以此类推， 直到为false时退出循环 实际上这两个语句功能类似， 但是注意do...while一定会执行一次 */ /**像这种将条件表达式写为true的循环，叫做死循环 * 该循环不会停止·，，除非浏览器关闭，死循环在开发中慎用 * 可以使用break，来终止循环 * */ // while(true)&#123; // alert(n++); // if(n==10)&#123; // break; // &#125; // &#125; // 创建一个循环，往往要有三个步骤 // 1初始化一个变量 var i = 0; // 2在循环中设置一个条件表达式 /* while(i&lt;=10)&#123; // alert(i); // 3定义一个更新表达式，每次更新初始化变量 // if(i==3)&#123; // continue; // &#125; document.write(i++ +&quot;&lt;br /&gt;&quot;); i++; &#125; */ do&#123; document.write(i++ +&quot;&lt;br /&gt;&quot;); &#125;while(i&lt;=10) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 8、while循环语句练习123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年 * * 1000 1000*1.05 * 1050 1050*1.05 */ // 定义一个变量，表示本金 var money = 1000; var i = 0; while(money&lt;5000)&#123; money = money*1.05; // 年数+1 i++; &#125; alert(&quot;花费了&quot;+i+&quot;年,&quot;+&quot;得到了&quot;+money+&quot;元&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 七、Day61、while练习1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 从键盘输入小明的期末成绩 * 当成绩为100时，‘奖励一辆BMW’ * 当成绩为80-90时，奖励一台iphone14 * 当成绩为60-80时，奖励参考书 * 当其他时，奖励大嘴巴子 */ // var scode = 50; // prompt();可以弹出一个提示框，该提示框会带有一个文本框 // 用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数 // 该字符串将会作为提示框的提示文字 // 用户输入的内容将作为函数的返回值返回，可以定义一个变量来接收该内容 while(true)&#123; var score = prompt(&quot;请输入小明的期末成绩&quot;); if(score&gt;=0&amp;&amp;score&lt;100)&#123; break; &#125; alert(&quot;请输入有效的分数&quot;); &#125; if(score==100)&#123; alert(&quot;BWM&quot;); &#125;else if(score&gt;=80 &amp;&amp; score&lt;=99)&#123; alert(&quot;iphone14&quot;); &#125;else if(score&gt;=60 &amp;&amp; score&lt;80)&#123; alert(&quot;参考书&quot;); &#125;else&#123; alert(&quot;大嘴巴子&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、for循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* for语句。也是一个循环语句，也成为for循环 在for循环中，为我们提供了专门位置用来放三个表达式 1、初始化表达式 2、条件表达式 3、更新表达式 for循环的语法： for(初始化表达式，条件表达式，更新表达式)&#123; 语句... &#125; 执行流程：先初始表达式，初始变量，只执行一次 再条件表达式，判断是否执行循环 最后更新表达式，继续执行条件表达式判断是否执行循环 */ // 创建一个执行10次的while循环 // 初始化表达式 /* var i = 0; // 创建一个循环，定义条件表达式 while(i&lt;10)&#123; // 设置更新表达式 alert(i++); &#125; */ for(var i = 0; i &lt; 10 ; i++)&#123; alert(i); &#125; // for语句中三部分都可以省略，也可以写在外部 for(;i&lt;10;)&#123; alert(i++); &#125; // 如果for循环中不写任何表达式，则变成死循环 for(;;)&#123; alert(&quot;hello&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、for循环练习123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var result = 0; for(var i = 1 ; i &lt; 100 ; i++)&#123; if(i%2!=0)&#123; result = result + i; &#125; &#125; alert(result); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、for循环练习—–100内7的倍数123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var result = 0; var j=0; for(var i=1;i&lt;100;i++)&#123; if(i%7==0)&#123; result = result+i; j++; &#125; &#125; alert(&quot;100以内7的倍数的个数为：&quot;+j+&quot;个，&quot;+&quot;总和为：&quot;+result); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、for循环练习—-水仙花数123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 水仙花数是指一个3位数，他的每位数的3次幂之和等于他的本身 // 求1000以内的水仙花数 for(var i=100;i&lt;1000;i++)&#123; // 个位数 var a=i%10 ; // 十位数 var b= parseInt(i%100/10); // 百位数 var c =parseInt(i/100); if(a*a*a + b*b*b + c*c*c==i)&#123; console.log(i); &#125; &#125; // &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、for循环练习1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /** * 在页面中接收一个用户输入的数字，判断该数是否为质数 * */ var num = prompt(&quot;请输入一个大于1的整数：&quot;); // 判断值是否合法 if(num&lt;1)&#123; alert(&quot;该数不合法！&quot;); &#125;else&#123; // 创建变量保存当前状态 var flag = true; // 判断是否为质数 // 获取2-num之间的数 for(var i = 2;i&lt;num;i++)&#123; // console.log(i); // 判断num是否能给i整数 if(num%i==0)&#123; //num不是质数 flag=false; &#125; &#125; // num是质数 if(flag)&#123; alert(num + &quot;是质数&quot;); &#125;else&#123; alert(num+&quot;不是质数&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、嵌套的for循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script&gt; /* 通过程序，输出如下的图形： * ** *** **** ... */ for(var i=0;i&lt;10;i++)&#123; for(var j=0;j&lt;=i;j++)&#123; document.write(&quot;*&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); &#125; // 页面的控制台默认独占一块，不同的consloe语句，输出在不同行，同一个可以用换行符隔开 // console.log(&quot;111&quot;+&quot;\\n&quot;+&quot;222&quot;); document.write(&quot;&lt;br /&gt;&quot;); document.write(&quot;&lt;br /&gt;&quot;); for(var i=10;i&gt;=0;i--)&#123; for(var j=0;j&lt;i;j++)&#123; document.write(&quot;*&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); document.write(&quot;&lt;br /&gt;&quot;); for(var i=0;i&lt;10;i++)&#123; for(var j=0;j&lt;10-i;j++)&#123; document.write(&quot;*&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); document.write(&quot;&lt;br /&gt;&quot;); for(var i=10;i&gt;=0;i--)&#123; for(var j=10-i;j&gt;0;j--)&#123; document.write(&quot;*&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); &#125; &lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 8、打印99乘法表123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 打印乘法表 for(var i=1;i&lt;=9;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write(&quot;&lt;span&gt;&quot;+j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&lt;/span&gt;&quot;); &#125; document.write(&quot;&lt;br /&gt;&quot;); &#125; &lt;/script&gt; &lt;style&gt; body&#123; width: 1000px; &#125; span&#123; display: inline-block; width: 80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 9、打印出1-100的所有质数123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; for(var i=2;i&lt;=100;i++)&#123; var flag=true; for(var j=2;j&lt;i;j++)&#123; if(i%j==0)&#123; flag=false; &#125; &#125; if(flag)&#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 八、Day71、break和continue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // break关键字可以用来退出switch或循环语句 // 不能在if语句中使用break和continue // break关键字，会立即终止最近的那个循环语句，嵌套循环一个break只跳出一层 /* for(var i=0;i&lt;5;i++)&#123; console.log(i); break; &#125; */ // 这种写法没问题，break对for起作用 /* for(var i=0;i&lt;5;i++)&#123; console.log(i); if(i==2)&#123; break; &#125; &#125; */ /* for(var i=0;i&lt;5;i++)&#123; console.log(&quot;@外层循环&quot;); for(var j=0;j&lt;5;j++)&#123; break; console.log(&quot;@内层循环&quot;); &#125; &#125; */ // 可以为循环语句创建一个label，来标记当前的循环 // 语法： 标签名:循环语句 /* 使用break语句时，可以在break后跟着一个标签名， 这样break将会结束指定的循环，而不是最近的 */ /* outer: for(var i=0;i&lt;5;i++)&#123; console.log(&quot;@外层循环&quot;); inner: for(var j=0;j&lt;5;j++)&#123; console.log(&quot;@内层循环&quot;); break outer; &#125; &#125; */ /* continue用来跳过当次循环 同样continue也是默认只对离他最近的循环起作用 */ /* for(var i=0;i&lt;5;i++)&#123; if(i==2)&#123; continue; &#125; console.log(i); &#125; */ /* for(var i=0;i&lt;5;i++)&#123; for(var j=0;j&lt;5;j++)&#123; if(j==1)&#123; continue; &#125; console.log(&quot;@内层循环&quot;+j); &#125; console.log(&quot;@外层循环&quot;+i); &#125; */ outer: for(var i=0;i&lt;5;i++)&#123; inter: for(var j=0;j&lt;5;j++)&#123; if(j==1)&#123; continue outer; &#125; console.log(&quot;@内层循环&quot;+j); &#125; console.log(&quot;@外层循环&quot;+i); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、质数练习补充12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; console.time(&quot;a&quot;); for(var i=2;i&lt;=100000;i++)&#123; // 计算程序执行时间 /* 开启计时器 参数是计时器的名字，这个参数是计时器的标识 */ var flag=true; var result = Math.sqrt(i); for(var j=2;j&lt;=result;j++)&#123; if(i%j==0)&#123; flag=false; // 现在i已经不可能是是质数了，可以直接退出循环 break; &#125; &#125; if(flag)&#123; // console.log(i); &#125; &#125; // console.timeEnd()用来停止一个计时器，需要一个计时器的名字作为参数 console.timeEnd(&quot;a&quot;); /* 36 1 36 2 18 3 12 4 9 6 6 */ // 开方 /* var result = Math.sqrt(16);\\ console.log(result); */ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* JS中的数据类型 - String 字符串 -Number 数值 - Boolean 布尔值 - Null 空值 - Undefined 未定义 以上五种类型属于基本数据类型，以后我们看到的值 只要不是上边的五种，就全都是对象 - Object 基本数据类型都是单一的值&quot;Hello&quot; 123 true, 值之间没有任何的联系 var name = &quot;swk&quot;; var gender = &quot;男&quot;; var age = 18; 如果使用基本数据类型表示，这些变量都是独立的，不能成为一个整体 对象属于一种复合的数据类型，在对象中可以保存多个不同的数据类型的属性 对象的分类： 1、内建对象 -由ES标准中定义的对象，在任何的ES的实现中都可以使用 -比如：Math String Number Boolean Function Object ..... 2、宿主对象 -有JS的运行环境提供的对象，目前主要指由浏览器提供的对象 -比如 BOM DOM 3、自定义对象 -由开发人员自己创建的对象 */ // 创建对象 /* 使用new关键字调用的函数，是构造函数construtor 构造函数是专门用来创建对象的函数 使用typeof检查一个对象是，会返回object */ var obj = new Object(); // console.log(obj); // console.log(typeof Obj); /* 在对象中保存的值称为属性 向对象添加属性 语法：对象.属性名 = 属性值; */ obj.name = &quot;孙悟空&quot;; obj.gender = &quot;男&quot;; obj.age = 18 ; console.log(obj); /* 读取对象中的属性 语法： 对象.属性名 如果读取对象中没有的属性，不会报错而返回undefined */ var name = obj.name; console.log(name); /* 修改对象的属性值 语法： 对象.属性名 = 属性值 ; */ obj.name = &quot;Tom&quot;; console.log(obj.name); /* 删除对象的属性 语法： delete 对象.属性名; */ delete obj.name; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、对象的属性名和属性值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var obj = new Object(); /* 向对象中添加属性 属性名： -对象的属性名不强制要求遵守标识符的规定 什么乱七八糟的名字都可以使用 - 但是我们使用时还是尽量按照标识符的规范去做 */ obj.name = &quot;孙悟空&quot;; // obj.var = &quot;Tom&quot;; /* 如果需要使用特殊的属性名，不能采用.的方式来操作 需要使用另一种方式 语法: 对象[&quot;属性名&quot;] = 属性值 ; 读取属性时也要采用这种方式 使用[]这种方式去操作属性，更加的灵活 在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性 */ obj[&quot;123&quot;] = 789; // console.log(obj[&quot;123&quot;]); var n = &quot;123&quot;; obj[n] = &quot;hello&quot;; // console.log(obj[n]); /* 属性值 JS对象的属性值，可以使任意的数据类型 甚至是一个对象 */ obj.test = true; obj.test = null; obj.test = undefined; // console.log(obj.test); // 创建一个对象 var obj2 = new Object(); obj2.name = &quot;猪八戒&quot;; obj2.age = 500; // 将obj2设置为obj的属性 obj.test = obj2; console.log(obj); console.log(obj.test); console.log(obj.test.name); /* in运算符 -通过该运算符可以查看一个对象是否含有指定的属性 如果月返回true，没有则返回false -语法： &quot;属性名&quot; in 对象 */ console.log(&quot;test2&quot; in obj); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、基本和引用数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object JS中的变量存放在栈内存中 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在的，修改一个变量不会影响其他的变量 引用数据类型，对象是保存在堆内存中的 每次创建一个新的对象，就会在堆内存中开辟一个新的空间 而变量的保存的是对象的内存地址（对象的引用），如果两个 变量保存的是同一个对象的引用，当一个通过一个变量修改属性时， 另外一个也会受到影响 */ var a = 123; var b = a; a++; // console.log(&quot;a=&quot;+a); // console.log(&quot;b=&quot;+b); var obj = new Object(); obj.name = &quot;swk&quot;; var obj2 = obj; obj.name = &quot;我变了&quot;; /* console.log(&quot;obj的name=&quot;+obj.name); console.log(&quot;obj2的name=&quot;+obj2.name); */ obj2 = null; /* console.log(obj); console.log(obj2); */ var c = 10; var d = 10; // console.log(c==d); var obj3 = new Object(); var obj4 = new Object(); obj3.name = &quot;沙和尚&quot;; obj4.name = &quot;沙和尚&quot;; /* */ console.log(obj3.name==obj4.name);//false &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、对象字面量12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个对象 var obj = new Object(): 使用字面量创建一个对象 var obj = &#123;&#125; */ var obj = &#123;&#125;; console.log(obj); obj.name = &quot;Tom&quot;; // 使用对象字面量。可以在创建对象时，直接指定对象中的属性 // 对象字面量的属性名可以加引号也可以不加，建议不加 // 如果要使用一些特殊的名字，则必须要加引号 // 属性名和属性值是一组一组的名值对结构 /* 名和值之间，使用:连接，多个名值之间使用,隔开 */ var obj2 =&#123; name:&quot;猪八戒&quot;, age:18, test:&#123; name: &quot;沙和尚&quot; &#125; &#125;; console.log(obj2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 函数 函数也是一个对象 函数中可以封装一些功能（代码），需要时可以执行这些功能（代码） 函数可以保存一些代码在需要时调用 使用typeof检查一个函数对象时，会返回function */ /* &#123; console.log(&quot;第一行代码&quot;); console.log(&quot;第二行代码&quot;); console.log(&quot;第三行代码&quot;); &#125;*/ /* 创建一个函数对象 可以将需要封装的代码以字符串的形式传递给函数 我们在实际开发中很少使用构造函数来创建一个函数对象 */ var fun = new Function(&quot;console.log(&#x27;这是我的第一个函数&#x27;);&quot;); console.log(fun); /* 封装到函数中的代码不会立刻执行 函数的代码会在函数调用时执行 调用函数 语法： 函数对象() 当调用函数时，函数中封装的代码会按照顺序执行 */ // fun(); // 使用函数声明来创建一个函数对象 /* 语法： function 函数名 ([形参1,形参2..])&#123; 语句... &#125; */ function fun2()&#123; alert(&quot;我是第二个函数&quot;); alert(&quot;哈哈哈&quot;); &#125; console.log(fun2); // 调用fun2 // fun2(); /* 使用函数表达式来创建一个函数对象 var 函数名 = function([形参1,形参2...])&#123; 语句... &#125; */ // 将匿名函数赋值给fun3 var fun3 = function()&#123; alert(&quot;我是第三个函数&quot;); &#125;; // 调用fun3 fun3(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 8、函数的参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 定义一个求两数和的函数 /* function sum()&#123; console.log(1+1); &#125; */ /* 可以在函数的()中指定一个或多个形参（形式参数） 多个形参之间使用,隔开，声明形参相当于在函数内部声明了对应的变量 */ function sum(a,b)&#123; console.log(a+b); &#125; /* 在调用函数时，可以在()中指定实参（实际参数） 实参将会赋值给函数中对应的形式参数 */ // sum(3,4); /* 调用函数时，解析器不会检查实参的类型 所以要注意，是否有可能会接受到非法的参数，如果有可能则需要对参数进行类型的检查 函数的实参可以是任意的数据类型 */ // sum(&quot;123&quot;,false); /* 调用函数时，解析器也不会检查实参的数量 多余的实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined */ sum(123,456,&quot;hello&quot;,true); sum(123); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 9、返回值12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个函数，用来计算三个数的和 可以使用return来设置函数的返回值 语法： return 值; return 后的值将会作为函数的执行结果返回 可以定义一个变量来接收这个结果 在函数中return后的语句都不会执行 如果在return语句后不加任何值则默认return undefined 如果函数不写return语句，则也返回undefined return 后可以跟任意类型的值 */ function sum(a,b,c)&#123; // alert(a+b+c); var result = a+b+c; return result; alert(&quot;我不会执行的！&quot;); &#125; //调用函数 // r的值就是函数返回的执行结果 var r = sum(1,2,3); alert(r); var a = alert(&quot;hello&quot;); console.log(a);//undefined &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 10、练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 定义一个函数。判断一个数字是否是偶数，如果是返回true，否则返回false */ function isEven(num)&#123; /* if(num%2==0)&#123; return true; &#125;else&#123; return false; &#125; */ // 优化 return num%2==0; &#125; var result = isEven(1828); // console.log(result); /* 定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果 */ function area(r)&#123; return 3.14*r*r; &#125; result = area(5); // console.log(result); /* 创建一个函数，可以在控制台中输出一个人的信息 可以输出一个人的name，age，gender，address 实参可以是任意的数据类型，也可以是一个对象 当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递 */ function sayHello(name,age,gender,address)&#123; return &quot;我是&quot;+name+&quot;,今年&quot;+age+&quot;岁了,我是&quot;+gender+&quot;的,我的住址是&quot;+address; &#125; // alert(sayHello(&#x27;孙悟空&#x27;,18,&#x27;男&#x27;,&#x27;花果山&#x27;)); // 创建一个对象 var obj = &#123; name: &#x27;孙悟空&#x27;, age: 18, gender: &#x27;男&#x27;, address: &#x27;花果山&#x27; &#125; function sayHello(o)&#123; return &quot;我是&quot;+obj.name+&quot;,今年&quot;+obj.age+&quot;岁了,我是&quot;+obj.gender+&quot;的,我住在&quot;+obj.address; &#125; // alert(sayHello(obj)); /* 实参可以是一个对象，也可以是一个函数对象 */ function fun(a)&#123; // a(obj); alert(a); &#125; // fun(sayHello); // fun(function()&#123;alert(&quot;hello&quot;)&#125;); /* area() 调用函数 相对于使用函数的返回值 area 函数对象 相对于直接使用函数对象 */ fun(area(10)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 11、return123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function fun()&#123; alert(&quot;函数要执行了&quot;); for(var i=0;i&lt;5;i++)&#123; if(i==2)&#123; // 使用break退出当前循环 // break; // 使用continue跳过当次循环 // continue; // 使用return可以结束整个函数 return; &#125; console.log(i); &#125; alert(&quot;函数执行结束了&quot;); &#125; // fun(); /* 返回值可以是任意的数据类型 也可以是一个对象，也可以是一个函数 */ function fun2()&#123; var obj = &#123; name: &#x27;猪八戒&#x27;, age: 18 &#125; // return 10; return obj; // return &#123;name:&#x27;猪八戒&#x27;,age:18&#125; &#125; var a = fun2(); // console.log(&quot;a=&quot;+a); function fun3()&#123; // 在函数内部声明一个函数 function fun4()&#123; alert(&quot;我是fun4&quot;); &#125; // 将fun4函数对象作为返回值返回 return fun4; &#125; a = fun3(); console.log(a); // a(); fun3()(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 12、立即执行函数123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 函数对象() /* 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行函数往往只执行一次 */ /* (function()&#123; alert(&quot;我是一个匿名函数&quot;); &#125;)(); */ (function(a,b)&#123; console.log(&quot;a=&quot;+a); console.log(&quot;b=&quot;+b); &#125;)(123,456); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 13、对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个对象 var obj = new Object(); // 向对象中添加属性 obj.name = &quot;孙悟空&quot;; obj.age = 18; // 对象的属性值可以是任何数据类型，也可以是个函数 obj.sayName = function()&#123; console.log(obj.name); &#125;; function fun()&#123; console.log(obj.name); &#125; // console.log(obj.sayName); // 调方法 // obj.sayName(); // 调函数 // fun(); /* 函数也可以成为对象的属性 如果一个函数作为一个对象的属性保存 那么我们称这个函数是这个对象的方法 调用这个函数就说是调用对象的方法（method） 但是它只是名称上的区别 */ // document.write(); // &quot;hello&quot;.toString(); var obj2 = &#123; name: &#x27;猪八戒&#x27;, age:18, sayName:function()&#123; console.log(obj2.name); &#125; &#125;; obj2.sayName(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 14、枚举对象中的属性12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var obj = &#123; name:&quot;swk&quot;, age:18, gender:&#x27;man&#x27;, address:&#x27;hgs&#x27; &#125;; // 枚举对象中的属性 // 使用for...in语句 /* 语法： for(var 变量 in 对象)&#123; &#125; for...in语句中 对象中有几个属性，循环体执行几次 每次执行时，会将对象中的一个属性的名字赋值给变量 */ for(var n in obj)&#123; console.log(&quot;属性名:&quot;+n);//有多少个属性执行多少次循环 console.log(&quot;属性值:&quot;+obj[n]); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 15、全局作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 作用域 -作用域指的是一个变量的作用的范围 -在js中一共有两种作用域 1、全局作用域 -直接编写在script标签中的js代码，都在全局作用域中 -全局作用域在页面打开时创建，在页面关闭时销毁 -在全局作用域中有一个全局对象window，我们可以直接使用 它代表的是一个浏览器的窗口，由浏览器创建 -在全局作用域中，创建的变量都会作为window对象的属性保存 创建的函数都会作为window的方法保存 -全局作用于的变量都是全局变量 在页面的任意的部分都可以访问到 2、函数作用域 */ // console.log(window);//object window var a =10; // console.log(window.a); function fun()&#123; console.log(&quot;我是fun函数&quot;); &#125; // window.fun(); // window.alert(&quot;hello&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 16、函数的声明提前12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 变量的声明提前 -使用var关键字声明的变量，会在所有代码执行之前被声明（不赋值） var a = 123; 相对于 先在开头声明var a;然后在赋值语句中赋值 a = 123 但是如果声明变量时不使用var关键字，则变量不会被声明提前，提前使用a会报错 函数的声明提前 -使用函数声明形式创建的函数function 函数()&#123;&#125; 它会再所有代码执行之前就被创建，所以我们也可以在函数声明前调用 -使用函数表达式创建的函数，不会被声明提前，所以不能提前调用 */ /* console.log(&quot;a=&quot;+a); var a = 123; */ // fun(); // fun2();//报错 // console.log(fun2);//undefined function fun()&#123; console.log(&quot;我是fun函数&quot;); &#125; var fun2 = function()&#123; console.log(&quot;我是fun2函数&quot;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 17、函数作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 函数作用域 -调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 -每调用一次函数就会创建一个新的函数作用域，他们中间是相互独立的 -在函数作用域中可以访问到全局作用域的变量 -在函数作用域中无法访问到函数作用域的变量 -在函数作用域中操作一个变量时，他会现在自身的作用域中寻找，如果有就用 没有就向上一级寻找,直到全局作用域，如果全局作用域也没有就报错 -在函数中要访问全局变量可以使用window对象 */ var a =10; /* var a = 10; function fun()&#123; var a = &quot;我是函数里面的a&quot;; var b = 20; console.log(&quot;a=&quot;+window.a); function fun2()&#123; var a = &quot;我是最里层的a&quot;; console.log(&quot;a=&quot;+window.a); &#125; fun2(); &#125; fun(); */ // console.log(b);//报错 // console.log(&quot;a=&quot;+a); /* 在函数作用域中也有声明提前的特性 使用var关键字声明的变量，会在函数中的所有代码执行之前声明 函数声明也会在函数中所有的代码执行之前执行 */ function fun3()&#123; // console.log(a); var a =23; fun4(); function fun4()&#123; console.log(&quot;我是fun4&quot;); &#125; &#125; // fun3(); /* 在函数中，不使用var声明的变量都会成为全局变量 */ var c =12; function fun5()&#123; console.log(&quot;c=&quot;+c);//12 // var c = 10; // c = 10;//给全局变量重新赋值 // 没有使用var，默认是window全局 d =100; &#125; // fun5(); // console.log(&quot;c=&quot;+c);//10 // console.log(&quot;d=&quot;+d);//100 var e= 25; /* 定义形参就相当于在函数作用域中声明了变量 */ function fun6(e)&#123; alert(e);//undefined &#125; fun6(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 18、DeBug1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; alert(d); var a = 10; var b = &quot;hello&quot;; c = true; function fun()&#123; alert(&quot;hello&quot;); &#125; var d = 35; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 九、Day81、this12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function fun()&#123; /* 解析器在调用函数时每次都会向函数内部传递一个隐含的参数 这个隐含的参数就是this,this指向一个对象 这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 1、以函数的形式调用时，this永远是window 2、以方法的形式调用时，this就是调用它的对象 */ var name = &quot;window&quot;; function fun(a,b)&#123; // console.log(&quot;a=&quot;+a+&quot;,b=&quot;+b); console.log(this); &#125; fun();//this指向window // 创建一个对象 var obj = &#123; name: &quot;tom&quot;, sayName:fun &#125;; var obj2 = &#123; name: &quot;joen&quot;, sayName:fun &#125;; obj.sayName();//this指向obj &#125; fun(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、this2.0123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个name变量 var name = &quot;全局&quot;; // 创建一个fun()函数 function fun()&#123; // 只会得到全局的name // console.log(name); // 现在可变了 console.log(this.name); &#125; // 创建两个对象 var obj = &#123; name:&quot;swk&quot;, sayName:fun &#125;; var obj2 = &#123; name:&quot;shs&quot;, sayName:fun &#125;; fun();//全局 obj.sayName();//全局 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、对象—工厂方法创建对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个对象 */ /* var obj = &#123; name:&quot;孙悟空&quot;, age:18, gender:&quot;man&quot;, sayName:function()&#123; alert(this.name); &#125; &#125; */ /* var ob2 = &#123; name:&quot;猪八戒&quot;, age:28, gender:&quot;man&quot;, sayName:function()&#123; alert(this.name); &#125; &#125; var obj3 = &#123; name:&quot;沙和尚&quot;, age:38, gender:&quot;man&quot;, sayName:function()&#123; alert(this.name); &#125; &#125; */ /* 使用工厂方法创建对象 */ function createPerson(name,age,gender)&#123; // 创建一个新的对象 var obj = new Object(); // 向对象中添加属性 obj.name=name; obj.age=age; obj.gender=gender; obj.sayName=function()&#123; alert(this.name); &#125;; // 返回对象 return obj; &#125; var obj2 = createPerson(&quot;猪八戒&quot;,28,&quot;man&quot;); var obj3 = createPerson(&quot;沙和尚&quot;,38,&quot;man&quot;); // console.log(obj2); // console.log(obj3); // obj2.sayName(); // obj.sayName();//孙悟空 // obj2.sayName();//猪八戒 /* 用来创建狗的对象 */ function createDog(name,age)&#123; var obj = new Object(); obj.name=name; obj.age=age; obj.sayHello=function()&#123; alert(&quot;汪汪~~&quot;); &#125; return obj; &#125; /* 使用工厂方法创建的对象，使用的构造函数都是object 所以创建的对象都是Object这个类型 就导致我们无法区分 */ // 创建一个狗对象 var dog1 = createDog(&quot;旺财&quot;,3); console.log(dog); console.log(obj2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个构造函数，专门用来创建Person对象的 构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数习惯上首字母大写 构造函数和普通函数的区别就是调用方式的不同 普通函数是直接调用，而构造函数小使用new关键字来调用 构造函数的执行流程： 1、立刻创建一个新的对象 2、将新建的对象设置为函数中的this 在构造函数中可以使用this来引用新创建的对象 3、逐行执行函数中的代码 4、将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个构造函数创建的实例，称为是该类的实例 this情况： 1、当以函数形式调用时，this就是window 2、当以方法的形式调用时，谁调用方法this就是谁 3、当以构造函数的形式调用时，this就是创建的那个对象 */ function Person(name,age)&#123; // alert(this); this.name = name; this.age=age; this.sayName=function()&#123; alert(this.name); &#125; &#125; function Dog(name,age)&#123; // alert(this); this.name = name; this.age=age; this.sayHello=function()&#123; alert(this.name+&quot;:汪汪~~&quot;); &#125; &#125; var person = new Person(&quot;swk&quot;,18); var person2 = new Person(&quot;zbj&quot;,28); var dog = new Dog(&quot;旺财&quot;,3); // console.log(person); /* person.sayName(); person2.sayName(); dog.sayHello() */; /* 使用instanceof可以检查一个对象是否是一个类的实例 语法： 对象 instanceof 构造函数名 是为true，否则false */ // console.log(person instanceof Person); /* 所有的对象都是Object的后代 所有任何对象和Object做instanceof检查时都返回true */ console.log(person instanceof Object);//true &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、构造函数2.01234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个Person构造函数 -在Person构造函数中，为每一个对象都添加了一个sayName方法 目前我们的方法是在构造函数内部创建的， 也就是构造函数每执行一次就会创建一个新的sayName方法 也就是所以实例的sayName都是唯一的 这样就是导致了构造函数执行一次就会创建一个新的方法 我们完成可以使所有对象共享同一个方法 */ function Person(name,age)&#123; // alert(this); this.name = name; this.age=age; this.sayName = fun; &#125; // 现在只会创建一个 /* 将函数定义在全局作用域中，污染了全局作用域的命令空间 而且定义在全局作用域中也很不安全 */ //将sayName方法在全局作用域中定义 function fun()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;; // 创建一个Person实例 var person = new Person(&quot;swk&quot;,18); var person2 = new Person(&quot;zbj&quot;,28); person.sayName(); person2.sayName(); alert(person.sayName==person2.sayName); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 原型prototype 我们所创建的每一个函数，解析器都会向函数添加一个属性prototype 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 如果函数作为普通函数调用prototype没有任何作用 当函数通过构造函数形式调用时，它所创建的对象中都会有一个隐含的属性 指向构造函数的原型对象，我们可以通过__proto__来访问该属性 原型对象就相当于一个公共的区域，所有同一个累的实例都可以访问到这个原型对象 我们可以将对象中共有的内容，统一设置到原型对象中 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用 如果没有则会去原型对象中寻找，如果找到则直接使用 以后我们创建构造函数时，可以将共有的属性和方法，统一添加到构造函数的原型对象中， 这样不用分别给每一个对象添加，也不会影响到全局作用域，这可以使每个对象都具有这些属性和方法了 */ /* function Person()&#123; &#125; function MyClass()&#123; &#125; */ // console.log(Person.prototype==MyClass.prototype);//false // 向MyClass的原型中添加属性a // MyClass.prototype.a = 123; // 向MyClass的原型中添加一个方法 // MyClass.prototype.sayHello= function()&#123; // alert(&quot;hello&quot;); // &#125;; // var mc = new MyClass(); // var mc2 = new MyClass(); // console.log(mc.__proto__ == MyClass.prototype); // 向mc中添加a属性 // mc.a=&quot;我是mc中的a&quot;; // console.log(mc.a);//我是mc中的a // console.log(mc2.a);//123 // mc.sayHello();//hello function Person(name,age)&#123; // alert(this); this.name = name; this.age=age; // this.sayName = fun; &#125; // 使用原型修改 Person.prototype.sayName=function fun()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;; // 创建一个Person实例 var person = new Person(&quot;swk&quot;,18); var person2 = new Person(&quot;zbj&quot;,28); person.sayName(); person2.sayName(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个构造函数 */ function MyClass()&#123; &#125; // 向MyClass原型中添加一个name属性 MyClass.prototype.name = &quot;我是原型中的name&quot;; var mc = new MyClass(); mc.age=18; // console.log(mc.name); // 使用in检查对象是否含有某个属性时，如果对象中没有，但是原型中有也会返回true // console.log(&quot;name&quot; in mc);//true // 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 // 使用该方法只有当对象自身中含有属性时，才会返回true // console.log(mc.hasOwnProperty(&quot;name&quot;)); // console.log(mc.hasOwnProperty(&quot;hasOwnProperty&quot;));//true，在原型中 /* 原型对象也是对象，所以他也有原型 当我们使用一个对象的属性或方法时，会先在自身找 自身有直接使用 没有则向原型找 还没有则向原型的原型找,直到找到Object对象的原型 Object的对象的原型没有原型，如果在这还找不到，则返回undefined */ // console.log(mc.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));//false // console.log(mc.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;));//true // console.log(mc.__proto__.__proto__.__proto__);//null &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 8、toString123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function Person(name,age,gender)&#123; this.name = name; this.age = age; this.gender = gender; &#125; // 创建一个Person实例 var per = new Person(&quot;孙悟空&quot;,18,&quot;man&quot;); var per2 = new Person(&quot;猪八戒&quot;,18,&quot;man&quot;); // 当我们直接在页面中打印一个对象时，实际上时输出对象的toString()方法的返回值 // 如果我们希望在输出对象时不输出[Object Object]，可以向对象中添加一个toString方法 // Person[name= ,age= ,gender= ,]; /* per.toString = function()&#123; // return &quot;我是一个快乐的小Person&quot;; return &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;,gender=&quot;+this.gender+&quot;]&quot;; &#125; */ // 修改原型的toString Person.prototype.toString = function()&#123; // return &quot;我是一个快乐的小Person&quot;; return &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;,gender=&quot;+this.gender+&quot;]&quot;; &#125; // console.log(per); // console.log(per.__proto__.__proto__.hasOwnProperty(&quot;toString&quot;));//true alert(per); alert(per2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 9、垃圾回收12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 垃圾回收（GC） -就像人生活时间长了会产生垃圾一样，程序运行过程中也会产生垃圾 这些垃圾积攒过多以后，会导致程序运行的速度过慢 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾 -当一个对象没有任何变量或属性对他进行引用，此时我们将永远无法操作该对象 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢 所以这种垃圾必须进行处理。 -在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁 我们不需要也不能进行连接回收的操作。 -我们需要做的只需要将不需要使用的对象设置为null即可 */ var obj = new Object(); // 对象的一系列操作 obj=null; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 10、数组简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 内建对象 宿主对象 自定义对象 数组（Array) -数组也是一个对象 -它和我们普通对象功能类似，也是用来存储一些值的 -不同的是普通对象时使用字符串作为属性名的 而数组使用数字来作为索引操作元素 -索引： 从0开始的整数就是索引 -数组的存储性能要比普通对象要好，在开发中我们经常使用数组来存储一些数据 */ // 创建一个数组对象 var arr = new Array(); //使用tyoeof检查一个数组时，会返回object // console.log(typeof arr); /* 向数组中添加元素 语法：数组[索引]=值 */ arr[0]=10; arr[1]=20; arr[2]=30; arr[3]=40; // arr[9]=11; /* 读取数组中的元素 语法：数组[索引] 如果读取不存在的索引，他不会报错而是返回undefined */ // console.log(arr[2]); /* 获取数组长度 可以使用length属性获取数组的长度 语法：数组.length 对于连续的数组，使用length可以获取到数组的长度（元素的个数） 对于非连续的数组，使用length会获取到数组最大的索引+1 尽量不要创建一个非连续的数组 */ /* console.log(arr.length); console.log(arr); */ // 修改length /* 如果修改的length大于原长度，则多出部分会空出 如果修改的length小于原长度，则多出的元素会被删除 */ // arr.length=10; /* arr.length=2; console.log(arr.length); console.log(arr); */ arr[4]=50; arr[5]=60; // 向数组最后一个位置添加元素 // 语法：数组[数组.length]=值; arr[arr.length]=70; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 11、数组2.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个数组 // var arr = new Array(); /* arr[0]=123; arr.hello=&quot;abc&quot;; console.log(arr.hello); */ // 使用字面量创建一个数组 // 语法： [] // var arr = []; // console.log(typeof arr); // 使用字面量创建数组时，可以直接指定数组中的元素 var arr = [1,34,52,223,11]; // console.log(arr.length); // 使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递 var arr2 = new Array(10,20,30); // console.log(arr2); // 创建一个数组，数组中只有一个元素10 arr=[10]; // 创建一个长度为10的数组 arr2=new Array(10); // console.log(arr2.length); // 数组中的元素可以是任意的数据类型 arr = [&quot;hello&quot;,1,true, null,undefined]; // 也可以是对象 var obj = &#123;name:&quot;孙悟空&quot;&#125;; arr[arr.length]=obj; console.log(arr[5].name); // 也可以是函数 arr=[function()&#123;alert(1)&#125;,function()&#123;&#125;]; // arr[0](); // 也可以是数组,多维数组 arr = [[1,2,3],[4,5,6],[7,8,9]]; console.log(arr[0][0]); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 12、数组的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个数组 var arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;]; /* push() -该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 -可以将要添加的元素作为方法的参数传递 这样这些元素将会自动添加到数组的末尾 -该方法会将数组新的长度作为返回值返回 */ var result = arr.push(&quot;唐僧&quot;,&quot;蜘蛛精&quot;,&quot;白骨精&quot;); // console.log(arr); // console.log(&quot;result=&quot;+result); /* pop() -该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回 */ // arr.pop(); result = arr.pop(); // console.log(arr); // console.log(&quot;result=&quot;+result); /* unshift() -向数组开头添加一个或多个元素，并返回新的数组长度 -向前边插入元素以后，其他元素索引会依次调整 */ arr.unshift(&quot;牛魔王&quot;,&quot;红孩儿&quot;); // console.log(arr); /* shift() -可以删除数组的第一个元素，并将被删除元素作为返回值返回 */ result = arr.shift(); console.log(arr); console.log(&quot;result=&quot;+result); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 13、数组的遍历1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个数组 var arr = [1,2,3,4,5]; // 所谓的遍历数组，就是将数组所有元素都取出来 for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 14、练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function Person(name,age)&#123; this.name=name; this.age=age; &#125; // 修改Person原型的toString Person.prototype.toString=function()&#123; return &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;]&quot;; &#125;; // 创建一个Person对象 var per1 = new Person(&quot;tom1&quot;,18); var per2 = new Person(&quot;tom2&quot;,15); var per3 = new Person(&quot;tom3&quot;,13); var per4 = new Person(&quot;tom4&quot;,20); var per5 = new Person(&quot;tom5&quot;,38); /* 将Person对象放入一个数组中 */ var perArr = [per1,per2,per3,per4,per5]; /* 创建一个函数，可以将perArr中的满18岁的Person提取出来 然后封装到一个新的数组中并返回 arr 形参，要提取信息的数组 */ function getAdult(arr)&#123; // 创建一个新的数组接收 var newArr = []; // 遍历获取数组中所有Person对象 for(var i=0,j=0;i&lt;arr.length;i++)&#123; // 判断Person对象中年龄是否大于等于18 if(arr[i].age&gt;=18)&#123; newArr.push(arr[i]); &#125; &#125; return newArr; &#125; var result = getAdult(perArr); console.log(result); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 15、forEach123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 一般我们都是使用for循环去遍历数组 JS中还为我们提供一个方法，用来遍历数组 forEach() -这个方法只支持IE8以上和其他的浏览器 -若需要兼容IE8，就不要使用 */ // 创建一个数组 var arr = [1,2,3,4,5]; /* forEach()方法需要一个函数作为参数 -像这种函数，由我们创建但是不由我们调用，我们称为回调函数 -数组中有几个元素，函数就会执行几次 每次执行时，浏览器会将遍历到的元素以实参的形式传递进来 我们可以来定义形参，来读取这些内容 -浏览器会在回调函数中传递三个参数： 1、当前正在遍历的元素 2、当前正在遍历的元素的索引 3、当前正在遍历的整个数组对象 */ arr.forEach(function (value,index,obj)&#123; // console.log(&quot;hello&quot;); console.log(&quot;value=&quot;+value); console.log(&quot;index=&quot;+index); console.log(&quot;obj=&quot;+obj); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 16、数组的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var arr = [1,2,3,4,5]; /* slice() -可以用来从数组提取指定的元素 -参数： 1、截取开始位置的索引，包含开始索引 2、截取结束位置的索引，不包含结束索引 第二个参数可以不写，默认是最后位置的索引 -索引可以传递一个负值，如果传递一个负值，则从后往前算 -该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回 */ var result = arr.slice(0,2); // console.log(result); /* splice() -可以用于删除数组中指定的元素 -使用splice()会影响到原数组，会将指定元素从原数组中删除 并将被删除的元素作为返回值返回 -参数， 1、表示开始位置的索引 2、表示删除的数量 3、第三个参数及以后都是插入新元素 可以借助这个在数组中插入一些元素 */ var result2 = arr.splice(1,2,&quot;牛魔王&quot;); console.log(arr); console.log(result2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 17、练习123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个数组 var arr = [1,2,2,2,3,2,1,3,4,5,3]; // 去除数组中重复的数字 for(var i=0;i&lt;arr.length;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; // 删除重复元素 arr.splice(j,1); // 当删除了当前j所在元素后，后边元素会自动补位 // 此时将不会再比较这个元素，我们需要让他再比较一次 j--; &#125; &#125; &#125; alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 18、数组的剩余方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var arr = [1,2,3]; var arr2 = [4,5,6]; /* concat()可以连接两个或多个数组，并将新的数组返回 -该方法不会对原数组产生影响 -也可以直接传元素 */ var result = arr.concat(arr,7,8,9); // console.log(result); /* join() -该方法可以把数组转换为一个字符串 -该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 -在join中可以指定一个字符串作为参数，这个字符串可以作为数组元素的连接符 */ result = arr.join(&quot;-&quot;); // console.log(result); /* reverse() -该方法用于反转数组（前边的去后边，后边的去前边） -会直接修改原数组 */ arr.reverse(); // console.log(arr); arr = [a,f,e,d,c,w,q,r]; /* sort() -可以对数组的元素进行排序 -会影响原数组，默认按照Unicode编码进行排序 */ arr.sort(); console.log(arr); // 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序 // 所以对数字进行排序时，可能会得到错误的结果 arr = [1,44,2,32,54,7]; /* 我们可以自己来指定排序的规则 可以在sort()中添加一个回调函数来指定规则 回调函数中需要定义两个形参 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个等于0的值，则认为两个元素相等，不交换位置 如果需要升序排列。则返回a-b 降序返回b-a */ // arr.sort(); arr.sort(function(a,b)&#123; /* if(a&gt;b)&#123; return 1; &#125;else if(a&lt;b)&#123; return -1; &#125;else&#123; return 0; &#125; */ // 升序 return a-b; &#125;); console.log(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 19、函数的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function fun(a,b)&#123; // alert(&quot;我是fun函数&quot;+this.name); console.log(&quot;a=&quot;+a); console.log(&quot;b=&quot;+b); &#125; /* call()和apply() -这两个方法都是函数对象的方法，需要通过函数对象来调用 -当对函数调用call()和apply()都会调用函数执行 -在调用call和apply可以将一个对象指定为第一个参数 此时这个对象将会作为函数执行时的this -call()方法可以将实参在对象之和依次传递 -apply()方法需要将实参封装到一个数组中统一传递 -this的情况 1、以函数形式调用，this永远是window 2、以方法形式调用，this是调用方法的对象 3、以构造函数的形式调用时，this是新创建的那个对象 4、使用call和apply调用时，this是指定的那个对象 */ var obj = &#123; name:obj, sayName:function()&#123; alert(this.name); &#125; &#125;; var obj2=&#123;&#125;; // fun.call(); // fun.apply(); // fun.call(obj); // obj.sayName.apply(obj2); // fun.call(obj,2,3);//a=2,b=3 // fun.apply(obj,2,3);//报错 fun.apply(obj,[2,3]); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 20、arguments12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 在调用函数时，浏览器每次都会传递进两个隐含的参数 1、函数的上下文对象this 2、封装实参的对象arguments -在arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度 -在调用函数时，我们所传递的实参都会在arguments中保存 -arguments.length可以获取实参的数量 -即使不定义形参，也可以通过arguments来使用实参 arguments[0]表示第一个实参 -它里边有一个属性叫做callee， 这个属性对应一个函数对象，就是当前正在指向的函数对象 */ function fun(a,b)&#123; // console.log(arguments instanceof Array);//false // console.log(Array.isArray(arguments));//false // console.log(arguments.length); // console.log(arguments[1]); console.log(arguments.callee==fun); &#125; fun(1,2); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 21、Date12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* Date对象 -在js中使用Date对象来表示一个时间 */ //创建一个Date对象 //如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间 var d = new Date(); // console.log(d); // 创建一个指定的时间对象 // 需要在构造函数值传递一个表示时间的字符串作为参数 // 日期格式： 月份/日/年份 时:分:秒 var d2 = new Date(&quot;23/10/2022 21:32:30&quot;); // console.log(d2); /* getDate() -获取当前日期对象是几日 getDay() -获取当前日期对象是周几 -会返回一个0-6的值 0表示周日 1表示周一 getMonth() -获取当前日期对象是几月 -返回0-11的值 0表示1月 11表示12月 getFullYear() -获取当前日期对象的年份 */ var date = d2.getDate(); var day = d2.getDay(); var month = d2.getMonth(); var year = d2.getFullYear(); // console.log(&quot;date=&quot;+date); // console.log(&quot;dat=&quot;+day); // console.log(&quot;month=&quot;+month); // console.log(&quot;year=&quot;+year); /* getTime() -获取当前日期对象的时间戳 -时间戳，指的是格林威治标准时间的1970年1月1日，0时0分0秒 到当前日期所花费的毫秒数（1秒=1000毫秒） -计算机底层保存时间时使用都是时间戳 */ var time = d2.getTime(); // console.log(time); var d3 = new Date(&quot;1/1/1970 0:0:0&quot;); time = d3.getTime(); // console.log(time);//-28800000，八个小时，东八区快八个小时 // 利用时间戳来测试代码的执行性能 // 获取当前的时间戳 var start = Date.now(); for(var i=0;i&lt;100;i++)&#123; console.log(i); &#125; var end = Date.now(); console.log(&quot;执行了&quot;+(end-start)+&quot;毫秒&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 22、Math12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* Math -Math和其他对象不同，他不是一个构造函数 它属于一个工具类不用创建对象，它里边封装了数学运算的属性和方法 -比如： Math.PI圆周率 */ // alert(Date);//函数 // alert(Math);//对象 // console.log(Math.PI);//圆周率 /* abs()可以用来计算一个数的绝对值 */ // console.log(Math.abs(-1)); /* Math.ceil() -可以对一个数进行向上取整，小数位只有有值就自动进1 */ // console.log(Math.ceil(1.1));//2 /* floor() -可以对一个数进行向下取整 小数部分会被舍掉 */ // console.log(Math.floor(1.99));//1 /* round() -可以对一个数进行四舍五入取整 */ // console.log(Math.round(1.4)); /* Math.random() -可以用来生成一个0-1之间的随机数 -生成一个0-x之间的随机数 Math.round(Math.random()*x) -生成1到10 -生成x到y之间的整数 Math.round(Math.random()*(y-x))+x; */ // 生成0-10的随机数 /* for(var i=0;i&lt;10;i++)&#123; console.log(Math.round(Math.random()*10)); &#125; */ /* max()可以获取多个数中的最大值 min()可以获取多个数中的最小值 */ var max = Math.max(10,45,30,100); // console.log(max); /* Math.pow(x,y) 返回x的y次幂 */ console.log(Math.pow(12,3)); console.log(Math.sqrt(4)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 23、包装类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 在JS中为我们提供了三个包装类。通过这三个包装类可以将基本数据类型的数据转换为对象 String() -可以将基本数据类型字符串转换为String对象 Number() -可以将基本数据类型的数字转换为Number对象 Boolean() -可以将基本数据类型的布尔值转换为Boolean对象 但是注意：我们在实际应用中不会使用基本数据类型的对象 如果使用基础数据类型的对象，在做一些比较时可能会带来一些不可预期的结果 */ var a =123; // console(typeof a); // 创建一个Number类型的对象 var num = new Number(3); var num2 = new Number(3); var String = new String(&quot;hello&quot;); var bool = new Boolean(true); var bool2 = true; //向num中添加一个属性 num.hello = &quot;abc&quot;; // console.log(num.hello); // console.log(num==nu2);//false // console.log(bool==bool2);//true,但是===就是false /* var b = new Boolean(false); if(b)&#123; alert(&quot;我运行了&quot;); &#125; */ /* 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型的值去调用属性或方法时 浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法 调用完以后，再将其转换为基本数据类型 */ var s =123; s.hello = &quot;你好&quot;; console.log(s.hello);//undefined s=s.toString(); console.log(s); console.log(typeof s); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 十、Day91、字符串的相关方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 创建一个字符串 var str = &quot;Hello JavaScript&quot;; /* 在底层字符串时以字符数组的形式保存的 [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;...] */ /* length属性 获取字符串的长度 */ // console.log(str.length);//13 // console.log(str[0]);//H /* charAt() -可以返回字符串指定位置的字符 -不会对原字符串影响 -参数为索引，从0开始 -也是可以str[0]; */ var result = str.charAt(3); // console.log(result);//l /* charCodeAt() -获取指定位置字符的字符编码（Unicode编码） */ result = str.charCodeAt(1); // cons.console.log(result);// /* String.fromCharCode() -可以根据字符编码去获取字符 */ result = String.fromCharCode(20015); // console.log(result); /* concat() -可以连接两个或多个字符串 -作用和+一样 */ result = str.concat(&quot;你好&quot;,&quot;再见&quot;); console.log(result); /* indexOf() -该方法可以检索一个字符串是否有指定内容 -如果字符串中含有该内容，则返回其中第一次出现的索引 如果没有找到指定内容，则返回-1 -可以指定第二个参数，指定开始查找的位置 */ str = &quot;hello javascript&quot;; result = str.indexOf(&quot;e&quot;); // console.log(result); /* lastIndexOf(); -该方法和indexOf一样，只是方向相反 -也同样可以指定开始查找的位置 */ result = str.lastIndexOf(&quot;a&quot;); // console.log(result); /* slice() -可以从字符串中截取指定内容 -不会影响源字符串，而是将截取结果返回 -参数： 第一个，开始位置的索引（包括开始） 第二个，结束位置的索引（不包括结束） -如果省略第二个参数，则会截取到后边所有 -也可以传递一个负数作为参数，负数将会从后边开始计算 */ str = &quot;abcdefg&quot;; result = str.slice(0,2); // console.log(result); /* substring() -可以用来截取一个字符串，跟slice类似 -参数： -第一个，开始位置的索引（包括开始） -第二个，结束位置的索引（不包括结束） -不同的是这个方法不能接收负值作为参数 如果传递了一个负值，则默认使用0 -而且他会自动调整参数位置，如果第二个参数小于第一个，则会交换 */ result = str.substring(2,0); // console.log(result); /* substr() -用来截取字符串 -参数： 1、截取开始位置的索引 2、截取的长度 */ result = str.substr(2,3); // console.log(result); /* split() -可以将一个字符串拆分为一个数组 -参数： -需要一个字符串作为参数，会根据该字符串去拆分数组 */ /* 如果传递一个空串作为参数，将会把每个字符都拆分为数组中的一个元素 */ str = &quot;abc,def,ghi&quot;; result = str.split(&quot;,&quot;); // console.log(Array.isArray(result));//true /* toUpperCase() toLowerCase() -将字符串转换为大/小写并返回 */ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 十一、Day101、正则表达式1.01234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 正则表达式 -admin -admin@qq.com -邮件的规则 1、前边可以xxxx 2、跟着一个@ 3、后边可以xxx 4、最后.com -正则表达式用于定义一些字符串的规则 计算机可以根据正则表达式来检查一个字符串是否符合规则 或者将字符串中符合规则的内容提取出来 */ // 创建正则表达式对象 /* 语法： var 变量 = new RegExp(&quot;正则表达式,&quot;匹配模式&quot;); 使用typeof检查正则表达式对象，会返回Object 以下这个正则表达式可以用来检查一个字符串中是否含有a 在构造函数中可以传递一个匹配模式作为第二参数 可以是i 忽略大小写 g 全局匹配模式 */ var reg = new RegExp(&quot;a&quot;,&quot;i&quot;); var str = &quot;a&quot;; /* 正则表达式的方法 test() -使用这个方法可以来检查一个字符串是否符合正则表达式的规则 如果符合true，否则false */ var result = reg.test(str); // console.log(reg.test(&quot;abc&quot;)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2、正则表达式2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 使用字面量来创建正则表达式 语法： var 变量 = /正则表达式/匹配模式 使用字面量的方式更加简单 使用构造函数创建更加灵活 */ var reg = /a/i; //console.log(reg.test(&quot;abc&quot;)); // 创建一个正则表达式，检查一个字符串是否含有a或b /* 使用|表示或者的意思 */ reg = /a|b/ // console.log(reg.test(&quot;a&quot;)); /* 创建一个正则表达式来检查一个字符串是否有字母 []里的内容也是或的关系 [a-z],任意小写字母 [A-Z],任意大写字母 [A-z]，任意字母 */ reg = /[ab]/; req= /[a-z]/; // console.log(&quot;acd&quot;); // 检查一个字符串是否含有abc或adc或aec reg = /abc|adc|aec/; reg = /a[bde]c/; // console.log(&quot;abce&quot;); /* [^]除了 */ reg = /[^ab]/; // console.log(reg.test(&quot;abc&quot;));//true // 除了纯数字 reg = /[^0-9]/; console.log(reg.test(&quot;12a345&quot;)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、字符串和正则相关方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var str = &quot;1a2b3c4d5e6f7&quot;; /* split() -可以将一个字符串拆分为一个数组 -方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式区拆分字符串 -这个方法即使不指定全局匹配，也会全部拆分 */ /* 根据任意字母来拆分字符串 */ var result = str.split(/A-z/); console.log(result); /* search() 可以搜索字符串中是否有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有返回-1 可以接收正则表达式作为参数 search只会查找第一个，即使设置全局也没用 */ str = &quot;hello abc hello aec afc&quot;; // result = str.search(&quot;abc&quot;); /* 搜索字符串中是否含有abc或aec或afc */ result = str.search(/a[bef]c/); // console.log(result); /* match 可以根据正则表达式从一个字符串中将符合条件的提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到 后就返回了，我们可以设置正则表达式为全局匹配模式，这样就可以匹配所有内容 match会将匹配到的内容封装到一个数组中返回，即使只有一个结果 */ str =&#x27;1a2b3c4D5E6F7&#x27;; result = str.match(/a-z/ig); // console.log(result); /* replace() 可以将字符串中指定内容替换为新的内容 参数： 1、被替换的内容 2、新的内容 默认只会替换第一个 */ result = str.replace(/[a-z]/ig,&quot;&quot;); // console.log(result); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、正则表达式3.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 创建一个正则表达式检查一个字符串是否含有aaa */ /* 量词 - 通过量词可以设置一个内容出现的次数 - 量词只对它前边的一个内容起作用 - &#123;n&#125;正好出现n次 - &#123;m-n&#125;出现m到n次，n不写表示大于m次 - +至少一个，相当于&#123;1,&#125; - *0个或多个， - ? 0个或1个,相对于&#123;0,1&#125; */ var reg = /aaa/; reg = /a&#123;3&#125;/; reg=/ab&#123;3&#125;/;//只对b起作用 reg=/(ab)&#123;3&#125;/;//对ab起作用 // 匹配a中间1-3个b，后c reg =/ab&#123;1,3&#125;c/; // console.log(req.test(&quot;bvaaa&quot;)); reg = /ab+c/; reg = /ab*c/; reg = /ab?c/; /* 检查一个字符串是否以a开头 ^表示开头 $表示结尾 */ reg = /^a/;//开头为a reg = /a$/;//结尾为a /* 如果在正则表达式中同时使用^$则要求字符串必须完全符合正则表达式 */ reg = /^a$/; reg = /^a|a$/; /* 创建一个正则表达式，用来检查一个字符串是否是一个手机号 手机号的规则 1、总共11位 2、以1开头 3、第二位3-9任意，不能是0,1,2 4、三位以后任意数字 ^1 [3-9] [0-9]&#123;9&#125;$ */ var phoneStr = &quot;15219377123&quot;; var phoneReg = /^1[3-9][0-9]&#123;9&#125;$/; console.log(phoneReg.test(phoneStr)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、正则表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 检查一个字符串是否含有 . . 表示任意字符 在正则表达式中使用\\作为转义字符 \\. 表示 . \\\\ 表示 \\ 注意：在使用构造函数时，由于它的参数是一个字符串，而 \\是字符串中的转义字符，如果要使用\\则需要使用\\\\来代替 */ var reg = /\\./; reg = /\\\\/; reg = new RegExp(&quot;\\\\.&quot;); // console.log(&quot;b.&quot;); /* \\w 表示任意字母和数字，下划线_ \\W 表示除了字母、数字、下划线 \\d 任意数字 \\D 除了数字 \\s 含有空格 \\S 除了空格，只匹配空格 \\b 单词边界 \\B 除了单词边界 */ reg = /\\w/; reg=/\\W/; reg = /\\d/; reg= /\\D/; reg= /\\s/; reg = /\\S/; // console.log(reg.test(&quot;abc&quot;)); /* 创建一个正则表达式检查一个字符串中是否含有单词child */ reg = /\\bchild\\b/; // console.log(reg.test(&quot;hello chilld ren&quot;)); /* 接收一个用户输入 */ var str = prompt(&quot;请输入你的用户名：&quot;); // console.log(str); // 去除字符串前后空格，使用&quot;&quot;替换 str = &quot; hello &quot;; // str = str.replace(/\\s/g,&quot;&quot;);//全部空格给去除了 // 去除开头的空格 // str = str.replace(/^\\s*/,&quot;&quot;); //去除结尾空格 // str = str.replace(/\\s*$/,&quot;&quot;); // 整合 str = str.replace(/^\\s* | \\s*$/g,&quot;&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6、电子邮件正则表达式1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 电子邮件 字母/数字/下划线 xxxx @ 字母 . com 任意字母数字下划线 .任意字母数字下划线 @ .任意字母(2-5位) .任意字母(2-5位) \\w&#123;3,&#125; (\\.\\w+)* @ [A-z0-9]+ (\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125; */ var emailReg=/^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/; console.log(emailReg.test(&quot;1849569695@qq.com&quot;)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 7、DOM 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;我是一个按钮&lt;/button&gt; &lt;script&gt; /* 浏览器已经为我们提供了文档节点对象，这个对象是window属性 可以在页面中直接使用，文档节点代表整个网页 */ // console.log(document); // 获取button对象 var btn= document.getElementById(&quot;btn1&quot;); // console.log(btn); // 修改按钮的文字 // console.log(btn.innerHTML); btn.innerHTML=&quot;我被改了&quot;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8、事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;!-- 我们可以在事件对应的属性中设置一些js代码 当事件被触发时，这些代码将会被执行 这种写法我们称为结构和行为耦合，不方便维护，不推荐使用 --&gt; &lt;!-- &lt;button id=&quot;btn&quot; onmousemove=&quot;alert(&#x27;讨厌，你点我干嘛&#x27;);&quot;&gt;我是一个按钮&lt;/button&gt; --&gt; &lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 事件就是用户和浏览器之间的交互行为 比如：点击按钮，鼠标移动，关闭窗口 onclick ondblclick onmousemove */ /* 可以为按钮的对应事件绑定处理函数的形式来响应事件 这样当事件被触发时，其对应的函数将会被调用 */ var btn = document.getElementById(&quot;btn&quot;); // console.log(btn); // 为按钮绑定一个单击事件 // 像这种单击事件绑定的函数，我们称为单击响应函数 /* btn.onclick = function()&#123; alert(&quot;你干嘛？哎哟~~&quot;); &#125; */ btn.ondblclick = function()&#123; alert(&quot;双击666&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9、文档的加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 浏览器在加载一个页面时，是按照自上向下的顺序加载的 读取一行就运行一行,如果将script标签写到页面的上边 在代码执行时，页面还没加载，页面没有加载DOM对象也没有加载 导致无法获取DOM对象 */ /* onload事件 页面加载完成之后再执行，再触发 支持该事件的有，window、image、layer 为window绑定一个onload事件 该事件对应的响应函数将会在页面加载完成之后执行。 这样可以确定我们的代码执行时所有的DOM对象都已经加载完毕了 */ window.onload=function()&#123; alert(&quot;页面加载完成后执行&quot;); &#125; // alert(&quot;我先执行&quot;); // 获取id为btn的对象 var btn = document.getElementById(&quot;btn&quot;); // 为按钮绑定单击响应函数 // console.log(btn);//null &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;我是一个按钮&lt;/button&gt; &lt;script&gt; /* 将js代码编写到页面的下部就是为了可以在页面加载完毕以后再执行js代码 */ // 获取id为btn的对象 var btn = document.getElementById(&quot;btn&quot;); // 为按钮绑定单击响应函数 btn.onclick = function()&#123; alert(&quot;hello&quot;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10、DOM查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; //为id为btn01的按钮绑定一个单击响应函数 var btn01 = document.getElementById(&quot;btn01&quot;); btn01.onclick = function()&#123; //查找#bj节点 var bj = document.getElementById(&quot;bj&quot;); //打印bj //innerHTML 通过这个属性可以获取到元素内部的html代码 alert(bj.innerHTML); &#125;; //为id为btn02的按钮绑定一个单击响应函数 var btn02 = document.getElementById(&quot;btn02&quot;); btn02.onclick = function()&#123; //查找所有li节点 //getElementsByTagName()可以根据标签名来获取一组元素节点对象 //这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中 //即使查询到的元素只有一个，也会封装到数组中返回 var lis = document.getElementsByTagName(&quot;li&quot;); //打印lis //alert(lis.length); //遍历lis for(var i=0 ; i&lt;lis.length ; i++)&#123; alert(lis[i].innerHTML); &#125; &#125;; //为id为btn03的按钮绑定一个单击响应函数 var btn03 = document.getElementById(&quot;btn03&quot;); btn03.onclick = function()&#123; //查找name=gender的所有节点 var inputs = document.getElementsByName(&quot;gender&quot;); //alert(inputs.length); for(var i=0 ; i&lt;inputs.length ; i++)&#123; /* * innerHTML用于获取元素内部的HTML代码的 * 对于自结束标签，这个属性没有意义 */ //alert(inputs[i].innerHTML); /* * 如果需要读取元素节点属性， * 直接使用 元素.属性名 * 例子：元素.id 元素.name 元素.value * 注意：class属性不能采用这种方式， * 读取class属性时需要使用 元素.className */ alert(inputs[i].className); &#125; &#125;; //查找#city下所有li节点 //返回#city的所有子节点 //返回#phone的第一个子节点 //返回#bj的父节点 //返回#android的前一个兄弟节点 //读取#username的value属性值 //设置#username的value属性值 //返回#bj的文本值 &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;total&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt; 你喜欢哪款单机游戏? &lt;/p&gt; &lt;ul id=&quot;game&quot;&gt; &lt;li id=&quot;rl&quot;&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt; 你手机的操作系统是? &lt;/p&gt; &lt;ul id=&quot;phone&quot;&gt;&lt;li&gt;IOS&lt;/li&gt;&lt;li id=&quot;android&quot;&gt;Android&lt;/li&gt;&lt;li&gt;Windows Phone&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot;&gt; gender: &lt;input class=&quot;hello&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt; Male &lt;input class=&quot;hello&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt; Female &lt;br&gt; &lt;br&gt; name: &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;username&quot; value=&quot;abcde&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;btnList&quot;&gt; &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn08&quot;&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn09&quot;&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn10&quot;&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn11&quot;&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 11、练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .outer&#123; width: 500px; margin: 50px auto; padding: 10px; background-color: skyblue; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 点击按钮切换图片 */ // 获取两个按钮 var prev = document.getElementById(&quot;prev&quot;); var next = document.getElementById(&quot;next&quot;); /* 要切换图片就是要修改img标签的src属性 */ // 获取img标签 var img = document.getElementsByTagName(&quot;img&quot;)[0]; // 创建一个数组，用来保存图片的路径 var imgArr = [&quot;img/1.jpg&quot;,&quot;img/2.jpg&quot;,&quot;img/3.jpg&quot;,&quot;img/4.jpg&quot;,&quot;img/5.jpg&quot;]; // 创建一个变量，来保存当前正在显示的图片的索引 var index=0; // 设置提示文字 // 获取id为info的p元素 var info = document.getElementById(&quot;info&quot;); info.innerHTML= &quot;一共&quot;+imgArr.length+&quot;张图片，当前为第&quot;+(index+1)+&quot;张&quot;; // 分别为两个按钮绑定单击响应函数 prev.onclick = function()&#123; // 索引自减 index--; // 判断index是否小于0 if(index&lt;0)&#123; index = imgArr.length-1; &#125; img.src=imgArr[index] //当点击按钮以后，重新设置提示信息 info.innerHTML= &quot;一共&quot;+imgArr.length+&quot;张图片，当前为第&quot;+(index+1)+&quot;张&quot;; &#125;; next.onclick = function()&#123; // 索引自增 index++; if(index &gt;imgArr.length-1)&#123; index = 0; &#125; img.src=imgArr[index]; info.innerHTML= &quot;一共&quot;+imgArr.length+&quot;张图片，当前为第&quot;+(index+1)+&quot;张&quot;; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;p id=&quot;info&quot;&gt;&lt;/p&gt; &lt;img src=&quot;img/1.jpg&quot; alt=&quot;冰棍&quot;&gt; &lt;button id=&quot;prev&quot;&gt;上一张&lt;/button&gt; &lt;button id=&quot;next&quot;&gt;下一张&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、获取元素节点的子节点、父节点和兄弟节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 定义一个函数专门为指定元素绑定的响应函数 /* 参数： idStr 要绑定单击响应函数对象的id属性值 fun 事件的回调函数，当点击元素时，该函数会被触发 */ function myClick(idStr,fun)&#123; //为id为btn01的按钮绑定一个单击响应函数 var btn = document.getElementById(idStr); btn.onclick = fun; &#125; window.onload = function()&#123; //为id为btn01的按钮绑定一个单击响应函数 var btn01 = document.getElementById(&quot;btn01&quot;); btn01.onclick = function()&#123; //查找#bj节点 var bj = document.getElementById(&quot;bj&quot;); //打印bj //innerHTML 通过这个属性可以获取到元素内部的html代码 alert(bj.innerHTML); &#125;; //为id为btn02的按钮绑定一个单击响应函数 var btn02 = document.getElementById(&quot;btn02&quot;); btn02.onclick = function()&#123; //查找所有li节点 //getElementsByTagName()可以根据标签名来获取一组元素节点对象 //这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中 //即使查询到的元素只有一个，也会封装到数组中返回 var lis = document.getElementsByTagName(&quot;li&quot;); //打印lis //alert(lis.length); //遍历lis for(var i=0 ; i&lt;lis.length ; i++)&#123; alert(lis[i].innerHTML); &#125; &#125;; //为id为btn03的按钮绑定一个单击响应函数 var btn03 = document.getElementById(&quot;btn03&quot;); btn03.onclick = function()&#123; //查找name=gender的所有节点 var inputs = document.getElementsByName(&quot;gender&quot;); //alert(inputs.length); for(var i=0 ; i&lt;inputs.length ; i++)&#123; /* * innerHTML用于获取元素内部的HTML代码的 * 对于自结束标签，这个属性没有意义 */ //alert(inputs[i].innerHTML); /* * 如果需要读取元素节点属性， * 直接使用 元素.属性名 * 例子：元素.id 元素.name 元素.value * 注意：class属性不能采用这种方式， * 读取class属性时需要使用 元素.className */ alert(inputs[i].className); &#125; &#125;; // 为id为btn04的按钮绑定单击响应函数 var btn04 = document.getElementById(&quot;btn04&quot;); btn04.onclick = function()&#123; // 获取id为city的元素 var city = document.getElementById(&quot;city&quot;); // 查找#city下所有的li节点 var lis = city.getElementsByTagName(&quot;li&quot;); // alert(lis.length); for(var i=0;i&lt;lis.length;i++)&#123; alert(lis[i].innerHTML); &#125; &#125; var btn05 = document.getElementById(&quot;btn05&quot;); btn05.onclick = function()&#123; var city = document.getElementById(&quot;city&quot;); //返回#city的所有子节点 /* childNodes会获取包括文本节点在内的所有子节点 根据DOM标签标签间的空白也会被当成文本节点 注意：在IE8及以下1浏览器中，不会将空白文本当成子节点 */ var cns = city.childNodes; /* children属性可以获取当前元素的所有子元素 */ var cns2 = city.children; /* for(var i=0;i&lt;cns.length;i++)&#123; alert(cns[i]); &#125; */ alert(cns.length); &#125; var btn06 = document.getElementById(&quot;btn06&quot;); btn06.onclick = function()&#123; //返回#phone的第一个子节点 var phone = document.getElementById(&quot;phone&quot;); // firstchildNodes可以获取当前元素的第一个子节点（包括空白文本节点） var pfc = phone.firstChild; // firstElementChild获取当前元素的第一个元素 // 不兼容ie8及以下 fir = phone.firstElementChild; alert(pfc.innerHTML); &#125; myClick(&quot;btn07&quot;,function()&#123; //获取id为bj的节点 var bj = document.getElementById(&quot;bj&quot;); // 返回#bj的父节点 var pn = bj.parentNode; // alert(pn.innerHTML); /* innerText -该属性可以获取到元素内部的文本内容 -它和innerHTML类似，不同的是它会自动将 标签 去除 */ alert(pn.innerText); &#125;); myClick(&quot;btn08&quot;,function()&#123; //获取id为Android的元素 var and = document.getElementById(&quot;android&quot;); //返回#android的前一个兄弟节点(也包括空白的文本) var ps = and.previousSibling; /* previousElementSibling 获取前一个兄弟元素，ie8及以下不能用 */ ps= and.previousElementSibling; alert(ps); &#125;); myClick(&quot;btn09&quot;,function()&#123; //读取#username的value属性值 var username = document.getElementById(&quot;username&quot;); // 文本框的value属性值，就是文本框中填写的的内容 var username = username.value; alert(username); &#125;); myClick(&quot;btn10&quot;,function()&#123; //设置#username的value属性值 // 设置value username.value = &quot;今天天气真不错！&quot;; &#125;); myClick(&quot;btn11&quot;,function()&#123; var bj = document.getElementById(&quot;bj&quot;); //返回#bj的文本值 // alert(bj.innerText); // alert(bj.innerHTML); // 获取bj中的文本节点 var fc = bj.firstChild; // nodeValue获取节点值 alert(fc.nodeValue); &#125;); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;total&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt; 你喜欢哪款单机游戏? &lt;/p&gt; &lt;ul id=&quot;game&quot;&gt; &lt;li id=&quot;rl&quot;&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt; &lt;br /&gt; &lt;p&gt; 你手机的操作系统是? &lt;/p&gt; &lt;ul id=&quot;phone&quot;&gt; &lt;li&gt;IOS&lt;/li&gt; &lt;li id=&quot;android&quot;&gt;Android&lt;/li&gt; &lt;li&gt;Windows Phone&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;inner&quot;&gt; gender: &lt;input class=&quot;hello&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt; Male &lt;input class=&quot;hello&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;/&gt; Female &lt;br&gt; &lt;br&gt; name: &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;username&quot; value=&quot;abcde&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;btnList&quot;&gt; &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn08&quot;&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn09&quot;&gt;返回#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn10&quot;&gt;设置#username的value属性值&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn11&quot;&gt;返回#bj的文本值&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 13、练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;全选练习&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; // 全选按钮 var checkedAllBtn = document.getElementById(&quot;checkedAllBtn&quot;); checkedAllBtn.onclick = function()&#123; var items = document.getElementsByName(&quot;items&quot;); // 设置选中状态 for(var i =0;i&lt;items.length;i++)&#123; items[i].checked = true; &#125; checkedAllBox.checked=true; &#125; // 全不选 var checkedNoBtn = document.getElementById(&quot;checkedNoBtn&quot;); checkedNoBtn.onclick = function()&#123; var items = document.getElementsByName(&quot;items&quot;); // 设置选中状态 for(var i =0;i&lt;items.length;i++)&#123; items[i].checked = false; &#125; checkedAllBox.checked=false; &#125; // 反选 var checkedRevBtn = document.getElementById(&quot;checkedRevBtn&quot;); checkedRevBtn.onclick = function()&#123; var items = document.getElementsByName(&quot;items&quot;); // 反选时也需要判断四个多选框是否全部选中 // 设置checkedAllBox为选中 checkedAllBox.checked=true; // 设置选中状态 for(var i =0;i&lt;items.length;i++)&#123; items[i].checked = !items[i].checked ; // 判断四个多选框是否全选 if(!items[i].checked)&#123; checkedAllBox.checked=false; &#125; &#125; &#125; // 提交 var sendBtn = document.getElementById(&quot;sendBtn&quot;); sendBtn.onclick = function()&#123; var items = document.getElementsByName(&quot;items&quot;); for(var i =0;i&lt;items.length;i++)&#123; if(items[i].checked )&#123; alert(items[i].value); &#125; &#125; &#125; // 全选多选框 /* 在事件的响应函数中，响应函数是给谁绑定的，this就是谁 */ var checkedAllBox = document.getElementById(&quot;checkedAllBox&quot;); var items = document.getElementsByName(&quot;items&quot;); checkedAllBox.onclick=function()&#123; for(var i =0;i&lt;items.length;i++)&#123; // items[i].checked = checkedAllBox.checked; items[i].checked =this.checked; &#125; &#125; /* 如果四个多选框都选中，则checkAllBox也应该选中 相反，也应该不选中 */ // 为四个多选框分别绑定单击响应函数 for(var i =0;i&lt;items.length;i++)&#123; items[i].onclick = function()&#123; // 设置checkedAllBox为选中 checkedAllBox.checked=true; for(var j=0;j&lt;items.length;j++)&#123; // 判断四个多选框是否全选 if(!items[j].checked)&#123; checkedAllBox.checked=false; // 一旦进入，就有结果了 break; &#125; &#125; &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; 你爱好的运动是？&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot; /&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反 选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提 交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 14、DOM查询的其他方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; // 获取body标签 // var body = document.getElementsByTagName(&quot;body&quot;)[0]; /* 在document中有一个属性body，它保存的是body的引用 */ var body = document.body; // console.log(body); /* document.documentElement是html根标签 */ var html = document.documentElement; // console.log(html); /* document.all代表页面中所有的元素 */ var all=document.all; for(var i=0;i&lt;all.length;i++)&#123; // console.log(all[i]); &#125; // 也是全部元素 // all = document.getElementsByTagName(&quot;*&quot;); /* 根据元素的class属性查询一组元素节点对象 该方法不支持ie8及以下的浏览器 */ var box1 = document.getElementsByClassName(&quot;box1&quot;); // console.log(box1.length); // 获取页面中所有的div var divs = document.getElementsByTagName(&quot;div&quot;); // 获取class为 box1中的所有div /* document.querySelector() -需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象 -虽然ie8没有getElementByClassName()但是可以使用querySelector()代替 -使用该方法总会返回唯一一个元素，如果满足条件的元素有多个，那么只会返回第一个 */ var div = document.querySelector(&quot;.box1 div&quot;); var box1 = document.querySelector(&quot;.box1&quot;); // console.log(div.innerHTML); // console.log(divs.length); /* document.querySelectorAll() -该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回 -即使符合条件的元素只有一个，也会返回一个数组 */ box1 = document.querySelectorAll(&quot;.box1&quot;); // console.log(box1.length); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; 第一个 &lt;div&gt;我是box1中的div&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 15、dom的增删改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style/css.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; //创建一个&quot;广州&quot;节点,添加到#city下 myClick(&quot;btn01&quot;,function()&#123; //创建广州节点 &lt;li&gt;广州&lt;/li&gt; //创建li元素节点 /* * document.createElement() * 可以用于创建一个元素节点对象， * 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， * 并将创建好的对象作为返回值返回 */ var li = document.createElement(&quot;li&quot;); //创建广州文本节点 /* * document.createTextNode() * 可以用来创建一个文本节点对象 * 需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回 */ // var gzText = document.createTextNode(&quot;广州&quot;); //将gzText设置li的子节点 /* * appendChild() * - 向一个父节点中添加一个新的子节点 * - 用法：父节点.appendChild(子节点); */ // li.appendChild(gzText); li.innerHTML = &quot;广州&quot;; //获取id为city的节点 var city = document.getElementById(&quot;city&quot;); //将广州添加到city下 city.appendChild(li); &#125;); //将&quot;广州&quot;节点插入到#bj前面 myClick(&quot;btn02&quot;,function()&#123; //创建一个广州 var li = document.createElement(&quot;li&quot;); var gzText = document.createTextNode(&quot;广州&quot;); li.appendChild(gzText); //获取id为bj的节点 var bj = document.getElementById(&quot;bj&quot;); //获取city var city = document.getElementById(&quot;city&quot;); /* * insertBefore() * - 可以在指定的子节点前插入新的子节点 * - 语法： * 父节点.insertBefore(新节点,旧节点); */ city.insertBefore(li , bj); &#125;); //使用&quot;广州&quot;节点替换#bj节点 myClick(&quot;btn03&quot;,function()&#123; //创建一个广州 var li = document.createElement(&quot;li&quot;); var gzText = document.createTextNode(&quot;广州&quot;); li.appendChild(gzText); //获取id为bj的节点 var bj = document.getElementById(&quot;bj&quot;); //获取city var city = document.getElementById(&quot;city&quot;); /* * replaceChild() * - 可以使用指定的子节点替换已有的子节点 * - 语法：父节点.replaceChild(新节点,旧节点); */ city.replaceChild(li , bj); &#125;); //删除#bj节点 myClick(&quot;btn04&quot;,function()&#123; //获取id为bj的节点 var bj = document.getElementById(&quot;bj&quot;); //获取city var city = document.getElementById(&quot;city&quot;); /* * removeChild() * - 可以删除一个子节点 * - 语法：父节点.removeChild(子节点); * * 子节点.parentNode.removeChild(子节点); */ //city.removeChild(bj); bj.parentNode.removeChild(bj); &#125;); //读取#city内的HTML代码 myClick(&quot;btn05&quot;,function()&#123; //获取city var city = document.getElementById(&quot;city&quot;); alert(city.innerHTML); &#125;); //设置#bj内的HTML代码 myClick(&quot;btn06&quot; , function()&#123; //获取bj var bj = document.getElementById(&quot;bj&quot;); bj.innerHTML = &quot;昌平&quot;; &#125;); myClick(&quot;btn07&quot;,function()&#123; //向city中添加广州 var city = document.getElementById(&quot;city&quot;); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += &quot;&lt;li&gt;广州&lt;/li&gt;&quot;; //创建一个li var li = document.createElement(&quot;li&quot;); //向li中设置文本 li.innerHTML = &quot;广州&quot;; //将li添加到city中 city.appendChild(li); &#125;); &#125;; function myClick(idStr, fun) &#123; var btn = document.getElementById(idStr); btn.onclick = fun; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;total&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;btnList&quot;&gt; &lt;div&gt;&lt;button id=&quot;btn01&quot;&gt;创建一个&quot;广州&quot;节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn02&quot;&gt;将&quot;广州&quot;节点插入到#bj前面&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn03&quot;&gt;使用&quot;广州&quot;节点替换#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn04&quot;&gt;删除#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn05&quot;&gt;读取#city内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn06&quot;&gt;设置#bj内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn07&quot;&gt;创建一个&quot;广州&quot;节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 16、练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加删除记录练习&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ex_2_style/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 删除函数 */ function del()&#123; // 删除超链接所在那行 // 这里我们点击哪个超链接，this就是哪个a var tr = this.parentNode.parentNode; // 提示 /* confirm用于弹出一个带有确认和取消的提示框 如果用户点击确定返回true，否则返回false */ // 获取要删除的员工的名字 // var name = tr.getElementsByTagName(&quot;td&quot;)[0].innerHTML; var name = tr.children[0].innerHTML; var flag = confirm(&quot;你确定要删除&quot;+name+&quot;吗?&quot;); if(flag)&#123; // 删除tr tr.parentNode.removeChild(tr); &#125; /* 点击超链接以后，超链接会跳转页面，这个是超链接的默认行为， 但是我们不希望出现默认行为，可以通过在响应函数的最后return false来取消默认行为 */ return false; &#125; window.onload = function()&#123; // 删除 var allA = document.getElementsByTagName(&quot;a&quot;); // 给a标签绑定单击函数 for(var i=0;i&lt;allA.length;i++)&#123; allA[i].onclick = del; &#125; // 添加 var button = document.getElementById(&quot;addEmpButton&quot;); button.onclick=function()&#123; //获取用户填写的信息 // 获取员工名字 var name = document.getElementById(&quot;empName&quot;).value; // 获取员工email和salary var email = document.getElementById(&quot;email&quot;).value; var salary= document.getElementById(&quot;salary&quot;).value; // 需要将获取到的信息保存到tr中 // 创建一个tr var tr = document.createElement(&quot;tr&quot;); // 创建四个td var nameTd = document.createElement(&quot;td&quot;); var emailTd = document.createElement(&quot;td&quot;); var salaryTd = document.createElement(&quot;td&quot;); var aTd = document.createElement(&quot;td&quot;); // 创建一个a元素 var a = document.createElement(&quot;a&quot;); // 创建文本节点 var nameText = document.createTextNode(name); var emailText = document.createTextNode(email); var salaryText = document.createTextNode(salary); var delText = document.createTextNode(&quot;Delete&quot;); // 将文本添加到td中 nameTd.appendChild(nameText); emailTd.appendChild(emailText); salaryTd.appendChild(salaryText); a.appendChild(delText); // 将a添加到td中 aTd.appendChild(a); // 将td添加到tr tr.appendChild(nameTd); tr.appendChild(emailTd); tr.appendChild(salaryTd); tr.appendChild(aTd); // 向a中添加属性 a.href = &quot;javascript:;&quot;; // 为新添加的a再绑定单击响应函数 a.onclick = del; // 获取table var table = document.getElementById(&quot;employeeTable&quot;); var tbody = table.getElementsByTagName(&quot;tbody&quot;)[0]; // 将tr添加到todody中 tbody.appendChild(tr); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 17、练习优化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加删除记录练习&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ex_2_style/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 删除函数 */ function del()&#123; // 删除超链接所在那行 // 这里我们点击哪个超链接，this就是哪个a var tr = this.parentNode.parentNode; // 提示 /* confirm用于弹出一个带有确认和取消的提示框 如果用户点击确定返回true，否则返回false */ // 获取要删除的员工的名字 // var name = tr.getElementsByTagName(&quot;td&quot;)[0].innerHTML; var name = tr.children[0].innerHTML; var flag = confirm(&quot;你确定要删除&quot;+name+&quot;吗?&quot;); if(flag)&#123; // 删除tr tr.parentNode.removeChild(tr); &#125; /* 点击超链接以后，超链接会跳转页面，这个是超链接的默认行为， 但是我们不希望出现默认行为，可以通过在响应函数的最后return false来取消默认行为 */ return false; &#125; window.onload = function()&#123; // 删除 var allA = document.getElementsByTagName(&quot;a&quot;); // 给a标签绑定单击函数 for(var i=0;i&lt;allA.length;i++)&#123; allA[i].onclick = del; &#125; // 添加 var button = document.getElementById(&quot;addEmpButton&quot;); button.onclick=function()&#123; //获取用户填写的信息 // 获取员工名字 var name = document.getElementById(&quot;empName&quot;).value; // 获取员工email和salary var email = document.getElementById(&quot;email&quot;).value; var salary= document.getElementById(&quot;salary&quot;).value; // 需要将获取到的信息保存到tr中 // 创建一个tr var tr = document.createElement(&quot;tr&quot;); // 设置tr中的内容 tr.innerHTML=&quot;&lt;td&gt;&quot;+name+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+email+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&quot;+salary+&quot;&lt;/td&gt;&quot;+ &quot;&lt;td&gt;&lt;a href=&#x27;javascript:;&#x27;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;; // 获取刚刚添加的a元素，并给它绑定单击响应函数 var a = tr.getElementsByTagName(&quot;a&quot;)[0]; a.onclick=del; // 获取table var table = document.getElementById(&quot;employeeTable&quot;); var tbody = table.getElementsByTagName(&quot;tbody&quot;)[0]; // 将tr添加到todody中 tbody.appendChild(tr); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 18、a的索引问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;添加删除记录练习&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ex_2_style/css.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; // 删除 var allA = document.getElementsByTagName(&quot;a&quot;); // 给a标签绑定单击函数 for(var i=0;i&lt;allA.length;i++)&#123; /* for循环会在页面加载完成之后立即执行 而响应函数会在超链接被点击时才执行 当响应函数执行时，for循环早已经执行完毕 */ alert(&quot;for循环正在执行&quot;+i); allA[i].onclick=function()&#123; alert(&quot;响应函数执行&quot;+i) &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table id=&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;tom@tom.com&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;/td&gt; &lt;td&gt;jerry@sohu.com&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;bob@tom.com&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=&quot;formDiv&quot;&gt; &lt;h4&gt;添加新员工&lt;/h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;name: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;email: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;word&quot;&gt;salary: &lt;/td&gt; &lt;td class=&quot;inp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt; Submit &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 19、使用dom操作css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: skyblue; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 点击按钮以后，修改box1的大小 */ var num = 100; var btn01 = document.getElementById(&quot;btn01&quot;); var box01 = document.getElementById(&quot;box1&quot;); btn01.onclick=function()&#123; // 修改box1的宽度 /* 通过js修改元素的样式： 语法： 元素.style.样式名 = 样式值 注意：如果css的样式名中含有- 这种名称在js中是不合法的比如background-color 需要将这种样式修改为驼峰命名 去掉-，然后将-后的字母大写 通过style属性设置的样式都是内联样式 而内联样式有较高的优先级，所以通过js修改的样式往往会立即显示 但是如果在样式中泄露！importtant，样式有最高的优先级 js也无法修改 通过style读取和设置的都是内联样式，无法读取样式表中的样式 */ num = num+10; box1.style.width=num+&quot;px&quot;; box1.style.height=num+&quot;px&quot;; box1.style.backgroundColor=&quot;yellow&quot;; &#125;; var btn02 = document.getElementById(&quot;btn02&quot;); btn02.onclick =function()&#123; // 读取box1的样式 alert(box1.style.width); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点我变大，变黄！！&lt;/button&gt; &lt;button id=&quot;btn02&quot;&gt;点我读取样式信息&lt;/button&gt; &lt;div class=&quot;box1&quot; id=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 20、读取元素的样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: yellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var box1= document.getElementById(&quot;box1&quot;); var btn01 = document.getElementById(&quot;btn01&quot;); btn01.onclick = function()&#123; // 读取box1的样式 /* 获取元素当前显示的样式 语法： 元素.currentStyle.样式名 它可以读取当前元素正在显示的样式 如果当前元素没有设置元素，则获取它的默认值 只有ie支持，其他浏览器不支持 */ // alert(box1.currentStyle.width); /* 其他浏览器可以使用 getComputedStyle()这个方法获取元素当前样式 这个方法是window的方法，可以直接使用 需要两个参数： 第一个：要获取样式的元素 第二个：可以传递一个伪元素，一般传null 该方法返回了一个对象，对象中封装了当前元素对应的样式 可以通过 对象.样式名 读取样式 没有设置样式，会显示准确值 ie8及以下不支持 通过currentStyle和getComputedStyle不能修改样式，只能读 */ // 正常浏览器 var obj = getComputedStyle(box1,null); //ie8 // alert(box1.currentStyle.backgroundColor); // alert(obj.width); alert(getStyle(box1,&quot;width&quot;)); &#125;; &#125;; /* 定义一个函数，用来获取指定元素的当前样式 参数： 1、元素 2、样式名 */ function getStyle(obj,name)&#123; // 如果单写getComputedStyle是变量，没有就会报错，加上window是属性，没有返回undefined---&gt;false /* if(window.getComputedStyle)&#123; // 正常,有getComputedStyle()方法 return getComputedStyle(obj,null)[name]; &#125;else&#123; // ie8 return obj.currentStyle[name]; &#125; */ return window.getComputedStyle?getComputedStyle(obj,null)[name]:obj.currentStyle[name]; /* if(obj.currentStyle)&#123; // ie8 return obj.currentStyle[name]; &#125;else&#123; // 正常,有getComputedStyle()方法 return getComputedStyle(obj,null)[name]; &#125; */ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点我一下&lt;/button&gt; &lt;br/&gt;&lt;br/&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十二、Day111、其他样式操作的属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: red; padding: 10px; border: 10px solid yellow; &#125; #box4&#123; width: 200px; height: 300px; background-color: #bfa; overflow: auto; &#125; #box5&#123; width: 450px; height: 600px; background-color:yellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var box1 = document.getElementById(&quot;box1&quot;); var btn01 = document.getElementById(&quot;btn01&quot;); var box4 = document.getElementById(&quot;box4&quot;); btn01.onclick=function()&#123; /* clientWidth clientHeight -这两个属性可以获取元素的可见宽度和高度 -这些属性不带px的，返回的是一个数字，可以直接进行计算 -会获取元素的宽度和高度，包括内容区和内边距 -这些属性只读，不能改 */ // alert(box1.clientWidth); // box1.clientHeight=300; /* offsetWidth offsetHeight -获取元素的整个宽度和高度，包括内容区，内边距和边框 */ // alert(box1.offsetHeight); /* offsetParent -可以获取当前元素的定位元素 -会获取到离当前元素最近的开启了定位的祖先元素 */ var op = box1.offsetParent; // alert(op.id); /* offsetLeft -当前元素相对于其定位父元素的水平偏移量 offsetTop -当前元素相对于其定位父元素的垂直偏移量 */ // alert(box1.offsetLeft); /* scrollWidth scrollHeight -获取指定元素的滚动区域宽度或高度 */ // alert(box4.scrollHeight); /* scrollLeft scrollTOp -获取水平或垂直滚动条滚动的距离 */ // alert(box4.scrollLeft); // alert(box4.clientHeight);//283 // alert(box4.scrollHeight);//600 // 当满足scrollHeight-scrollTop ==clientHeight时，说明滚动条滚到低了 alert(box4.scrollHeight - box4.scrollTop);// &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点我一下&lt;/button&gt; &lt;br/&gt;&lt;br/&gt; &lt;div id=&quot;box4&quot;&gt; &lt;div id=&quot;box5&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;box2&quot; style=&quot;position: relative;&quot;&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2、练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #info&#123; width: 300px; height: 500px; background-color: #bfa; overflow: auto; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 当垂直滚动条滚到底时，设置表单项可用 onsroll -该事件在元素的滚动条滚动时触发 */ var info = document.getElementById(&quot;info&quot;); info.onscroll=function()&#123; if(info.scrollHeight-info.scrollTop == info.clientHeight)&#123; // 滚到底部了，设置可用 var inputs = document.getElementsByTagName(&quot;input&quot;); for(var i=0;i&lt;inputs.length;i++)&#123; /* disabled属性设置元素是否禁用 如果设置为true，元素禁用，否则元素可用 */ inputs[i].disabled = false; &#125; &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;欢迎用户注册&lt;/h3&gt; &lt;p id=&quot;info&quot;&gt; 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 亲爱的用户，请你乖乖仔细阅读下面的协议，如果胆敢不看不仔细阅读那你就完了，别想注册了，给我爬 &lt;/p&gt; &lt;!-- disabled不可用 --&gt; &lt;input type=&quot;checkbox&quot; disabled/&gt;我已阅读完协议，确定同意！ &lt;input type=&quot;submit&quot; disabled value=&quot;确定&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 3、事件对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #areaDiv&#123; width: 300px; height: 150px; border: 1px solid black; &#125; #showMsg&#123; width: 300px; height: 50px; border:1px solid black; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var areaDiv = document.getElementById(&quot;areaDiv&quot;); var showMsg = document.getElementById(&quot;showMsg&quot;); /* onmousemove -该事件将会在鼠标在元素中移动时触发 事件对象 -当事件的响应函数被触发时，浏览器每次都会传递一个事件对象作为实参传递进响应函数 在事件对象中封装了当前事件相关的一切信息，比如，鼠标的坐标，键盘哪个按键被按下，鼠标滚轮滚动的 */ areaDiv.onmousemove=function(event)&#123; /* 在ie8中，响应函数被触发时，浏览器不会传递事件触发事件对象 在ie8及以下浏览器中，是将事件对象作为window对象事件的属性保存的 */ /* if(!event)&#123; event=window.event; &#125; */ // 解决事件对象的兼容问题 event = event || window.event; // 获取坐标 /* clientX,clientY -返回当事件被触发时鼠标的坐标 */ var x = event.clientX; var y = event.clientY; showMsg.innerHTML=&quot;(&quot;+x+&quot;,&quot;+y+&quot;)&quot;; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: red; /* 开启box1的绝对定位 */ position: absolute; &#125; body&#123; height: 1000px; width: 2000px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var box1 = document.getElementById(&quot;box1&quot;); window.onmousemove=function(event)&#123; event = event || window.event; // 获取滚动条滚动的距离 /* chrome认为浏览器的滚动条是body，可以通过body.scrollTop来获取 其他浏览器认为浏览器的滚动条是html的 */ // var st = document.body.scrollTop; // var st = document.documentElement.scrollTop; var st = document.documentElement.scrollTop || document.body.scrollTop; var sl = document.documentElement.scrollLeft || document.body.scrollLeft; // 获取鼠标坐标 /* clientX，clientY 用于获取在可见窗口的坐标 而div的偏移量是相对于整个页面的 */ var x = event.clientX; var y = event.clientY; /* pageX和pageY可以获取鼠标相对于当前页面的坐标 但是这两个属性在ie8中不支持，所以如果需要兼容ie8，则不要使用 */ // var x = event.pageX; // var y = event.pageY; // 设置box1坐标 box1.style.left = x+sl+ &quot;px&quot;; box1.style.top = y +st + &quot;px&quot;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、冒泡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 200px; height: 200px; background-color: green; &#125; #s1&#123; background-color: yellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 事件的冒泡(Bubble) -所谓的冒泡就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发 -在开发中大部分冒泡是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡 */ var s1 = document.getElementById(&quot;s1&quot;); s1.onclick=function(event)&#123; event = event||window.event; alert(&quot;我是span的单击响应函数&quot;); // 取消冒泡 /* 将事件对象的cancelBubble设置为true，即可取消冒泡 */ event.cancelBubble=true; &#125;; var box1 = document.getElementById(&quot;box1&quot;); box1.onclick=function(event)&#123; event = event||window.event; event.cancelBubble=true; alert(&quot;我是div的单击响应函数&quot;); &#125;; document.body.onclick=function()&#123; alert(&quot;我是body的单击响应函数&quot;); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;我是box1 &lt;span id=&quot;s1&quot;&gt;我是span&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、事件的委派12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; /* 为每一个超链接绑定一个单击响应函数 */ var u1 = document.getElementById(&quot;u1&quot;); /* 为每一个超链接绑定一个的点击响应函数 这里我们为每一个超链接都绑定了一个单击响应函数，这种操作比较麻烦 而且这些操作只能为已有的超链接设置事件，而新添加的超链接必须重新绑定 */ // 获取所有的a var allA = document.getElementsByTagName(&quot;a&quot;); // 遍历 /* for(var i=0;i&lt;allA.length;i++)&#123; allA[i].onclick=function()&#123; alert(&quot;我是a的单击响应函数&quot;); &#125; &#125; */ /* 我们希望值绑定一次事件，即可应用到多个元素上，即使元素是后添加的 我们可以尝试将其绑定给元素的共同的祖先元素 事件的委派 -指将事件统一给元素的共同的祖先元素，这样当后代元素上的事件被触发时，会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件 -事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 */ u1.onclick=function(event)&#123; // 如果触发事件的对象是我们期望的元素，则执行，否则不执行 /* target -event中的tar get表示的触发事件的对象 */ if(event.target.className==&quot;link&quot;)&#123; alert(&quot;我是ul的单击响应函数&quot;); &#125; &#125;; // 点击按钮以后添加超链接 var btn01 = document.getElementById(&quot;btn01&quot;); var num=4; btn01.onclick=function()&#123; // 创建一个li var li =document.createElement(&quot;li&quot;); li.innerHTML=(&quot;&lt;a class=&#x27;link&#x27; href=&#x27;javascript:;&#x27;&gt;超链接&quot;+num+&quot;&lt;/a&gt;&quot;); u1.appendChild(li); // 以下这种不行，因为此时li节点还未被添加进去，无法获取父节点 // li.paraentNode.appendChild(li); num++; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;添加超链接&lt;/button&gt; &lt;ul id=&quot;u1&quot;&gt; &lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;javascript:;&quot;&gt;超链接1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;javascript:;&quot;&gt;超链接2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;link&quot; href=&quot;javascript:;&quot;&gt;超链接3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 7、事件的绑定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; /* 点击按钮后弹出一个内容 */ var btn01 = document. getElementById(&quot;btn01&quot;); /* 使用对象.事件 = 函数 的形式绑定响应函数 它只能同时为一个元素的一个事件绑定一个函数 不能绑定多个，如果绑定了多个，则后边的会覆盖前面的 */ /* btn01.onclick=function()&#123; alert(1); &#125;; */ /* 为btn01绑定第二个响应函数 */ /* btn01.onclick=function()&#123; alert(2); &#125;; */ /* addEventListener() -通过这个方法也可以为元素绑定响应函数 -参数 1、事件的字符串，不要on 2、回调函数，当事件触发时，该函数会被调用 3、是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用这个可以同时为一个元素的相同事件同时绑定多个响应函数 这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持Ie8及以下的浏览器 */ /* btn01.addEventListener(&quot;click&quot;,function()&#123; alert(1); &#125;,false); btn01.addEventListener(&quot;click&quot;,function()&#123; alert(2); &#125;,false); */ /* attachEvent() -在ie8中可以使用attachEvent()来绑定事件 -参数： 1、事件的字符串，要加on 2、回调函数 -这个方法也可以同时使一个事件绑定多个处理函数 不同的是它是后绑定的事件会先执行，执行顺序和addEventListener()相反 -只能在ie8使用 */ /* btn01.attachEvent(&quot;onclik&quot;,function()&#123; alert(1); &#125;); btn01.attachEvent(&quot;onclik&quot;,function()&#123; alert(2); &#125;); */ /* btn01.attachEvent(&quot;onclik&quot;,function()&#123; alert(this);//window &#125;); */ /* btn01.addEventListener(&quot;click&quot;,function()&#123; alert(this);//button &#125;,false); */ bind(btn01,&quot;click&quot;,function()&#123; alert(this); &#125;); &#125;; // 定义一个函数，用来为指定元素绑定响应函数 /* addEventListener()中的this是绑定事件的对象 attachEvent()中的this是window 需要统一两个方法的this */ /* 参数： obj要绑定事件的对象 evenStr事件的字符串(不要on) callback回调函数 */ function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容 obj.addEventListener(eventStr,callback,false); &#125;else&#123; /* this是谁由调用方式决定 callback.call(obj) */ // ie8及以下 // obj.attachEvent(&quot;on&quot;+eventStr,callback); obj.attachEvent(&quot;on&quot;+eventStr,function()&#123; callback.call(obj); &#125;); &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;我是一个按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 8、事件的传播1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 300px; height: 300px; background-color: #bfa; &#125; #box2&#123; width: 200px; height: 200px; background-color: yellow; &#125; #box3&#123; width: 100px; height: 100px; background-color: green; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 分别为三个div绑定单击响应函数 */ var box1 = document.getElementById(&quot;box1&quot;); var box2 = document.getElementById(&quot;box2&quot;); var box3 = document.getElementById(&quot;box3&quot;); /* 事件的传播 -关于事件的传播网景公司和微软格式有不同的理解 -微软公司认为事件应该是有内向外传播，也就是当事件触发时，应该先触发当前元素上的事件 然后再向当前元素的祖先元素传播，也就是说事件应该在冒泡阶段执行 -网景公司认为事件应该是由外向内传播，就是当事件触发时，先触发当前元素最外层的祖先元素的事件 然后在向内传播给后代元素 -w3c综合两个公司的方案，将事件分成了三个阶段 1、事件的捕获阶段 -在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获， 捕获过程中不会触发响应函数 2、目标阶段 -事件捕获到目标元素，捕获结束后开始在目标元素中执行触发事件 3、冒泡阶段 -事件从目标元素向它的祖先元素传递，依次触发祖先元素的事件 -如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下不会使用，一般设置为false -ie8及以下的浏览器中没有捕获阶段 */ bind(box1,&quot;click&quot;,function()&#123; alert(&quot;我是box1的响应函数&quot;); &#125;); bind(box2,&quot;click&quot;,function()&#123; alert(&quot;我是box2的响应函数&quot;); &#125;); bind(box3,&quot;click&quot;,function()&#123; alert(&quot;我是box3的响应函数&quot;); &#125;); &#125;; function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容 obj.addEventListener(eventStr,callback,false); &#125;else&#123; /* this是谁由调用方式决定 callback.call(obj) */ // ie8及以下 // obj.attachEvent(&quot;on&quot;+eventStr,callback); obj.attachEvent(&quot;on&quot;+eventStr,function()&#123; callback.call(obj); &#125;); &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt; &lt;div id=&quot;box2&quot;&gt; &lt;div id=&quot;box3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9、练习—拖拽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: #bfa; position: absolute; &#125; #box2&#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 可以拖拽box1元素 -拖拽的流程 1、当鼠标在被拖拽元素上按下时，开始拖拽onmousedown 2、当鼠标移动时，被拖拽元素跟随鼠标移动onmousemove 3、当鼠标松开时，被拖拽元素固定在当前位置onmouseup */ var box1 = document.getElementById(&quot;box1&quot;); // 1、当鼠标在被拖拽元素上按下时，开始拖拽onmousedown box1.onmousedown=function(event)&#123; event = event||window.event; // div的偏移量 /* 鼠标.clientX - 元素.offsetLeft 鼠标.clientY - 元素.offsetTop */ var x1 =event.clientX - box1.offsetLeft; var y1 =event.clientY - box1.offsetTop; // 2、当鼠标移动时，被拖拽元素跟随鼠标移动onmousemove // 为document绑定一个鼠标移动事件 document.onmousemove=function(event)&#123; event = event||window.event; var x = event.clientX-x1; var y = event.clientY-y1; box1.style.left=x+&quot;px&quot;; box1.style.top=y+&quot;px&quot;; &#125;; document.onmouseup=function(event)&#123; //3、当鼠标松开时，被拖拽元素固定在当前位置onmouseup // 取消document的onmousemove事件 document.onmousemove=null; document.onmouseup=null; &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 10、拖拽2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: #bfa; position: absolute; &#125; #box2&#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 200px; top: 200px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 可以拖拽box1元素 -拖拽的流程 1、当鼠标在被拖拽元素上按下时，开始拖拽onmousedown 2、当鼠标移动时，被拖拽元素跟随鼠标移动onmousemove 3、当鼠标松开时，被拖拽元素固定在当前位置onmouseup */ var box1 = document.getElementById(&quot;box1&quot;); // 获取box2 var box2 = document.getElementById(&quot;box2&quot;); var img = document.getElementById(&quot;img1&quot;); drag(img1); drag(box1); // 给box2绑定拖拽 drag(box2); &#125;; /* 提取一个专门用来设置拖拽的函数 */ function drag(obj,event)&#123; // 1、当鼠标在被拖拽元素上按下时，开始拖拽onmousedown obj.onmousedown=function(event)&#123; obj.setCapture&amp;&amp;obj.setCapture(); event = event||window.event; var x1 =event.clientX - obj.offsetLeft; var y1 =event.clientY - obj.offsetTop; document.onmousemove=function(event)&#123; event = event||window.event; var x = event.clientX-x1; var y = event.clientY-y1; obj.style.left=x+&quot;px&quot;; obj.style.top=y+&quot;px&quot;; &#125;; document.onmouseup=function(event)&#123; document.onmousemove=null; document.onmouseup=null; obj.releaseCapture&amp;&amp;obj.releaseCapture(); &#125;; return false; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 我是一段文字 &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; &lt;img id=&quot;img1&quot; src=&quot;img/1.jpg&quot;style=&quot;position: absolute;&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; // 分别为两个按钮绑定单击响应函数 var btn01 = document.getElementById(&quot;btn01&quot;); var btn02 = document.getElementById(&quot;btn02&quot;); btn01.onclick=function()&#123; alert(1); &#125;; btn02.onclick=function()&#123; alert(2); &#125; // 设置btn01对鼠标按下相关的事件进行捕获 /* 当调用一个元素的setCaptrue()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自己身上 */ // btn01.setCaptrue(); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;按钮1&lt;/button&gt; &lt;button id=&quot;btn02&quot;&gt;按钮2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 十三、Day121、滚轮事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var box1 = document.getElementById(&quot;box1&quot;); /* 当滚轮向下滚动，box1变长，相反变短 */ /* 为box1绑定一个鼠标滚轮事件 onmousewheel鼠标滚轮滚动事件，会在鼠标滚动时触发 但是火狐不支持该属性 在火狐中需要使用DOMMouseScroll来绑定滚动事件 注意该事件需要通过addEventListener()函数来绑定 */ // var num=100; box1.onmousewheel=function(event)&#123; event=event||window.event; // alert(&quot;滚了&quot;); // 判断鼠标滚轮滚动的方向 // event.wheelDelta可以获取鼠标滚轮滚动的方向 // 不看大小，只看正负，向上正，向下负，但是火狐不支持 // alert(event.wheelDelta); // 火狐使用detail获取滚动的方向 // alert(event.detail); if(event.wheelDelta&gt;0||event.detail&lt;0)&#123; // alert(&quot;向上滚&quot;); // num+=10; box1.style.height= box1.clientHeight+10+&quot;px&quot;; &#125;else&#123; // num-=10; box1.style.height=box1.clientHeight-10+&quot;px&quot;; // alert(&quot;向下滚&quot;); &#125; /* 使用addEventListener()绑定的响应函数，取消默认行为不能使用return false 需要使用event来取消默认行为.但是ie8不支持，会报错 */ event.preventDefault&amp;&amp;event.preventDefault(); /* 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动 这是浏览器的默认行为，如果不希望发生，则取消默认行为return false */ return false; &#125;; // 为火狐绑定滚轮事件,现在使用onwheel bind(box1,&quot;DOMMouseScroll&quot;,box1.onmousewheel); &#125;; function bind(obj,eventStr,callback)&#123; if(obj.addEventListener)&#123; // 大部分浏览器兼容 obj.addEventListener(eventStr,callback,false); &#125;else&#123; /* this是谁由调用方式决定 callback.call(obj) */ // ie8及以下 // obj.attachEvent(&quot;on&quot;+eventStr,callback); obj.attachEvent(&quot;on&quot;+eventStr,function()&#123; callback.call(obj); &#125;); &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、键盘事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 键盘事件： onkeydown -按键按下 -对于onkeydown来说如果一直按着按键不松手，则事件会一直触发 -当onkeydown连续触发时，第一次和二次之间间隔会稍微长点，其他的非常的快 这种设计是为了防止误操作 onkeyup -按键松开 -不会连续触发 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document */ /* document.onkeydown=function(event)&#123; alert(event.key+&quot;按键被按下了&quot;); &#125; */ document.onkeyup=function(event)&#123; event=event||window.event; /* event.keycode 按键的Unicode编码 event.key 按键名字 -通过它那个判断哪个按键被按下 */ /* if(event.keyCode==89)&#123; alert(&quot;y被松开了&quot;); &#125; */ /* 判断y和ctrl是否同时被按下 无法通过以下判断，每次只能获取一个按键的编码 */ /* if(event.keyCode==89&amp;&amp;event.keyCode==17)&#123; alert(&quot;y和ctrl被松开了&quot;); &#125; */ /* 除了keyCode，事件对象还提供了几个属性 altKey ctrlKey shiftKey -这三个用来判断alt ctrl 和shift是否被按下 如果按下则返回true，否则返回false */ if(event.keyCode==89&amp;&amp;event.ctrlKey)&#123; alert(&quot;y和ctrl被同时松开了&quot;); &#125; // alert(event.key+&quot;按键被松开了&quot;); &#125;; // 获取input var input = document.getElementsByTagName(&quot;input&quot;)[0]; input.onkeydown=function(event)&#123; event=event||window.event; // console.log(event.key+&quot;按键被按下了&quot;); // 使用文本框不能输入数字，其他的可以 // 数字的keyCode是48到57 if(event.keyCode&gt;=48&amp;&amp;event.keyCode&lt;=57)&#123; alert(&quot;不能输入数字&quot;); return false; &#125; /* 在文本框中输入内容，属于onkeydown的默认行为 // 如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 */ // return false; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;input1&quot; type=&quot;text&quot;&gt;&lt;/body&gt;&lt;/html&gt; 3、练习—-移动div123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: #bfa; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; /* 使div可以根据不同的方向键向不同的方向移动， 按左键-左移 ... */ window.onload=function()&#123; var box1 = document.getElementById(&quot;box1&quot;); document.onkeydown=function(event)&#123; event=event||window.event; // alert(event.keyCode); /* if(event.keyCode==39||event.keyCode==68)&#123; // 右移 box1.style.left = box1.offsetLeft + 20 +&quot;px&quot;; &#125;else if(event.keyCode==37||event.keyCode==65)&#123; // 左移 box1.style.left = box1.offsetLeft - 20 +&quot;px&quot;; &#125;else if(event.keyCode==38||event.keyCode==87)&#123; // 上移 box1.style.top = box1.offsetTop - 20 +&quot;px&quot;; &#125;else if(event.keyCode==40||event.keyCode==83)&#123; // 下移 box1.style.top = box1.offsetTop + 20 +&quot;px&quot;; &#125; */ // 定义一个变量表示移动的速度 var speed = 10; // 当用户按住ctrl后，速度加快 if(event.ctrlKey)&#123; speed=30; &#125; switch(event.keyCode)&#123; case 37: // 左移 box1.style.left = box1.offsetLeft - speed +&quot;px&quot;; break; case 39: // 右移 box1.style.left = box1.offsetLeft + speed +&quot;px&quot;; break; case 38: // 上移 box1.style.top = box1.offsetTop - speed +&quot;px&quot;; break; case 40: // 下移 box1.style.top = box1.offsetTop + speed +&quot;px&quot;; break; &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、BOM—-Navigator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* BOM -浏览器对象模型 -BOM可以使我们通过JS来操作浏览器 -在BOM中为我们提供了一组对象，用来完成对浏览器的操作 -BOM对象 Window -代表整个浏览器的窗口，同时也是网页中的全局对象 Navigator -代表当前浏览器的信息，通过该对象可以识别不同的浏览器 Location -代表当前浏览器的地址栏信息，或者操作浏览器跳转页面 History -代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效 Screen -代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关信息 这些BOM对象在浏览器中都是作为window对象的属性保存的 可以通过window对象来使用，也可以直接使用 */ /* alert(window.navigator); alert(window.location); alert(window.screen); alert(window.history); */ /* Navigator -代表当前浏览器的信息，通过该对象可以识别不同的浏览器 -由于历史原因，Navigator对象的大部分属性都已经不能帮助我们识别浏览器了 -一般我们只会使用userAgent来判断浏览器的信息 userAgent就是一个字符串，这个字符串中包含有用来描述浏览器信息的内容 不同的浏览器有不同的userAgent 火狐：Mozilla/5.0(Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0 edge：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.52 在ie11中已经将微软和ie相关的标识已经去除了，所以我们基本已经不能通过userAgent来识别是不是ie浏览器了 属性： appName：返回浏览器的名字 */ // alert(window.navigator.appName); // alert(navigator.userAgent); var ua = navigator.userAgent; console.log(ua); if(/firefox/i.test(ua))&#123; alert(&#x27;你是火狐&#x27;); &#125;else if(/edg/i.test(ua))&#123; alert(&quot;你是edge&quot;); &#125;else if(/mise/i.test(ua))&#123; alert(&quot;你是ie&quot;); &#125;else if(&quot;ActiveXObject&quot; in window)&#123; alert(&quot;你是ie11，你个王八蛋！&quot;); &#125; /* 如果通过userAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息 比如：ActiveXObject */ /* if(window.ActiveXObject)&#123; alert(&quot;你是ie,你完了&quot;); &#125;else&#123; alert(&quot;你不是ie&quot;); &#125; */ // alert(!!window.ActiveXObject);//ie11让他是false // alert(&quot;ActiveXObject&quot; in window);//ie11可以抓了 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 5、History123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* Histroy -对象可以用来操作浏览器向前或向后翻页 属性： -length可以获取当前访问的链接数量 */ // alert(history);//Object history // alert(history.length); window.onload=function()&#123; var btn01= document.getElementById(&quot;btn01&quot;); btn01.onclick=function()&#123; /* back() -可以用来回退到上一个页面，作用和浏览器的回退按钮一样 */ // history.back(); /* forward() -可以跳转到下一个页面，作用和浏览器的前进按钮一样 */ // history.forward(); /* go() -可以用来跳转到指定的页面 -它需要一个整数作为参数 1、表示向前跳转一个页面 2、表示向前跳转两个页面 -1、向后跳转一个页面 ...... */ // history.go(1); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点我一下有惊喜&lt;/button&gt; &lt;h1&gt;Histroy&lt;/h1&gt; &lt;a href=&quot;04_BOM.html&quot;&gt;去bom&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 6、Location1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; var btn01= document.getElementById(&quot;btn01&quot;); btn01.onclick=function()&#123; /* 如果直接打印Location，则是获取地址栏的信息（当前页面的完整路径） */ // alert(location); /* 如果将location修改为一个绝对或相对路径， 页面会直接跳转到相应页面，并生成相应的历史记录 */ // location=&quot;https://www.xiaolin-blog.top&quot;; /* assign() -用来跳转到其他的页面，作用和直接修改location一样 */ // location.assign(&quot;https://www.bilibili.com&quot;); /* reload() -用于重新刷新当前页面，作用和刷新一样 -如果在方法中传递了一个参数true，则强制清空缓存刷新 */ // location.reload(true); /* replace() -可以使一个新页面替换当前页面，跳转后无法回退到当前页面 -不会生成历史记录 */ location.replace(&quot;https://bilibili.com&quot;); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点我一下有惊喜&lt;/button&gt; &lt;h1&gt;Location&lt;/h1&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;a href=&quot;04_BOM.html&quot;&gt;去bom&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 7、window–定时调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; var count = document.getElementById(&quot;count&quot;); /* 使count中的内容，自动切换 Js程序的执行速度是非常快的 如果希望一段程序，可以每隔一段事件执行一次，可以使用定时调用 */ /* for(var i =0;i&lt;100;i++)&#123; count.innerHTML=i; &#125; */ /* setInterval(); -定时调用 -可以将一个函数每隔一段时间执行一次 -参数: 1、回调函数，该函数会每隔一段时间被调用一次 2、每次调用间隔的时间，单位毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识 */ var num=0; var fun = function()&#123; count.innerHTML=num; num++; if(num==10)&#123; clearInterval(timer); &#125; &#125; var timer = setInterval(fun,1000); /* clearInterval() -用来关闭一个定时器 -方法需要一个定时器的标识作为参数，关闭指定的定时器 */ &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=&quot;count&quot;&gt;1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 8、练习–切换图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 500px; height: 400px; /* background-color: skyblue; */ text-align: center; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; /* 自动隔一段时间切换图片 */ //图片数组 var imgs = [&quot;img/1.jpg&quot;,&quot;img/2.jpg&quot;,&quot;img/3.jpg&quot;,&quot;img/4.jpg&quot;,&quot;img/5.jpg&quot;]; var img1 = document.getElementById(&quot;img1&quot;); var i=0; var btn01 = document.getElementById(&quot;btn01&quot;); var btn02 = document.getElementById(&quot;btn02&quot;); var timer; btn01.onclick=function()&#123; /* 目前，我们每点击一次，就会开启一个定时器 点击多次就会有多个，这就导致图片切换速度过快 并且只能关掉最后一个定时器（不断赋予新值的原因） */ // 在开启定时器之前，需要将当前元素上一次定时器关闭 // clearInterval(timer); timer = setInterval(function()&#123; i++; /* if(i&gt;=imgs.length)&#123; i=0; &#125; */ i = i%imgs.length; img1.src = imgs[i]; &#125;,1000); btn01.disabled=true; btn02.disabled=false; &#125; btn02.onclick=function()&#123; /* 点击按钮以后，关闭定时器 clearInterval可以接收任意类型，undefined也可以 如果有效就停止，无效就没啥事 */ clearInterval(timer); btn01.disabled=false; btn02.disabled=true; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;自动播放图片！！ &lt;img id=&quot;img1&quot; src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt; &lt;button id=&quot;btn01&quot;&gt;开始&lt;/button&gt; &lt;button id=&quot;btn02&quot; disabled&gt;结束&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9、移动div练习–优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1&#123; width: 100px; height: 100px; background-color: #bfa; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; /* 使div可以根据不同的方向键向不同的方向移动， 按左键-左移 ... */ window.onload=function()&#123; // 创建一个变量 var dir=0; var speed = 10; // 开启一个定时器，来控制div的移动 setInterval(function()&#123; // 定义一个变量表示移动的速度 // 通过修改dir影响div移动的方向 switch(dir)&#123; case 37: // 左移 box1.style.left = box1.offsetLeft - speed +&quot;px&quot;; break; case 39: // 右移 box1.style.left = box1.offsetLeft + speed +&quot;px&quot;; break; case 38: // 上移 box1.style.top = box1.offsetTop - speed +&quot;px&quot;; break; case 40: // 下移 box1.style.top = box1.offsetTop + speed +&quot;px&quot;; break; &#125; &#125;,30); var box1 = document.getElementById(&quot;box1&quot;); document.onkeydown=function(event)&#123; event=event||window.event; // alert(event.keyCode); /* if(event.keyCode==39||event.keyCode==68)&#123; // 右移 box1.style.left = box1.offsetLeft + 20 +&quot;px&quot;; &#125;else if(event.keyCode==37||event.keyCode==65)&#123; // 左移 box1.style.left = box1.offsetLeft - 20 +&quot;px&quot;; &#125;else if(event.keyCode==38||event.keyCode==87)&#123; // 上移 box1.style.top = box1.offsetTop - 20 +&quot;px&quot;; &#125;else if(event.keyCode==40||event.keyCode==83)&#123; // 下移 box1.style.top = box1.offsetTop + 20 +&quot;px&quot;; &#125; */ // 当用户按住ctrl后，速度加快 if(event.ctrlKey)&#123; speed=30; &#125;else&#123; speed=10; &#125; dir=event.keyCode; &#125;; // 当按键松开时，div不再移动 document.onkeyup=function()&#123; dir=0; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 10、延时调用1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; var num=1; // 开启一个定时器 /* setInterval(function()&#123; console.log(num++); &#125;,3000); */ /* 延时调用 延时调用一个函数不马上执行，而是隔一段时间以后再执行，只会执行一次 延时调用和定时调用的区别，就是定时调用执行多次，而延时调用只会执行一次 延时调用和定时调用实际上时可以互相代替的，在开发中可以根据需要去选择 */ var timer=setTimeout(function()&#123; console.log(num++); clearTimeout(timer); &#125;,3000); // clearTimeout(timer);关闭延时调用 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 11、定时器—练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #box1&#123; width: 100px; height: 100px; background-color: green; position: absolute; left: 0; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; // 获取box1 var box1 = document.getElementById(&quot;box1&quot;); // 获取btn01 var btn01= document.getElementById(&quot;btn01&quot;); // 点击按钮以后，使box1向右（left值增大） var timer; btn01.onclick=function()&#123; // 关闭一个定时器 clearInterval(timer); // 开启定时器，执行动画效果 timer = setInterval(function()&#123; // alert(oldValue); // 获取box1原来的left值 var oldValue =parseInt(getStyle(box1,&quot;left&quot;)); var newValue=oldValue+19; // 判断newValue是否大于800 if(newValue&gt;800)&#123; newValue=800; &#125; box1.style.left=newValue+&quot;px&quot;; // 当元素移动到800px是，使其停止执行 if(newValue==800)&#123; clearInterval(timer); &#125; &#125;,30); &#125;; &#125; function getStyle(obj,name)&#123; return window.getComputedStyle?getComputedStyle(obj,null)[name]:obj.currentStyle[name]; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点击按钮，box1向右移动&lt;/button&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width: 0px;height:1000px;border-left:1px solid black;position: absolute;left:800px;top:0&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、定时器–练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #box1&#123; width: 100px; height: 100px; background-color: green; position: absolute; left: 0; &#125; &lt;/style&gt; &lt;script&gt; var timer; window.onload=function()&#123; // 获取box1 var box1 = document.getElementById(&quot;box1&quot;); // 获取btn01 var btn01= document.getElementById(&quot;btn01&quot;); // 获取btn02 var btn02= document.getElementById(&quot;btn02&quot;); // 点击按钮以后，使box1向右（left值增大） btn01.onclick=function()&#123; move(box1,800,10) &#125; btn02.onclick=function()&#123; move(box1,0,10) &#125; &#125; function getStyle(obj,name)&#123; return window.getComputedStyle?getComputedStyle(obj,null)[name]:obj.currentStyle[name]; &#125; // 创建一个可以执行简单动画的函数 /* 参数： 1、obj执行动画的对象 2、target执行动画的目标位置 3、speed速度 */ function move(obj,target,speed)&#123; // 关闭一个定时器 clearInterval(timer); // 获取元素目前的位置 var current = parseInt(getStyle(obj,&quot;left&quot;)); // 判断speed的正负值 // 如果0-800移动，则speed为正 // 如果800-0移动，则speed为负 if(current&gt;target)&#123; //此时speed应该为负 speed=-speed; &#125; // 开启定时器，执行动画效果 timer = setInterval(function()&#123; // alert(oldValue); // 获取box1原来的left值 var oldValue =parseInt(getStyle(obj,&quot;left&quot;)); var newValue=oldValue+speed; // 判断newValue是否大于800 // 向左或向右移动时判断 if((speed&lt;0&amp;&amp;newValue&lt;target) || speed&gt;0&amp;&amp;newValue&gt;target)&#123; newValue=target; &#125; obj.style.left=newValue+&quot;px&quot;; // 当元素移动到0px时，使其停止执行 if(newValue==target)&#123; clearInterval(timer); &#125; &#125;,30); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点击按钮，box1向右移动&lt;/button&gt; &lt;button id=&quot;btn02&quot;&gt;点击按钮，box1向左移动&lt;/button&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width: 0px;height:1000px;border-left:1px solid black;position: absolute;left:800px;top:0&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 13、定时器—练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;tool.js&quot;&gt;&lt;/script&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #box1&#123; width: 100px; height: 100px; background-color: green; position: absolute; left: 0; &#125; #box2&#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 0; top:200px; &#125; &lt;/style&gt; &lt;script&gt; /* 目前定时器的标识由全局变量timer保存 所有正在执行的定时器都在这个变量中保存 */ // var timer; window.onload=function()&#123; // 获取box1 var box1 = document.getElementById(&quot;box1&quot;); // 获取btn01 var btn01= document.getElementById(&quot;btn01&quot;); // 获取btn02 var btn02= document.getElementById(&quot;btn02&quot;); // 获取btn03 var btn03= document.getElementById(&quot;btn03&quot;); // 获取btn04 var btn04= document.getElementById(&quot;btn04&quot;); // 点击按钮以后，使box1向右（left值增大） btn01.onclick=function()&#123; move(box1,&quot;left&quot;,800,20); &#125;; btn02.onclick=function()&#123; move(box1,&quot;left&quot;,0,10); &#125;; btn03.onclick=function()&#123; move(box2,&quot;left&quot;,800,10); &#125;; btn04.onclick=function()&#123; // move(box2,&quot;width&quot;,800,10) move(box2,&quot;width&quot;,800,10,function()&#123; // alert(&quot;动画执行完毕&quot;); move(box2,&quot;height&quot;,400,10,function()&#123; move(box2,&quot;top&quot;,0,10,function()&#123; move(box2,&quot;width&quot;,100,10,function()&#123; &#125;); &#125;); &#125;); &#125;); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点击按钮，box1向右移动&lt;/button&gt; &lt;button id=&quot;btn02&quot;&gt;点击按钮，box1向左移动&lt;/button&gt; &lt;button id=&quot;btn03&quot;&gt;点击按钮，box2向右移动&lt;/button&gt; &lt;button id=&quot;btn04&quot;&gt;测试&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div style=&quot;width: 0px;height:1000px;border-left:1px solid black;position: absolute;left:800px;top:0&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 封装js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function getStyle(obj,name)&#123; return window.getComputedStyle?getComputedStyle(obj,null)[name]:obj.currentStyle[name];&#125;// 创建一个可以执行简单动画的函数/* 参数： 1、obj执行动画的对象 2、attr执行动画的样式，比如left、top、width、height 3、target执行动画的目标位置 4、speed速度 5、callback回调函数，这个函数将会在动画执行完毕后执行*/function move(obj,attr,target,speed,callback)&#123; // 关闭一个定时器 clearInterval(obj.timer); // 获取元素目前的位置 var current = parseInt(getStyle(obj,attr)); // 判断speed的正负值 // 如果0-800移动，则speed为正 // 如果800-0移动，则speed为负 if(current&gt;target)&#123; //此时speed应该为负 speed=-speed; &#125; // 开启定时器，执行动画效果 /* 向执行动画的对象中添加一个timer属性，用来保存自己的定时器的标识 */ obj.timer = setInterval(function()&#123; // alert(oldValue); // 获取box1原来的left值 var oldValue =parseInt(getStyle(obj,attr)); var newValue=oldValue+speed; // 判断newValue是否大于800 // 向左或向右移动时判断 if((speed&lt;0&amp;&amp;newValue&lt;target) || speed&gt;0&amp;&amp;newValue&gt;target)&#123; newValue=target; &#125; obj.style[attr]=newValue+&quot;px&quot;; // 当元素移动到0px时，使其停止执行 if(newValue==target)&#123; clearInterval(obj.timer); // 动画执行完毕，调用回调函数 callback&amp;&amp;callback(); &#125; &#125;,30); &#125;; 14、轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0;; padding: 0; &#125; #outer&#123; /* 设置宽和高 */ width: 520px; height: 333px; margin: 100px auto; /* 设置背景颜色 */ background-image: linear-gradient(120deg,skyblue 70%,yellowgreen); /* 设置padding */ padding: 30px 0; /* overflow: hidden; */ position: relative; /* 裁剪溢出内容 */ overflow: hidden; &#125; #imgList&#123; /* width: 2600px; */ /* 去除项目符号 */ list-style: none; /* display: flex; */ /* 开启绝对定位 */ position: absolute; left: 0px; &#125; #imgList li&#123; margin: 0 10px; float: left; &#125; /* 设置导航按钮 */ #navDiv&#123; /* 开启绝对定位 */ position: absolute; bottom: 15px; /* 设置left值 outer宽度520 navDiv宽度25*5=125 520-125=395 395/2=197.5 */ /* left: 197px; */ &#125; #navDiv a&#123; float: left; width: 15px; height: 15px; background-color: red; margin: 0 5px; opacity: 0.4; filter: alpha(opacity=50); &#125; /* 设置鼠标移入的效果 */ #navDiv a:hover&#123; background-color: black; &#125; &lt;/style&gt; &lt;script src=&quot;tool.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload=function()&#123; // 设置imgList的宽度 // 获取imgList var imgList = document.getElementById(&quot;imgList&quot;); // 获取所有的img var imgArr = document.getElementsByTagName(&quot;img&quot;); // 设置imgList的宽度 imgList.style.width = 520*imgArr.length +&quot;px&quot;; /* 设置导航条居中 */ var navDiv = document.getElementById(&quot;navDiv&quot;); var outer = document.getElementById(&quot;outer&quot;); navDiv.style.left=(outer.offsetWidth- navDiv.offsetWidth)/2 +&quot;px&quot;; // 默认图片的索引 var index = 0; // 获取所有的a var allA = document.getElementsByTagName(&quot;a&quot;); // 设置默认选中的效果 allA[index].style.backgroundColor=&quot;black&quot;; /* 点击超链接切换到指定的图片 */ for(var i=0;i&lt;allA.length;i++)&#123; allA[i].num=i; allA[i].onclick = function()&#123; // 关闭自动切换定时器 clearInterval(timer); // 获取点击超链接的索引,并将其设置为index index=this.num; // 切换图片 // imgList.style.left= -520*index +&quot;px&quot;; setA(); // 使用move函数切换 move(imgList,&quot;left&quot;,-520*index,20,function()&#123; // 动画执行完毕，开启定时器 autoChange(); &#125;); &#125;; &#125; // 自动切换图片 autoChange(); // 创建一个方法来设置选中的a function setA()&#123; // 判断当前索引是否是最后一张 if(index&gt;=imgArr.length-1)&#123; // 将index设置为0 index=0; // 此时是最后一张，最后一张和第一张一模一样 imgList.style.left=0; &#125; for(var i=0;i&lt;allA.length;i++)&#123; allA[i].style.backgroundColor=&quot;&quot;; &#125; allA[index].style.backgroundColor=&quot;black&quot;; &#125;; var timer; // 创建一个函数，用来开启切换图片 function autoChange()&#123; // 开启定时器，定时切换 timer = setInterval(function()&#123; // 使用索引自增 index++; // 判断图片索引 index%=imgArr.length; //切换图片 move(imgList,&quot;left&quot;,-520*index,20,function()&#123; // 修改导航条 setA(); &#125;); &#125;,3000) &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个外部div，作为外层容器 --&gt; &lt;div id=&quot;outer&quot;&gt; &lt;!-- 创建 一个ul，用于放置图片--&gt; &lt;ul id=&quot;imgList&quot;&gt; &lt;li&gt; &lt;img src=&quot;img/1.jpg&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;img/2.jpg&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;img/3.jpg&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;img/4.jpg&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;img/5.jpg&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;img/1.jpg&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 创建导航按钮 --&gt; &lt;div id=&quot;navDiv&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十四、Day131、类的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .b1&#123; width: 100px; height: 100px; background-color: red; &#125; .b2&#123; /* width: 200px; */ height: 200px; background-color: greenyellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; // 获取btn01 var btn01 = document.getElementById(&quot;btn01&quot;); // 获取box1 var box1= document.getElementById(&quot;box1&quot;); btn01.onclick=function()&#123; // 修改box1的样式 /* 通过style属性来修改元素的样式，每修改一个样式，浏览器就要重新渲染一次页面 这样执行的性能很差，而且这种形式当我们要修改多个样式时，也不太方便 */ /* box1.style.width=200+&quot;px&quot;; box1.style.height=200+&quot;px&quot;; box1.style.backgroundColor=&quot;yellow&quot;; */ /* 希望一行代码修改多个样式 这样我们只需要修改一次，即可同时修改多个样式 浏览器只需要重新渲染一次，性能较好 表现和行为耦合度降低 */ // box1.className+=&quot; b2&quot;; // addClass(box1,&quot;b2&quot;); // removeClass(box1,&quot;b1&quot;); // addClass(box1,&quot;b2&quot;); toggleClass(box1,&quot;b2&quot;); &#125;; &#125;; // 定义一个函数，用来向一个元素中添加指定的class属性值 /* 参数 1、obj 要添加class属性的元素 2、cn要添加的class值 */ function addClass(obj,cn)&#123; if(!hasClass(obj,cn))&#123; obj.className+=&quot; &quot;+cn; &#125; &#125; /* 判断一个元素是否含有指定的class属性值 如果有该class返回true，没有返回false */ function hasClass(obj,cn)&#123; // 判断obj中有没有cn这个类 var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;); return reg.test(obj.className); &#125; /* 删除一个元素中的一个Class */ function removeClass(obj,cn)&#123; // 使用正则表达式用空串替换cn var reg = new RegExp(&quot;\\\\s\\\\b&quot;+cn+&quot;\\\\b&quot;); obj.className=obj.className.replace(reg,&quot;&quot;); &#125; /* toggleClass可以用来切换一个类 如果元素中具有该类，则删除 如果元素中没有该类，则添加 */ function toggleClass(obj,cn)&#123; if(hasClass(obj,cn))&#123; removeClass(obj,cn); &#125;else&#123; // 没有则添加 addClass(obj,cn); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn01&quot;&gt;点击按钮以后，修改box的样式&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;div id=&quot;box1&quot; class=&quot;b1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、二级菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;二级菜单&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; list-style-type: none; &#125; a,img &#123; border: 0; text-decoration: none; &#125; body &#123; font: 12px/180% Arial, Helvetica, sans-serif, &quot;新宋体&quot;; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/sdmenu.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tools.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; /* 每一个菜单都是一个div 当div具有collapsed这个类时，是折叠 当div没有这个类时，dic就是展开的状态 */ /* 点击菜单，切换菜单的显示状态 */ // 获取全部菜单span var spans = document.querySelectorAll(&quot;.menuSpan&quot;); // 定义一个变量，用来保存当前打开的菜单 var openDiv = spans[0].parentNode; for(var i=0;i&lt;spans.length;i++)&#123; spans[i].onclick=function()&#123; // this是当前的span // 获取span的父元素 var parentDiv = this.parentNode; // 切换菜单显示状态 toggleMenu(parentDiv); // 判断openDiv和parentDiv是否相同 if(openDiv!=parentDiv&amp;&amp;!hasClass(openDiv,&quot;collapsed&quot;))&#123; // 关闭之前打开的菜单 // 为了统一处理动画过渡效果，现在将addClass改为toggleClass // addClass(openDiv,&quot;collapsed&quot;); // 此处只需要添加class // toggleClass(openDiv,&quot;collapsed&quot;); //切换菜单显示状态 toggleMenu(openDiv); &#125; openDiv=parentDiv; &#125;; &#125; /* 用来切换菜单展开和折叠 */ function toggleMenu(obj)&#123; // 在切换类之前，获取元素的高度 var begin = obj.offsetHeight; // 切换parentDiv的显示 toggleClass(obj,&quot;collapsed&quot;); // 在切换类之后获取一个高度 var end = obj.offsetHeight; // 动画效果就是要将高度从begin向end过渡 // 将元素高度重置为begin obj.style.height=begin+&quot;px&quot;; // 执行动画 move(obj,&quot;height&quot;,end,10,function()&#123; // 动画执行完毕,删除内联样式 obj.style.height=&quot;&quot;; &#125;); // obj.style.transition=&quot;all 2s&quot; ; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;my_menu&quot; class=&quot;sdmenu&quot;&gt; &lt;div&gt; &lt;span class=&quot;menuSpan&quot;&gt;在线工具&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;图像优化&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;收藏夹图标生成器&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;邮件&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;htaccess密码&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;梯度图像&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;按钮生成器&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapsed&quot;&gt; &lt;span class=&quot;menuSpan&quot;&gt;支持我们&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;推荐我们&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;链接我们&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;网络资源&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapsed&quot;&gt; &lt;span class=&quot;menuSpan&quot;&gt;合作伙伴&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;JavaScript工具包&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;CSS驱动&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;CodingForums&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;CSS例子&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapsed&quot;&gt; &lt;span class=&quot;menuSpan&quot;&gt;测试电流&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;Current or not&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Current or not&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Current or not&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Current or not&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3、JSON1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* JSON -js中的对象只有js自己认识，其他的语言都不认识 JSOn就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别 并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 -JSON -JavaScript Object Notation JS对象表示法 ——JSON和js对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他和js语法一致 -JSON分类 1、对象&#123;&#125; 2、数组[] -JSON中允许的值 1、字符串 2、数值 3、布尔值 4、null 5、对象 6、数组 */ // var obj = &#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;; // console.log(typeof obj);//String var arr =&#x27;[1,2,3,&quot;hello&quot;,true]&#x27;; var obj2 =&#x27;&#123;&quot;arr&quot;:[1,2,3]&#125;&#x27;; var arr2 =&#x27;[&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;,1,2,3,&quot;hello&quot;,true]&#x27;; /* 将json字符串转换为js中的对象 在js中为我们提供了一个工具类，就加json 这个对象可以帮助我们将一个json转换为js对象，也可以将js对象转换为json */ var objJson = &#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;; /* JSON--&gt;js对象 JSON.parse(); -可以将JSON字符串转换为js对象 -它需要一个JSON字符串作为参数，会将该字符串转换为js对象 */ var o = JSON.parse(objJson); // console.log(o.gender); var o2 =JSON.parse(arr); // console.log(o2[1]); var obj3 = &#123; &quot;name&quot;:&quot;猪八戒&quot;, &quot;age&quot;:18, &quot;gender&quot;:&quot;男&quot; &#125;; /* JS对象---&gt;JSON字符串 -JSON.stringify() -可以将一个js对象转换为json字符串 -需要一个js对象作为参数，会返回一个JSON字符串 */ var s3 = JSON.stringify(obj3); console.log(s3); /* JSON对象在ie7以下的浏览器中不支持，所以在这些浏览器中 调用时会报错 */ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 4、JSON123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 如果需要兼容ie7及以下的json操作，则可以通过引入一个外部的js文件来解决 --&gt; &lt;script src=&quot;js/json2.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var str = &#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;; /* eval() 这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回 如果使用eval()执行的字符串中含有&#123;&#125;。他会将&#123;&#125;当成代码块 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() -eveal()这个函数功能很强大，可以直接执行一个字符串的js代码 但在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 */ var str2=&quot;alert(&#x27;hello&#x27;);&quot;; // eval(str2); var obj = eval(&quot;(&quot;+str+&quot;)&quot;); console.log(obj); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","tags":"js"},{"title":"ES6","url":"/2022/11/02/ECMAScript6（包含es6-es11）/","text":"# ECMAScript6（包含es6-es11） [Toc] 一、强大的babel被称为下一代的JavaScript编译器，可以将es6的代码转换成es5的代码，从而让浏览器获得支持 Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下： 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装 12345# 最新转码规则$ npm install --save-dev @babel/preset-env# react 转码规则$ npm install --save-dev @babel/preset-react 然后，将这些规则加入.babelrc 1234567&#123; &quot;presets&quot;: [ &quot;@babel/env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;: [] &#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc. 命令行转码Babel 提供命令行工具@babel/cli，用于命令行转码。它的安装命令如下： 1$ npm install --save-dev @babel/cli 基本用法如下: 1234567891011121314151617# 转码结果输出到标准输出$ npx babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ npx babel example.js --out-file compiled.js# 或者$ npx babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ npx babel src --out-dir lib# 或者$ npx babel src -d lib# -s 参数生成source map文件$ npx babel src -d lib -s babel-node@babel/node模块的babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 安装模块命令： 1$ npm install --save-dev @babel/node 然后，执行babel-node就进入 REPL 环境： 123$ npx babel-node&gt; (x =&gt; x * 2)(1)2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行: 1234# es6.js 的代码# console.log((x =&gt; x * 2)(1));$ npx babel-node es6.js2 babel&#x2F;register模块@babel/register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 安装模块： 1$ npm install --save-dev @babel/register 使用时，必须首先加载@babel/register： 123// index.jsrequire(&#x27;@babel/register&#x27;);require(&#x27;./es6.js&#x27;); 然后，就不需要手动对index.js转码了: 12$ node index.js2 需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 polyfillBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片。 安装命令如下。 1$ npm install --save-dev core-js regenerator-runtime 然后，在脚本头部，加入如下两行代码。 12345import &#x27;core-js&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;// 或者require(&#x27;core-js&#x27;);require(&#x27;regenerator-runtime/runtime&#x27;); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 浏览器环境Babel 也可以用于浏览器环境，使用@babel&#x2F;standalone模块提供的浏览器版本，将其插入网页。 1234&lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;// Your ES6 code&lt;/script&gt; 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 二、let和const123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // var 变量提升 /* console.log(a); var a = 2; */ // 1、let声明变量，没有变量提升 // console.log(a);//报错 // let a = 10; // console.log(b); // 2、是一个块级作用域 /* if(1===1)&#123; let b =10; &#125; */ // console.log(b);//报错 /* var c=2; var c=4; */ // console.log(c);//4 // 3、不能重复声明 // let c =1; // let c=4;//报错，c已经被声明了 // console.log(c); // 1、不会变量提升 // console.log(Max);//报错 // const Max = 30; // const 2、声明常量，一旦被声明，无法修改const。一旦声明变量，就必须立即初始化，不能留到以后赋值。 // Max =40;//报错 // console.log(max); // 3、有块级作用域 /* if(1===1)&#123; const Max = 30; &#125; console.log(Max); */ //报错 // 4、不能重复声明 // const Max = 30; // const Max = 40;//报错 /* const person =&#123; name:&#x27;xiaolin&#x27; &#125;; person.name = &#x27;XIAOLIN&#x27;; */ //可以修改属性 // 不能修改整个对象 /* person =&#123; age:20 &#125;; console.log(person.name); */ //如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze(&#123;&#125;); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; //除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === &#x27;object&#x27; ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; /* var arr = []; for(var i=0;i&lt;10;i++)&#123; arr[i] = function()&#123; return i; &#125; &#125; console.log(arr); console.log(arr[5]()); */ //10 // 作用1：for循环（经典例子） const arr = []; for(let i=0;i&lt;10;i++)&#123; arr[i] = function()&#123; return i; &#125; &#125; //上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 console.log(arr);// console.log(arr[5]());//5 // 作用2：不会污染全局变量 let RegExp = 10; console.log(RegExp); console.log(window.RegExp); // 建议：在默认情况下用const，而只有你知道变量值需要被修改的情况下使用let &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &#x27;abc&#x27;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量） 暂时性死区有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 三、模板字符串1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;script&gt; // 模板字符串：使用tab键上面的反引号，插入变量时使用$&#123;变量名&#125; const oBox = document.querySelector(&#x27;.box&#x27;);; let id= 1, name=&quot;xiaolin&quot;; // oBox.innerHTML = &quot;&lt;ul&gt;&lt;li&gt;&lt;p id=&quot;+id+&quot;&gt;&quot;+name+&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&quot; // 使用反引号添加 let htmlStr = ` &lt;ul&gt; &lt;li&gt; &lt;p id=&quot;$&#123;id&#125;&quot;&gt;$&#123;name&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;`; oBox.innerHTML = htmlStr; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、强大的函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1、带参数默认值的函数 // es5写法 /* function add(a,b)&#123; a = a || 10; //给a添加默认值 b = b || 20; //给b添加默认值 return a+b; &#125; consle.log(add()); */ // 直接使用=给a和b添加默认值 function add(a=10,b=20)&#123; return a+b; &#125; // console.log(add(30)); // 2、默认的表达式也可以是一个函数 /* function add(a,b=getVal(5))&#123; return a+b; &#125; function getVal(val)&#123; return val +5; &#125; consle.log(add(10)); */ //10+10=20 // es5写法 /* function pick(obj)&#123; let result = Object.create(null); for(let i=1;i&lt;arguments.length;i++)&#123; // console.log(arguments[i]); result[arguments[i]] = obj[arguments[i]]; &#125; return result; &#125; let book = &#123; title:&#x27;es6hhh&#x27;, author:&#x27;xiaolin&#x27;, year:2022 &#125; let bookData = pick(book,&#x27;author&#x27;,&#x27;year&#x27;,&#x27;author&#x27;); console.log(bookData); */ // 3、剩余参数：由三个点...和一个紧跟着的具体参数指定 ...keys function pick(obj,...keys)&#123; //...keys 解决了arguments的问题 let result = Object.create(null); for(let i=1;i&lt;keys.length;i++)&#123; result[keys[i]] = obj[keys[i]]; &#125; return result; &#125; let book = &#123; title:&#x27;es6hhh&#x27;, author:&#x27;xiaolin&#x27;, year:2022 &#125; let bookData = pick(book,&#x27;author&#x27;,&#x27;year&#x27;,&#x27;author&#x27;); // console.log(bookData); function checkArgs(...args)&#123; //剩余运算符：如果原来是对象：产生的就是对象；如果原来是数组，产生的就是数组 console.log(args); console.log(arguments); &#125; // checkArgs(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); // 4、扩展运算符... // 剩余运算符：把多个独立的参数合并到一个数组中 // 扩展运算符：将一个数组分割，并将各个项作为分离的参数传给函数 /* const maxNum = Math.max(20,30); console.log(maxNum); */ // 处理数组中的最大值,使用apply const arr = [10,20,30,40,50,100,200,300]; // console.log(Math.max.apply(null,arr)); //es5 // es6扩展运算符更方便 // console.log(Math.max(...arr)); // 5、es6的箭头函数 ***** // 使用 =&gt;来定义 function()&#123;&#125; 等于()=&gt;&#123;&#125; /* let add =function(a,b)&#123; return a+b; &#125; */ /* let add = (a,b)=&gt;&#123; return a+b; &#125; */ /* let add = val =&gt;&#123; return val+5; &#125; */ // let add = val =&gt; (val+5); // let add = (a,b) =&gt;a+b; // console.log(add(10,20)); let fn = ()=&gt; &#x27;hello World&#x27;+123; // console.log(fn()); /* let getObj = id =&gt;&#123; return &#123; id:id, name:&quot;xiaolin&quot; &#125; &#125; */ let getObj = id =&gt;(&#123;id:id,name:&quot;xiaolin&quot;&#125;); let obj = getObj(1); // console.log(obj); /* let fn2 = (function()&#123; return function()&#123; console.log(&#x27;hello es6&#x27;); &#125; &#125;)(); */ let fn2 = (()=&gt;&#123; return ()=&gt;&#123; console.log(&#x27;hello es6&#x27;); &#125; &#125;)(); // fn2(); // 6、箭头函数没有this绑定 // es5中的this指向：取决于调用该函数的上下文对象 /* let PageHandle = &#123; id:123, init:function()&#123; document.addEventListener(&#x27;click&#x27;,function(event)&#123; console.log(this);//document this.doSomethings(event.type);// this.doSomethings is not a function &#125;.bind(this),false) &#125;, doSomethings:function(type)&#123; console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`); &#125; &#125; PageHandle.init(); */ let PageHandle = &#123; id:123, init:function()&#123; // 箭头函数没有this指向，箭头函数内部this值只能通过查找作用域链 // 一旦使用箭头函数，当前就不存在作用域链 document.addEventListener(&#x27;click&#x27;,(event)=&gt;&#123; console.log(this);//PagrHandle this.doSomethings(event.type); &#125;) &#125;, doSomethings:function(type)&#123; console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`); &#125; &#125; // PageHandle.init(); // 使用箭头函数的注意事项 // 1、函数内部没有arguments let getVal=(a,b)=&gt;&#123; console.log(arguments);//arguments is not defined return a+b; &#125; // console.log(getVal(1,3)); // 2、箭头函数不能使用new关键字来实例化对象 let Person = ()=&gt;&#123; &#125;; // function函数，也是一个对象，但是箭头函数不是一个对象，它其实是一个语法糖 // let p =new Person();//报错 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、解构赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 解构赋值是对赋值运算符的一种扩展 // 针对数组和对象进行操作的 // 优点:代码书写上简洁易读 //如果解构不成功，变量的值就等于undefined。 let node = &#123; type:&#x27;iden&#x27;, name:&#x27;foo&#x27; &#125; /* let type =node.type; let name = node.name; */ // 完全解构 let &#123;type,name&#125;=node; // console.log(type,name); let obj=&#123; a:&#123; name:&quot;张三&quot; &#125;, b:[1,2,3], c:&#x27;hello es6&#x27; &#125; // 不完全解构 // let &#123;a&#125; = obj; // console.log(a); // 剩余运算符 //如果原来是对象：产生的就是对象；如果原来是数组，产生的就是数组 // let &#123;a,...res&#125;=obj; // console.log(res); //注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 //如果变量名与属性名不一致，必须写成下面这样。 let &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;; // baz &quot;aaa&quot; let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;; let &#123; first: f, last: l &#125; = obj; //f &#x27;hello&#x27; //l &#x27;world&#x27; // 运行指定默认值 // let &#123;a,b=30&#125; = &#123;a:20&#125;; // 对数组解构 let arr = [1,2,3]; // let [a,b] = arr; // console.log(a,b); // 可嵌套 let [a,[b,b1,b2],c] = [1,[2,3,4],3]; console.log(a,b,b1,b2,c); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log(&#x27;aaa&#x27;);&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明 解构赋值的用途（1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set(&#x27;first&#x27;, &#x27;hello&#x27;);map.set(&#x27;second&#x27;, &#x27;world&#x27;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;); 六、扩展的对象的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1、es6直接写入变量和函数，作为对象的属性和方法 // const name = &#x27;xiaolin&#x27;,age=21; /* const person =&#123; name:name, age:age, sayName:function()&#123; console.log(this.name); &#125; &#125; */ // 等价于以下写法，同名省略 const name = &#x27;xiaolin&#x27;,age=21; const person =&#123; name, age, sayName()&#123; console.log(this.name); &#125; &#125; // person.sayName(); /* function fn(x,y)&#123; return &#123;x,y&#125;; &#125; */ let fn = (x,y)=&gt;(&#123;x,y&#125;); // console.log(fn(10,20)); let cart = &#123; wheel:4, set(newVal)&#123; if(newVal&lt;this.wheel)&#123; throw new Error(&#x27;轮子数太少了&#x27;); &#125; this.wheel=newVal; &#125;, get()&#123; return this.wheel; &#125; &#125; // console.log(cart.get()); // cart.set(3); // console.log(cart.get()); /* const obj = &#123;&#125;; obj.isShow = true; const name = &#x27;a&#x27;; obj[name+&#x27;bc&#x27;]=123; // console.log(obj); obj[&#x27;f&#x27;+&#x27;bc&#x27;]=function()&#123; console.log(this); &#125; console.log(obj); */ const name1 = &#x27;a&#x27;; const obj=&#123; isShow:true, [name1+&#x27;bc&#x27;]:123, [&#x27;f&#x27;+name1]:function()&#123; console.log(this); &#125; &#125;; // console.log(obj); // 对象的方法 // is() ==== 比较两个值是否严格相等 // 解决NaN的问题 // console.log(NaN===NaN);//false // console.log(Object.is(NaN,NaN));//true // assign() 对象的合并***** // Object.assign(target,obj1,obj2,...); // 返回合并之后的新对象，浅拷贝 let newObj = Object.assign(&#123;&#125;,&#123;a:1&#125;,&#123;b:2&#125;); // console.log(newObj); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、Symbol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 原始数据类型Symbol，它表示的是独一无二的值 // 最大用途：用来定义对象的私有变量 const name = Symbol(&#x27;name&#x27;); const name2 = Symbol(&#x27;name&#x27;); // console.log(name===name2);//false // console.log(name);//Symbol(name) // console.log(name2);//Symbol(name) // console.log(typeof name);//symbol let s1 = Symbol(&#x27;s1&#x27;); // console.log(s1); let obj = &#123; [s1]:&#x27;xiaolin&#x27; &#125;; // obj[s1]=&#x27;xiaolin&#x27;; // 如果用Symbol定义的对象中的变量，取值时一定要用[变量名] // console.log(obj[s1]); //可枚举可以理解为是否可以被遍历被列举出来，可枚举性决定了这个属性能否被for…in查找遍历到。 /* for(let key in obj)&#123; console.log(key);//无法输出 &#125; */ // [s1]不可枚举，所以输出空数组 // console.log(Object.keys(obj)); // 获取Symbol声明的属性名（作为对象的key） let s = Object.getOwnPropertySymbols(obj); // console.log(s); // console.log(s[0]); //静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。 let m = Reflect.ownKeys(obj); // console.log(m); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、Map和Set1、Set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 集合：表示无重复值的有序列表 let set = new Set(); // console.log(set); // 添加元素 set.add(2); set.add(&#x27;2&#x27;); set.add([&quot;hello&quot;,1,2,3]); // 删除元素 set.delete(&#x27;2&#x27;); // 检验某个值是否在set中 // console.log(set.has(2)); // console.log(set); // 集合的长度 // console.log(set.size); // key和val是一样的 set.forEach((val,key)=&gt;&#123; // console.log(val,key); &#125;); // 将set转换成数组(去除数组中的重复内容) let set2 = new Set([1,2,3,4,5,4,3]); // 扩展运算符 let arr = [...set2]; // console.log(arr); // 1、set中的对象的引用无法被释放 let set3 = new Set(),obj=&#123;a:1&#125;; set3.add(obj); // 释放obj对象 obj = null; // console.log(set3);//依然存在obj let set4 = new WeakSet(),obj1=&#123;a:1&#125;; set4.add(obj1); // 释放obj对象 obj1 = null; console.log(set4); /* WeakSet 1、不能传入非对象类型的参数 2、不可迭代 3、没有forEach() 4、没有size属性 */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、Map123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // Map类型是键值对的有序列表，键和值是任意类型 /* let map = new Map(); map.set(&#x27;name&#x27;,&#x27;张三&#x27;); map.set(&#x27;age&#x27;,21); console.log(map.get(&#x27;name&#x27;)); console.log(map); map.has(&#x27;name&#x27;); map.delete(&#x27;name&#x27;); console.log(map); map.clear(); console.log(map); map.set([&#x27;a&#x27;,1,2],&quot;hello&quot;); console.log(map); */ let m = new Map([ [&#x27;a&#x27;,1], [&#x27;c&#x27;,2] ]); console.log(m); // WeakMap和WeakSet类似 let map2 = new WeakMap(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 九、数组的扩展功能1、扩展方法11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 数组的方法 from() of() //1、form()将伪数组转换为真正的数组 function add()&#123; console.log(arguments); // es5的转换方法 /* let arr = [].slice.call(arguments); console.log(arr); */ // es6写法 let arr = Array.from(arguments); console.log(arr); &#125; // add(1,2,3); let lis = document.querySelectorAll(&#x27;li&#x27;); // console.log(lis); // console.log(Array.from(lis)); // 扩展运算符，将伪数组转换为真正的数组 // console.log([...lis]); // from()还可以接收第二个参数，用来对每个元素进行处理 let liContents = Array.from(lis,ele=&gt;ele.textContent); // console.log(liContents); //2、of()将一组值(任意类型），转换为数组 let arr = console.log(Array.of(3,11,&#x27;20&#x27;,[1,3],&#123;id:1&#125;)); // 3、copywithin()复制3索引开始位置往后的内容替换0索引开始往后的内容 console.log([1,2,3,8,9,10].copyWithin(0,3));//[8,9,10,8,9,10] // 4、find() findIndex() // find()找到一个符合条件的数组成员并返回 let num = [1,2,-10,-20,9,2].find(n=&gt;n&lt;0); console.log(num); // findIndex()找到一个符合条件的数组成员的索引并返回 let numIndex = [1,2,-10,-20,9,2].findIndex(n=&gt;n&lt;0); console.log=(numIndex); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、扩展方法212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //5、entries() keys() values()返回一个遍历器，可以使用for...of循环进行遍历 //keys()对键名遍历 // values()对值进行遍历 // entries()对键值对遍历 console.log([&#x27;a&#x27;,&#x27;b&#x27;].keys()); // 取索引 for(let index of [&#x27;a&#x27;,&#x27;b&#x27;].keys())&#123; console.log(index); &#125; for(let value of [&#x27;a&#x27;,&#x27;b&#x27;].values())&#123; console.log(value); &#125; /* let arr = new Array; for(let arr of [&#x27;a&#x27;,&#x27;b&#x27;].entries())&#123; console.log(arr[0],arr[1]); &#125; */ for(let [index,ele] of [&#x27;a&#x27;,&#x27;b&#x27;].entries())&#123; console.log(index,ele); &#125; let letter = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]; let it = letter.entries(); /* console.log(it.next().value); console.log(it.next().value); console.log(it.next().value); console.log(it.next().value); */ // 6、includes()返回一个布尔值，表示某个数组是否包含给定的值 console.log([1,2,3].includes(2));//true console.log([1,2,3].includes(4));//false // 以前的indexOf() console.log([1,2,3].indexOf(3));//返回的是索引的位置 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十、迭代器12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // Iterator // 是一种新的遍历机制 // 1、迭代器是一个接口，能快捷的访问数据 // 通过Symbol.iterator来创建迭代器，通过迭代器的next()来获取迭代之后的结果 // 2、迭代器是用于遍历数据结构的指针（数据库的游标） // 使用迭代 const items = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;]; // 创建新的迭代器 const ite = items[Symbol.iterator](); console.log(ite.next());//&#123;value: &quot;one&quot;, done:false&#125; done表示是否遍历完成，false未完成，true为完成 console.log(ite.next()); console.log(ite.next()); console.log(ite.next()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十一、生成器1、生成器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //generator函数，可以通过yield关键字，将函数挂起，为了改变执行流程提供了可能，同时为异步编程也提供了方案 // 它和普通函数的区别 // 1、function后面 函数名之前有个* // 2、只能在函数内部使用yield表达式，让函数挂起 function* func()&#123; console.log(&quot;one&quot;); yield 2; console.log(&quot;two&quot;); yield 3; console.log(&quot;end&quot;); &#125; // 返回一个遍历对象，可以调用next() let fn = func(); // console.log(fn.next()); // console.log(fn.next()); // console.log(fn.next()); // 总结：generator函数是分段执行的，yield语句是暂停执行，而next()是恢复执行 function* add()&#123; console.log(&quot;start&quot;); let x = yield &#x27;2&#x27;; console.log(&quot;one:&quot;+x); let y = yield &#x27;3&#x27;; console.log(&quot;two:&quot;+y); console.log(&quot;total:&quot;+(x+y)); // return x+y; &#125; const fn1 = add(); /* console.log(fn1.next());//在yield &#x27;2&#x27;处，停下，&#123;value:&#x27;2&#x27;,done:false&#125; console.log(fn1.next(20));//在yield &#x27;3&#x27;处停下，20给x传值，x变为20，输出one:20，&#123;value:&#x27;3&#x27;,done:false&#125;; console.log(fn1.next(30));//30给y传值，输出 two:30,&#123;value:50,done=true&#125;; console.log(fn.return(100)); */ // 使用场景，为不具备Iterator接口的对象提供了遍历操作 function* objectEntires(obj)&#123; // 获取对象的所有key保存到数组[name,age] const propkeys = Object.keys(obj); for(const propkey of propkeys)&#123; yield [propkey,obj[propkey]]; &#125; &#125; const obj = &#123; name:&quot;小林&quot;, age:21 &#125; // obj[Symbol.iterator] = objectEntires; // console.log(obj); for(let [key,value] of objectEntires(obj))&#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、Generator的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* Generator 部署ajax操作，让异步代码同步化 */ // 回调地狱 // $.ajax(&#123; // url:&#x27;http://127.0.0.1:5500/test.html&#x27;, // method:&#x27;get&#x27;, // success(res)&#123; // console.log(res); // // 继续发送请求 // /* $.ajax(&#123; // url:&#x27;&#x27;, // method:&#x27;&#x27;, // success(res1)&#123; // console.log(res1); // // 继续发送请求 // &#125; // &#125;) */ // &#125; // &#125;); /* const a = 10; const b = 20; */ /* function* main()&#123; let res = yield request(&#x27;url&#x27;); console.log(res); // 执行后面操作 console.log(&quot;数据请求完成，可以继续操作&quot;); &#125; const ite = main(); ite.next(); function request(url)&#123; $.ajax(&#123; url, method:&#x27;get&#x27;, success(res)&#123; ite.next(res); &#125; &#125;); &#125; */ // 加载locaing...页面 // 数据加载完成... // loading关闭掉 function* load()&#123; loadUI(); yield showData(); hideUI(); &#125; let itLoad = load(); itLoad.next(); function loadUI()&#123; console.log(&quot;加载loading...页面&quot;); &#125; function showData()&#123; setTimeout(()=&gt;&#123; console.log(&quot;数据加载完成&quot;); itLoad.next(); &#125;,5000); &#125; function hideUI()&#123; console.log(&quot;隐藏loading...页面&quot;); &#125; /* loadUI(); showData(); hideUI(); */ /* function showData1()&#123; console.log(&quot;加载loading...页面&quot;); setTimeout(()=&gt;&#123; console.log(&quot;数据加载完成&quot;); console.log(&quot;隐藏loading...页面&quot;); &#125;,1000); &#125; showData1(); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十二、Promise1、Promise对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // Promise 承诺 // 相对于一个容器，保存着未来才会结束的事件（异步操作）的一个结果 // 各种异步操作都可以用同样的方法进行处理axios /* 特点： 1、对象的状态不受外界影响，处理异步操作有三个操作 Pending（进行中） Resolved（成功） Rejected（失败） 2、一旦状态改变，就不会再变，任何时候都可以得到这个结果 */ /* let pro = new Promise(function(resolved,rejected)&#123; // 执行异步操作 let res = &#123; code:404, data:&#123; name: &#x27;xiaolin&#x27; &#125;, error:&quot;请求失败&quot; &#125; setTimeout(()=&gt;&#123; if(res.code===200)&#123; resolved(res.data); &#125;else&#123; rejected(res.error); &#125; &#125;,2000); &#125;); console.log(pro); pro.then((val)=&gt;&#123; console.log(val); &#125;,(err)=&gt;&#123; console.log(err); &#125;); */ function timeOut(ms)&#123; return new Promise((resolved,rejected)=&gt;&#123; setTimeout(()=&gt;&#123; resolved(&quot;请求成功！&quot;); &#125;,ms); &#125;); &#125; timeOut(5000).then((val)=&gt;&#123; console.log(val); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、使用Promise封装ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; const getJSON = function(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest(); xhr.open(&#x27;GET&#x27;,url); xhr.onreadystatechange = handler; xhr.responseType=&#x27;json&#x27;; xhr.setRequestHeader(&#x27;Accept&#x27;,&#x27;application/json&#x27;); // 发送 xhr.send(); function handler()&#123; // console.log(this.readyState); if(this.readyState===4&amp;&amp;this.status==200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); &#125; /* getJSON(&quot;http://127.0.0.1:5500/test.html&quot;) .then((data)=&gt;&#123; console.log(data); &#125;,(error)=&gt;&#123; console.log(error); &#125;); */ /* getJSON(&#x27;http://127.0.0.1:5500/test.html&#x27;) .then((data)=&gt;&#123; console.log(data); &#125;).then(null,err=&gt;&#123; &#125;); */ // 等价于下面 getJSON(&#x27;http://127.0.0.1:5500/test.html&#x27;) .then(data=&gt;&#123; console.log(data); &#125;).catch(err=&gt;&#123; console.log(err); &#125;); // then()方法 /* then()第一个参数就是resolve回调函数，第二个参数是可选的，是reject状态回调函数 then()返回一个新的Promise实例，可以采用链式编程 */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、Promise的其他方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt;正在加载图片....&lt;/div&gt; &lt;script&gt; // 1、resolve()能将现有的任何对象转换为promise对象 // let p =Promise.resolve(&#x27;foo&#x27;); /* let p =new Promise(resolve=&gt;resolve(&#x27;foo&#x27;)); // console.log(p); p.then((data)=&gt;&#123; console.log(data); &#125;); */ // 2、all()应用：一些游戏类的素材，等待图片、flash、等等静态资源等加载完成后才进行页面初始化 /* let pro1 = new Promise((resolve,reject)=&gt;&#123; &#125;); let pro2 = new Promise((resolve,reject)=&gt;&#123; &#125;); let pro3 = new Promise((resolve,reject)=&gt;&#123; &#125;); let p4 = Promise.all([pro1,pro2,pro3]); p4.then(()=&gt;&#123; //三个都成功才成功 &#125;).catch(err=&gt;&#123; // 如果有一个失败了，就失败了 &#125;); */ const div = document.getElementById(&#x27;div&#x27;); // 3、race():某个异步请求设置超时时间，并且在超时后执行相应的操作 // 请求图片资源 function requestImg(imgSrc)&#123; return new Promise((resolve,reject)=&gt;&#123; const img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = imgSrc; &#125;); &#125; function timeOut()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(new Error(&quot;图片请求超时&quot;)); &#125;,5000); &#125;); &#125; Promise.race([requestImg(&#x27;https://ts2.cn.mm.bing.net/th?id=OIP-C.tV58EvgJSzLG3iOTLzB85QHaEo&amp;w=316&amp;h=197&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2&#x27;),timeOut()]).then(data=&gt;&#123; console.log(data); div.innerHTML=&quot;&quot;; document.body.appendChild(data); &#125;).catch(err=&gt;&#123; console.log(err); div.innerText=&quot;您的网速过慢，图片请求失败！&quot;; &#125;); /* done()和finnally() 无论成功还是失败都会执行 */ /* server.listen(3000).then(()=&gt;&#123; &#125;).finnally(server.stop()); */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十三、async的用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* async作用：使得异步操作更加方便 基本操作 async他会返回一个Promise对象 就可以使用then catch 是generator的一个语法糖 */ /* Generator Promise async 1、解决回调地域 2、使得异步操作变得方便 */ async function f()&#123; // return await &#x27;hello async&#x27;; let s = await &#x27;hello async&#x27;; let data = await s.split(&#x27;&#x27;); return data; &#125; // 如果async函数中有多个await，那么then函数会等待所有await指令。运行完的结果才去执行 // console.log(f); f().then(v=&gt;&#123; console.log(v); &#125;).catch(e=&gt;&#123; console.log(e); &#125;); async function f2()&#123; // throw new Error(&quot;出错了！&quot;); try &#123; await Promise.reject(&quot;出错了&quot;); &#125; catch (error) &#123; &#125; return await Promise.resolve(&quot;hello&quot;); &#125; f2().then(v=&gt;console.log(v)).catch(e=&gt;console.log(e)); // 需求，获取和风天气 现在now的数据 const getJSON = function(url)&#123; return new Promise((resolve,reject)=&gt;&#123; const xhr = new XMLHttpRequest(); xhr.open(&#x27;GET&#x27;,url); xhr.onreadystatechange = handler; xhr.responseType=&#x27;json&#x27;; xhr.setRequestHeader(&#x27;Accept&#x27;,&#x27;application/json&#x27;); // 发送 xhr.send(); function handler()&#123; // console.log(this.readyState); if(this.readyState===4&amp;&amp;this.status==200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; &#125;); &#125; async function getNowWeather(url)&#123; // 发送ajax 获取实况天气 let res = await getJSON(url); console.log(res); // 获取HeWeather6的数据 获取未来3-7天的天气 let arr =await res.HeWeather6; return arr[0].now; &#125; getNowWeather(&quot;url&quot;) .then(now=&gt;&#123; console.log(now); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十四、class类1、类的简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // es5造类 /* function Person(name,age)&#123; this.name, this.age=age &#125; Person.prototype.sayName=function()&#123; return this.name; &#125; let p1 = new Person(&#x27;xiaolin&#x27;,21); */ // console.log(p1); // es6 class Person&#123; // 实例化的时候会立即被调用 constructor(name,age)&#123; this.name=name, this.age &#125; /* sayName()&#123; return this.name; &#125; sayAge()&#123; return this.age; &#125; */ &#125; // 通过Object.assign方法一次性向类的原型添加多个方法 Object.assign(Person.prototype,&#123; sayName()&#123; return this.name; &#125;, sayAge()&#123; return this.age; &#125; &#125;); let p2 = new Person(&#x27;xiaolin&#x27;,21); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、类的继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 使用关键字extends class Animal&#123; constructor(name,age)&#123; this.name=name; this.age=age; &#125; sayName()&#123; return this.name; &#125; sayAge()&#123; return this.age; &#125; &#125; class Dog extends Animal&#123; constructor(name,age,color)&#123; super(name,age); // Animal.call(this,name,age); this.color=color; &#125; sayColor()&#123; return this.color; &#125; // 重写 sayName()&#123; console.log(&quot;我叫：&quot;+ this.name); &#125; &#125; let d = new Dog(&#x27;xiaoh&#x27;,3,&#x27;yellow&#x27;); console.log(d); d.sayName(); console.log( d.sayColor()); // 思考：如何让多个类，混入到一个类中 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十五、module模块的应用 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;module&quot;&gt; // import obj,&#123;name,age,sayName&#125; from &#x27;./modules/index.js&#x27; import * as f from &#x27;./modules/index.js&#x27; // console.log(obj); console.log(f.default); console.log(f.name); // console.log(name,age,sayName()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233// es6模块功能主要有两个命令构成：export和import// export用于规定模块的对外接口，import用于输入其他模块提供的功能/* 一个模块就是一个独立的文件*/export const name =&#x27;XIAOLIN&#x27;;export const age =18;export const sayName = function()&#123; return &quot;my name is xiaolin&quot;;&#125;;function sayName1()&#123; return &quot;my name is xiaolin&quot;;&#125;;export &#123;sayName1&#125;;/* const obj =&#123; foo:&#x27;foo&#x27;&#125; */class Person&#123; constructor()&#123; &#125; sayName()&#123; &#125;&#125;// export default obj;export default Person;","tags":"es6、js"},{"title":"SpringSecurity","url":"/2022/10/22/Spring Security/","text":"# Spring Security 一、Spring Security框架简介1、概要 2、历史 3、同款产品对比3.1、Spring SecuritySpring 技术栈的组成部分。 通过提供完整可扩展的认证和授权支持保护你的应用程序。 https://spring.io/projects/spring-sercurity Spring Security 特点： 和Spring无缝整合 全面的权限控制 专门为Web开发而设计 旧版本不能脱离Web环境使用 新版本对整个框架进行了分层抽取，分成了核心模块和Web模块，单独引入了核心模块就可以脱离Web环境 重量级 3.2、ShiroApache旗下的轻量级权限控制框架 特点： 轻量级，Shiro主张的理念就是把复杂的事情变简单，针对对性能有更高要求的互联网应用有更好的表现。 通用性 好处：不局限于Web环境，可以脱离Web环境使用 缺陷：在Web环境下一些特定的需求需要手动编写代码定制 4、模块划分 二、Spring Security 入门案例1、创建一个SpringBoot项目2、引入相关依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 3、编写Controller进行测试12345678910111213141516package com.lxg.securitydemo1.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello security!&quot;; &#125;&#125; 默认的用户名：user 密码在运行项目后在启动控制台随机生成 4、权限管理中的相关概念 5、Spring Security基本原理 代码底层流程：重点看三个过滤器 FilterSecurityInterceptor：是一个方法级的权限过滤器，基本位于过滤链的最底部。 12345678910111213141516171819202122232425public void invoke(FilterInvocation filterInvocation) throws IOException, ServletException &#123; if (isApplied(filterInvocation) &amp;&amp; this.observeOncePerRequest) &#123; // filter already applied to this request and user wants us to observe // once-per-request handling, so don&#x27;t re-do security checking filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse()); return; &#125; // first time this request being called, so perform security checking if (filterInvocation.getRequest() != null &amp;&amp; this.observeOncePerRequest) &#123; filterInvocation.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE); &#125; InterceptorStatusToken token = super.beforeInvocation(filterInvocation); try &#123; filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse()); &#125; finally &#123; super.finallyInvocation(token); &#125; super.afterInvocation(token, null); &#125; super.beforeInvocation(fi)表示查看之前的filter是否放行 fi.getChain().doFilter(fi.getRequest(),fi.getResponse());表示真正的调用后台的服务。 ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常。 123456789101112131415161718192021222324252627private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; try &#123; chain.doFilter(request, response); &#125; catch (IOException ex) &#123; throw ex; &#125; catch (Exception ex) &#123; // Try to extract a SpringSecurityException from the stacktrace Throwable[] causeChain = this.throwableAnalyzer.determineCauseChain(ex); RuntimeException securityException = (AuthenticationException) this.throwableAnalyzer .getFirstThrowableOfType(AuthenticationException.class, causeChain); if (securityException == null) &#123; securityException = (AccessDeniedException) this.throwableAnalyzer .getFirstThrowableOfType(AccessDeniedException.class, causeChain); &#125; if (securityException == null) &#123; rethrow(ex); &#125; if (response.isCommitted()) &#123; throw new ServletException(&quot;Unable to handle the Spring Security Exception &quot; + &quot;because the response is already committed.&quot;, ex); &#125; handleSpringSecurityException(request, response, chain, securityException); &#125; &#125; UsernamePasswordAuthenticationFilter：对&#x2F;login的POST请求做拦截，校验表单中的用户名和密码。 1234567891011121314151617@Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123; throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod()); &#125; String username = obtainUsername(request); username = (username != null) ? username.trim() : &quot;&quot;; String password = obtainPassword(request); password = (password != null) ? password : &quot;&quot;; UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username, password); // Allow subclasses to set the &quot;details&quot; property setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; 6、过滤器如何进行加载的？ 7、UserDetailsService接口讲解当什么都没配置的时候，账号和密码是由SpringSecurity定义生成的，而实际项目中账号和密码都是从数据库中查询出来的，所以我们要通过自定义逻辑控制认证逻辑。 如果需要自定义逻辑时，只需要实现UserDetailService接口即可。 接口定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.security.core.userdetails;/** * Core interface which loads user-specific data. * &lt;p&gt; * It is used throughout the framework as a user DAO and is the strategy used by the * &#123;@link org.springframework.security.authentication.dao.DaoAuthenticationProvider * DaoAuthenticationProvider&#125;. * * &lt;p&gt; * The interface requires only one read-only method, which simplifies support for new * data-access strategies. * * @author Ben Alex * @see org.springframework.security.authentication.dao.DaoAuthenticationProvider * @see UserDetails */public interface UserDetailsService &#123; /** * Locates the user based on the username. In the actual implementation, the search * may possibly be case sensitive, or case insensitive depending on how the * implementation instance is configured. In this case, the &lt;code&gt;UserDetails&lt;/code&gt; * object that comes back may have a username that is of a different case than what * was actually requested.. * @param username the username identifying the user whose data is required. * @return a fully populated user record (never &lt;code&gt;null&lt;/code&gt;) * @throws UsernameNotFoundException if the user could not be found or the user has no * GrantedAuthority */ UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125; 返回值UserDetails 这个类是系统默认的用户“主体” 12345678910111213141516public interface UserDetails extends Serializable &#123;// 表示获取登录用户所有权限Collection&lt;? extends GrantedAuthority&gt; getAuthorities();// 表示获取密码String getPassword();// 表示获取用户名String getUsername();// 表示判断账户是否过期boolean isAccountNonExpired();// 表示判断账户是否被锁定boolean isAccountNonLocked();// 表示凭证&#123;密码&#125;是否过期boolean isCredentialsNonExpired();// 表示当前用户是否可用boolean isEnabled();&#125; UserDetails的实现类User 以后只需要使用User这个实体类即可！ 方法参数username 表示用户名，此值是客户端表单传递过来的数据，默认情况下必须叫username，否则无法接收。 8、PasswordEncoder接口讲解数据加密接口，用于返回User对象里面密码加密 接口定义如下： 12345678910111213public interface PasswordEncoder &#123;// 表示把参数按照特定的解析规则进行解析String encode(CharSequence rawPassword);// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。boolean matches(CharSequence rawPassword, String encodedPassword);// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。default boolean upgradeEncoding(String encodedPassword) &#123;return false;&#125;&#125; 接口的实现类： BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析 器。 BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单 向加密。可以通过 strength 控制加密强度，默认 10 测试： 123456789101112131415@Testpublic void test01()&#123;// 创建密码解析器BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();// 对密码进行加密String atguigu = bCryptPasswordEncoder.encode(&quot;atguigu&quot;);// 打印加密之后的数据System.out.println(&quot;加密之后数据：\\t&quot;+atguigu);//判断原字符加密后和加密之前是否匹配boolean result = bCryptPasswordEncoder.matches(&quot;atguigu&quot;, atguigu);// 打印比较结果System.out.println(&quot;比较结果：\\t&quot;+result);&#125; 三、Spring Security Web权限方案1、认证1、设置登录的用户名和密码 第一种方式：通过配置文件 在application.properties: 12spring.security.user.name=xiaolinspring.security.user.password=123456 第二种方式：通过配置类 12345678910111213141516171819202122@Configurationpublic class MyConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Bean PasswordEncoder password()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String password = passwordEncoder.encode(&quot;123&quot;); auth.inMemoryAuthentication().withUser(&quot;lxg&quot;).password(password).roles(&quot;admin&quot;); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true) // 启用方法安全设置public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private static final String KEY = &quot;edward&quot;; @Autowired private UserDetailsService userDetailsService; @Autowired private PasswordEncoder passwordEncoder; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); // 使用 BCrypt 加密 &#125; @Bean public AuthenticationProvider authenticationProvider() &#123; DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(userDetailsService); authenticationProvider.setPasswordEncoder(passwordEncoder); // 设置密码加密方式 return authenticationProvider; &#125; /** * 自定义配置 */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/fonts/**&quot;, &quot;/index&quot;).permitAll() // 都可以访问 .antMatchers(&quot;/h2-console/**&quot;).permitAll() // 都可以访问 .antMatchers(&quot;/admins/**&quot;).hasRole(&quot;ADMIN&quot;) // 需要相应的角色才能访问 .and() .formLogin() //基于 Form 表单登录验证 .loginPage(&quot;/login&quot;).failureUrl(&quot;/login-error&quot;) // 自定义登录界面 .and().rememberMe().key(KEY) // 启用 remember me .and().exceptionHandling().accessDeniedPage(&quot;/403&quot;); // 处理异常，拒绝访问就重定向到 403 页面 http.csrf().ignoringAntMatchers(&quot;/h2-console/**&quot;); // 禁用 H2 控制台的 CSRF 防护 http.headers().frameOptions().sameOrigin(); // 允许来自同一来源的H2 控制台的请求 &#125; /** * 认证信息管理 * @param auth * @throws Exception */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService); auth.authenticationProvider(authenticationProvider()); &#125;&#125; 第三种方式：自定义编写实现类 第一步、创建配置类，设置使用哪个userDetailService实现类 12345678910111213141516171819@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(password()); &#125; @Bean PasswordEncoder password()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 第二步、编写实现类，返回User对象，User对象有用户名、密码和操作权限 12345678910111213@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //Spring Security只会帮我们验证密码，不会帮我们验证用户名 if(!username.equals(&quot;xiaolin&quot;))&#123; throw new RuntimeException(&quot;输入用户名错误！&quot;); &#125; List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(username,new BCryptPasswordEncoder().encode(&quot;123&quot;),authorityList); &#125;&#125; 2、实现数据库认证来完成用户登录（整合MyBatisPlus)1、准备数据库和表 2、添加依赖 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok 用来简化实体类--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、创建实体类及其mapper接口和xml 123@Repositorypublic interface UsersMapper extends BaseMapper&lt;Users&gt; &#123;&#125; 4、 1234567891011121314151617181920@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Autowired private UsersMapper usersMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; QueryWrapper&lt;Users&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.lambda().eq(Users::getUsername, username); //Users user = usersService.getOne(wrapper); Users user = usersMapper.selectOne(wrapper); //Spring Security只会帮我们验证密码，不会帮我们验证用户名 if(user==null)&#123; //数据库中不存在该用户 throw new UsernameNotFoundException(&quot;输入用户名错误！&quot;); &#125; List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(user.getUsername(),new BCryptPasswordEncoder().encode(user.getPassword()),authorityList); &#125;&#125; 5、注意在启动类上添加MapperScan注解 6、配置数据源 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/security_demo?serverTimezone=GMT%2B8 username: root password: 123456 7、测试 3、自定义设置登录界面以及设置不需要认证可以访问1、在配置类实现相关的配置 123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()//自定义登录界面--自己编写的页面 .loginPage(&quot;/login.html&quot;) //登录页面设置 .loginProcessingUrl(&quot;/user/login&quot;) //登录访问路径 .defaultSuccessUrl(&quot;/test/index&quot;).permitAll()//登录成功之后，跳转路径 .and().authorizeRequests() .antMatchers(&quot;/&quot;,&quot;/test/hello&quot;,&quot;/user/login&quot;).permitAll() //设置哪些路径可以直接访问，不需要认证 .anyRequest().authenticated() //所有请求都可以访问 .and().csrf().disable(); //关闭csrf防护&#125; 2、创建相关页面，controller 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234@GetMapping(&quot;index&quot;) public String index() &#123; return &quot;hello index!&quot;; &#125; 4、授权1、基于角色或权限进行访问控制1、hasAuthority方法如果当前的主体有指定的权限，则返回true，否则返回false 1、修改配置类： 12//当前登录用户，只有具有admins权限才可以进行访问这个路径 .antMatchers(&quot;/test/index&quot;).hasAuthority(&quot;admins&quot;) 2、在UserDetailsService中设置返回User对象的权限 12List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admins&quot;); return new User(user.getUsername(),new BCryptPasswordEncoder().encode(user.getPassword()),authorityList); 没有yhu权限的情况 2、hasAnythority方法如果当前的主体有任何提供的权限（给定的作为一个逗号分隔的字符串列表）的话，返回true 1234.antMatchers(&quot;/test/index&quot;).hasAnyAuthority(&quot;admins,manager&quot;) 老版写法 .antMatchers(&quot;/test/index&quot;).hasAnyAuthority(&quot;admins&quot;,&quot;manager&quot;)新版写法 3、hasRole方法如果用户具备给定角色就允许访问，否则出现403. 如果当前主体具有指定的角色，则返回true。 1234567//hasRole方法 ROLE_sale .antMatchers(&quot;/test/index&quot;).hasRole(&quot;sale&quot;) List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;manager,ROLE_sale&quot;); 4、hasAnyRole方法如果用户具备给定的任意一个角色就允许访问，否则出现403 如果当前主体具备指定的角色，则返回true 1234//hasAnyRole方法 .antMatchers(&quot;/test/index&quot;).hasAnyRole(&quot;sale&quot;,&quot;manager&quot;) List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ROLE_manager&quot;); 2、自定义403没有权限访问页面在配置类中进行配置 123456 @Override protected void configure(HttpSecurity http) throws Exception &#123;//配置没有权限访问跳转的自定义页面 http.exceptionHandling().accessDeniedPage(&quot;/unauth.html&quot;); &#125; 3、注解使用1、@Secured判断是否具有某个角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_”。 使用注解先要开启注解功能。（在启动类或者配置类上添加开启注解注解） 12345678910@EnableGlobalMethodSecurity(securedEnabled = true)@SpringBootApplication@MapperScan(&quot;com.lxg.securitydemo1.mapper&quot;)public class Securitydemo1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Securitydemo1Application.class, args); &#125;&#125; 在控制器方法上添加注解 123456@GetMapping(&quot;update&quot;) @Secured(&#123;&quot;ROLE_sale&quot;,&quot;ROLE_manager&quot;&#125;) public String update() &#123; return &quot;hello update!&quot;; &#125; 设置用户角色或权限 1List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ROLE_manager&quot;); 2、@PreAuthorize先开启注解功能 1@EnableGlobalMethodSecurity(prePostEnabled = true) 注解适合进入方法前的权限验证 ，可以将用户的roles&#x2F;permissions参数传到方法中。 12345@GetMapping(&quot;delete&quot;) @PreAuthorize(&quot;hasAnyAuthority(&#x27;admins&#x27;)&quot;) public String delete() &#123; return &quot;hello delete!&quot;; &#125; 3、PostAuthorize先开启注解功能 1@EnableGlobalMethodSecurity(prePostEnabled = true) 该注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值的权限。 123456@GetMapping(&quot;select&quot;) @PostAuthorize(&quot;hasAnyAuthority(&#x27;admins1&#x27;)&quot;) public String select() &#123; System.out.println(&quot;select......&quot;); return &quot;hello select!&quot;; &#125; 控制台能打印说明先执行方法了，但是依然是没有权限访问 4、@PostFilter权限验证之后对数据进行过滤，留下用户名是admin1的数据 表达式中的filterObject引用的是方法返回值List的某一个元素。 12345678910@GetMapping(&quot;getAll&quot;) @PostAuthorize(&quot;hasAnyAuthority(&#x27;admins1&#x27;)&quot;) @PostFilter(&quot;filterObject.username == &#x27;admin1&#x27;&quot;) public List&lt;Users&gt; getAlluser() &#123; ArrayList&lt;Users&gt; list = new ArrayList&lt;Users&gt;(); list.add(new Users(11,&quot;admin1&quot;,&quot;666666&quot;)); list.add(new Users(21,&quot;admin2&quot;,&quot;666666&quot;)); System.out.println(list); return list; &#125; 5、@PreFilter进入控制器方法之前对数据进行过滤 1234567891011@GetMapping(&quot;get&quot;) @PreAuthorize(&quot;hasAnyAuthority(&#x27;admins&#x27;)&quot;) @PreFilter(value = &quot;filterObject.id%2==0&quot;) public List&lt;Users&gt; getAll(@RequestBody List&lt;Users&gt; list) &#123; list.forEach(t-&gt; &#123; System.out.println(t.getId()+&quot;\\t&quot;+t.getUsername()); &#125;); System.out.println(&quot;无&quot;); return list; &#125; 4、用户注销1、在登录成功页面添加一个退出链接success.html 12&lt;h1&gt;登录成功！&lt;/h1&gt;&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt; 2、在配置类中添加退出的映射地址12//退出 http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/test/hello&quot;)//.permitAll(); 3、测试 修改配置类，登录成功之后跳转到成功页面 在成功页面添加超链接，设置退出路径 登录成功之后，在成功页面点击退出，再去访问其他controller不能进行访问了 1234@GetMapping(&quot;success&quot;) public String success()&#123; return &quot;success&quot;; &#125; 5、基于数据库实现权限认证（记住我）自动登录： cookie技术 安全框架机制实现自动登录 实现原理： 具体实现： 创建数据库表 12345678CREATE TABLE `persistent_logins` ( `username` varchar(64) NOT NULL, `series` varchar(64) NOT NULL, `token` varchar(64) NOT NULL, `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`series`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 配置类，注入数据源，配置操作数据库对象 12345678910111213//注入数据源 @Autowired private DataSource dataSource; //配置对象 @Bean public PersistentTokenRepository persistentTokenRepository(DataSource dataSource)&#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //生成表 //jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository; &#125; 配置类中配置自动登录 123.and().rememberMe().tokenRepository(persistentTokenRepository()).tokenValiditySeconds(60)//设置有效时长，单位秒.userDetailsService(userDetailsService) 在登录界面设置复选框 1&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot;/&gt;自动登录 name值固定，底层封装好了 6、CSRF理解 网络安全：https://www.bilibili.com/video/BV1Lf4y1t7Mc?spm_id_from=333.337.search-card.all.click 四、Spring Security 微服务权限方案1、什么是微服务？ 2、微服务认证和授权实现过程单点登录、授权 1、认证授权过程分析12（1）如果是基于 Session，那么 Spring-security 会对 cookie 里的 sessionid 进行解析，找 到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求。（2）如果是 token，则是解析出 token，然后将当前请求加入到 Spring-security 管理的权限 信息中去 3、完成基于SpringSecurity认证授权案例1、实现功能1234567891、登录（认证）2、添加角色3、为角色分配菜单4、添加用户5、为用户分配角色 2、权限管理数据模型 3、案例涉及技术说明1、Maven 创建父工程：管理项目依赖版本 创建子模块：使用具体依赖 2、SpringBoot 本质就是Spring 3、MyBatisPlus 操作数据库框架 4、SpringCloud GateWay网关 注册中心 Nacos 5、Redis6、Jwt7、Swagger8、前端技术4、搭建项目工程1、创建父工程acl_parent:管理依赖版本2、在父工程创建子模块 common service_base：工具类 spring_security:权限配置 infrastructure api_gateway:网关 service service_acl:权限管理微服务模块 5、启动Redis和Nacos1、启动Redis输入命令redis-server redis.windows.conf 如下图所示则启动成功 输入redis-cli.exe -h 127.0.0.1 -p 6379 客户端访问 查找所有符合给定模式的key KEYS * 获取指定key的值 get name 设置指定key的值 set name “hello world” 2、启动Nacos注册中心 访问地址：http://localhost:8848/nacos 默认用户名和密码都是：nacos 6、编写common里面需要的工具类 7、编写SpringSecurity认证授权工具类和处理器 密码处理工具类： 123456789101112131415161718192021222324@Componentpublic class DefaultPasswordEncoder implements PasswordEncoder &#123; public DefaultPasswordEncoder()&#123; this(-1); &#125; public DefaultPasswordEncoder(int strength) &#123; &#125; //进行MD5加密 @Override public String encode(CharSequence rawPassword) &#123; return MD5.encrypt(rawPassword.toString()); &#125; //进行密码的比对 @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; boolean equals = encodedPassword.equals(MD5.encrypt(rawPassword.toString())); return equals; &#125;&#125; token操作工具类： 使用jwt生成token 123456789101112131415161718192021222324252627282930@Componentpublic class TokenManager &#123; //token有效时长 private long tokenExpiration = 24*60*60*1000; //编码密钥 private String tokenSignKey = &quot;123456&quot;; //1、使用Jwt根据用户名生成token public String createToken(String username)&#123; String token = Jwts.builder().setSubject(username) .setExpiration(new Date(System.currentTimeMillis()+tokenExpiration)) .signWith(SignatureAlgorithm.ES512,tokenSignKey).compressWith(CompressionCodecs.GZIP).compact(); return token; &#125; //2、根据token字符串得到用户信息 public String getUserInfoFormToken(String token)&#123; String userInfo = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject(); return userInfo; &#125; //3、删除token public void removeToken(String token)&#123; //jwttoken 无需删除，客户端扔掉即可。 &#125;&#125; 8、jwt介绍1、访问令牌的类型 2、JWT的组成典型的，一个 JWT 看起来如下图： 该对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。 每一个子串表示了一个功能块，总共有以下三个部分：JWT 头、有效载荷和签名 JWT 头 JWT 头部分是一个描述 JWT 元数据的 JSON 对象，通常如下所示。 { “alg”: “HS256”, “typ”: “JWT” } 在上面的代码中，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）； typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。 有效载荷 有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据。 JWT 指定七个默认字段供选择。 iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID 用于标识该 JWT 除以上默认字段外，我们还可以自定义私有字段，如下例： { “sub”: “1234567890”, “name”: “Helen”, “admin”: true } 请注意，默认情况下 JWT 是未加密的，任何人都可以解读其内容，因此不要构建隐私信息 字段，存放保密信息，以防止信息泄露。 JSON 对象也使用 Base64 URL 算法转换为字符串保存 签名哈希 签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡 改。 首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公 开。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成 签名。 HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(claims), secret) 在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个 部分用”.”分隔，就构成整个 JWT 对象。 Base64URL算法 如前所述，JWT 头和有效载荷序列化的算法都用到了 Base64URL。该算法和常见 Base64 算 法类似，稍有差别。 作为令牌的 JWT 可以放在 URL 中（例如 api.example&#x2F;?token&#x3D;xxx）。 Base64 中用的三个 字符是”+”，”&#x2F;“和”&#x3D;”，由于在 URL 中有特殊含义，因此 Base64URL 中对他们做了替换： “&#x3D;”去掉，”+”用”-“替换，”&#x2F;“用”_”替换，这就是 Base64URL 算法。 9、编写退出处理器123456789101112131415161718192021222324252627282930//退出处理器public class TokenLogoutHandler implements LogoutHandler &#123; private TokenManager tokenManager; private RedisTemplate redisTemplate; public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate)&#123; this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; &#125; @Override public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123; //1、从header里面获取token //2、token不为空，移除token，从redis删除token String token = request.getHeader(&quot;token&quot;); if(token != null)&#123; //移除 tokenManager.removeToken(token); //从token获取用户名 String username = tokenManager.getUserInfoFormToken(token); redisTemplate.delete(username); &#125; ResponseUtil.out(response, R.ok()); &#125;&#125; 10、编写未授权统一处理类123456public class UnauthEntryPoint implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseUtil.out(response, R.error()); &#125;&#125; 11、编写认证的过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123; private TokenManager tokenManager; private AuthenticationManager authenticationManager; private RedisTemplate redisTemplate; TokenLoginFilter(TokenManager tokenManager, AuthenticationManager authenticationManager, RedisTemplate redisTemplate)&#123; this.tokenManager = tokenManager; this.authenticationManager = authenticationManager; this.redisTemplate = redisTemplate; this.setPostOnly(false); this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;/admin/acl/login&quot;,&quot;POST&quot;)); &#125; //1、获取表单提交用户名和密码 @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; //获取表单提交数据 try &#123; User user = new ObjectMapper().readValue(request.getInputStream(), User.class); return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(),new ArrayList&lt;&gt;())); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; //2、认证成功调用的方法 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; //认证成功，先得到成功之后用户信息 SecurityUser user =(SecurityUser)authResult.getPrincipal(); //根据用户名生成token String token = tokenManager.createToken(user.getCurrentUserInfo().getUsername()); //把用户名称和用户权限信息放入redis redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(),user.getPermissionValueList()); //返回token ResponseUtil.out(response, R.ok().data(&quot;token&quot;,token)); &#125; //3、认证失败调用的方法 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123; ResponseUtil.out(response, R.error()); &#125;&#125; 12、编写授权过滤器1234567891011121314151617181920212223242526272829303132333435363738394041public class TokenAuthFilter extends BasicAuthenticationFilter &#123; private TokenManager tokenManager; private RedisTemplate redisTemplate; public TokenAuthFilter(AuthenticationManager authenticationManager, RedisTemplate redisTemplate,TokenManager tokenManager) &#123; super(authenticationManager); this.redisTemplate = redisTemplate; this.tokenManager = tokenManager; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //获取当前认证成功用户权限信息 UsernamePasswordAuthenticationToken authRequest = getAuthentication(request); //判断如果有权限信息，则放入到权限上下文中 if(authRequest != null) &#123; SecurityContextHolder.getContext().setAuthentication(authRequest); &#125; chain.doFilter(request, response); &#125; private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) &#123; //从header中获取token String token = request.getHeader(&quot;token&quot;); if(token != null) &#123; //从token中获取用户名 String username = tokenManager.getUserInfoFormToken(token); //从redis中获取对应权限 List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(username); //Collection&lt;? extends GrantedAuthority&gt; authorities Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;GrantedAuthority&gt;(); for (String permissionValue : permissionValueList) &#123; SimpleGrantedAuthority authority = new SimpleGrantedAuthority(permissionValue); authorities.add(authority); &#125; return new UsernamePasswordAuthenticationToken(username,token, authorities); &#125; return null; &#125;&#125; 13、编写核心配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Configurationpublic class TokenWebSecurityConfig extends WebSecurityConfigurerAdapter &#123; private TokenManager tokenManager; private RedisTemplate redisTemplate; private DefaultPasswordEncoder defaultPasswordEncoder; private UserDetailsService userDetailsService; @Autowired public TokenWebSecurityConfig(UserDetailsService userDetailsService, DefaultPasswordEncoder defaultPasswordEncoder, TokenManager tokenManager, RedisTemplate redisTemplate) &#123; this.userDetailsService = userDetailsService; this.defaultPasswordEncoder = defaultPasswordEncoder; this.tokenManager = tokenManager; this.redisTemplate = redisTemplate; &#125; /** * 配置设置 */ //设置退出的地址和 token，redis 操作地址 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.exceptionHandling() .authenticationEntryPoint(new UnauthEntryPoint()) //没有权限访问 .and().csrf().disable() .authorizeRequests() .anyRequest().authenticated() .and().logout().logoutUrl(&quot;/admin/acl/index/logout&quot;)//退出路径 .addLogoutHandler(new TokenLogoutHandler(tokenManager,redisTemplate)).and() .addFilter(new TokenLoginFilter(tokenManager, authenticationManager(), redisTemplate)) .addFilter(new TokenAuthFilter(authenticationManager(), redisTemplate, tokenManager)).httpBasic(); &#125; //调用userDetailsService和密码处理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(defaultPasswordEncoder); &#125; //不进行认证的路径，可以直接访问 @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/api/**&quot;); &#125;&#125; 14、编写UserDetailsServiceImpl123456789101112131415161718192021222324252627282930@Service(&quot;userDetailsService&quot;)public class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserService userService; @Autowired private PermissionService permissionService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userService.selectByUsername(username); //判断 if(user == null) &#123; throw new UsernameNotFoundException(&quot;用户不存在！&quot;); &#125; com.lxg.security.entity.User curUser = new com.lxg.security.entity.User(); BeanUtils.copyProperties(user,curUser); //根据用户查询用户权限列表 List&lt;String&gt; permissionValueList = permissionService.selectPermissionByUserId(user.getId()); SecurityUser securityUser = new SecurityUser(); securityUser.setPermissionValueList(permissionValueList); return securityUser; &#125;&#125; 15、service_acl模块代码说明1、配置文件123456789101112131415161718192021222324252627282930# 服务端口server.port=8009# 服务名spring.application.name=service-acl# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/acldb?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=root# redis连接spring.redis.host=192.168.44.132spring.redis.port=6379spring.redis.database= 0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0#最小空闲#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/lxg/aclservice/mapper/xml/*.xml# nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 16、编写网关相关代码配置类： 1234567891011121314151617181920212223242526272829package com.lxg.gateway.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.cors.reactive.CorsConfigurationSource;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.util.pattern.PathPatternParser;@Configurationpublic class CorsConfig &#123; //解决跨域 @Bean public CorsWebFilter corsWebFilter()&#123; CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(&quot;*&quot;); //允许任何类型的请求 config.addAllowedOrigin(&quot;*&quot;); //允许任何域名来源请求 config.addAllowedHeader(&quot;*&quot;); //允许携带任何请求头 UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(&quot;/**&quot;,config); return new CorsWebFilter((CorsConfigurationSource) source); &#125;&#125; 五、Spring Security 原理总结1、 SpringSecurity 的过滤器介绍SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤 器链的 15 个过滤器进行说明: （1） WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于 处理异步请求映射的 WebAsyncManager 进行集成。 （2） SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上 下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在 Session 中维护一个用户的安全信 息就是这个过滤器处理的。 （3） HeaderWriterFilter：用于将头信息加入响应中。 （4） CsrfFilter：用于处理跨站请求伪造。 （5）LogoutFilter：用于处理退出登录。 （6）UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中 获取用户名和密码。默认情况下处理来自 &#x2F;login 的请求。从表单中获取用户名和密码 时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个 过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。 （7）DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会 配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。 （8）BasicAuthenticationFilter：检测和处理 http basic 认证。 （9）RequestCacheAwareFilter：用来处理请求的缓存。 （10）SecurityContextHolderAwareRequestFilter：主要是包装请求对象 request。 （11）AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。 （12）SessionManagementFilter：管理 session 的过滤器 （13）ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。 （14）FilterSecurityInterceptor：可以看做过滤器链的出口。 （15）RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。 2、SpringSecurity 基本流程Spring Security 采取过滤链实现认证与授权，只有当前过滤器通过，才能进入下一个 过滤器： 绿色部分是认证过滤器，需要我们自己配置，可以配置多个认证过滤器。认证过滤器可以 使用 Spring Security 提供的认证过滤器，也可以自定义过滤器（例如：短信验证）。认 证过滤器要在 configure(HttpSecurity http)方法中配置，没有配置不生效。下面会重 点介绍以下三个过滤器： UsernamePasswordAuthenticationFilter 过滤器：该过滤器会拦截前端提交的 POST 方式 的登录表单请求，并进行身份认证。 ExceptionTranslationFilter 过滤器：该过滤器不需要我们配置，对于前端提交的请求会 直接放行，捕获后续抛出的异常并进行处理（例如：权限访问限制）。 FilterSecurityInterceptor 过滤器：该过滤器是过滤器链的最后一个过滤器，根据资源 权限配置来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，并 由 ExceptionTranslationFilter 过滤器进行捕获和处理。 1、认证流程 当前端提交的是一个 POST 方式的登录表单请求，就会被该过滤器拦截，并进行身份认 证。该过滤器的 doFilter() 方法实现在其抽象父类 *** 上述的 第二 过程调用了 UsernamePasswordAuthenticationFilter 的 attemptAuthentication() 方法，源码如下： 上述的（3）过程创建的 UsernamePasswordAuthenticationToken 是 Authentication 接口的实现类，该类有两个构造器，一个用于封装前端请求传入的未认 证的用户信息，一个用于封装认证成功后的用户信息： Authentication 接口的实现类用于存储用户认证信息，查看该接口具体定义 上述过程中，UsernamePasswordAuthenticationFilter 过滤器的 attemptAuthentication() 方法的（5）过程将未认证的 Authentication 对象传入 ProviderManager 类的 authenticate() 方法进行身份认证。 ProviderManager 是 AuthenticationManager 接口的实现类，该接口是认证相关的核心接 口，也是认证的入口。在实际开发中，我们可能有多种不同的认证方式，例如：用户名+ 密码、邮箱+密码、手机号+验证码等，而这些认证方式的入口始终只有一个，那就是 AuthenticationManager。在该接口的常用实现类 ProviderManager 内部会维护一个 List列表，存放多种认证方式，实际上这是委托者模式 （Delegate）的应用。每种认证方式对应着一个 AuthenticationProvider， AuthenticationManager 根据认证方式的不同（根据传入的 Authentication 类型判断）委托 对应的 AuthenticationProvider 进行用户认证。 上述认证成功之后的（6）过程，调用 CredentialsContainer 接口定义的 eraseCredentials() 方法去除敏感信息。查看 UsernamePasswordAuthenticationToken 实现的 eraseCredentials() 方法，该方 法实现在其父类中 上述过程就是认证流程的最核心部分，接下来重新回到 UsernamePasswordAuthenticationFilter 过滤器的 doFilter() 方法，查看认证成 功&#x2F;失败的处理： 认证成功和认证失败源码： 2、权限访问流程上一个部分通过源码的方式介绍了认证流程，下面介绍权限访问流程，主要是对 ExceptionTranslationFilter 过滤器和 FilterSecurityInterceptor 过滤器进行介绍。 1、 ExceptionTranslationFilter 过滤器该过滤器是用于处理异常的，不需要我们配置，对于前端提交的请求会直接放行，捕获后 续抛出的异常并进行处理（例如：权限访问限制）。具体源码如下： 2、FilterSecurityInterceptor 过滤器FilterSecurityInterceptor 是过滤器链的最后一个过滤器，该过滤器是过滤器链 的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果 访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器 ExceptionTranslationFilter 进行捕获和处理。具体源码如下： 需要注意，Spring Security 的过滤器链是配置在 SpringMVC 的核心组件 DispatcherServlet 运行之前。也就是说，请求通过 Spring Security 的所有过滤器， 不意味着能够正常访问资源，该请求还需要通过 SpringMVC 的拦截器链。 3、SpringSecurity 请求间共享认证信息一般认证成功后的用户信息是通过 Session 在多个请求之间共享，那么 Spring Security 中是如何实现将已认证的用户信息对象 Authentication 与 Session 绑定的进行 具体分析. 在前面讲解认证成功的处理方法 successfulAuthentication() 时，有以下代码： 查 看 SecurityContext 接 口 及 其 实 现 类 SecurityContextImpl ， 该 类 其 实 就 是 对 Authentication 的封装： 查 看 SecurityContextHolder 类 ， 该 类 其 实 是 对 ThreadLocal 的 封 装 ， 存 储 SecurityContext 对象: 1、 SecurityContextPersistenceFilter 过滤器前面提到过，在 UsernamePasswordAuthenticationFilter 过滤器认证成功之 后，会在认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进 SecurityContext，并存入 SecurityContextHolder。 之后，响应会通过 SecurityContextPersistenceFilter 过滤器，该过滤器的位置 在所有过滤器的最前面，请求到来先进它，响应返回最后一个通过它，所以在该过滤器中 处理已认证的用户信息对象 Authentication 与 Session 绑定。 认证成功的响应通过 SecurityContextPersistenceFilter 过滤器时，会从 SecurityContextHolder 中取出封装了已认证用户信息对象 Authentication 的 SecurityContext，放进 Session 中。当请求再次到来时，请求首先经过该过滤器，该过滤 器会判断当前请求的 Session 是否存有 SecurityContext 对象，如果有则将该对象取出再次 放入 SecurityContextHolder 中，之后该请求所在的线程获得认证用户信息，后续的资源访 问不需要进行身份认证；当响应再次返回时，该过滤器同样从 SecurityContextHolder 取出 SecurityContext 对象，放入 Session 中。具体源码如下：","tags":"springsecurity"},{"title":"Spring","url":"/2022/10/22/Spring5/","text":"# Spring5框架 一、Spring框架概述1、Spring概述1234567891011121314151、Spring是轻量级的开源的JavaEE应用程序框架。2、Spring可以解决企业应用开发的复杂性。3、Spring有两个核心部分：IOC和Aop（1）IOC：控制反转，把创建对象过程交给Spring进行管理。（2）Aop：面向切面，不修改源代码进行功能增强。4、Spring特点：（1）方便解耦，简化开发。（2）Aop编程支持（3）方便程序的测试（4）可以方便和其他框架进行整合（5）方便进行事务操作（6）降低API开发难度5、现在课程中，选取Spring版本5.x6、什么是bean？在Spring中，构成应用程序主干并且由Spring IOC容器所管理的对象称为bean，bean一个由Spring IOC容器实例化、组装和管理的对象。 2、入门案例1、下载Spring5 123spring.io官网点击小猫（官方文件保存在Github）然后找文件进行下载 2、打开idea工具，创建普通java工程 3、导入Spring5相关jar包 至少需要Core Container 里四个包 4、创建一个普通类，在类中创建一个普通方法 1234567package com.lxg.spring5;public class User &#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125; 5、创建Spring配置文件，在配置文件中配置创建的对象 （1）Spring配置文件使用xml格式 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置User对象创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.lxg.spring5.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 6、进行测试代码编写 1234567891011121314151617181920package com.lxg.spring5.testDemo;import com.lxg.spring5.User;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.testng.annotations.Test;public class TestSpring5 &#123; @Test public void testAdd()&#123; //1.加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //2.获取配置创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add(); &#125;&#125; 二、IOC容器1、IOC底层原理IOC（概念和原理）123456781、什么是IOC？（1）控制反转，把对象的创建和对象之间的调用过程，交给Spring进行管理。（2)使用IOC的目的：为了耦合度降低（3）做入门案例就是IOC实现2、IOC底层原理（1）xml解析，工厂模式、反射3、画图讲解IOC底层原理如下： 进一步降低耦合度 2、IOC接口（BeanFactory）123456781、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂2、Spring提供了IOC容器实现的两种方式：（两个接口）（1）BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用 加载配置文件时不会创建对象，在获取对象（使用）时采取创建对象。（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。 加载配置文件的时候就会把配置文件对象进行创建3、ApplicationContext接口有实现类如下： 3、IOC操作 Bean 管理12345671、什么是Bean管理（0）Bean管理指的就是两个操作（1）Spring创建对象（2）Spring注入属性2、Bean管理的两种方式（1）基于xml配置文件方式实现（2）基于注解方式实现 3.1、IOC操作 Bean管理（基于xml方式）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631、基于xml方式创建对象（1）在Spring配置文件中，使用Bean标签，标签里面添加对应属性，就可以实现对象创建（2）在bean标签有很多属性，介绍常用的属性： ①id属性：唯一标识 ②class属性：类全路径（包类路径） ③name属性：功能跟id一样，name可以加特殊符号（3）创建对象时候，默认也是执行无参数构造方法完成对象创建2、基于xml方式注入属性（1）DI：是IOC的一个具体实现，依赖注入，就是注入属性（2）第一种注入方式：使用set方法进行注入 ①创建类，定义属性和对应的set方法 public class Book &#123; //创建属性 private String bname; private String bauthor; //创建属性对应的set方法 public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125;&#125; ②在Spring配置文件配置对象创建，配置属性注入 &lt;!--2、set方法注入属性--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.lxg.spring5.Book&quot;&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=&quot;bname&quot; value=&quot;西游记&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;吴承恩&quot;&gt;&lt;/property&gt; &lt;/bean&gt;（3）第二种注入方式：使用有参构造进行注入 ①创建类，定义属性，创建属性对应的有参构造方法 public class Order &#123; private String name; private String address; public Order(String name, String address) &#123; this.name = name; this.address = address; &#125;&#125; ②在Spring配置文件中进行配置 &lt;!--有参构造注入属性--&gt; &lt;bean id=&quot;orders&quot; class=&quot;com.lxg.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;中国&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 注意：也可这么写 &lt;constructor-arg index=&quot;0&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt;（4）p名称空间注入（set方法注入的简化） ①使用p名称空间注入，可以简化基于xml配置方式 第一步添加p名称空间在配置文件中。 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 第二步进行属性注入，在bean标签里面进行操作 &lt;bean id=&quot;book&quot; class=&quot;com.lxg.spring5.Book&quot; p:bname=&quot;红楼梦&quot; p:bauthor=&quot;曹雪芹&quot;&gt; &lt;/bean&gt; 3.1.1、 IOC操作 Bean管理（xml注入其他类型属性）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321、字面量 name（1）null值 &lt;!--null值--&gt; &lt;property name=&quot;address&quot;&gt; &lt;null/&gt; &lt;/property&gt;（2）属性值包含特殊符号 &lt;!--属性值包含特殊符号 1.把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2.把带特殊符号内容写到CDATA中 3.格式：&lt;![CDATA[你想写的内容]]&gt; --&gt; &lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;2、注入属性-外部bean （1）创建两个类service类和Dao类 public class UserService &#123; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; //创建UserDao类型属性，生成set方法 private UserDao userDao; public void add() &#123; System.out.println(&quot;service add...&quot;); //原始的方法// UserDao userDao = new UserDaoImpl();// userDao.update(); //使用set方法注入 userDao.update(); &#125;&#125; （2）在service中调用dao里面的方法 （3）在Spring配置文件中进行配置 &lt;!--1、service和dao对象创建--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.lxg.spring5.service.UserService&quot;&gt; &lt;!--注入userDao对象 name:类中的属性名称 ref:引用的bean的id(创建userDao对象bean标签的id值) --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.lxg.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; （4）测试 @Test public void testAdd() &#123; //加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); //获取bean UserService userService = context.getBean(&quot;userService&quot;, UserService.class); //调用方法 userService.add(); &#125; 3、注入属性-内部bean（1）一对多关系：部门和员工 一个部门可以有多个员工，一个员工属于一个部门 部门是一，员工是多。（2）在实体类之间表示一对多关系//部门类public class Dept &#123; private String deptName; public void setDeptName(String deptName) &#123; this.deptName = deptName; &#125; public String getDname() &#123; return dname; &#125;&#125;//员工类public class Emp &#123; private String ename; private String job; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setJob(String job) &#123; this.job = job; &#125;&#125;（3）在Spring配置文件中进行配置&lt;!--内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.lxg.spring5.bean.Emp&quot;&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lxg&quot;&gt;&lt;/property&gt; &lt;property name=&quot;job&quot; value=&quot;java&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id = &quot;dept&quot; class = &quot;com.lxg.spring5.bean.Dept&quot;&gt; &lt;property name =&quot;dname&quot; value = &quot;程序员&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;4、注入属性-级联赋值（1）第一种写法&lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.lxg.spring5.bean.Emp&quot;&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;xiaolin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;job&quot; value=&quot;总经理&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.lxg.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt;（2）第二种写法 对象必须有get方法&lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.lxg.spring5.bean.Emp&quot;&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;xiaolin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;job&quot; value=&quot;总经理&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.lxg.spring5.bean.Dept&quot;&gt; &lt;/bean&gt; 3.1.2 、IOC操作 Bean管理（xml注入集合属性）123456789101112131415161718192021222324252627282930311、注入数组类型属性2、注入List集合类型属性3、注入Map集合类型属性4、注入Set集合类型属性（1）创建类，定义属性和相关属性set方法public class Stu &#123; //1、数组类型属性 private String[] courses; //2、List类型属性 private List&lt;String&gt; list; //3、Map类型属性 private Map&lt;String,String&gt; maps; //4、Set类型属性 private Set&lt;String&gt; sets; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536（2）在Spring配置文件进行配置&lt;!--1、集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.lxg.spring5.collectiontype.Stu&quot;&gt; &lt;!--1、数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java&lt;/value&gt; &lt;value&gt;c++&lt;/value&gt; &lt;value&gt;pyhton&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--2、数组类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--3、Map类型属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;张三&quot; value=&quot;1&quot;/&gt; &lt;entry key=&quot;李四&quot; value=&quot;2&quot;/&gt; &lt;entry key=&quot;王五&quot; value=&quot;3&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--4、Set类型属性注入--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Web&lt;/value&gt; &lt;value&gt;Spring&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 1234567891011121314151617181920212223242526272829303132335、在集合里面设置对象类型值&lt;!--注入list集合类型，值是对象--&gt; &lt;property name=&quot;coursesList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;!--创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.lxg.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.lxg.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt;6、把集合注入部分提取出来共用（1）在Spring配置文件中引入一个名称空间util&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;（2）用util标签完成list集合注入提取 &lt;!--提取list集合类型属性注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/util:list&gt; &lt;!--怎么使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.lxg.spring5.collectiontype.Book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3.1.3 、IOC 操作 Bean管理（FactoryBean）1234567891011121314151617181920212223242526272829303132333435361、Spring有两种bean,一种普通bean，另外一种工厂bean（FactoryBean）2、普通bean：在配置文件中定义bean类型就是返回的类型3、工厂bean：在配置文件中定义bean类型可以和返回类型不一样 第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean 第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型 public class MyBean implements FactoryBean&lt;Course&gt; &#123; //定义返回bean @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(&quot;java&quot;); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return FactoryBean.super.isSingleton(); &#125;&#125;//测试 @Test public void testMyBean() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course); &#125;//配置文件&lt;bean id=&quot;myBean&quot; class=&quot;com.lxg.spring5.factorybean.MyBean&quot;&gt; &lt;/bean&gt; 3.1.4、 IOC 操作 Bean管理（bean的作用域）12345678910111213141516171819202122232425262728293031323334351、在Spring里面，设置创建bean实例是单实例还是多实例。2、在Spring里面，默认情况下，bean是一个单实例对象 @Test public void testCollection2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book1 = context.getBean(&quot;book&quot;, Book.class); //book.show(); Book book2= context.getBean(&quot;book&quot;, Book.class); System.out.println(book1); System.out.println(book2); &#125; //结果 com.lxg.spring5.collectiontype.Book@7bd7d6d6com.lxg.spring5.collectiontype.Book@7bd7d6d6 3、如何设置单实例还是多实例（1）在Spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例 （2）scope属性值第一个值：默认值，singleton，表示单实例对象第二个prototype，表示是多实例对象 &lt;bean id=&quot;book&quot; class=&quot;com.lxg.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; //结果com.lxg.spring5.collectiontype.Book@5b799640com.lxg.spring5.collectiontype.Book@6cb107fd（3）singleton和prototype区别第一singleton单实例，prototype多实例第二设置scope值是singleton时候，加载Spring配置文件时就会创建单实例对象设置scope值是prototype时候，不是在加载Spring配置文件时候创建，在调用getBean方法时候创建多实例对象（4）request和session（了解） 3.1.5 、IOC操作Bean 管理（bean生命周期）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495961、生命周期（1）从对象创建到对象销毁的过程2、bean生命周期（1）通过构造器创建bean实例(无参数构造)（2）为bean的属性设置值和其他bean的引用（调用set方法）（3）调用bean的初始化的方法（需要进行配置初始化的方法）（4）bean可以使用了（对象获取到了）（5）当容器关闭时候，调用bean的销毁方法（需要进行配置销毁的方法）3、演示bean的生命周期public class Orders &#123; public Orders() &#123; System.out.println(&quot;第一步执行无参数构造方法创建bean实例&quot;); &#125; private String oname; public void setOname(String oname) &#123; this.oname = oname; System.out.println(&quot;第二步执行set方法设置属性值&quot;); &#125; //创建执行的初始化方法 public void initMethod() &#123; System.out.println(&quot;第三步执行初始化方法&quot;); &#125; //创建执行的销毁方法 public void destroyMethod() &#123; System.out.println(&quot;第五步执行销毁方法&quot;); &#125;&#125;测试： @Test public void testMyBean3() &#123; /*ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);*/ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); Orders orders = context.getBean(&quot;orders&quot;, Orders.class); System.out.println(&quot;第四步：获取创建的bean实例对象&quot;); System.out.println(orders); //执行销毁方法// ((ClassPathXmlApplicationContext) context).close(); context.close(); &#125;配置文件： &lt;bean id=&quot;orders&quot; class=&quot;com.lxg.spring5.bean.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 结果：第一步执行无参数构造方法创建bean实例第二步执行set方法设置属性值第三步执行初始化方法第四步：获取创建的bean实例对象com.lxg.spring5.bean.Orders@5386659f第五步执行销毁方法 4、bean的后置处理器，bean的生命周期有七步（1）通过构造器创建bean实例(无参数构造)（2）为bean的属性设置值和其他bean的引用（调用st方法）（3）把bean实例传递bean后置处理器的方法postProcessBeforeInitialization(Object bean, String beanName)（4）调用bean的初始化的方法（需要进行配置初始化的方法）（5）把bean实例传递bean后置处理器的方法postProcessAfterInitialization(Object bean, String beanName) （6）bean可以使用了（对象获取到了）（7）当容器关闭时候，调用bean的销毁方法（需要进行配置销毁的方法）5、演示添加后置处理器效果（1）创建类，实现接口BeanPostProcessor，创建后置处理器 public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125;配置文件 &lt;!--配置后置处理器--&gt; &lt;bean id=&quot;myBeanPost&quot; class=&quot;com.lxg.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt;结果：第一步执行无参数构造方法创建bean实例 第二步执行set方法设置属性值在初始化之前执行的方法第三步执行初始化方法在初始化之后执行的方法第四步：获取创建的bean实例对象com.lxg.spring5.bean.Orders@48bb62第五步执行销毁方法 3.1.6 、IOC操作Bean管理（xml自动装配）123456789101112131415161718192021221、什么是自动装配？（1）根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入2、演示自动装配过程&lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值: byName根据属性名称注入，注入值bean的id值和类属性名称一致 byType根据属性类型注入，不能有多个同类型的bean --&gt;①根据属性名称注入 &lt;bean id=&quot;emp&quot; class=&quot;com.lxg.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.lxg.spring5.autowire.Dept&quot;&gt; &lt;/bean&gt;②根据属性类型注入 &lt;bean id=&quot;emp&quot; class=&quot;com.lxg.spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.lxg.spring5.autowire.Dept&quot;&gt; &lt;bean&lt;/bean&gt; 3.1.7、IOC操作Bean管理（外部属性文件）1234567891011121314151617181920212223242526272829303132333435363738391、直接配置数据库信息（1）配置德鲁伊连接池 &lt;!--直接配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;623718&quot;&gt;&lt;/property&gt; &lt;/bean&gt;（2）引入德鲁伊连接池依赖jar包2、引入外部属性文件配置数据库连接池（1）创建外部属性文件，properties格式文件，写上数据库信息properties配置文件： prop.driverClass=com.mysql.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/bjpowernode prop.user=root prop.password=623718（2）把外部properties属性文件引入Spring配置文件中引入context名称空间&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;（3）在Spring配置文件中使用标签引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 三、IOC操作Bean管理（基于注解方式）1、什么是注解？ 注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值…) 使用注解，注解可以作用在类上面，方法上面，属性上面 使用注解的目的：简化xml配置 2、Spring针对Bean管理中创建对象提供的注解 @Component @Service @Controller @Repository 注意：上面四个注解功能是一样的，都可以用来创建bean实例 3、基于注解方式实现对象创建 引入依赖spring-aop-5.3.20.jar 开启组件扫描 12345&lt;!--开启组件扫描 1、如果扫描多个包，包之间使用逗号隔开 2、也可以直接扫描上层目录包--&gt;&lt;context:component-scan base-package=&quot;com.lxg.spring5&quot;&gt;&lt;/context:component-scan&gt; 创建类，在类上面添加创建对象注解 123456789//在注解里面value属性值可以省略不写//默认值是类名首字母小写//UserService---userService@Component(value=&quot;userService&quot;)//&lt;bean id=&quot;userService&quot; class=&quot;&quot;....&quot;&quot;&gt;;public class UserService &#123; public void addUser() &#123; System.out.println(&amp;quot;addUser...&amp;quot;); &#125;&#125; 测试 1234567891011@Testpublic void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.addUser();&#125;//com.lxg.spring5.service.UserService@48b67364//addUser... 4、开启组件扫描细节配置123456789101112131415&lt;!--示例1 use-default-lazy-init=&quot;false&quot;表示现在不适用默认filter，使用自己配置filter context:include-filter=&quot;filter1&quot;表示使用filter1过滤器,可以设置扫描哪些内容--&gt;&lt;context:component-scan base-package=&quot;com.lxg.spring5&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--示例2 下面配置扫描包所有内容 exclude-filter=&quot;filter1&quot;表示排除filter1过滤器,可以设置不扫描哪些内容--&gt;&lt;context:component-scan base-package=&quot;com.lxg.spring5&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 5、基于注解方式实现属性注入 @AutoWired 根据属性类型进行自动装配 第一步把service和dao对象创建，在service和dao类添加创建对象注解 第二步在service中注入dao对象，在service类中添加dao类型属性，在属性上面使用注解 12345678910111213@Servicepublic class UserService &#123; //定义dao类型属性 //不需要添加set方法 //添加注入属性注解 @Autowired private UserDao userDao; public void addUser() &#123; System.out.println(&quot;addUser...&quot;); userDao.add(); &#125;&#125; @Qualifier 根据名称进行注入 这个注解的使用，需要和上面@Autowired一起使用 123456//定义dao类型属性//不需要添加set方法//添加注入属性注解@Autowired //根据类型进行注入@Qualifier(value = &quot;userDaoImpl1&quot;)//根据名称进行注入private UserDao userDao; @Resource 可以根据类型注入，也可以根据名称注入 12//@Resource//根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;)//根据名称进行注入 是 javax.annotation.Resource包下的依赖，不是Spring的，一般不建议使用。 @value 注入普通类型属性 12@Value(value = &quot;lxg&quot;)private String name; 6、完全注解开发 创建配置类，替代xml配置文件 12345@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &quot;com.lxg.spring5&quot;) //扫描包，指定扫描的包public class SpringConfig &#123;&#125; 编写测试类 123456789@Testpublic void testService2()&#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.addUser();&#125; 四、AOP1、什么是AOP？1231、面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高查询的可重用性，同时提高了开发的效率。2、通俗描述：不通过修改源代码的方式，在主干功能中添加新功能。3、使用登录例子说明AOP 2、AOP（底层原理）2.1、AOP底层使用动态代理 有两种情况的动态代理 第一种有接口情况，使用JDK动态代理 创建接口实现类代理对象，增强类的方法 第二种没有接口情况，使用CGLIB动态代理 创建子类的代理对象，增强类的方法 2.2、AOP（JDK动态代理） 使用JDK动态代理，使用Proxy类里面的方法创建代理对象 1)调用newProxyInstance方法 方法有三个参数： 123第一个参数，类加载器第二个参数，增强方法所在的类，这个类实现的接口，支持多个接口第三个参数，实现这个接口InvocationHandler，创建代理对象，写增强的部分。 JDK动态代理代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591、创建接口，定义方法public interface UserDao &#123; public int add(int a, int b); public String update(String id);&#125;2、创建接口实现类，实现方法public class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法执行了...&quot;); return a+b; &#125; @Override public String update(String id) &#123; System.out.println(&quot;update方法执行了...&quot;); return id; &#125;&#125;3、使用Proxy类创建接口代理对象public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;; /*Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125; &#125;);*/ UserDaoImpl userDao = new UserDaoImpl(); UserDao dao =(UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(&quot;result：&quot;+result); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler &#123; //1、把创建的是谁的对象，把谁的对象传进来 //有参构造传递 private Object obj; public UserDaoProxy(Object obj) &#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法之前执行...&quot;+method.getName()+&quot;:传递的参数...&quot;+ Arrays.toString(args)); //被增强方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(&quot;方法之后执行...&quot;+obj); return res; &#125;&#125; 2.3、AOP（术语）123456789101112131415161、连接点类里面哪些方法可以被增强，这些方法就称为连接点2、切入点实际被真正增强的方法，称为切入点3、通知（增强）（1）实际增强的逻辑部分称为通知（增强）（2）通知有多种类型 *前置通知 *后置通知 *环绕通知 *异常通知 *最终通知4、切面是动作（1）把通知应用到切入点的过程 2.4、AOP操作（准备）12345671、Spring框架一般都是基于AspectJ实现AOP（1）什么是AspectJ？ *AspectJ不是Spring组成部分，一般把AspectJ和Spring框架一起使用，进行AOP操作。2、基于AspectJ实现AOP操作（1）基于xml文件方式实现（2）基于注解方式实现（使用）3、在项目工程里面引入AOP相关依赖 1234567891011121314151617181920214、切入点表达式（1）切入点表达式的作用：知道对哪个类里面的哪个方法进行增强。（2）语法结构：execution([权限修饰符][返回值类型][类的全路径][方法名]([参数列表]))权限修饰符可以省略举例1：对com.lxg.dao.BookDao类里面的add进行增强execution(* com.lxg.BookDao.add(..))举例2：对com.lxg.dao.BookDao类里面的所有方法进行增强execution(* com.lxg.BookDao.*(..))举例3：对com.lxg.dao包里面的所有类所有方法进行增强execution(* com.lxg.*.*(..))第一个*表示返回值可以是任意类型，第二个*表示任意类，第三个*表示任意方法，括号里的..表示参数任意。execution：用于匹配方法执行的连接点；execution(* com.test.method.des..*.*(..))1, execution() 表达式的主体2, 第一个“*”符号 表示返回值的类型任意3, com.test.method.des AOP所切的服务的包名，即，需要进行横切的业务类4, 包名后面的“..”表示当前包及子包5, 第二个“*” 表示类名，*即所有类6, .*(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型 2.5、AOP操作（AspectJ注解）123456789101112131415161、创建类，在类里面定义方法public class User &#123; public void add() &#123; System.out.println(&quot;add...&quot;); &#125;&#125;2、创建增强类（编写增强逻辑）（1）在增强类里面，创建方法，让不同方法代表不同通知类型 //增强的类public class UserProxy &#123; //前置通知 public void before() &#123; System.out.println(&quot;before...&quot;); &#125;&#125; 123456789101112131415161718192021223、进行通知的配置（1）在spring配置文件中，开启注解扫描引入aop名称 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.lxg.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt;（2）使用注解创建User和UserProxy对象（3）在增强类上面添加注解@Aspect（4）在spring配置文件中开启生成代理对象&lt;!--开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414、配置不同类型的通知（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置。//增强的类@Component@Aspectpublic class UserProxy &#123; //前置通知 //@Before注解表示该方法是一个前置通知 @Before(&quot;execution(* com.lxg.spring5.aopanno.User.add(..))&quot;) public void before() &#123; System.out.println(&quot;before...&quot;); &#125; //后置通知 //最终通知 //@After注解表示该方法是一个后置通知 @After(&quot;execution(* com.lxg.spring5.aopanno.User.add(..))&quot;) public void after() &#123; System.out.println(&quot;after...&quot;); &#125; //返回通知 //@AfterReturning注解表示该方法是一个返回通知 @AfterReturning(&quot;execution(* com.lxg.spring5.aopanno.User.add(..))&quot;) public void afterReturning() &#123; System.out.println(&quot;afterReturning...&quot;); &#125; //异常通知 //@AfterThrowing注解表示该方法是一个异常通知 @AfterThrowing(&quot;execution(* com.lxg.spring5.aopanno.User.add(..))&quot;) public void afterThrowing() &#123; System.out.println(&quot;afterThrowing...&quot;); &#125; //环绕通知 //@Around注解表示该方法是一个环绕通知 @Around(&quot;execution(* com.lxg.spring5.aopanno.User.add(..))&quot;) public void around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕之前...&quot;); //被增强的方法执行 pjp.proceed(); System.out.println(&quot;环绕之后...&quot;); &#125;&#125; 1234567891011121314155、相同的切入点抽取//相同切入点抽取//定义切入点，通知增强目标类的哪些方法@Pointcut(&quot;execution(*com.lxg.spring5.aopanno.User.add(..))&quot;)public void pointDemo()&#123;&#125;6、有多个增强类对同一个方法进行增强，设置增强类优先级（1）在增强类上面添加注解@Order(数字类型值)，值越小，优先级越高7、完全使用注解开发（1）创建配置类，不需要xml配置文件@Configuration//声明为配置类@ComponentScan(&quot;com.lxg.spring5.aopanno&quot;)//扫描注解@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAop &#123;&#125; @EnableAspectJAutoProxy注解等同于在xml中配置aspectj-autoproxy，表示开启spring对注解AOP的支持，proxyTargClass=true表示强制使用cglib代理方式。 2.6、AOP操作（Aspect配置文件）12345678910111213141516171、创建两个类，增强类和被增强类，创建方法2、在Spring配置文件中创建两个类对象&lt;!--创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.lxg.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.lxg.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt;3、在Spring配置文件中配置切入点&lt;!--配置aop增强--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.lxg.spring5.aopxml.Book.buy(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;!--把before方法配置到切入点p上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 五、jdbcTemplate（概念和准备）1、什么是JdbcTemplate11、Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库的操作 2、准备工作11、引入相关依赖 1234567892、在spring配置文件中配置数据库连接池&lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.31.1:3306/bjpowernode&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;623718&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt; 123453、配置JdbcTemplate对象，注入DataSource &lt;!--创建JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 12345678910111213141516171819204、创建service类，创建dao类，在dao注入jdbcTemplate对象配置文件：&lt;!--开始组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lxg.spring5&quot;&gt;&lt;/context:component-scan&gt; @Servicepublic class BookService &#123; //注入dao @Autowired private BookDao bookDao;&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate;&#125; 3、jdbcTemplate 操作数据库（添加）3.1、对应数据库创建出实体类1234567891011121314151617181920212223242526272829public class User &#123; private String useId; private String userName; private String ustatus; public String getUseId() &#123; return useId; &#125; public void setUseId(String useId) &#123; this.useId = useId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUstatus() &#123; return ustatus; &#125; public void setUstatus(String ustatus) &#123; this.ustatus = ustatus; &#125;&#125; 3.2、编写service和dao1、在dao进行数据库添加操作 2、调用JdbcTemplate对象里面的update方法实现添加操作 有两个参数 第一个参数：sql语句 第二个参数：可变参数，设置sql语句值 12345678910111213141516@Repositorypublic class BookDaoImpl implements BookDao &#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(Book book) &#123; //1、创建sql语句 String sql = &quot;insert into t_book values(?,?,?)&quot;; //2、调用方法实现 Object[] args = &#123;book.getBookId(), book.getBookName(),book.getBookAuthor()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(&quot;添加了&quot;+update+&quot;条数据&quot;); &#125;&#125; 3、测试类 1234567891011@Testpublic void testJdbcTemplate() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); book.setBookId(&quot;6&quot;); book.setBookName(&quot;Spring5&quot;); book.setBookAuthor(&quot;lxg&quot;); bookService.addBook(book);&#125; 4、jdbcTemplate操作数据库（修改和删除）1234567891011121314@Overridepublic void bookupdate(Book book) &#123; String sql= &quot;update t_book set bookName=?,bookAuthor=? where bookId=?&quot;; Object[] args = &#123;book.getBookName(),book.getBookAuthor(),book.getBookId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(&quot;更新了&quot;+update+&quot;条数据&quot;);&#125;@Overridepublic void bookdelete(String id) &#123; String sql= &quot;delete from t_book where bookId=?&quot;; int update = jdbcTemplate.update(sql, id); System.out.println(&quot;删除了&quot;+update+&quot;条数据&quot;);&#125; 测试： 1234567891011121314151617181920 @Test public void testJdbcTemplate() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); //添加// Book book = new Book();// book.setBookId(&quot;6&quot;);// book.setBookName(&quot;Spring5&quot;);// book.setBookAuthor(&quot;lxg&quot;);// bookService.addBook(book); //修改// Book book1 = new Book();// book1.setBookId(&quot;5&quot;);// book1.setBookName(&quot;web&quot;);// book1.setBookAuthor(&quot;lxg&quot;);// bookService.updateBook(book1); //删除 bookService.deleteBook(&quot;5&quot;); &#125; 5、jdbcTemplate操作数据库（查询）5.1、查询返回某个值1、查询表里面有多少条记录，返回是某个值 2、使用JdbcTemplate实现查询返回某个值 两个参数 第一个参数，sql语句 第二个参数，返回类型Class 1234567//查询表记录数@Overridepublic int findCount() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count= jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; 3、测试 123//查询表中记录数int count= bookService.getCount();System.out.println(count); 5.2、查询返回对象1、场景：查询图书详情 2、JdbcTemplate实现查询返回对象 有三个参数 第一个参数，sql语句 第二个参数：RowMapper，是接口，针对返回不同类型数据，使用这个接口里面的实现类完成数据封装 第三个参数：sql语句值 1234567//查询返回对象@Overridepublic Book findBook(String id) &#123; String sql = &quot;select * from t_book where bookId=?&quot;; Book book = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),id); return book;&#125; 5.3、查询返回集合1、场景：查询图书列表分页… 2、调用jdbcTemplate方法实现查询返回集合 123456@Overridepublic List&lt;Book&gt; findBooks() &#123; String sql = &quot;select * from t_book&quot;; List&lt;Book&gt; list = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return list;&#125; 6、jdbcTemplate操作数据库（批量操作）1、批量操作：操作表里面多条记录 6.1、实现批量添加操作 有两个参数 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 1234567//批量添加@Overridepublic void addBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_book values(?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;添加了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量添加List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] args1 = &#123;&quot;7&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;Object[] args2 = &#123;&quot;8&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;Object[] args3 = &#123;&quot;9&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;batchArgs.add(args1);batchArgs.add(args2);batchArgs.add(args3);bookService.addBooks(batchArgs); 6.2、实现批量修改操作1234567//批量更新@Overridepublic void updateBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_book set bookName=?,bookAuthor=? where bookId=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;更新了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量更新List&lt;Object[]&gt; batchArgs1= new ArrayList&lt;&gt;();Object[] args1 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;7&quot;&#125;;Object[] args2 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;8&quot;&#125;;Object[] args3 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;9&quot;&#125;;batchArgs1.add(args1);batchArgs1.add(args2);batchArgs1.add(args3);bookService.updateBooks(batchArgs1); 6.3、实现批量删除操作1234567//批量删除@Overridepublic void deleteBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_book where bookId=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;删除了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量删除List&lt;Object[]&gt; ids = new ArrayList&lt;&gt;();Object[] id1 = &#123;&quot;7&quot;&#125;;Object[] id2 = &#123;&quot;8&quot;&#125;;Object[] id3 = &#123;&quot;9&quot;&#125;;ids.add(id1);ids.add(id2);ids.add(id3);bookService.deleteBooks(ids); 六、Spring5框架的新功能1、整个Spring框架的代码基于Java8，运行时兼容jdk9，许多不建议的类和方法在代码库中删除。 2、Spring5.0框架自带了通用的日志封装 123451、Spring5已经移除了log4jConfigListener，官方建议使用Log4j22、Spring框架中整合Log4j2*第一步：引入jar包*第二步：创建log4j2配置文件 3、Spring框架核心容器支持@Nullable注解 11、@Nullable注解可以使用在方法上面，属性上面，参数上面，表示方法可以方法返回值可以为空，属性值可以为空，参数值可以为空。 4、Spring5核心容器支持函数式风格 123456789101112131415//函数式风格创建对象，交给Spring管理@Testpublic void testAccount4()&#123; //创建GenericApplicationContext对象 GenericApplicationContext context = new GenericApplicationContext(); //调用context的方法对象注册 context.refresh();//把内容清空进行注册 context.registerBean(&quot;user1&quot;,User.class, () -&gt; new User()); //获取在Spring注册的对象 //User user =(User)context.getBean(&quot;com.lxg.spring5.test.User&quot;); User user1 = (User)context.getBean(&quot;user1&quot;); //System.out.println(user); System.out.println(user1);&#125; 5、Spring5支持整合JUnit5 1231、整合Junit4*第一步：引入Spring相关针对的依赖spring-test依赖 1234567891011@RunWith(SpringJUnit4ClassRunner.class)//单元测试框架@ContextConfiguration(&quot;classpath:bean1.xml&quot;)//加载配置文件public class JTest4 &#123; @Autowired private UserService userService; @Test public void test1()&#123; userService.transfer(); &#125;&#125; 122、Spring5整合Junit5*第一步：引入JUnit5jar包 1234567891011@ExtendWith(SpringExtension.class)@ContextConfiguration(&quot;classpath:bean1.xml&quot;)public class JTest5 &#123; @Autowired private UserService userService; @Test public void test()&#123; userService.transfer(); &#125;&#125; 使用复合注解替代上面两个注解 1@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;) 6、WebFulx介绍 7、响应式编程 8、WebFlux执行流程和核心API 9、SpringWebFlux（基于注解编程模型） 10、SpringWebFlux（基于函数式编程模型） 七、事务1、事物概念1.1、什么是事务？12341、事务是数据库操作最基本的单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作就都失败。2、典型场景：银行转账*lucy转账100元要给mary*lucy少100元，mary多100元 1.2、事物的四个特性（ACID） 原子性：不可分割 一致性：操作前后总量不变，守恒 隔离性：多事务之间互不干扰 持久性：表中数据发生变化是永久的 2、事务操作（搭建事务操作环境） 1、创建数据库表，添加记录 2、创建service，搭建dao，完成对象创建和注入关系 （1）service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource 1234567891011121314@Servicepublic class UserService &#123; //注入dao @Autowired private UserDao userDao;&#125;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate;&#125; 3、在dao创建两个方法：多钱和少钱，在service创建转账的方法 1234567891011121314//多钱//lucy转账100给marry@Overridepublic void addMoney() &#123; String sql = &quot;update t_account set money = money + ? where username = ?&quot;; jdbcTemplate.update(sql, &quot;marry&quot;);&#125;//少钱@Overridepublic void reduceMoney() &#123; String sql = &quot;update t_account set money = money -? where username = ?&quot;; jdbcTemplate.update(sql, &quot;lucy&quot;);&#125; 12345678910111213@Servicepublic class UserService &#123; //注入dao @Autowired private UserDao userDao; //转账 public void transfer() &#123; //转出 userDao.reduceMoney(); //转入 userDao.addMoney(); &#125;&#125; 4、上面代码正常执行没有问题，但是如果在执行过程中有异常就会有问题 123456789//转账public void transfer() &#123; //转出 userDao.reduceMoney(); //模拟异常 int i = 1/0; //转入 userDao.addMoney();&#125; lucy少了钱但是marry钱没增加 12345671、怎么解决这个问题？*使用事务进行解决2、事务操作过程1、开启事务2、执行业务操作3、没有异常，提交事务4、出现异常，回滚事务 3、事务操作（Spring事务管理介绍）1、事务添加到JavaEE三层结构里面Service层（业务逻辑层） 2、在Spring进行事务管理操作 有两种方式：编程式事务管理和声明式事务管理（常用） 3、声明式事务管理 基于注解方式（多用） 基于xml配置文件方式 4、在Spring进行声明式事务管理，底层使用AOP 5、Spring事务管理的API 11、提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 3.1、事务操作（注解声明式事务管理）1、在Spring配置文件中配置事务管理器 12345&lt;!--创建事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、在Spring配置文件中开启事务注解 12345678910111、在spring配置文件中引入名称空间tx&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schem/tx/spring-tx.xsd&quot;&gt; 1232、开启事务注解&lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 123453、在service类上面（获取service类里面方法上面）添加事务注解@Transactional，这个注解可以添加在类上面，也可以添加到方法上面如果把这个注解添加到类上面，这个类中的所有方法都添加事务如果把这个注解添加到方法上面，为这个方法添加事务 3.2、事务操作（声明式事务管理参数配置）1、在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 2、proagation：事务传播行为 （1）多事务方法之间进行调用，这个过程中事务是如何管理的。 掌握前两种即可 3、ioslation：事务隔离级别 12345671、事务里有个特性为隔离性，多事务操作之间不会产生影响，不考虑隔离线产生很多问题2、有三个读的问题：脏读、不可重复读、虚（幻）读3、脏读：一个未提交的事务读取到另一个未提交事务的数据4、不可重复读：一个未提交事务读取到另一个已提交的事务的数据5、一个未提交事务读取到另一个提交事务添加的数据6、解决：通过设置隔离级别，解决读的问题默认可重复读 1@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ) 4、timeout：超时时间 121、事务需要在一定的事间内进行提交，如果不提交进行回滚2、默认值是-1，不回滚，设置时间以秒单位进行计算 5、reafOnly：是否只读 1231、读：查询操作，写：添加修改删除操作2、readOnly默认值false，表示可以查询，也可以增删改3、设置为true，则只能查询 6、rollbackFor：回滚 11、设置出现哪些异常进行事务回滚 7、noRollbackFor：不回滚 1设置出现哪些异常不进行事务回滚 3.3、事务操作（XML声明式事务管理）1、在Spring配置文件中进行配置 第一步配置事务管理器 第二步配置通知 第三步配置切入点和切面 12345678910111213141516&lt;!--配置通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;tansfer&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.lxg.spring5.service.UserService.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 3.4、事务操作（完全注解声明式事务管理）123456789101112131415161718192021222324252627282930313233@Configuration//配置类@ComponentScan(basePackages = &quot;com.lxg&quot;)//组件扫描@EnableTransactionManagement//开启事务管理public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDuridDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/bjpowernode&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;623718&quot;); return dataSource; &#125; //创建jdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; //到IOC容器中根据类型找到dataSource对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125;","tags":"spring"},{"title":"Tomcat和Servlet","url":"/2022/10/22/Tomcat&Servlet/","text":"Tomcat1、JavaWeb的概念1、什么是JavaWeb？ 121、JavaWeb是指，所有通过Java语言编写可以通过浏览器访问的程序的总称，叫JavaWeb。2、JavaWeb是基于请求和响应来开发的。 2、什么是请求？ 11、请求是指客户端给服务器发送数据，叫请求Request 3、什么是响应？ 1响应是指服务器给客户端回传数据，叫响应Response 4、请求和响应的关系 1请求和响应是承兑出现的，有请求就有响应。 2、Web资源的分类1231、web资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。2、静态资源：html、css、js、txt、mp4视频、jpg图片3、动态资源：jsp页面、Servlet程序 3、常用的Web服务器123451、Tomcat：由Apache组织提供的一种Web服务器，提供对jsp和Servlet的支持。它是一种轻量级的JavaWeb容器（服务器），也是当前应用最广的JavaWeb服务器（免费）2、Jboss：是一个遵从JavaEE规范的、开源代码的、纯java的EJB服务器，它支持所有的JavaEE规范（免费）3、GlassFlsh：由Oracle公司开发的一款JavaWeb服务器，是一款强健的商业服务器，达到产品级质量（应用很少）4、Resin：是CAUCHO公司的产品，是一个非常流行的服务器，对Servlet和JSP提供了良好的支持，性能也比较优良，resin自身采用Java语言开发（收费、应用比较多）5、WebLogic：是Oracle公司的产品，是目前应用最广泛的Web服务器，支持JavaEE规范，而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 4、Tomcat服务器和Servlet版本的对应关系1、当前企业常用的版本7.或8. Tomcat版本 Servlet&#x2F;JSP版本 JavaEE版本 运行环境 4.1 2.3&#x2F;1.2 1.3 JDK1.3 5.0 2.4&#x2F;2.0 1.4 JDK1.4 5.5&#x2F;6.0 2.5&#x2F;2.1 5.0 JDK5.0 7.0 3.0&#x2F;2.2 6.0 JDK6.0 8.0 3.1&#x2F;2.3 7.0 JDK7.0 2、Servlet程序从2.5版本是现在市面使用最多的版本（xml配置） 到了Servlet3.0之后，就是注解版本的Servlet使用。 5、Tomcat的使用1、安装 找到需要用的Tomcat版本对应的zip压缩包，解压到需要安装的目录即可 2、目录介绍 12345671、bin：专门用来存放Tomcat服务器的可执行程序2、conf：专门用来存放Tomcat服务器的配置文件3、lib：专门用来存放Tomcat服务器的jar包4、logs：专门用来存放Tomcat服务器运行时输出的日志信息5、temp：专门用来存放Tomcat服务器运行时产生的临时数据6、webapps：专门用来存放部署的Web工程。7、work：是Tomcat工作时的目录，用来存放Tomcat运行时jsp翻译为Servlet的源码，和Session钝化的目录。 3、如何启动Tomcat服务器？ 12341、找到Tomcat目录下的bin目录下的start.bat文件，双击打开就可以启动服务器2、如何测试成功？*打开浏览器输入http://localhost:8080/*如果出现Tomcat界面即启动成功 4、常见的启动失败的情况，双击start.bat文件，就会出现一个黑窗口一闪而退 11、原因：未配置好JAVA_HOME环境变量 5、常见的JAVA_HOME配置错误有以下几种情况： 1231、JAVA_HOME必须全大写2、JAVA_HOME中间必须是下划线，不是减号3、JAVA_HOME配置的路径只需要配置到jdk的安装目录，不需要带上bin目录 6、另一种启动服务器的方式 1231、打开命令行2、cd到Tomcat的bin目录下3、敲入启动命令：catalina run 7、Tomcat的停止 1231、点击Tomcat服务器窗口的x关闭按钮2、把Tomcat服务器窗口置为当前窗口，然后按快捷键Ctrl+C3、找到Tomcat的bin目录下的shutdown.bat双击，就可以停止Tomcat服务器。 8、如何修改Tomcat的端口号？ 1231、MySQL默认的端口号是：33062、Tomcat默认的端口号是80803、修改：找到Tomcat目录下的conf目录，找到server.xml配置文件打开。 12平时上百度：http://www.baidu.com:80HTTP协议默认端口号是80. 9、如何部署web工程到Tomcat中 1234561、第一种方法：只需要web工程的目录拷贝到Tomcat的webapps目录下即可*在webapps目录下创建一个新项目文件夹*把web项目的内容拷贝到里面：2、如何访问Tomcat下的web工程。只需要在浏览器打开输入http://localhost:8080/项目名/网页名 123456782、第二种部署方法：找到Tomcat的conf目录\\Catalina\\localhost\\下，创建配置文件.xml&lt;!--Context表示一个工程的上下文path表示工程访问路径：/abcdocBase表示你的工程目录在哪里--&gt;&lt;context path=&quot;/abc&quot; docBase=&quot;E:\\book&quot;/&gt;上面为文件内容，文件名称不能为中文 10、手拖html页面到浏览器和在浏览器中输入http://ip:端口号/工程名/访问的区别： 11、ROOT的工程的访问，以及默认index.html页面的访问 1234当我们在浏览器地址栏输入的访问地址如下：http://ip:port/ 没有工程名的时候默认访问的是Tomcat目录下的ROOT工程当我们在浏览器地址栏中输入的访问地址如下：http://ip:port/工程名/ 没有资源名的时候，默认访问index.html页面 6、IDEA整合Tomcat服务器 7、IDEA中动态web工程的操作1、IDEA中如何创建动态web工程 1231、创建一个新模块2、选择你要创建什么类型的功能模块3、输入模块名，点击finish 2、web工程的目录介绍 3、如何给动态web工程添加额外的jar包 在WEB-INF目录下新建一个lib目录 将依赖jar包复制到目录下 在项目模块的库中新建一个库 在工件中修正依赖 4、如何在IDEA中部署工程到Tomcat上运行 121、建议修改每个web工程对应的tomcat运行实例名称2、确认你的tomcat实例中有你要部署运行的web工程模块 13、修改运行时的地址，端口号... 124、在idea中如何运行和停止tomcat实例与普通程序一样。 5、配置资源热部署 选择：更新类和资源 Servlet1、Servlet技术1、什么是Servlet？ 1231、Servlet是JavaEE规范之一，规范就是接口。2、Servlet是JavaWeb三大组件之一，三大组件分别是：Servlet程序、Filter过滤器、Listener监听器3、Servlet是运行在服务器上的一个java小程序，它可以接受客户端发送过来的请求，并响应数据给客户端。 2、手动实现Servlet程序 1231、编写一个类去实现Servlet接口2、实现service方法，处理请求，并响应数据3、到web.xml中去配置Servlet程序的访问地址 12345678910111213141516&lt;!--servlet标签给tomcat服务器配置Servl程序--&gt;&lt;servlet&gt; &lt;!--servlet-name标签是Servlet程序起的一个别名--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--全类名--&gt; &lt;servlet-class&gt;com.lxg.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--servlet-mapping标签给程序配置访问地址--&gt;&lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给哪个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--url-patten配置访问地址 /斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 /hello 表示地址为http://ip:port/工程路径/hello--&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、常见的错误： 1231、url-pattern中配置路径没有以斜杠打头2、servlet-name配置的值不存在3、servlet-class标签的全类名配置错误 4、原理: 5、Servlet的生命周期 12345671、执行Servlet构造器方法2、执行init初始化方法第一和第二步是在第一次访问的时候创建Servlet程序时会调用，只调用一次3、执行service方法第三步，每次访问都会调用4、执行destroy销毁方法第四步，在web工程停止的时候调用 6、GET和POST请求的分发处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.lxg.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2 init初始化&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; /** * service方法是专门来处理请求和响应的 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3 service==HelloServlet被访问了&quot;); //类型转换(因为它有getMethod方法） HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String method = httpServletRequest.getMethod(); if(&quot;GET&quot;.equals(method))&#123; doGet(); &#125;else if(&quot;POST&quot;.equals(method))&#123; doPost(); &#125; &#125; /* *处理post */ public void doPost()&#123; System.out.println(&quot;post请求1&quot;); System.out.println(&quot;post请求2&quot;); &#125; public void doGet()&#123; System.out.println(&quot;get请求1&quot;); System.out.println(&quot;get请求2&quot;); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;4 销毁方法&quot;); &#125;&#125; 7、通过继承HttpServlet实现Servlet程序 1234一般在时机项目开发中，都是使用继承HttpServlet类的方式去实现Servlet程序。1、编写一个类去继承HttpServlet类2、根据业务需要重写doGet或doPost方法3、到web.xml中的配置Servlet程序的访问地址。 类： 123456789101112131415161718192021222324252627282930313233package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet2 extends HttpServlet &#123; /** * doGet()在get请求的时候调用 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;HelloServlet2的doGet请求&quot;); &#125; /** * doPost()在post请求的时候调用 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;HelloServlet2的doPost请求&quot;); &#125;&#125; 配置文件： 12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lxg.servlet.HelloServlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 8、使用IDEA创建Servlet程序 11、new-&gt;Servlet程序 12、配置Servlet信息 9、Servlet类的继承体系 2、ServletConfig类ServletConfig类从类名上来看，就知道是Servlet程序的配置信息类。 Servlet程序和ServletConfig对象都是由Tomcat负责创建的，我们只负责使用。 Servlet程序默认是第一次访问的时候创建，ServletConfig是每个Servlet程序创建时，就创建一个对应的ServletConfig对象。 1、ServletConfig类的三大作用 1231、可以获取Servlet程序的别名servlet-name的值2、获取初始化参数init-param3、获取ServletContext对象 123456789101112 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;2 init初始化&quot;);// 1、可以获取Servlet程序的别名servlet-name的值 System.out.println(&quot;HelloServlet程序的别名是：&quot;+servletConfig.getServletName());// 2、获取初始化参数init-param System.out.println(&quot;初始化参数username的值是：&quot;+servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数url的值是：&quot;+servletConfig.getInitParameter(&quot;url&quot;));// 3、获取ServletContext对象 System.out.println(&quot;ServletContext对象是：&quot;+servletConfig.getServletContext()); &#125; 3、ServletContext类1、什么是ServletContext？ 12341、ServletContext是一个接口，它表示Servlet上下文对象2、一个Web工程，只有一个ServletContext对象实现。3、ServletContext对象是一个域对象。4、ServletContext是在web工程部署启动的时候创建，在web工程停止的时候销毁的。 123什么是域对象？1、域对象，是可以像Map一样存取数据的对象，叫做域对象2、这里的域指的是存取数据的操作范围，整个web工程 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() 2、ServletContext类的四个作用 12341、获取web.xml中配置的上下文参数context-param2、获取当前的工作路径格式：/工程路径3、获取工程部署后在服务器硬盘上的绝对路径4、像Map一样存取数据 123456789101112131415161718192021222324252627282930package com.lxg.servlet;import javax.servlet.*;import javax.servlet.http.*;import java.io.IOException;public class ContextServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;// 1、获取web.xml中配置的上下文参数context-param ServletContext context = getServletConfig().getServletContext(); String username = context.getInitParameter(&quot;username&quot;); System.out.println(&quot;context-param参数username的值是：&quot;+username); String password = context.getInitParameter(&quot;password&quot;); System.out.println(&quot;context-param参数password的值是：&quot;+password);// 2、获取当前的工作路径格式：/工程路径 System.out.println(&quot;当前工程路径：&quot;+context.getContextPath());// 3、获取工程部署后在服务器硬盘上的绝对路径 /* * / 斜杠被服务器解析地址为http://ip:port/工程名/ 映射到IDEA代码的web目录 */ System.out.println(&quot;工程部署的路径是：&quot;+context.getRealPath(&quot;/&quot;)); System.out.println(&quot;工程下css目录的绝对路径是：&quot;+context.getRealPath(&quot;/css&quot;)); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 123456789&lt;!--context-param是上下文参数（它属于整个web工程）--&gt;&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;context&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt;&lt;/context-param&gt; 4、Http协议1、什么是Http协议 12341、什么是协议？协议就是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议2、所谓Http协议就是指客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫Http协议3、Http协议中的数据又叫报文。 2、请求的Http协议格式 1231、客户端给服务器发送数据叫请求2、服务器给客户端回传数据叫响应3、请求又分GET请求和POST请求两种。 12345671、GET请求（1）请求行*请求的方式 GET*请求的资源路径[+?+请求参数]*请求的协议的版本号 HTTP/1.1（2）请求头*key:value 组成，不同的键值对，表示不同的含义 123456789102、POST请求（1）请求行*请求的方式 POST*请求的资源路径[+?+请求参数]*请求的协议的版本号（2）请求头*key:value 不同的请求头，有不同的含义空行（3）请求体就是发送给服务器的数据 3、常用请求头的说明 1234Accept：表示客户端能够接受的数据类型Accept—Language：表示客户端可以接收的语言类型User-Agent：表示客户端浏览器的信息Host：表示请求时的服务器ip和端口号 4、哪些是GET请求和POST请求？ 12345678GET请求有哪些？1、form标签 method=get2、a标签3、link标签引入css4、Script 标签引入js文件5、img标签引入图片6、iframe标签引入html页面7、在浏览器地址栏中输入地址后回车 12POST请求有哪些？1、form标签 method=post 5、响应的HTTP协议格式 1234567891、响应行*响应的协议和版本号*响应状态码*响应状态描述符2、响应头*key:value 不同的响应头，有不同的含义空行3、响应体*就是回传给客户端的数据 6、常用的响应码说明 1234200 表示请求成功302 表示请求重定向404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）500 表示服务器已经收到请求，但是服务器内部错误（代码错误） 7、MIME类型说明 MIME是HTTP协议中的数据类型 MIME的英文全称是“Multipurpose Internet Mall Extensions”多功能Internet邮件扩充服务。MIME类型的格式是“大类型&#x2F;小类型”，并与一种文件的扩展名相对应。 常见的MIME类型： 文件 MIME类型 超文本标记语言文本 .html htm text&#x2F;html 普通文本 .txt text&#x2F;plain RTF文本 .rtf application&#x2F;trf GIF图形 .gif image&#x2F;gif JPEG图形 .jpeg .jpg image&#x2F;jpeg au声音文件 .au audio&#x2F;base MIDI音乐文件 mid,.midi audio&#x2F;midi,audio&#x2F;x-midi RealAudio音乐文件 .ra .ram audio&#x2F;x-pn-realaudio MPEG文件 .mpg .mpeg video&#x2F;mpeg AVI文件 .avi video&#x2F;x-msvideo GZIP文件 .gz application&#x2F;x-gzip TAR文件 .tar application&#x2F;x-tar 8、谷歌浏览器如何查看Http协议？ 5、HttpServletRequest类1、HttpServletRequest类有什么作用？ 1每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的Http协议信息解析好封装到Request对象中，然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息。 2、HttpServletRequest类的常用方法 123456789101、getRequestURI()获取请求的资源路径2、getRequestURL()获取请求的统一资源定位符（绝对路径）3、getRemoteHost()获取客户端的ip地址4、getHeader()获取请求头5、getParameter()获取请求的参数6、getParameterValues()获取请求的参数（多个值的时候使用）7、getMethod()获取请求的方式（GET或POST请求）8、setAttribute(key,value);设置域数据9、getAttribute(key);获取域数据10、getRequestDispatcher()获取请求转发对象 123456789101112131415161718192021222324package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RequestAPIServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// 1、getRequestURI()获取请求的资源路径 System.out.println(&quot;URI=&gt;&quot;+req.getRequestURI());// 2、getRequestURL()获取请求的统一资源定位符（绝对路径） System.out.println(&quot;URL=&gt;&quot;+req.getRequestURL()); //默认是127.0.0.1，浏览器输入真实ip就是真实ip地址// 3、getRemoteHost()获取客户端的ip地址 System.out.println(&quot;客户端ip地址=&gt;&quot;+req.getRemoteHost());// 4、getHeader()获取请求头 System.out.println(&quot;请求头user-Agent=&gt;&quot;+req.getHeader(&quot;user-Agent&quot;));// 7、getMethod()获取请求的方式（GET或POST请求） System.out.println(&quot;请求的方式=&gt;&quot;+req.getMethod()); &#125;&#125; URI&#x3D;&gt;&#x2F;07_servlet&#x2F;requestAPIServletURL&#x3D;&gt;http://192.168.171.1:8080/07_servlet/requestAPIServlet客户端ip地址&#x3D;&gt;192.168.171.1请求头user-Agent&#x3D;&gt;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;102.0.5005.61 Safari&#x2F;537.36请求的方式&#x3D;&gt;GET 3、如何获取请求参数？ 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Array;import java.util.Arrays;public class ParameterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求参数 System.out.println(&quot;======Get======&quot;); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String hobbies[] = req.getParameterValues(&quot;hobby&quot;); System.out.println(&quot;用户名：&quot;+username); System.out.println(&quot;密码：&quot;+password); System.out.println(&quot;兴趣爱好：&quot;+ Arrays.toString(hobbies)); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求体的字符集为utf-8，从而解决post请求的中文乱码问题 //要在全部获取请求参数之前用才会生效 req.setCharacterEncoding(&quot;UTF-8&quot;); System.out.println(&quot;======doPost======&quot;); //获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String hobbies[] = req.getParameterValues(&quot;hobby&quot;); System.out.println(&quot;用户名：&quot;+username); System.out.println(&quot;密码：&quot;+password); System.out.println(&quot;兴趣爱好：&quot;+ Arrays.toString(hobbies)); &#125;&#125; 4、请求的转发 121、什么是请求的转发？请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫做请求转发。 12345678910111213141516171819202122232425262728package com.lxg.servlet;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Servlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数（办事材料）查看 String username = req.getParameter(&quot;username&quot;); System.out.println(&quot;在Servlet1（柜台1）查看参数（材料）：&quot;+username); //给材料盖一个章，并传递到Servlet2（柜台2）去查看 req.setAttribute(&quot;key1&quot;,&quot;柜台1的章&quot;); //问路：Servlet2（柜台2）怎么走 /** * 请求转发必须以斜杠 / 打头，斜杠表示地址为http:ip:port/工程名/,映射到IDEA代码的web目录下 */ RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;); //走向servlet2（柜台2） requestDispatcher.forward(req,resp); &#125;&#125; 123456789101112131415161718192021package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Servlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求的参数（办事材料）查看 String username = req.getParameter(&quot;username&quot;); System.out.println(&quot;在Servlet2（柜台2）查看参数（材料）：&quot;+username); //查看柜台1是否有盖章 Object key1 = req.getAttribute(&quot;key1&quot;); System.out.println(&quot;柜台1是否有章：&quot;+key1); //处理自己的业务 System.out.println(&quot;Servlet处理自己的业务&quot;); &#125;&#125; 不能访问工程以外的资源 5、base标签的作用 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--base标签设置页面相对路径工作时参照地址 href属性就是参数的地址值 --&gt; &lt;base href=&quot;http://localhost:8080/07_servlet/a/b/c/c.html&quot;&gt;&lt;/head&gt;&lt;body&gt; 这是a下的b下的c.html页面&lt;br/&gt; &lt;a href=&quot;../../../index.html&quot;&gt;跳回首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是web下的index.html&lt;br/&gt; &lt;a href=&quot;a/b/c/c.html&quot;&gt;a/b/c/c.html&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://localhost:8080/07_servlet/forwardC&quot;&gt;请求转发：a/b/c/c.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ForwardC extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;经过了程序wardC&quot;); req.getRequestDispatcher(&quot;/a/b/c/c.html&quot;).forward(req,resp); &#125;&#125; 6、web中的相对路径和绝对路径 12345678在javaweb中，路径分为相对路径和绝对路径两种：相对路径是：. 表示当前目录.. 表示上一级目录资源名 表示当前目录/资源名绝对路径：http://ip:port/工程路径/资源路径 7、web中 &#x2F; 斜杠 的不同意义 123456789在web中斜杠是一种绝对路径/ 斜杠 如果被浏览器解析，得到的地址是：http://ip:port/&lt;a href=&quot;/&quot;斜杠&lt;/a&gt;/ 斜杠 如果被服务器解析，得到的地址是：http://ip:port/工程名1、&lt;url-pattern&gt;/servlet1&lt;/url-pattern&gt;2、servletContext.getRealPath(&quot;/&quot;);3、request.getRequestDispatcher(&quot;/&quot;);特殊情况：response.sendRediect(&quot;/&quot;);把斜杠发送给浏览器解析，得到http://ip:port/ 6、HttpServletResponse类1、HttpServletResponse类的作用 12HttpServletResponse类和HttpServletResponse类一样，每次请求进来，Tomcat服务器都创建一个Response对象传递给Servlet程序去使用，HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息。我们如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置。 2、两个输出流的说明。 1231、字节流 getOutputStream();常用于下载（传递二进制数据）2、字符流 getWriter();常用于回传字符串（常用）3、两个流同时只能使用一个，使用了字节流就不能再使用字符流，反之亦然，否则就会报错。 3、如何往客户端回传数据 要求：往客户端回传字符串数据 4、响应中文乱码的问题 123456789101112131415161718192021222324252627package com.lxg.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class ResponseIOServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //System.out.println(resp.getCharacterEncoding());//默认ISO-8859-1 //设置服务器字符集为UTF-8 // resp.setCharacterEncoding(&quot;UTF-8&quot;); //通过响应头，设置浏览器也使用UTF-8字符集 // resp.setHeader(&quot;Content-type&quot;,&quot;text/html;charset-UTF-8&quot;); //它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头 //此方法一定要在获取流对象之前调用才有效 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(resp.getCharacterEncoding());//默认ISO-8859-1 //要求：往客户端回传字符串数据 PrintWriter writer = resp.getWriter(); writer.write(&quot;小林加油！&quot;); &#125;&#125; 5、请求重定向 1请求重定向是指客户端给服务器发请求，如何服务器告诉客户端说，我给你一些地址，你去新地址访问，叫请求重定向（因为之前的地址可能已经被废弃） 1234第一种方案//设置响应状态码为302，表示重定向（已搬迁）resp.setStatus(302);resp.setHeader(&quot;Location&quot;,&quot;http://localhost:8080/07_servlet/response2&quot;); 12第二种方案（推荐使用）resp.sendRedirect(&quot;http://baidu.com&quot;);","tags":"tomcat、servlet"},{"title":"MyBatis","url":"/2022/10/22/MyBatis笔记/","text":"# Mybatis简介 ## MyBatis历史 - MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github - iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO） MyBatis特性 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架 MyBatis下载 MyBatis下载地址 和其它持久化层技术对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受 搭建MyBatis开发环境 IDE：idea 2019.2 构建工具：maven 3.5.4 MySQL版本：MySQL 5.7 MyBatis版本：MyBatis 3.5.7 创建maven工程 打包方式：jar 引入依赖 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建MyBatis的核心配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/MyBatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 12345678package com.atguigu.mybatis.mapper; public interface UserMapper &#123; /** * 添加用户信息 */ int insertUser(); &#125; 创建MyBatis的映射文件 相关概念：ORM（Object Relationship Mapping）对象关系映射。 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段&#x2F;列 对象 记录&#x2F;行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;) &lt;/insert&gt; &lt;/mapper&gt; 通过junit测试功能 SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂” 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象12345678910111213141516171819202122public class UserMapperTest &#123; @Test public void testInsertUser() throws IOException &#123; //读取MyBatis的核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 //SqlSession sqlSession = sqlSessionFactory.openSession(); //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 SqlSession sqlSession = sqlSessionFactory.openSession(true); //通过代理模式创建UserMapper接口的代理实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句 int result = userMapper.insertUser(); //提交事务 //sqlSession.commit(); System.out.println(&quot;result:&quot; + result); &#125;&#125; 此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(true);，传入一个Boolean类型的参数，值为true，这样就可以自动提交 加入log4j日志功能 加入依赖 123456&lt;!-- log4j日志 --&gt;&lt;dependency&gt;&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 加入log4j的配置文件 log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下 日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 核心配置文件详解 核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot; &quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=&quot;mysql_test&quot;&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=&quot;mysql_test&quot;&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot; type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理 type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot; type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建 type=&quot;JNDI&quot;：调用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 默认的类型别名 MyBatis的增删改查 添加 1234&lt;!--int insertUser();--&gt;&lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)&lt;/insert&gt; 删除 1234&lt;!--int deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 6 &lt;/delete&gt; 修改 1234&lt;!--int updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username = &#x27;张三&#x27; where id = 5 &lt;/update&gt; 查询一个实体类对象 1234 &lt;!--User getUserById();--&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt; select * from t_user where id = 2 &lt;/select&gt; 查询集合 1234&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt; select * from t_user&lt;/select&gt; 注意： 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值 MyBatis获取参数值的两种方式（重点） MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号 单个字面量类型的参数 若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号1234&lt;!--User getUserByUsername(String username);--&gt;&lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125;&lt;/select&gt; 1234&lt;!--User getUserByUsername(String username);--&gt;&lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = &#x27;$&#123;username&#125;&#x27; &lt;/select&gt; 多个字面量类型的参数 若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中 以arg0,arg1…为键，以参数为值； 以param1,param2…为键，以参数为值； 因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。 使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的 1234&lt;!--User checkLogin(String username,String password);--&gt;&lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; 1234&lt;!--User checkLogin(String username,String password);--&gt;&lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;&lt;/select&gt; map集合类型的参数 若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号1234&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;&lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt; 12345678910@Testpublic void checkLoginByMap() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;usermane&quot;,&quot;admin&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User user = mapper.checkLoginByMap(map); System.out.println(user);&#125; 实体类类型的参数 若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号1234&lt;!--int insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)&lt;/insert&gt; 1234567@Testpublic void insertUser() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); User user = new User(null,&quot;Tom&quot;,&quot;123456&quot;,12,&quot;男&quot;,&quot;123@321.com&quot;); mapper.insertUser(user);&#125; 使用@Param标识参数 可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 以@Param注解的value属性值为键，以参数为值； 以param1,param2…为键，以参数为值； 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 1234&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt; &lt;select id=&quot;CheckLoginByParam&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; 123456@Testpublic void checkLoginByParam() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); mapper.CheckLoginByParam(&quot;admin&quot;,&quot;123456&quot;);&#125; 总结 建议分成两种情况进行处理 实体类类型的参数 使用@Param标识参数 MyBatis的各种查询功能 如果查询出的数据只有一条，可以通过 实体类对象接收 List集合接收 Map集合接收，结果&#123;password=123456, sex=男, id=1, age=23, username=admin&#125; 如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过 实体类类型的LIst集合接收 Map类型的LIst集合接收 在mapper接口的方法上添加@MapKey注解 查询一个实体类对象123456/** * 根据用户id查询用户信息 * @param id * @return */User getUserById(@Param(&quot;id&quot;) int id); 1234&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from t_user where id = #&#123;id&#125;&lt;/select&gt; 查询一个List集合12345/** * 查询所有用户信息 * @return */List&lt;User&gt; getUserList(); 1234&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select * from t_user&lt;/select&gt; 查询单个数据123456789/** * 查询用户的总记录数 * @return * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--&gt;int|integer * 例如：int--&gt;_int|_integer * 例如：Map--&gt;map,List--&gt;list */ int getCount(); 1234&lt;!--int getCount();--&gt;&lt;select id=&quot;getCount&quot; resultType=&quot;_integer&quot;&gt; select count(id) from t_user&lt;/select&gt; 查询一条数据为map集合123456/** * 根据用户id查询用户信息为map集合 * @param id * @return */ Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id); 12345&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;&lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user where id = #&#123;id&#125;&lt;/select&gt;&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt; 查询多条数据为map集合方法一123456/** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap(); 12345678910&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt; &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user &lt;/select&gt;&lt;!-- 结果： [&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;, &#123;password=123456, sex=男, id=2, age=23, username=张三&#125;, &#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]--&gt; 方法二1234567/** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */@MapKey(&quot;id&quot;)Map&lt;String, Object&gt; getAllUserToMap(); 123456789101112&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user&lt;/select&gt;&lt;!-- 结果： &#123; 1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;, 2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;, 3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125; &#125;--&gt; 特殊SQL的执行模糊查询1234567/** * 根据用户名进行模糊查询 * @param username * @return java.util.List&lt;com.atguigu.mybatis.pojo.User&gt; * @date 2022/2/26 21:56 */List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); 123456&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;&lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; &lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt; &lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt; select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;&lt;/select&gt; 其中select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;是最常用的 批量删除 只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in (&#39;1,2,3&#39;)，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)1234567/** * 根据id批量删除 * @param ids * @return int * @date 2022/2/26 22:06 */int deleteMore(@Param(&quot;ids&quot;) String ids); 123&lt;delete id=&quot;deleteMore&quot;&gt; delete from t_user where id in ($&#123;ids&#125;)&lt;/delete&gt; 12345678//测试类@Testpublic void deleteMore() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); int result = mapper.deleteMore(&quot;1,2,3,8&quot;); System.out.println(result);&#125; 动态设置表名 只能使用${}，因为表名不能加单引号1234567/** * 查询指定表中的数据 * @param tableName * @return java.util.List&lt;com.atguigu.mybatis.pojo.User&gt; * @date 2022/2/27 14:41 */List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName); 1234&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;&lt;select id=&quot;getUserByTable&quot; resultType=&quot;User&quot;&gt; select * from $&#123;tableName&#125;&lt;/select&gt; 添加功能获取自增的主键 使用场景 t_clazz(clazz_id,clazz_name) t_student(student_id,student_name,clazz_id) 添加班级信息 获取新添加的班级的id 为班级分配学生，即将某学的班级id修改为新添加的班级的id 在mapper.xml中设置两个属性 useGeneratedKeys：设置使用自增的主键 keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中123456/** * 添加用户信息 * @param user * @date 2022/2/27 15:04 */void insertUser(User user); 1234&lt;!--void insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)&lt;/insert&gt; 12345678910//测试类@Testpublic void insertUser() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); User user = new User(null, &quot;ton&quot;, &quot;123&quot;, 23, &quot;男&quot;, &quot;123@321.com&quot;); mapper.insertUser(user); System.out.println(user); //输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中&#125; 自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来 1234567891011&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;&lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&gt; select * from t_emp&lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 1234&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;&lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt; select eid,emp_name empName,age,sex,email from t_emp&lt;/select&gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息 123456789public class Emp &#123; private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等&#125; 级联方式处理映射关系12345678910111213&lt;resultMap id=&quot;empAndDeptResultMapOne&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&gt;&lt;/result&gt; &lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;&lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapOne&quot;&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;&lt;/select&gt; 使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型123456789101112131415&lt;resultMap id=&quot;empAndDeptResultMapTwo&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;&lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapTwo&quot;&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;&lt;/select&gt; 分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件123456789//EmpMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid); 1234567891011121314&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;did&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;&lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&gt; select * from t_emp where eid = #&#123;eid&#125;&lt;/select&gt; 2. 查询部门信息123456789//DeptMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did); 123456789&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;&lt;resultMap id=&quot;EmpAndDeptByStepTwoResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultMap=&quot;EmpAndDeptByStepTwoResultMap&quot;&gt; select * from t_dept where did = #&#123;did&#125;&lt;/select&gt; 一对多映射处理123456public class Dept &#123; private Integer did; private String deptName; private List&lt;Emp&gt; emps; //...构造器、get、set方法等&#125; collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型123456789101112131415&lt;resultMap id=&quot;DeptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;DeptAndEmpResultMap&quot;&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;&lt;/select&gt; 分步查询1. 查询部门信息12345678/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did); 1234567891011&lt;resultMap id=&quot;DeptAndEmpByStepOneResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot; column=&quot;did&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;DeptAndEmpByStepOneResultMap&quot;&gt; select * from t_dept where did = #&#123;did&#125;&lt;/select&gt; 2. 根据部门id查询部门中的所有员工12345678/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did); 1234&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where did = #&#123;did&#125;&lt;/select&gt; 延迟加载 分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”1234&lt;settings&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 1234567@Testpublic void getEmpAndDeptByStepOne() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName());&#125; 关闭延迟加载，两条SQL语句都运行了 开启延迟加载，只运行获取emp的SQL语句 123456789@Testpublic void getEmpAndDeptByStepOne() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); System.out.println(&quot;----------------&quot;); System.out.println(emp.getDept());&#125; 开启后，需要用到查询dept的时候才会调用相应的SQL语句 fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)” 1234567891011&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;did&quot; fetchType=&quot;lazy&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt; 动态SQL Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题 if if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行 在where后面添加一个恒成立条件1=1 这个恒成立条件并不会影响查询的结果 这个1=1可以用来拼接and语句，例如：当empName为null时 如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错 如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错 12345678910111213141516&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where 1=1 &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; and emp_name = #&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age != null and age !=&#x27;&#x27;&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;sex != null and sex !=&#x27;&#x27;&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=&quot;email != null and email !=&#x27;&#x27;&quot;&gt; and email = #&#123;email&#125; &lt;/if&gt;&lt;/select&gt; where where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉 123456789101112131415161718&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; emp_name = #&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age != null and age !=&#x27;&#x27;&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;sex != null and sex !=&#x27;&#x27;&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=&quot;email != null and email !=&#x27;&#x27;&quot;&gt; and email = #&#123;email&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 注意：where标签不能去掉条件后多余的and&#x2F;or 1234567&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;&lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt;emp_name = #&#123;empName&#125; and&lt;/if&gt;&lt;if test=&quot;age != null and age !=&#x27;&#x27;&quot;&gt; age = #&#123;age&#125;&lt;/if&gt; trim trim用于去掉或添加标签中的内容 常用属性 prefix：在trim标签中的内容的前面添加某些内容 suffix：在trim标签中的内容的后面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容 若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp123456789101112131415161718&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; emp_name = #&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age != null and age !=&#x27;&#x27;&quot;&gt; age = #&#123;age&#125; and &lt;/if&gt; &lt;if test=&quot;sex != null and sex !=&#x27;&#x27;&quot;&gt; sex = #&#123;sex&#125; or &lt;/if&gt; &lt;if test=&quot;email != null and email !=&#x27;&#x27;&quot;&gt; email = #&#123;email&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 12345678//测试类@Testpublic void getEmpByCondition() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List&lt;Emp&gt; emps= mapper.getEmpByCondition(new Emp(null, &quot;张三&quot;, null, null, null, null)); System.out.println(emps);&#125; choose、when、otherwise choose、when、otherwise相当于if...else if..else when至少要有一个，otherwise至多只有一个12345678910111213141516171819202122&lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt; emp_name = #&#123;empName&#125; &lt;/when&gt; &lt;when test=&quot;age != null and age != &#x27;&#x27;&quot;&gt; age = #&#123;age&#125; &lt;/when&gt; &lt;when test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt; sex = #&#123;sex&#125; &lt;/when&gt; &lt;when test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; did = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 1234567@Testpublic void getEmpByChoose() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List&lt;Emp&gt; emps = mapper.getEmpByChoose(new Emp(null, &quot;张三&quot;, 23, &quot;男&quot;, &quot;123@qq.com&quot;, null)); System.out.println(emps);&#125; 相当于if a else if b else if c else d，只会执行其中一个 foreach 属性： collection：设置要循环的数组或集合 item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如, open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符 批量删除 1234567&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;&lt;delete id=&quot;deleteMoreByArray&quot;&gt; delete from t_emp where eid in &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;eid&#125; &lt;/foreach&gt;&lt;/delete&gt; 1234567@Testpublic void deleteMoreByArray() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); int result = mapper.deleteMoreByArray(new Integer[]&#123;6, 7, 8, 9&#125;); System.out.println(result);&#125; 批量添加 1234567&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreByList&quot;&gt; insert into t_emp values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null) &lt;/foreach&gt;&lt;/insert&gt; 1234567891011@Testpublic void insertMoreByList() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Emp emp1 = new Emp(null,&quot;a&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); Emp emp2 = new Emp(null,&quot;b&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); Emp emp3 = new Emp(null,&quot;c&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null); List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3); int result = mapper.insertMoreByList(emps); System.out.println(result);&#125; SQL片段 sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 声明sql片段：&lt;sql&gt;标签1&lt;sql id=&quot;empColumns&quot;&gt;eid,emp_name,age,sex,email&lt;/sql&gt; 引用sql片段：&lt;include&gt;标签1234&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp&lt;/select&gt; MyBatis的缓存MyBatis的一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 使一级缓存失效的四种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 MyBatis的二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 二级缓存开启的条件 在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置 在映射文件中设置标签 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 二级缓存的相关配置 在mapper配置文件中添加的cache标签可以设置一些属性 eviction属性：缓存回收策略 LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true&#x2F;false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false MyBatis缓存查询的顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存 整合第三方缓存EHCache（了解）添加依赖123456789101112&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 各个jar包的功能 jar包名称 作用 mybatis-ehcache Mybatis和EHCache的整合包 ehcache EHCache核心包 slf4j-api SLF4J日志门面包 logback-classic 支持SLF4J门面接口的一个具体实现 创建EHCache的配置文件ehcache.xml 名字必须叫ehcache.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\atguigu\\ehcache&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 设置二级缓存的类型 在xxxMapper.xml文件中设置二级缓存类型1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 加入logback日志 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别 --&gt; &lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt; EHCache配置文件说明 属性名 是否必须 作用 maxElementsInMemory 是 在内存中缓存的element的最大数目 maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大 eternal 是 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds 否 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作 memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出 MyBatis的逆向工程 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类 Mapper接口 Mapper映射文件 创建逆向工程的步骤添加依赖和插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;dependencies&gt; &lt;!-- MyBatis核心依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 创建MyBatis的核心配置文件123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;typeAliases&gt; &lt;package name=&quot;&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建逆向工程的配置文件 文件名必须是：generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- javaBean的生成策略--&gt; &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt; &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 执行MBG插件的generate目标 如果出现报错：Exception getting JDBC Driver，可能是pom.xml中，数据库驱动配置错误 dependency中的驱动 mybatis-generator-maven-plugin插件中的驱动 两者的驱动版本应该相同 执行结果 QBC查询 selectByExample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据 example.createCriteria().xxx：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系 example.or().xxx：将之前添加的条件通过or拼接其他条件1234567891011121314@Test public void testMBG() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample example = new EmpExample(); //名字为张三，且年龄大于等于20 example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThanOrEqualTo(20); //或者did不为空 example.or().andDidIsNotNull(); List&lt;Emp&gt; emps = mapper.selectByExample(example); emps.forEach(System.out::println);&#125; 增改 updateByPrimaryKey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3)); updateByPrimaryKeySelective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段 mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3)); 分页插件分页插件使用步骤添加依赖123456&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 配置分页插件 在MyBatis的核心配置文件（mybatis-config.xml）中配置插件 1234&lt;plugins&gt; &lt;!--设置分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 分页插件的使用开启分页功能 在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码 pageSize：每页显示的条数123456789101112@Testpublic void testPageHelper() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 PageHelper.startPage(1,4); List&lt;Emp&gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println);&#125; 分页相关数据方法一：直接输出12345678910111213@Testpublic void testPageHelper() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 Page&lt;Object&gt; page = PageHelper.startPage(1, 4); List&lt;Emp&gt; emps = mapper.selectByExample(null); //在查询到List集合后，打印分页数据 System.out.println(page);&#125; 分页相关数据： 1Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;] 方法二使用PageInfo 在查询获取list集合之后，使用PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)获取分页相关数据 list：分页之后的数据 navigatePages：导航分页的页码数123456789101112@Testpublic void testPageHelper() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); PageHelper.startPage(1, 4); List&lt;Emp&gt; emps = mapper.selectByExample(null); PageInfo&lt;Emp&gt; page = new PageInfo&lt;&gt;(emps,5); System.out.println(page);&#125; 分页相关数据： 1234PageInfo&#123;pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125; 其中list中的数据等同于方法一中直接输出的page数据 常用数据： pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页 hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5]","tags":"mybatis"},{"title":"SpringMVC","url":"/2022/10/22/SpringMVC笔记/","text":"[TOC] 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2019.2 构建工具：maven3.5.4 服务器：tomcat7 Spring版本：5.3.1 2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 1234567891011121314&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 123456789101112131415161718192021222324252627&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用&#x2F;和&#x2F;*的区别： &#x2F;所匹配的请求可以是&#x2F;login或.html或.js或.css方式的请求路径，但是&#x2F;不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 &#x2F;*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用&#x2F;*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 1234@Controllerpublic class HelloController &#123; &#125; 5、创建springMVC的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 6、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 12345678// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() &#123; //设置视图名称 return &quot;index&quot;;&#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 在请求控制器中创建处理请求的方法 1234@RequestMapping(&quot;/hello&quot;)public String HelloWorld() &#123; return &quot;target&quot;;&#125; 7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 1234567891011@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 12&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; 123456@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported 1234&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数且param&#x3D;value “param!&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数但是param!&#x3D;value 1&lt;a th:href=&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!&#x3D;123456” not met for actual request parameters: username&#x3D;{admin}, password&#x3D;{123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header&#x3D;value “header!&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header!&#x3D;value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用&#x2F;**&#x2F;xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始方式：&#x2F;deleteUser?id&#x3D;1 rest方式：&#x2F;deleteUser&#x2F;1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; 123456@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;&#125;//最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 1234567891011121314151617&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据1、使用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 2、使用ModelAndView向request域对象共享数据1234567891011121314@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 3、使用Model向request域对象共享数据12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 4、使用map向request域对象共享数据12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; 5、使用ModelMap向request域对象共享数据12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; 6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 1234public interface Model&#123;&#125;public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; 7、向session域共享数据12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; 8、向application域共享数据123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:&#x2F;“，”forward:&#x2F;employee” 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:&#x2F;“，”redirect:&#x2F;employee” 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以&#x2F;开头，若是则会自动拼接上下文路径 4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 12345&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven &#x2F;&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id&#x3D;1 user&#x2F;1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id&#x3D;1 user&#x2F;1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： String paramValue = request.getParameter(this.methodParam); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 八、RESTful案例### 1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。- 搭建环境- 准备实体类 ```java package com.atguigu.mvc.bean; public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125; &#125; 准备dao模拟数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ &#x2F; GET 查询全部数据√ &#x2F;employee GET 删除√ &#x2F;employee&#x2F;2 DELETE 跳转到添加数据页面√ &#x2F;toAdd GET 执行保存√ &#x2F;employee POST 跳转到更新数据页面√ &#x2F;employee&#x2F;2 GET 执行更新√ &#x2F;employee PUT 3、具体功能：访问首页a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法123456@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;&#125; b&gt;创建employee_list.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单12345&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 1&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法12345@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 6、具体功能：跳转到添加数据页面a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;&#125; c&gt;创建employee_update.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;&#125; 输出结果： requestBody:username&#x3D;admin&amp;password&#x3D;123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;&#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age&#x3D;0”, sec-ch-ua:”” Not A;Brand”;v&#x3D;”99”, “Chromium”;v&#x3D;”90”, “Google Chrome”;v&#x3D;”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080“, user-agent:”Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36”]requestBody:username&#x3D;admin&amp;password&#x3D;123 3、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 结果：浏览器页面显示success 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 1&lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用@ResponseBody注解进行标识 d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 5、SpringMVC处理ajaxa&gt;请求超链接： 123&lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;&lt;/div&gt; b&gt;通过vue和axios处理点击事件： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法： 123456@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;&#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype&#x3D;”multipart&#x2F;form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; c&gt;控制器方法： 12345678910111213141516171819@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;&#125; 十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 1234567891011&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 b&gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： 123456789101112131415&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、基于注解的异常处理12345678910111213//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。 123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125;&#125; 2、创建SpringConfig配置类，代替spring的配置文件1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 4、测试功能1234@RequestMapping(&quot;/&quot;)public String index()&#123; return &quot;index&quot;;&#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 3、DispatcherServlet调用组件处理请求a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; d&gt;processDispatchResult()12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","tags":"springmvc"},{"title":"MyBatis-Plus","url":"/2022/10/22/MyBatis-Plus/","text":"# 一、MyBatis-Plus 1.简介MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。 2.特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 3.支持数据库 任何能使用 MyBatis 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。 MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库 4.框架结构 5.官方地址 官方网站：https://baomidou.com/ 官方文档：https://baomidou.com/pages/24112f/ 二、入门案例1.开发环境 IDE：IDEA 2019.3.5 JDK：JDK8+ 构建工具：Maven 3.5.4 MySQL：MySQL 8.0.24 Navicat：Navicat Premium 15 Spring Boot：2.6.7 MyBatis-Plus：3.5.1 2.建库建表 打开Navicat运行以下SQL脚本进行建库建表 123456789CREATE DATABASE `mybatis_plus` /*!40100 DEFAULT CHARACTER SET utf8mb4 */; use `mybatis_plus`; CREATE TABLE `user` ( `id` bigint(20) NOT NULL COMMENT &#x27;主键ID&#x27;, `name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入几条测试数据 123456INSERT INTO user (id, name, age, email) VALUES (1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;), (2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;), (3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;), (4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;), (5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); 3.创建工程 使用Spring Initializer快速初始化一个 Spring Boot 工程 引入MyBatis-Plus的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 安装Lombok插件 4.配置编码 配置application.yml文件 1234567891011121314151617181920#配置端口server: port: 80spring: #配置数据源 datasource: #配置数据源类型 type: com.zaxxer.hikari.HikariDataSource #配置连接数据库的信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: &#123;username&#125; password: &#123;password&#125;#MyBatis-Plus相关配置mybatis-plus: configuration: #配置日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹 1234567@SpringBootApplication@MapperScan(&quot;指定Mapper接口所在的包&quot;)public class MybatisPlusDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisPlusDemoApplication.class, args); &#125;&#125; 编写实体类 User.java（此处使用了 Lombok 简化代码） 1234567@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 编写 Mapper 包下的 UserMapper接口 1public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 5.测试查询 编写一个测试类MyBatisPlusTest.java 123456789101112131415@SpringBootTestpublic class MyBatisPlusTest &#123; @Resource private UserMapper userMapper; /** * 测试查询所有数据 */ @Test void testSelectList()&#123; //通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125;&#125; 控制台打印查询结果 三、增删改查1.BaseMapper&lt;T&gt; 说明: 通用 CRUD 封装BaseMapper 接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器 泛型 T 为任意实体对象 参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键 对象 Wrapper 为条件构造器 MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。 本次演示的CRUD操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。 BaseMapper中提供的CRUD方法： 增加：Insert 12// 插入一条记录int insert(T entity); 删除：Delete 12345678// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 修改：Update 1234// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity); 查询：Selete 12345678910111213141516171819202122// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 2.调用Mapper层实现CRUD2.1 插入 最终执行的结果，所获取的id为1527206783590903810 这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id 12345678910111213141516/** * 测试插入一条数据 * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id */@Testpublic void testInsert()&#123; User user = new User(); user.setName(&quot;Vz&quot;); user.setAge(21); user.setEmail(&quot;vz@oz6.cn&quot;); int result = userMapper.insert(user); System.out.println(result &gt; 0 ? &quot;添加成功！&quot; : &quot;添加失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result); //1527206783590903810（当前 id 为雪花算法自动生成的id） System.out.println(&quot;id自动获取&quot; + user.getId());&#125; 2.2 删除 a、根据ID删除数据 调用方法：int deleteById(Serializable id); 123456789/** * 测试根据id删除一条数据 */@Testpublic void testDeleteById()&#123; int result = userMapper.deleteById(1527206783590903810L); System.out.println(result &gt; 0 ? &quot;删除成功！&quot; : &quot;删除失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; b、根据ID批量删除数据 调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); 12345678910/** * 测试通过id批量删除数据 */@Testpublic void testDeleteBatchIds()&#123; List&lt;Long&gt; ids = Arrays.asList(6L,7L,8L); int result = userMapper.deleteBatchIds(ids); System.out.println(result &gt; 0 ? &quot;删除成功！&quot; : &quot;删除失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; c、根据Map条件删除数据 调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 1234567891011121314/** * 测试根据Map集合中所设置的条件删除数据 */@Testpublic void testDeleteByMap()&#123; //当前演示为根据name和age删除数据 //执行SQL为：DELETE FROM user WHERE name = ? AND age = ? Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;Vz&quot;); map.put(&quot;age&quot;,21); int result = userMapper.deleteByMap(map); System.out.println(result &gt; 0 ? &quot;删除成功！&quot; : &quot;删除失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 2.3 修改 调用方法：int updateById(@Param(Constants.ENTITY) T entity); 123456789101112131415/** * 测试根据id修改用户信息 */@Testpublic void testUpdateById()&#123; //执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=? User user = new User(); user.setId(6L); user.setName(&quot;VzUpdate&quot;); user.setAge(18); user.setEmail(&quot;Vz@sina.com&quot;); int result = userMapper.updateById(user); System.out.println(result &gt; 0 ? &quot;修改成功！&quot; : &quot;修改失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 2.4 查询 a、根据ID查询用户信息 调用方法：T selectById(Serializable id); 12345678/** * 测试根据id查询用户数据 */@Testpublic void testSelectById()&#123; User user = userMapper.selectById(1L); System.out.println(user);&#125; b、根据多个ID查询多个用户信息 调用方法：List selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); 12345678910/** * 根据多个id查询用户数据 */@Testpublic void testSelectBatchIds()&#123; //执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; ids = Arrays.asList(1L,2L,3L); List&lt;User&gt; users = userMapper.selectBatchIds(ids); users.forEach(System.out::println);&#125; c、根据Map条件查询用户信息 调用方法：List selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 1234567891011/** * 根据Map所设置的条件查询用户 */@Testpublic void testSelectByMap()&#123; //执行SQL为：SELECT id,name,age,email FROM user WHERE age = ? Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;age&quot;,18); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println);&#125; d、查询所有用户信息 调用方法：List selectList(@Param(Constants.WRAPPER) Wrapper queryWrapper); 12345678/** * 测试查询所有数据 */@Testvoid testSelectList()&#123; List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println);&#125; 3.通用Service 说明: 通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆， 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 对象 Wrapper 为 条件构造器 MyBatis-Plus中有一个接口 **IService**和其实现类 **ServiceImpl**，封装了常见的业务层逻辑，详情查看源码IService和ServiceImpl 因此我们在使用的时候仅需在自己定义的**Service接口中继承IService接口，在自己的实现类中实现自己的Service并继承ServiceImpl**即可 IService中的CRUD方法 增加：Save、SaveOrUpdate 123456789101112131415// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize); 删除：Remove 12345678// 根据 entity 条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList); 修改：Update 12345678910// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize); 查询：Get、List、Count 12345678910111213141516171819202122232425262728293031323334353637// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);// 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper); 分页：Page 12345678910// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper); 4.调用Service层操作数据 我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。 创建UserService并继承IService 1234/** * UserService继承IService模板提供的基础功能 */public interface UserService extends IService&lt;User&gt; &#123;&#125; 创建UserService的实现类并继承ServiceImpl 123456/** * ServiceImpl实现了IService，提供了IService中基础功能的实现 * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现 */@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService&#123;&#125; 测试查询记录数 调用方法：int count(); 1234567@Testpublic void testGetCount()&#123; //查询总记录数 //执行的SQL为：SELECT COUNT( * ) FROM user long count = userService.count(); System.out.println(&quot;总记录数：&quot; + count);&#125; 测试批量插入数据 调用方法：boolean saveBatch(Collection entityList); 123456789101112@Testpublic void test()&#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; User user = new User(); user.setName(&quot;Vz&quot;+i); user.setAge(20+i); list.add(user); &#125; boolean b = userService.saveBatch(list); System.out.println(b ? &quot;添加成功！&quot; : &quot;添加失败！&quot;);&#125; 四、常用注解 MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。 1.@TableName 经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。 1.1 引出问题 若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？ 我们将表user更名为t_user，测试查询功能 程序抛出异常，Table ‘mybatis_plus.user’ doesn’t exist，因为现在的表名为t_user，而默认操作的表名和实体类型的类名一致，即user表 1.2 解决问题 a、使用注解解决问题 在实体类类型上添加@TableName(&quot;t_user&quot;)，标识实体类对应的表，即可成功执行SQL语句 12345678@Data@TableName(&quot;t_user&quot;)public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; b、使用全局配置解决问题 在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 t_ 或 tbl_ 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表 12345mybatis-plus: global-config: db-config: # 设置实体类所对应的表的统一前缀 table-prefix: t_ 2.@TableId 经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id 2.1 引出问题 若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？ 我们实体类中的属性id改为uid，将表中的字段id也改为uid，测试添加功能 程序抛出异常，Field ‘uid’ doesn’t have a default value，说明MyBatis-Plus没有将uid作为主键赋值 2.2 解决问题 在实体类中uid属性上通过@TableId将其标识为主键，即可成功执行SQL语句 12345678@Datepublic class User &#123; @TableId private Long uid; private String name; private Integer age; private String email;&#125; 2.3 @TableId的value属性 若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常**Unknown column ‘id’ in ‘field list’**，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，@TableId(&quot;uid&quot;)或@TableId(value=&quot;uid&quot;) 2.4 @TableId的type属性 type属性用来定义主键策略：默认雪花算法 常用的主键策略： 值 描述 IdType.ASSIGN_ID（默认） 基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增， 配置全局主键策略： 1234567891011#MyBatis-Plus相关配置mybatis-plus: configuration: #配置日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: #配置mp的主键策略为自增 id-type: auto # 设置实体类所对应的表的统一前缀 table-prefix: t_ 3.@TbaleField 经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致 如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？ 3.1 情况一 若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格 例如实体类属性userName，表中字段user_name 此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格 相当于在MyBatis中配置 3.2 情况二 若实体类中的属性和表中的字段不满足情况1 例如实体类属性name，表中字段username 此时需要在实体类属性上使用@TableField(&quot;username&quot;)设置属性所对应的字段名 12345678public class User &#123; @TableId(&quot;uid&quot;) private Long id; @TableField(&quot;username&quot;) private String name; private Integer age; private String email;&#125; 4.@TableLogic4.1 逻辑删除 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 使用场景：可以进行数据恢复 4.2 实现逻辑删除 数据库中创建逻辑删除状态列，设置默认值为0 实体类中添加逻辑删除属性 测试删除功能，真正执行的是修改 12345public void testDeleteById()&#123; int result = userMapper.deleteById(1527472864163348482L); System.out.println(result &gt; 0 ? &quot;删除成功！&quot; : &quot;删除失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 此时执行查询方法，查询的结果为自动添加条件is_deleted=0 五、条件构造器1.Wrapper介绍 Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 2.QueryWrapper 组装查询条件 执行SQL：SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) 1234567public void test01()&#123; //查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;username&quot;,&quot;a&quot;).between(&quot;age&quot;,20,30).isNotNull(&quot;email&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装排序条件 执行SQL：SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 ORDER BY age DESC,id ASC 1234567public void test02()&#123; //查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装删除条件 执行SQL：UPDATE t_user SET is_deleted&#x3D;1 WHERE is_deleted&#x3D;0 AND (email IS NULL) 12345678public void test03()&#123; //删除邮箱地址为null的用户信息 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); int result = userMapper.delete(queryWrapper); System.out.println(result &gt; 0 ? &quot;删除成功！&quot; : &quot;删除失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 条件的优先级 执行SQL：UPDATE t_user SET user_name&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL) 123456789101112public void test04()&#123; //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改 UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.gt(&quot;age&quot;,20).like(&quot;username&quot;,&quot;a&quot;).or().isNull(&quot;email&quot;); User user = new User(); user.setName(&quot;Oz&quot;); user.setEmail(&quot;test@oz6.com&quot;); int result = userMapper.update(user, updateWrapper); System.out.println(result &gt; 0 ? &quot;修改成功！&quot; : &quot;修改失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 执行SQL：UPDATE t_user SET username&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL)) 123456789101112public void test05()&#123; //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改 UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.like(&quot;username&quot;,&quot;a&quot;).and(i-&gt;i.gt(&quot;age&quot;,20).or().isNull(&quot;email&quot;)); User user = new User(); user.setName(&quot;Vz7797&quot;); user.setEmail(&quot;test@ss8o.com&quot;); int result = userMapper.update(user, updateWrapper); System.out.println(result &gt; 0 ? &quot;修改成功！&quot; : &quot;修改失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 组装select子句 执行SQL：SELECT username,age,email FROM t_user WHERE is_deleted&#x3D;0 1234567public void test06()&#123; //查询用户的用户名、年龄、邮箱信息 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;username&quot;,&quot;age&quot;,&quot;email&quot;); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125; 实现子查询 执行SQL：SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (uid IN (select uid from t_user where uid &lt;&#x3D; 100)) 1234567public void test07()&#123; //查询id小于等于100的用户信息 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.inSql(&quot;uid&quot;, &quot;select uid from t_user where uid &lt;= 100&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 3.UpdateWrapper UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息 12345678public void test08()&#123; //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改 UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); updateWrapper.like(&quot;username&quot;,&quot;a&quot;).and( i -&gt; i.gt(&quot;age&quot;,20).or().isNull(&quot;email&quot;)).set(&quot;email&quot;,&quot;svip@qq.com&quot;); int result = userMapper.update(null, updateWrapper); System.out.println(result &gt; 0 ? &quot;修改成功！&quot; : &quot;修改失败！&quot;); System.out.println(&quot;受影响的行数为：&quot; + result);&#125; 4.condition 在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果 思路一 执行SQL：SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (user_name LIKE ? AND age &lt;&#x3D; ?) 123456789101112131415161718public void test09()&#123; String username = &quot;a&quot;; Integer ageBegin = null; Integer ageEnd = 30; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); if(StringUtils.isNotBlank(username))&#123; //isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符 queryWrapper.like(&quot;user_name&quot;, username); &#125; if(ageBegin != null)&#123; queryWrapper.ge(&quot;age&quot;, ageBegin); &#125; if(ageEnd != null)&#123; queryWrapper.le(&quot;age&quot;, ageEnd); &#125; List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 思路二 上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写 1234567891011public void test10()&#123; String username = &quot;a&quot;; Integer ageBegin = null; Integer ageEnd = 30; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(StringUtils.isNotBlank(username), &quot;user_name&quot;, username) .ge(ageBegin != null, &quot;age&quot;, ageBegin) .le(ageEnd != null, &quot;age&quot;, ageEnd); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 5.LambdaQueryWrapper 功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。 1234567891011public void test11()&#123; String username = &quot;a&quot;; Integer ageBegin = null; Integer ageEnd = 30; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username) .ge(ageBegin != null, User::getAge, ageBegin) .le(ageEnd != null, User::getAge, ageEnd); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 6.LambdaUpdateWrapper 功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。 123456789public void test12()&#123; //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改 LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;(); updateWrapper.like(User::getName, &quot;a&quot;) .and(i -&gt; i.gt(User::getAge, 20).or().isNull(User::getEmail)); updateWrapper.set(User::getName, &quot;小黑&quot;).set(User::getEmail,&quot;abc@atguigu.com&quot;); int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result：&quot;+result);&#125; 六、常用插件1.分页插件 MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能 添加配置类MyBatisPlusConfig 1234567891011@Configuration@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)public class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 编写测试方法 1234567@Testpublic void testPage()&#123; //new Page()中的两个参数分别是当前页码，每页显示数量 Page&lt;User&gt; page = userMapper.selectPage(new Page&lt;&gt;(1, 2), null); List&lt;User&gt; users = page.getRecords(); users.forEach(System.out::println);&#125; 2.自定义分页 上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？ 在UserMapper接口中定义一个方法 1234567/** * 根据年龄查询用户列表，分页显示 * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 * @param age 年龄 * @return */Page&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page,@Param(&quot;age&quot;) Integer age); 在UserMapper.xml中编写SQL实现该方法 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;User&quot;&gt; select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;&lt;/select&gt; 编写测试方法 123456@Testpublic void testPageVo()&#123; Page&lt;User&gt; page = userMapper.selectPageVo(new Page&lt;User&gt;(1,2), 20); List&lt;User&gt; users = page.getRecords(); users.forEach(System.out::println);&#125; 3.乐观锁 作用：当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁的实现方式： 取出记录时，获取当前 version 更新时，带上这个 version 执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion 如果 version 不对，就更新失败 3.1 场景 一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。 此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。 现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。 3.2 乐观锁与悲观锁 上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。 如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。 3.3 模拟修改冲突 数据库中增加商品表 1234567CREATE TABLE t_product ( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;商品名称&#x27;, price INT(11) DEFAULT 0 COMMENT &#x27;价格&#x27;, VERSION INT(11) DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;, PRIMARY KEY (id) ); 添加一条数据 1INSERT INTO t_product (id, NAME, price) VALUES (1, &#x27;外星人笔记本&#x27;, 100); 添加一个实体类Product 1234567@Datapublic class Product &#123; private Long id; private String name; private Integer price; private Integer version;&#125; 添加一个Mapper接口ProductMapper 1public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123;&#125; 测试方法 12345678910111213141516171819202122@Testpublic void testProduct01()&#123; //1.小李获取商品价格 Product productLi = productMapper.selectById(1); System.out.println(&quot;小李获取的商品价格为：&quot; + productLi.getPrice()); //2.小王获取商品价格 Product productWang = productMapper.selectById(1); System.out.println(&quot;小李获取的商品价格为：&quot; + productWang.getPrice()); //3.小李修改商品价格+50 productLi.setPrice(productLi.getPrice()+50); productMapper.updateById(productLi); //4.小王修改商品价格-30 productWang.setPrice(productWang.getPrice()-30); productMapper.updateById(productWang); //5.老板查询商品价格 Product productBoss = productMapper.selectById(1); System.out.println(&quot;老板获取的商品价格为：&quot; + productBoss.getPrice());&#125; 执行结果 3.4 乐观锁解决问题 实体类version字段添加注解@Version 12345678@Datapublic class Product &#123; private Long id; private String name; private Integer price; @Version private Integer version;&#125; 添加乐观锁插件配置 123456789@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //添加乐观锁插件 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor;&#125; 再次执行测试方法 小李查询商品信息： ​ SELECT id,name,price,version FROM t_product WHERE id&#x3D;? 小王查询商品信息： ​ SELECT id,name,price,version FROM t_product WHERE id&#x3D;? 小李修改商品价格，自动将version+1 ​ UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;? ​ Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer) 小王修改商品价格，此时version已更新，条件不成立，修改失败 ​ UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;? ​ Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer) 最终，小王修改失败，查询价格：150 ​ SELECT id,name,price,version FROM t_product WHERE id&#x3D;? 优化执行流程 12345678910111213141516171819202122232425262728@Testpublic void testProduct01()&#123; //1.小李获取商品价格 Product productLi = productMapper.selectById(1); System.out.println(&quot;小李获取的商品价格为：&quot; + productLi.getPrice()); //2.小王获取商品价格 Product productWang = productMapper.selectById(1); System.out.println(&quot;小李获取的商品价格为：&quot; + productWang.getPrice()); //3.小李修改商品价格+50 productLi.setPrice(productLi.getPrice()+50); productMapper.updateById(productLi); //4.小王修改商品价格-30 productWang.setPrice(productWang.getPrice()-30); int result = productMapper.updateById(productWang); if(result == 0)&#123; //操作失败，重试 Product productNew = productMapper.selectById(1); productNew.setPrice(productNew.getPrice()-30); productMapper.updateById(productNew); &#125; //5.老板查询商品价格 Product productBoss = productMapper.selectById(1); System.out.println(&quot;老板获取的商品价格为：&quot; + productBoss.getPrice());&#125; 七、通用枚举 表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现 数据库表添加字段sex 创建通用枚举类型 1234567891011121314@Getterpublic enum SexEnum &#123; MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;); @EnumValue //将注解所标识的属性的值存储到数据库中 private int sex; private String sexName; SexEnum(Integer sex, String sexName) &#123; this.sex = sex; this.sexName = sexName; &#125;&#125; User实体类中添加属性sex 123456789101112public class User &#123; private Long id; @TableField(&quot;username&quot;) private String name; private Integer age; private String email; @TableLogic private int isDeleted; //逻辑删除 private SexEnum sex;&#125; 配置扫描通用枚举 123456789101112131415161718#MyBatis-Plus相关配置mybatis-plus: #指定mapper文件所在的地址 mapper-locations: classpath:mapper/*.xml configuration: #配置日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: banner: off db-config: #配置mp的主键策略为自增 id-type: auto # 设置实体类所对应的表的统一前缀 table-prefix: t_ #配置类型别名所对应的包 type-aliases-package: com.atguigu.mybatisplus.pojo # 扫描通用枚举的包 type-enums-package: com.atguigu.mybatisplus.enums 执行测试方法 123456789@Testpublic void test()&#123; User user = new User(); user.setName(&quot;admin&quot;); user.setAge(33); user.setSex(SexEnum.MALE); int result = userMapper.insert(user); System.out.println(&quot;result:&quot;+result);&#125; 代码生成器1、引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; 2、快速生成12345678910111213141516171819202122public class FastAutoGeneratorTest &#123; public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus?characterEncoding=utf- 8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;123456&quot;).globalConfig(builder -&gt; &#123; builder.author(&quot;atguigu&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录&#125;).packageConfig(builder -&gt; &#123;builder.parent(&quot;com.atguigu&quot;) // 设置父包名.moduleName(&quot;mybatisplus&quot;) // 设置父包模块名.pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;));// 设置mapperXml生成路径&#125;).strategyConfig(builder -&gt; &#123;builder.addInclude(&quot;t_user&quot;) // 设置需要生成的表名.addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀&#125;).templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板.execute();&#125;&#125; 八、多数据源 适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等 场景说明： 我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功 1.创建数据库及表 创建数据库mybatis_plus_1和表&#96;product 123456789CREATE DATABASE `mybatis_plus_1` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;use `mybatis_plus_1`; CREATE TABLE product ( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;商品名称&#x27;, price INT(11) DEFAULT 0 COMMENT &#x27;价格&#x27;, version INT(11) DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;, PRIMARY KEY (id) ); 添加测试数据 1INSERT INTO product (id, NAME, price) VALUES (1, &#x27;外星人笔记本&#x27;, 100); 删除mybatis_plus库中的product表 12use mybatis_plus; DROP TABLE IF EXISTS product; 2.新建工程引入依赖 自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖 引入MyBaits-Plus的依赖及多数据源的依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 3.编写配置文件12345678910111213141516171819spring: # 配置数据源信息 datasource: dynamic: # 设置默认的数据源或者数据源组,默认值即为master primary: master # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: master: url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 132537 slave_1: url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 132537 4.创建实体类 新建一个User实体类（如果数据库表名有t_前缀记得配置） 1234567@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 新建一个实体类Product 1234567@Datapublic class Product &#123; private Long id; private String name; private Integer price; private Integer version;&#125; 5.创建Mapper及Service 新建接口UserMapper 1public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 新建接口ProductMapper 1public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123;&#125; 新建Service接口UserService指定操作的数据源 12@DS(&quot;master&quot;) //指定操作的数据源，master为user表public interface UserService extends IService&lt;User&gt; &#123;&#125; 新建Service接口ProductService指定操作的数据源 12@DS(&quot;slave_1&quot;)public interface ProductService extends IService&lt;Product&gt; &#123;&#125; 自行建立Service的实现类 1... 6.编写测试方法 记得在启动类中添加注解@MapperScan() 12345678910111213141516class TestDatasourceApplicationTests &#123; @Resource UserService userService; @Resource ProductService productService; @Test void contextLoads() &#123; User user = userService.getById(1L); Product product = productService.getById(1L); System.out.println(&quot;User = &quot; + user); System.out.println(&quot;Product = &quot; + product); &#125;&#125; 九、MyBatisX插件 MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。 MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 1.安装MyBatisX插件 打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。 2.快速生成代码 新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动） 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 配置数据源信息 1234567spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: root password: 132537 在IDEA中与数据库建立链接 填写数据库信息并保存 找到我们需要生成的表点击右键 填写完信息以后下一步 继续填写信息 大功告成（真特么好用yyds） 3.快速生成CRUD MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句 十、致谢感谢尚硅谷杨博超老师：https://www.bilibili.com/video/BV12R4y157Be?p=1 感谢MyBatis-Plus作者苞米豆：https://baomidou.com/ 感谢自己又坚持学习了一门课程：https://www.oz6.cn/","tags":"mybatis"},{"title":"Linux","url":"/2022/10/22/Linux/","text":"# Linux [TOC] 一、基础一、入门1、介绍1、Linux主要发行版Ubuntu乌班图、RedHat红帽、CentOS、Debain蝶变、Fedora、SuSE、OpenSUSE示意图 2、安装vm和Centos1、先安装vm 官方网址：https://www.vmware.com/cn.html 其他地址：https://www.novmd.com/windows/740.html 2、再安装Linux（CentOS7.6&#x2F;CentOS8.1） 7.6网址（现在主流）：https://vault.centos.org/7.6.1810/isos/x86_64/ http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso 8.1网址（未来主流）：http://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso 全部版本：https://mirrors.163.com/centos/ 3、vm和Linux的关系 4、开始安装centos 3、网络连接的三种模式 4、虚拟机克隆 5、虚拟机快照 6、虚拟机的迁移和删除 7、安装vmtools 注意要使用root账号进行登录 cd&#x2F;opt进入到opt目录 tar -zxvf xxx.tar.gz 解压 cd vmware…进入到解压后的目录 8、设置共享文件夹 9、Linux目录结构 2、实操1、远程登录到Linux服务器 2、安装Xshell6(远程操作）和XFTP6（文件的上传和下载）下载free-for-home-school版本 下载地址：https://www.netsarang.com/en/free-for-home-school/ 目前官网7版本免费提供学生使用 左边为window（主机）的文件系统，右边为Linux系统 怎么解决xftp7中文乱码问题？在文件-&gt;会话属性-&gt;选项-&gt;编码 选择utf-8即可 小tips：Xshell7中输入命令reboot，能够远程重启Linux系统 3、Vi和Vim编辑器Linux系统会内置vi文本编辑器 Vim具有程序编辑的能力，可以看作是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，代码补完，编译以及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 使用vim编写一个Hello.java程序，保存，步骤说明和演示。 退出编辑模式：按esc按键 进入命令行模式：输入冒号:即可 在命令行模式下输入wq：保存并退出（write and quit） tab键有快速补全功能 q！强制退出并且不保存 w是保存 q是退出，如果未保存就退出，会有提醒 4、vi和vim的快捷键 粘贴输入P即可 5、开机、重启、和用户登录注销 只输入shotdown默认一分钟后关机 如果在普通用户下切换到root时，输入logout会回退到普通用户 6、用户管理 pwd显示当前在哪个目录 passwd 用户名：为用户设置密码 userdel 用户名 只删除用户，不删除用户家目录 userdel -r 用户名 删除用户以及其家目录 只会显示第一次登录的用户 用户组方便管理，可以统一附加权限 clear清屏 bashell tcshell cshell 组内用户列表被隐藏起来了 7、实用指令运行级别 找回root密码 1、首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。如图 2、 进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。如图 3、 接着，输入完成后，直接按快捷键：Ctrl+x 进入单用户模式。 4、 接着，在光标闪烁的位置中输入：mount -o remount,rw &#x2F;（注意：各个单词间有空格），完成后按键盘的回车键（Enter）。如图 5、 在新的一行最后面输入：passwd， 完成后按键盘的回车键（Enter）。输入密码，然后再次确认密码即可(韩顺平提示: *密码长度最好8***位以上,**但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功 6、 接着，在鼠标闪烁的位置中（最后一行中）输入：touch &#x2F;.autorelabel（注意：touch与 &#x2F;之间有一个空格），完成后按键盘的回车键（Enter） 7、 继续在光标闪烁的位置中，输入：exec &#x2F;sbin&#x2F;init（注意：exec与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）,等待系统自动修改密码(韩顺平提示：这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启, 新的密码生效了 帮助指令 在linux下隐藏文件是以 . 开头的 查看所有文件，方式： ls -a 单列查看文件（详细）：ls -l 或ll 也可以组合起来用：如 ls -la 或 ls -al 后面还可以加文件路径进行定位查看 如： ls -la &#x2F;home 文件目录类 &#x2F; 是根目录，根目录下有root和home目录，root目录是root用户的家目录，home下还有其他用户的家目录 创建多级目录：mkdir -p 多级目录路径 cp hello.txt &#x2F;home&#x2F;bbb 把cp换成\\cp –&gt; 强制不覆盖 也可以移动并重命名 管道命令：把前面的结果交给下一个指令 cat -n &#x2F;etc&#x2F;profile | more 【空格下一页，回车键下一行】 输出环境变量：$PATH $HOSTNAME ctrl+c退出监控 如果指令后面的文件不存在，会自动创建 cal显示当前日历 ln -s&#x2F;root &#x2F;home&#x2F;myroot 删除跟删除文件操作一样 history history 10 ！5 时间日期类 搜素查找类 find &#x2F;home -name hello.txt 文件大小单位：kMG find &#x2F;opt -user nobody find &#x2F; size +200 ls -lh:h能够显示文件大小 which指令，可以查看某个指令在哪个目录下，比如ls指令在哪目录 which ls cat &#x2F;home&#x2F;hello.txt | grep -n yes grep -n yes &#x2F;home&#x2F;hello.txt 压缩和解压类 zip -r myhome.zip &#x2F;home&#x2F; tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt tar -zcvf myhome.tar.gz &#x2F;home&#x2F; tar -zxvf pc.tar.gz tar -zxvf myhome.tar.gz -C &#x2F;opt&#x2F;tmp2&#x2F; -C指定位置 Linux组管理和权限管理 特别说明：第二个命令，用户需要有进入到新目录的权限 赋值，添加，删除 文件为绿色代表为可执行文件，即有可执行的权限 修改所在组 递归带上参数：-R rwx作用于目录？ r代表可以用ls查看目录下内容 x代表可以进入该目录 w代表可以在目录下创建文件&#x2F;目录，或者删除文件&#x2F;目录 定时任务调度 每分钟执行一次 ： ls -l &#x2F;etc&#x2F; &gt; &#x2F;tmp&#x2F;to.txt 案例2： 第一种：写两条命令 第二种：写一个脚本程序my.sh 内容如下 12date &gt;&gt; /home/mycalcal &gt;&gt; /home/mycal 要赋予所有者文件执行权限 chmod u+x my.sh 加入到crond调度 案例3： crontab -e 0 2 * * * mysqldump -u root -p123456 testdb &gt; &#x2F;home&#x2F;db.bak ps -ef | grep atd 过滤查看当前atd进程是否启动 案例1: at 5pm + 2 days &#x2F;bin&#x2F;ls &#x2F;home 案例2: atq 查看没有执行的任务 案例3: at 5pm + 1 days date &gt; &#x2F;root&#x2F;date100.log 案例4: at now + 2 minutes date &gt; &#x2F;root&#x2F;date200.log 案例5: atrm 编号，删除指定编号的任务 Linux磁盘分区、挂载 lsblk可以查看硬盘分区挂载到目录的情况 带-f 参数 uuid：分区40位唯一标识符 MOUNtPOINT:挂载点 添加硬盘 分区 如果无法删除输入内容就按住CTRL再删除 格式化磁盘 挂载 设置自动永久挂载 磁盘使用情况 1、ls -l &#x2F;opt | grep “^-“ | wc -l 2、ls -l &#x2F;opt | grep “^d” | wc -l 3、ls -lR &#x2F;opt | grep “^-“ | wc -l 4、ls -lR &#x2F;opt | grep “^d” | wc -l 5、tree &#x2F;home&#x2F; 注意：如果没有tree，则使用yum install tree 安装 8、网络配置 9、进程管理 top指令 查看sshd的父进程信息 ps -ef | grep sshd 案例1： 先查看sshd下非法用户进程对应的进程编号 kill 进程编号 案例2： 查看sshd进程对应的进程编号 kill 进程编号 恢复：&#x2F;bin&#x2F;systemctl start sshd.service 案例3： killall gedit gedit 是文本编辑器 案例4： ps -aux | grep bash 查看bash对应进程号 kill -9 进程编号 空格修改星好，关闭自启动，tab键退出 把network在3运行级别，关闭自启动 chkconfig –level 3 nerwork off chkconfig –level 3 network on 对3和5两个级别都生效 systemctl staus firewalld netstat 可以查看端口信息 10、动态监控进程 11、RPM与YUM 12、搭建JavaEE环境 word文档 新建文件夹&#x2F;opt&#x2F;mysql，并cd进去 运行wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar，下载mysql安装包 PS：centos7.6自带的类mysql数据库是mariadb，会跟mysql冲突，要先删除。 运行tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 运行rpm -qa|grep mari，查询mariadb相关安装包 运行rpm -e –nodeps mariadb-libs，卸载 然后开始真正安装mysql，依次运行以下几条 rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm 7.运行systemctl start mysqld.service，启动mysql 8.然后开始设置root用户密码 Mysql自动给root用户设置随机密码，运行grep “password” &#x2F;var&#x2F;log&#x2F;mysqld.log可看到当前密码 9.运行mysql -u root -p，用root用户登录，提示输入密码可用上述的，可以成功登陆进入mysql命令行 10.设置root密码，对于个人开发环境，如果要设比较简单的密码（生产环境服务器要设复杂密码），可以运行 set global validate_password_policy&#x3D;0; 提示密码设置策略 （validate_password_policy默认值1，） 11.set password for ‘root‘@’localhost’ &#x3D;password(‘hspedu100’); 12.运行flush privileges;使密码设置生效 大数据篇 13、Shell编程 shell脚本的多行注释 :&lt;&lt;!内容! 如果希望希望将expr的结果赋予某个变量，使用&#96;&#96;包含起来 案例1： 1234if [ &quot;ok&quot; = &quot;ok&quot; ]then echo &quot;equal&quot;fi 案例2： 1234if [ 23 -ge 22]then echo &quot;大于&quot;fi 案例3： 1234if [ -f /root/shcode/aaa.txt ]then echo &quot;存在&quot;fi 1234567if [ $1 -ge 60 ]then echo &quot;及格了&quot;elif [ $1 -lt 60 ]then echo &quot;不及格&quot;fi 1234567891011case $1 in&quot;1&quot;)echo &quot;周一&quot;;;&quot;2&quot;)echo &quot;周二&quot;;;*)echo &quot;other...&quot;;;esac 案例1： 123456for i in &quot;$*&quot;do echo &quot;num is $i&quot;done输出一次，因为$*把全部参数当作一个整体 123456for i in &quot;$@&quot;do echo &quot;num is $i&quot;done输出多次，因为$@把全部参数分别对待 案例1： 123456SUM=0for (( i=1; i&lt;=100; i++ ))do SUM=$[$SUM+$i]done echo &quot;SUM=$SUM&quot; 123456SUM=0for (( i=1; i&lt;=$1; i++ ))do SUM=$[$SUM+$i]done echo &quot;SUM=$SUM&quot; 123456789SUM=0i=1while [ $i -le $1 ]do SUM=$[$SUM+$i] i=$[$i+1]done echo &quot;SUM=$SUM&quot; basename &#x2F;home&#x2F;aaa&#x2F;test.txt .txt 返回 test dirname &#x2F;home&#x2F;aaa&#x2F;test.txt 案例1： 1234567891011#定义函数function getSum() &#123; SUM=$[$n1+$n2] echo &quot;和是：$SUM&quot;&#125;#输入两个数read -p &quot;请输入第一个数：&quot; n1read -p &quot;请输入第二个数；&quot; n2#调用函数getSum $n1 $n2 14、Ubuntu 安装 15、APT软件管理和远程登录 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse sudo apt-get update 16、CentOS8.1的使用 二、高级1、日志管理 vim &#x2F;etc&#x2F;rsyslog.conf 2、定制自己的Linux系统 操作步骤： 3、Linux内核源码 地址：https://www.kernel.org/ 地址：https://www.kernel.org/ yum info kernel -q &#x2F;&#x2F;检测内核版本，显示可以升级的内核 查看当前内核：uname -a yum update kernel &#x2F;&#x2F;升级内核 yum list kernel -q 查看已安装的内核 4、Linux系统备份与恢复 安装dump:yum -y install dump 安装restore:yum -y install restore 5、Linux可视化管理—–webmin和bt运维工具 地址：http://download.webmin.com/download/yum/ 命令：wget http://download.webmin.com/download/yum/webmin-1.700-1noarch.rpm 还有任务调度，mysql等 yum install -y wget安装wget指令 &amp;&amp;先执行前面的在执行后面的 6、Linux面试题—（腾讯、美团、百度、滴滴） 1、 cut -d ‘&#x2F;‘：以&#x2F;为分隔符进行截取 sort 排序从小到大，加-nr ：排序从大到小 uniq -c 统计次数 2、 netstat -an | grep ESTABLISHED awk -F “ “ ‘{print $5}’:以空格为分割符，打印第五部分 一定要先排序再统计再排序 因为uniq -c是根据连续多少个1相同的进行统计的 1、 vim &#x2F;etc&#x2F;my.cnf 在【mysqld】下写入一句话：skip-grant-tables 重启mysqld服务：service mysqld restart 重新进入mysql，此时无需密码 在mysql数据库中有user表： use mysql update user set password&#x3D;password(‘new_password’) where user&#x3D;’root’;mysql&gt; flush privileges;mysql &gt;exit; 这样就把密码修改了， 改完了密码之后，需要恢复权限：把之前对&#x2F;etc&#x2F;my.cnf的 skip-grant-tables 删掉 然后执行 service mysqld restart； 然后mysql -u root -p Enter Password :你的新密码； 2、 access.log 1234567891011192.168.130.21 aaa.html192.168.130.20 aaa.html192.168.130.20 aaa.html192.168.130.20 aaa.html192.168.130.23 aaa.html192.168.130.20 aaa.html192.168.130.25 aaa.html192.168.130.20 aaa.html192.168.130.20 aaa.html192.168.130.25 aaa.html192.168.130.20 aaa.html cat access.log | awk -F “ “ ‘{print $1}’ |sort |uniq -c |sort -nr| head -2 head -2 查看前2行 3、 tcpdump -i ens33 host 192.168.200.1 and port 22 &gt;&gt; &#x2F;opt&#x2F;interview&#x2F;tcpdump.log 4、 chattr（change attribute） chattr +i &#x2F;etc&#x2F;passwd&#x2F; 锁定 也可以隐藏命令，改名 which命令. which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。. 也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。. 我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：. which 查看可执行文件的位置。. whereis 查看文件的位置。. locate 配合数据库查看文件位置。. find 实际搜寻硬盘查询文件名称。. which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。. chattr -i &#x2F;etc&#x2F;passwd:解锁 Tripwire官网：https://www.tripwire.com/ 1、能读，不能修改，能删除 2、不能，进不去目录 3、能读，不能修改，不能删除 4、能读，不能修改，能删除 看word笔记 1、 netstat &#x2F;&#x2F;网络状态监控 top &#x2F;&#x2F;系统运行状态 lsblk &#x2F;&#x2F;查看硬盘分区 find &#x2F;&#x2F;查看 ps -aux 查看运行进程 chkconfig &#x2F;&#x2F;查看服务启动状态 systemctl &#x2F;&#x2F;管理系统服务器 2、 top iotop (yum install iotop) df -lh netstat -tunlp ps -aux 3、 cat t2.txt | awk -F “ “ ‘{sum+&#x3D;$2} END {print sum}’ 1、 if [ -f 文件名 ] then echo “存在” else echo “不存在” fi 2、 3、 grep -r “cat” &#x2F;home | cut -d “:” -f 1 4、 find &#x2F;home -name “*.*“ | xargs wc -l xargs显示行数和总行数 1、Nginx、Haproxy、keepalived、LVS 2、 vim mail.sh 12#!/bin/bashca /var/spool/ &amp;&amp; /bin/tar zcvf /home/mail-`date +%Y-%m-%d_%H%M%S`.tar.gz mail/ crontab -e 30 20 * * * &#x2F;root&#x2F;mail.sh 3、 ①对linux的架构的优化，和原则分析（示意图） ②对linux系统本身的优化-规则 不用root，使用sudo提升权限 定时的自动更新服务升级，使用npdate npt1.aliyun.com，让crond定时更新 配置yum源，指向国内镜像（清华，163） 配置合理的防火墙策略，打开必要的端口，关闭不必要的端口 打开最大文件数（调整文件描述的数量）vim &#x2F;etc&#x2F;profile ulimit -SHn 65535 配置合理的监控策略 配置合理的系统重要文件的备份策略 对安装的软件进优化，比如Nginx，apache 对内核参数进行优化 &#x2F;etc&#x2F;sysctl.conf 锁定一些重要的系统文件 chattr &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow &#x2F;etc&#x2F;inittab 禁用不必要的服务 setup，ntsysv","tags":"linux"},{"title":"JDBCTemplate","url":"/2022/10/22/jdbcTemplate（概念和准备）/","text":"# jdbcTemplate（概念和准备） 1、什么是JdbcTemplate11、Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库的操作 2、准备工作11、引入相关依赖 1234567892、在spring配置文件中配置数据库连接池&lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.31.1:3306/bjpowernode&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;623718&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt; 123453、配置JdbcTemplate对象，注入DataSource &lt;!--创建JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 12345678910111213141516171819204、创建service类，创建dao类，在dao注入jdbcTemplate对象配置文件：&lt;!--开始组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.lxg.spring5&quot;&gt;&lt;/context:component-scan&gt; @Servicepublic class BookService &#123; //注入dao @Autowired private BookDao bookDao;&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate;&#125; 3、jdbcTemplate 操作数据库（添加）3.1、对应数据库创建出实体类1234567891011121314151617181920212223242526272829public class User &#123; private String useId; private String userName; private String ustatus; public String getUseId() &#123; return useId; &#125; public void setUseId(String useId) &#123; this.useId = useId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUstatus() &#123; return ustatus; &#125; public void setUstatus(String ustatus) &#123; this.ustatus = ustatus; &#125;&#125; 3.2、编写service和dao1、在dao进行数据库添加操作 2、调用JdbcTemplate对象里面的update方法实现添加操作 有两个参数 第一个参数：sql语句 第二个参数：可变参数，设置sql语句值 12345678910111213141516@Repositorypublic class BookDaoImpl implements BookDao &#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(Book book) &#123; //1、创建sql语句 String sql = &quot;insert into t_book values(?,?,?)&quot;; //2、调用方法实现 Object[] args = &#123;book.getBookId(), book.getBookName(),book.getBookAuthor()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(&quot;添加了&quot;+update+&quot;条数据&quot;); &#125;&#125; 3、测试类 1234567891011@Testpublic void testJdbcTemplate() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); book.setBookId(&quot;6&quot;); book.setBookName(&quot;Spring5&quot;); book.setBookAuthor(&quot;lxg&quot;); bookService.addBook(book);&#125; 4、jdbcTemplate操作数据库（修改和删除）1234567891011121314@Overridepublic void bookupdate(Book book) &#123; String sql= &quot;update t_book set bookName=?,bookAuthor=? where bookId=?&quot;; Object[] args = &#123;book.getBookName(),book.getBookAuthor(),book.getBookId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(&quot;更新了&quot;+update+&quot;条数据&quot;);&#125;@Overridepublic void bookdelete(String id) &#123; String sql= &quot;delete from t_book where bookId=?&quot;; int update = jdbcTemplate.update(sql, id); System.out.println(&quot;删除了&quot;+update+&quot;条数据&quot;);&#125; 测试： 1234567891011121314151617181920 @Test public void testJdbcTemplate() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); //添加// Book book = new Book();// book.setBookId(&quot;6&quot;);// book.setBookName(&quot;Spring5&quot;);// book.setBookAuthor(&quot;lxg&quot;);// bookService.addBook(book); //修改// Book book1 = new Book();// book1.setBookId(&quot;5&quot;);// book1.setBookName(&quot;web&quot;);// book1.setBookAuthor(&quot;lxg&quot;);// bookService.updateBook(book1); //删除 bookService.deleteBook(&quot;5&quot;); &#125; 5、jdbcTemplate操作数据库（查询）5.1、查询返回某个值1、查询表里面有多少条记录，返回是某个值 2、使用JdbcTemplate实现查询返回某个值 两个参数 第一个参数，sql语句 第二个参数，返回类型Class 1234567//查询表记录数@Overridepublic int findCount() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count= jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; 3、测试 123//查询表中记录数int count= bookService.getCount();System.out.println(count); 5.2、查询返回对象1、场景：查询图书详情 2、JdbcTemplate实现查询返回对象 有三个参数 第一个参数，sql语句 第二个参数：RowMapper，是接口，针对返回不同类型数据，使用这个接口里面的实现类完成数据封装 第三个参数：sql语句值 1234567//查询返回对象@Overridepublic Book findBook(String id) &#123; String sql = &quot;select * from t_book where bookId=?&quot;; Book book = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),id); return book;&#125; 5.3、查询返回集合1、场景：查询图书列表分页… 2、调用jdbcTemplate方法实现查询返回集合 123456@Overridepublic List&lt;Book&gt; findBooks() &#123; String sql = &quot;select * from t_book&quot;; List&lt;Book&gt; list = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return list;&#125; 6、jdbcTemplate操作数据库（批量操作）1、批量操作：操作表里面多条记录 6.1、实现批量添加操作 有两个参数 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 1234567//批量添加@Overridepublic void addBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_book values(?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;添加了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量添加List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] args1 = &#123;&quot;7&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;Object[] args2 = &#123;&quot;8&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;Object[] args3 = &#123;&quot;9&quot;,&quot;Spring5&quot;,&quot;lxg&quot;&#125;;batchArgs.add(args1);batchArgs.add(args2);batchArgs.add(args3);bookService.addBooks(batchArgs); 6.2、实现批量修改操作1234567//批量更新@Overridepublic void updateBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_book set bookName=?,bookAuthor=? where bookId=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;更新了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量更新List&lt;Object[]&gt; batchArgs1= new ArrayList&lt;&gt;();Object[] args1 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;7&quot;&#125;;Object[] args2 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;8&quot;&#125;;Object[] args3 = &#123;&quot;java&quot;,&quot;lxg&quot;,&quot;9&quot;&#125;;batchArgs1.add(args1);batchArgs1.add(args2);batchArgs1.add(args3);bookService.updateBooks(batchArgs1); 6.3、实现批量删除操作1234567//批量删除@Overridepublic void deleteBatch(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_book where bookId=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;删除了&quot;+ints.length+&quot;条数据&quot;);&#125; 123456789//批量删除List&lt;Object[]&gt; ids = new ArrayList&lt;&gt;();Object[] id1 = &#123;&quot;7&quot;&#125;;Object[] id2 = &#123;&quot;8&quot;&#125;;Object[] id3 = &#123;&quot;9&quot;&#125;;ids.add(id1);ids.add(id2);ids.add(id3);bookService.deleteBooks(ids);","tags":"jdbc"},{"title":"书城项目","url":"/2022/10/22/书城项目/","text":"# 书城项目 第一阶段：表单验证验证用户名：必须由字母，数字下划线组成，并且长度在5-12位 验证密码：必须由字母，数字下划线组成，并且长度为5-12位 验证确认密码：和密码相同 邮箱验证：&#x78;&#x78;&#x78;&#x78;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#99;&#x6f;&#109; 验证码：现在只需要验证用户已输入，因为还没将到服务器，验证码生成。 1、新建一个模块 2、把书城的静态资源拷贝到模块工程下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script type=&quot;text/javascript&quot;&gt; //页面加载完成之后 $(function()&#123; //给注册绑定单击事件 $(&quot;#sub_btn&quot;).click(function() &#123; // 验证用户名：必须由字母，数字下划线组成，并且长度在5-12位 //1、获取用户输入框里的内容 var usernameText = $(&quot;#username&quot;).val(); //2、创建正则表达式对象 var usernamePatt =/^\\w&#123;5,12&#125;$/; //3、使用test方法验证 if (!usernamePatt.test(usernameText)) &#123; //4、提示用户结果 $(&quot;span.errorMsg&quot;).text(&quot;用户名不合法！&quot;); return false; &#125; // 验证密码：必须由字母，数字下划线组成，并且长度为5-12位 //1、获取密码输入框里的内容 var passwordText = $(&quot;#password&quot;).val(); //2、创建正则表达式对象 var passwordPatt = /^\\w&#123;5,12&#125;$/; //3、使用test方法验证 if (!passwordPatt.test(passwordText)) &#123; //4、提示用户结果 $(&quot;span.errorMsg&quot;).text(&quot;密码不合法！&quot;); return false; &#125; // 验证确认密码：和密码相同 //1、获取确认密码的内容 var repwdText = $(&quot;#repwd&quot;).val(); //2、和密码比较 if(repwdText!=passwordText)&#123; //3、提示用户 $(&quot;span.errorMsg&quot;).text(&quot;确认密码和密码不一致！&quot;) return false; &#125; // 邮箱验证：xxxxx@xxx.com //1、获取邮箱里的内容 var emailText = $(&quot;#email&quot;).val(); //2、创建正则表达式对象 var emailPatt = /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.&#123;1,2&#125;[a-z]+)+$/; //3、使用test方法验证 if(!emailPatt.test(emailText))&#123; //4、提示用户 $(&quot;span.errorMsg&quot;).text(&quot;邮箱格式不正确！&quot;) return false; &#125; // 验证码：现在只需要验证用户已输入，因为还没将到服务器，验证码生成。 var codeText = $(&quot;#code&quot;).val(); //去掉验证码前后空格 codeText = $.trim(codeText); if(codeText==null ||codeText==&quot;&quot; )&#123; $(&quot;span.errorMsg&quot;).text(&quot;验证码不能为空！&quot;) return false; &#125; $(&quot;span.errorMsg&quot;).text(&quot;&quot;); &#125;); &#125;); 第二阶段：用户注册和登录1、JavaEE项目的三层架构 分层的目的是为了解耦，解耦就是为了降低代码的耦合度，方便项目后期的维护和升级。 12345678web层 com.lxg.web/servlet/controllerservice层 com.lxg.service Service接口包 com.lxg.service.impl Service接口实现类dao持久层 com.lxg.dao Dao接口包 com.lxg.dao.impl Dao接口实现类实体bean对象 com.lxg.pojo/entity/domain/bean JavaBean类测试包 com.lxg.test/junit工具类 com.lxg.utils 2、编码环节1、先创建书城需要的数据库和表 123456789101112131415drop database if EXISTS book;CREATE DATABASE book;use book;CREATE table t_user( `id` int PRIMARY key auto_increment, `username` varchar(20) not null unique, `password` VARCHAR(32) not null, `email` varchar(200));INSERT INTO t_user(`username`,`password`,`email`) VALUES (&#x27;admin&#x27;,&#x27;admin&#x27;,&#x27;admin@qq.com&#x27;);select * from t_user; 2、编写数据库表对应的JavaBean对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.lxg.domain;public class User &#123; private Integer id; private String username; private String password; private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(Integer id, String username, String password, String email) &#123; this.id = id; this.username = username; this.password = password; this.email = email; &#125; public User() &#123; &#125;&#125; 3、编写工具类JdbcUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.lxg.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;public class JdbcUtils &#123; private static DruidDataSource dataSource; static &#123; try&#123; Properties properties = new Properties(); //读取jdbc.properties属性配置文件 InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //从流中读取数据 properties.load(inputStream); //创建数据库连接池 dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池中的连接 * @return 如果返回null说明获取连接失败，反之成功 */ public static Connection getConnection()&#123; Connection conn =null; try&#123; conn = dataSource.getConnection(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return conn; &#125; /** * 关闭连接，返回数据库连接池 * @param conn */ public static void close(Connection conn)&#123; if(conn!=null)&#123; try&#123; conn.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试 123456789@Testpublic void testJdbcUtils()&#123; for (int i = 0; i &lt; 100; i++) &#123; Connection connection = JdbcUtils.getConnection(); System.out.println(connection); JdbcUtils.close(connection); &#125;&#125; 4、编写BaseDao12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.lxg.dao;import com.lxg.utils.JdbcUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public abstract class BaseDao &#123; //使用DBUtils操作数据库 private QueryRunner queryRunner = new QueryRunner(); /** * update()方法用来执行：Insert\\update\\Delete语句 * @param sql * @param args * @return如果返回-1，说明执行失败，其他表示影响的行数 */ public int update(String sql,Object...args)&#123; Connection connection = JdbcUtils.getConnection(); try&#123; return queryRunner.update(connection,sql,args); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(connection); &#125; return -1; &#125; /** * 查询返回一个javaBean的sql语句 * @param type 返回的对象类型 * @param sql 执行的sql语句 * @param args sql对应的参数值 * @param &lt;T&gt; 返回的类型的泛型 * @return */ public&lt;T&gt; T queryForOne(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection connection = JdbcUtils.getConnection(); try &#123; return queryRunner.query(connection,sql,new BeanHandler&lt;T&gt;(type),args); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(connection); &#125; return null; &#125; /** * 查询返回多个javaBean的sql语句 * @param type 返回的对象类型 * @param sql 执行的sql语句 * @param args sql对应的参数值 * @param &lt;T&gt; 返回的类型的泛型 * @return */ public &lt;T&gt; List&lt;T&gt; queryForList(Class&lt;T&gt; type,String sql,Object...args)&#123; Connection connection = JdbcUtils.getConnection(); try &#123; return queryRunner.query(connection,sql,new BeanListHandler&lt;T&gt;(type),args); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(connection); &#125; return null; &#125; /** * 执行返回一行一列的sql语句 * @param sql 执行的sql语句 * @param args sql对应的参数值 * @return */ public Object queryForSingleValue(String sql,Object...args)&#123; Connection connection = JdbcUtils.getConnection(); try &#123; queryRunner.query(connection,sql,new ScalarHandler(),args); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.close(connection); &#125; return null; &#125;&#125; 5、编写UserDao和测试1234567891011121314151617181920212223242526272829303132333435package com.lxg.test;import com.lxg.dao.UserDao;import com.lxg.dao.impl.UserDaoImpl;import com.lxg.domain.User;import org.junit.Test;import static org.junit.Assert.*;public class UserDaoTest &#123; UserDao userDao = new UserDaoImpl(); @Test public void queryUserByUsername() &#123; if(userDao.queryUserByUsername(&quot;admin&quot;)==null)&#123; System.out.println(&quot;用户名可用&quot;); &#125;else&#123; System.out.println(&quot;用户名已存在&quot;); &#125; &#125; @Test public void queryUserByUsernameAndPassword() &#123; if(userDao.queryUserByUsernameAndPassword(&quot;admin&quot;,&quot;123456&quot;)==null)&#123; System.out.println(&quot;用户名或密码错误&quot;); &#125;else&#123; System.out.println(&quot;登录成功&quot;); &#125; &#125; @Test public void saveUser() &#123; System.out.println(userDao.saveUser(new User(null,&quot;lxg&quot;,&quot;123456&quot;,&quot;xiaolin@qq.com&quot;))); &#125;&#125; 6、编写UserService和测试12345678910111213141516171819202122232425262728293031package com.lxg.test;import com.lxg.domain.User;import com.lxg.service.UserService;import com.lxg.service.impl.UserServiceImpl;import org.junit.Test;import static org.junit.Assert.*;public class UserServiceTest &#123; UserService userService = new UserServiceImpl(); @Test public void registUser() &#123; userService.registUser(new User(null,&quot;zs&quot;,&quot;123456&quot;,&quot;zs@qq.com&quot;)); userService.registUser(new User(null,&quot;ls&quot;,&quot;123456&quot;,&quot;ls@qq.com&quot;)); &#125; @Test public void login() &#123; System.out.println(userService.login(new User(null,&quot;zs&quot;,&quot;123456&quot;,null))); &#125; @Test public void existsUsername() &#123; if(userService.existsUsername(&quot;zs&quot;))&#123; System.out.println(&quot;用户名已存在&quot;); &#125;else &#123; System.out.println(&quot;用户名可用&quot;); &#125; &#125;&#125; 7、编写web层1、用户注册 123456需求如下：1、访问注册页面2、填写注册信息，提交给服务器3、服务器应该保存用户4、当用户已经存在——提示用户注册失败，用户名已存在5、当用户不存在——注册成功 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lxg.web;import com.lxg.domain.User;import com.lxg.service.UserService;import com.lxg.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RegistServlet extends HttpServlet &#123; private UserService userService = new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String email = req.getParameter(&quot;email&quot;); String code = req.getParameter(&quot;code&quot;); //2、检查验证码是否正确===写死，要求验证码为：abcde if (&quot;abcde&quot;.equalsIgnoreCase(code)) &#123; //正确 //3、检查用户名是否可用 if(userService.existsUsername(username))&#123; //用户名已存在,不可用 System.out.println(&quot;用户名[&quot;+username+&quot;]已存在!&quot;); req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125;else&#123; //用户名可用 //调用service保存到数据库 userService.registUser(new User(null,username,password,email)); //跳转到注册成功页面 req.getRequestDispatcher(&quot;/pages/user/regist_success.html&quot;).forward(req,resp); &#125; &#125;else&#123; System.out.println(&quot;验证码[&quot;+code+&quot;]错误&quot;); //跳回注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.html&quot;).forward(req,resp); &#125; &#125;&#125; 2、用户登录 12345需求如下：1、访问登录页面2、填写用户名和密码后提交3、服务器判断用户是否存在4、如果登录失败——返回用户名或密码的错误信息 12345678910111213141516171819202122232425262728293031package com.lxg.web;import com.lxg.domain.User;import com.lxg.service.UserService;import com.lxg.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; UserService userService = new UserServiceImpl(); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //2、调用userService.login完成业务逻辑 User loginUser= userService.login(new User(null,username, password,null)); //如果等于null，说明登录失败 if(loginUser==null)&#123; //3、跳转到登录页面 req.getRequestDispatcher(&quot;/pages/user/login.html&quot;).forward(req,resp); &#125;else &#123; //4、登录成功,跳转到登录成功页面 req.getRequestDispatcher(&quot;/pages/user/login_success.html&quot;).forward(req,resp); &#125; &#125;&#125; 3、IDEA中的Debug调试的使用 123Debug调试代码，首先需要两个元素：断点+Debug启动服务器1、断点：只需要在代码需要停的行的左边上单击，就可以添加和取消2、Debug服务器启动Tomcat运行代码：点击调试按钮 测试工具栏： 变量窗口，它可以查看当前方法范围内所有有效变量 方法调用窗口 121、方法调用栈可以查看当前线程有哪些方法调用信息2、下面一行的方法调用上面一行的方法 其他常用调试相关按钮： 第三阶段：优化a:页面jsp动态化 在html页面顶行添加page指令 修改文件后缀名为：.jsp 3.使用idea搜索替换.html为.jsp ​ CTRL+SHIF+R：或者CTRL+R b:抽取页面相同的内容 c：登录，注册错误提示以及表单回显在Servlet后端代码中将用户信息保存进域对象， 在jsp前端页面代码中使用EL表达式获取信息并显示 d:BaseServlet的抽取在实际的项目开发中，一个模块，一般只使用一个Servlet程序。 LoginServlet和RegistServle优化为UserServlet： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package main.java.com.lxg.web;import main.java.com.lxg.domain.User;import main.java.com.lxg.service.UserService;import main.java.com.lxg.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class UserServlet extends HttpServlet &#123; private UserService userService = new UserServiceImpl(); /** * 处理登录功能 * * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //System.out.println(&quot;处理登录的需求&quot;); // 1、获取请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); // 调用 userService.login()登录处理业务 User loginUser = userService.login(new User(null, username, password, null)); // 如果等于null,说明登录 失败! if (loginUser == null) &#123; // 把错误信息，和回显的表单项信息，保存到Request域中 req.setAttribute(&quot;msg&quot;, &quot;用户或密码错误！&quot;); req.setAttribute(&quot;username&quot;, username); // 跳回登录页面 req.getRequestDispatcher(&quot;/pages/user/login.jsp&quot;).forward(req, resp); &#125; else &#123; // 登录 成功 //跳到成功页面login_success.html req.getRequestDispatcher(&quot;/pages/user/login_success.jsp&quot;).forward(req, resp); &#125; &#125; /** * 处理注册功能 * * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1、获取请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String email = req.getParameter(&quot;email&quot;); String code = req.getParameter(&quot;code&quot;); //2、检查 验证码是否正确 === 写死,要求验证码为:abcde if (&quot;abcde&quot;.equalsIgnoreCase(code)) &#123; //3、检查 用户名是否可用 if (userService.existsUsername(username)) &#123; System.out.println(&quot;用户名[&quot; + username + &quot;]已存在!&quot;); // 把回显信息，保存到Request域中 req.setAttribute(&quot;msg&quot;, &quot;用户名已存在！！&quot;); req.setAttribute(&quot;username&quot;, username); req.setAttribute(&quot;email&quot;, email); //跳回注册页面 req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req, resp); &#125; else &#123; //可用 //调用Sservice保存到数据库 userService.registUser(new User(null, username, password, email)); //跳到注册成功页面 regist_success.jsp req.getRequestDispatcher(&quot;/pages/user/regist_success.jsp&quot;).forward(req, resp); &#125; &#125; else &#123; // 把回显信息，保存到Request域中 req.setAttribute(&quot;msg&quot;, &quot;验证码错误！！&quot;); req.setAttribute(&quot;username&quot;, username); req.setAttribute(&quot;email&quot;, email); System.out.println(&quot;验证码[&quot; + code + &quot;]错误&quot;); req.getRequestDispatcher(&quot;/pages/user/regist.jsp&quot;).forward(req, resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String action = req.getParameter(&quot;action&quot;); if (&quot;login&quot;.equals(action)) &#123; login(req, resp); &#125; else if (&quot;regist&quot;.equals(action)) &#123; regist(req, resp); &#125; &#125;&#125; doPost还可以继续优化为： 12345678910String action = req.getParameter(&quot;action&quot;);try &#123; //通过action业务鉴别字符串，获取对应的业务，方法反射对象 Method method = this.getClass().getDeclaredMethod(action,HttpServletRequest.class,HttpServletResponse.class); //System.out.println(method); //调用目标业务方法 method.invoke(this,req,resp);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 如若系统又有其他模块，这个代码可以抽取出来变成BaseServlet e:数据的封装和抽取BeanUtils的使用 BeanUtils工具类，它可以一次性的把请求的参数注入到javaBean中。 BeanUtils不是jdk的类，是第三方的工具类，所以需要导包 导入需要的jar包： commons-beanutils-1.8.0.jarcommons-logging-1.1.1.jar 使用BeanUti类方法实现注入 123456789101112131415161718192021222324252627package main.java.com.lxg.utils;import org.apache.commons.beanutils.BeanUtils;import java.util.Map;public class WebUtils &#123; /** * 把Map中的值注入到对应的JavaBean属性中。 * @param value * @param bean */ public static &lt;T&gt; T copyParamToBean(Map value, T bean)&#123; try &#123; System.out.println(&quot;注入之前：&quot;+bean); /** * 把所有请求的参数全都注入到user对象中 */ BeanUtils.populate(bean,value); System.out.println(&quot;注入之后：&quot;+bean); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bean; &#125;&#125; 12//给参数注入值User user = WebUtils.copyParamToBean(req.getParameterMap(),new User()); CTRL+ALT+T快捷键: 第四阶段：使用EL表达式修改表单回显（上面已修改）第五阶段：图书模块1、MVC概念123456789101112MVC全称：Model模型、View视图、Controller控制器MVC最早出现在JavaEE三层的web层，它可以有效的指导web层的代码如何有效分离，单独工作View视图：只负责数据和界面的显示，不接受任何域显示数据无关的代码，便于程序员和美工的分工合作---jsp/HtmlController控制器：只负责接收请求，调用业务层的代码请求，然后派发页面，是一个“调度者”的角色--Servlet。转到某个页面，或者是重定向到某个页面。Model模型：将与业务逻辑相关的数据封装成为具体的JavaBean类，其中不掺杂任何与数据处理相关的代码--JavaBean、domain、entity。MVC是一种思想MVC的理念是将软件代码拆分成为组件，单独开发，组合使用（目的还是为了解耦合）。 MVC的作用还是为了降低耦合，让代码合理分层，方便后期升级和维护。 2、图书模块2.1、编写图书模块的数据库表2.2、编写图书模块的JavaBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package main.java.com.lxg.domain;import java.math.BigDecimal;public class Book &#123; private Integer id; private String name; private String author; private BigDecimal price; private Integer sales; private Integer stock; private String imgPath=&quot;static/img/default.jpg&quot;; public Book() &#123; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales + &quot;, stock=&quot; + stock + &quot;, imgPath=&#x27;&quot; + imgPath + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getSales() &#123; return sales; &#125; public void setSales(Integer sales) &#123; this.sales = sales; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public String getImgPath() &#123; return imgPath; &#125; public void setImgPath(String imgPath) &#123; //要求给定的图书封面图书路径不能为空 if (imgPath!=null &amp;&amp; !&quot;&quot;.equals(imgPath))&#123; this.imgPath = imgPath; &#125; &#125; public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String imgPath) &#123; this.id = id; this.name = name; this.author = author; this.price = price; this.sales = sales; this.stock = stock; //要求给定的图书封面图书路径不能为空 if (imgPath!=null &amp;&amp; !&quot;&quot;.equals(imgPath))&#123; this.imgPath = imgPath; &#125; &#125;&#125; 2.3、编写图书模块的Dao和测试Dao123456789101112131415161718package main.java.com.lxg.dao;import main.java.com.lxg.domain.Book;import java.util.List;public interface BookDao &#123; public int addBook(Book book); public int deleteBookById(Integer id); public int updateBook(Book book); public Book queryBookById(Integer id); public List&lt;Book&gt; queryBooks();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package main.java.com.lxg.dao.impl;import main.java.com.lxg.dao.BookDao;import main.java.com.lxg.domain.Book;import java.util.List;public class BookDaoImpl extends BaseDao implements BookDao &#123; @Override public int addBook(Book book) &#123; String sql = &quot;insert into t_book(`name`,`author`,`price`,`sales`,`stock`,`img_path`) \\n&quot; + &quot;values(?,?,?,?,?,?)&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath()); &#125; @Override public int deleteBookById(Integer id) &#123; String sql = &quot;delete from t_book where id=?&quot;; return update(sql,id); &#125; @Override public int updateBook(Book book) &#123; String sql=&quot;update t_book set `name`=?,`author`=?,`price`=?,`sales`=?,`stock`=?,`img_path`=? where id=?&quot;; return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId()); &#125; @Override public Book queryBookById(Integer id) &#123; String sql = &quot;select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` imPath from t_book where id=? &quot;; return queryForOne(Book.class,sql,id); &#125; @Override public List&lt;Book&gt; queryBooks() &#123; String sql = &quot;select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` from t_book&quot;; return queryForList(Book.class,sql); &#125;&#125; 生成测试快捷键：CTRL+SHIFT+T 2.4、编写图书模块的Service和测试Service12345678910111213package main.java.com.lxg.service;import main.java.com.lxg.domain.Book;import java.util.List;public interface BookService &#123; public void addBook(Book book); public void deleteBookById(Integer id); public void updateBook(Book book); public Book findBookById(Integer id); public List&lt;Book&gt; findAllBooks();&#125; 12345678910111213141516171819202122232425262728293031323334353637package main.java.com.lxg.service.impl;import main.java.com.lxg.dao.BookDao;import main.java.com.lxg.dao.impl.BookDaoImpl;import main.java.com.lxg.domain.Book;import main.java.com.lxg.service.BookService;import java.util.List;public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl(); @Override public void addBook(Book book) &#123; bookDao.addBook(book); &#125; @Override public void deleteBookById(Integer id) &#123; bookDao.deleteBookById(id); &#125; @Override public void updateBook(Book book) &#123; bookDao.updateBook(book); &#125; @Override public Book findBookById(Integer id) &#123; return bookDao.queryBookById(id); &#125; @Override public List&lt;Book&gt; findAllBooks() &#123; return bookDao.queryBooks(); &#125;&#125; 2.5、编写图书模块的Web层，和页面联调测试BookServlet： 12345678910111213141516171819202122232425262728293031323334353637package main.java.com.lxg.web;import main.java.com.lxg.domain.Book;import main.java.com.lxg.service.BookService;import main.java.com.lxg.service.impl.BookServiceImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;public class BookServlet extends BaseServlet&#123; private BookService bookService = new BookServiceImpl(); protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125; protected void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、通过BookService查询全部图书 List&lt;Book&gt; books = bookService.findAllBooks(); //2、把全部图书信息保存到Req域中 req.setAttribute(&quot;books&quot;,books); //3、请求转发到pages/manager/book_manager.jsp页面 req.getRequestDispatcher(&quot;/pages/manager/book_manager.jsp&quot;).forward(req,resp); &#125;&#125; 需要给BaseServlet加上doGet方法才可处理get请求 1234@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp);&#125; 实现展示所有图书功能： 使用jstl标签遍历获取数据显示在前端页面： 1234567891011&lt;c:forEach items=&quot;$&#123;requestScope.books&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;book_edit.jsp&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 前后台的介绍： 实现添加图书功能： 请求转发定位到工程目录 请求重定向定位到端口号 123456789protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求的参数==封装成为Book对象 Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book()); //2、调用BookService.addBook()保存图书 bookService.addBook(book); //3、跳到图书列表页面 //req.getRequestDispatcher(&quot;/manager/bookServlet?action=list&quot;).forward(req,resp); resp.sendRedirect(req.getContextPath()+&quot;/manager/bookServlet?action=list&quot;);&#125; 实现图书删除功能： 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; $(function ()&#123; //给删除的a标签绑定单击事件 $(&quot;a.deleteClass&quot;).click(function () &#123; //在事件的function函数中，有一个this对象，这个this对象，是当前正在响应事件的dom对象 /** * confirm是确认提示框函数 * 参数是它提示的内容 * 它有两个按钮，一个确定，一个是取消 * 返回true表示点击了确定，返回false表示点击了取消 */ return confirm(&quot;你确定要删除【&quot;+$(this).parent().parent().find(&quot;td:first&quot;).text()+&quot;】?&quot;); &#125;) &#125;);&lt;/script&gt; 123456789protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求的参数id，图书编号 int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //2、调用BookService.deleteBookById(id); bookService.deleteBookById(id); //3、重定向会图书列表管理页面 resp.sendRedirect(req.getContextPath()+&quot;/manager/bookServlet?action=list&quot;);&#125; 1&lt;td&gt;&lt;a class=&quot;deleteClass&quot; href=&quot;manager/bookServlet?action=delete&amp;id=$&#123;book.id&#125;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; 实现图书修改功能： 获取前端页面数据： 12345678910protected void getBook(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求的参数，图书编号 int id = WebUtils.parseInt(req.getParameter(&quot;id&quot;),0); //2、调用bookService.queryBookById查询图书 Book book = bookService.findBookById(id); //3、保存图书信息到request域中 req.setAttribute(&quot;book&quot;,book); //4、请求转发到，pages/maanger/book_edit.jsp页面 req.getRequestDispatcher(&quot;/pages/manager/book_edit.jsp&quot;).forward(req,resp);&#125; 回显数据： 12345678&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;$&#123;book.name&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;price&quot; type=&quot;text&quot; value=&quot;$&#123;book.price&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;author&quot; type=&quot;text&quot; value=&quot;$&#123;book.author&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;sales&quot; type=&quot;text&quot; value=&quot;$&#123;book.sales&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;stock&quot; type=&quot;text&quot; value=&quot;$&#123;book.stock&#125;&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt;&lt;/tr&gt; 保存修改： 123&lt;%--&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;param.method&#125;&quot;&gt;--%&gt;&lt;%--&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty param.id ? &quot;add&quot; : &quot;update&quot;&#125;&quot;&gt;--%&gt;&lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;$&#123;empty requestScope.book ? &quot;add&quot; : &quot;update&quot;&#125;&quot;&gt; 12&lt;%--&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp?method=add&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt;--%&gt;&lt;td&gt;&lt;a href=&quot;pages/manager/book_edit.jsp&quot;&gt;添加图书&lt;/a&gt;&lt;/td&gt; 12&lt;%--&lt;td&gt;&lt;a href=&quot;manager/bookServlet?action=getBook&amp;id=$&#123;book.id&#125;&amp;method=update&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;--%&gt;&lt;td&gt;&lt;a href=&quot;manager/bookServlet?action=getBook&amp;id=$&#123;book.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td 12345678protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1、获取请求的参数==封装成Book对象 Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book()); //2、调用BookService.updateBook(book);修改图书 bookService.updateBook(book); //3、重定向会图书列表管理页面 resp.sendRedirect(req.getContextPath()+&quot;/manager/bookServlet?action=list&quot;);&#125; 3、图书分页 分页功能分析 分页模型Page对象的创建 分页初步实现 首页，上一页，末页的实现 跳转到指定页码的功能 数据边界有效的检验 分页条页码的显示（显示5个连续的页码，而且当前页码在中间，除了当前页码之外，每个页码都可以点击跳转到相应的指定页面 修改分页对原来添加修改删除功能的影响 4、前台分页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;书城首页&lt;/title&gt; &lt;%--静态包含base标签，css样式，jQuery文件--%&gt; &lt;%@ include file=&quot;/pages/common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;header&quot;&gt; &lt;img class=&quot;logo_img&quot; alt=&quot;&quot; src=&quot;static/img/logo.gif&quot; &gt; &lt;span class=&quot;wel_word&quot;&gt;网上书城&lt;/span&gt; &lt;div&gt; &lt;a href=&quot;pages/user/login.jsp&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;pages/user/regist.jsp&quot;&gt;注册&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;pages/cart/cart.jsp&quot;&gt;购物车&lt;/a&gt; &lt;a href=&quot;pages/manager/manager.jsp&quot;&gt;后台管理&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;book&quot;&gt; &lt;div class=&quot;book_cond&quot;&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; 价格：&lt;input id=&quot;min&quot; type=&quot;text&quot; name=&quot;min&quot; value=&quot;&quot;&gt; 元 - &lt;input id=&quot;max&quot; type=&quot;text&quot; name=&quot;max&quot; value=&quot;&quot;&gt; 元 &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=&quot;text-align: center&quot;&gt; &lt;span&gt;您的购物车中有3件商品&lt;/span&gt; &lt;div&gt; 您刚刚将&lt;span style=&quot;color: red&quot;&gt;时间简史&lt;/span&gt;加入到了购物车中 &lt;/div&gt; &lt;/div&gt; &lt;c:forEach items=&quot;$&#123;requestScope.page.items&#125;&quot; var=&quot;book&quot; &gt; &lt;div class=&quot;b_list&quot;&gt; &lt;div class=&quot;img_div&quot;&gt; &lt;img class=&quot;book_img&quot; alt=&quot;&quot; src=&quot;$&#123;book.imgPath&#125;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;book_info&quot;&gt; &lt;div class=&quot;book_name&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;书名:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_author&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;作者:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.author&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_price&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;价格:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;￥$&#123;book.price&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_sales&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;销量:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.sales&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_amount&quot;&gt; &lt;span class=&quot;sp1&quot;&gt;库存:&lt;/span&gt; &lt;span class=&quot;sp2&quot;&gt;$&#123;book.stock&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;book_add&quot;&gt; &lt;button&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;/div&gt; &lt;div id=&quot;page_nav&quot;&gt; &lt;%--大于首页才显示--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo&gt;1&#125;&quot;&gt; &lt;a href=&quot;client/bookServlet?action=page&amp;pageNo=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;client/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;%--页码输出的开始--%&gt; &lt;c:choose&gt; &lt;%--1、总页码小于等于五，页码范围1-总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal&lt;=5&#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--2、总页码大于五--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageTotal&gt;5&#125;&quot;&gt; &lt;c:choose&gt; &lt;%--2.1当前页码为前面三个，1,2,3的情况-，页码范围为1到5--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo &lt;=3&#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;1&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;5&quot;/&gt; &lt;/c:when&gt; &lt;%--2.2当前页码为最后三个，页码范围为总页码减4到总页码--%&gt; &lt;c:when test=&quot;$&#123;requestScope.page.pageNo&gt;requestScope.page.pageTotal-3&#125;&quot;&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageTotal-4&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageTotal&#125;&quot;/&gt; &lt;/c:when&gt; &lt;%--2.3:剩下的页码--%&gt; &lt;c:otherwise&gt; &lt;c:set var=&quot;begin&quot; value=&quot;$&#123;requestScope.page.pageNo-2&#125;&quot;/&gt; &lt;c:set var=&quot;end&quot; value=&quot;$&#123;requestScope.page.pageNo+2&#125;&quot;/&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;c:forEach begin=&quot;$&#123;begin&#125;&quot; end=&quot;$&#123;end&#125;&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;$&#123;i==requestScope.page.pageNo&#125;&quot;&gt; 【$&#123;i&#125;】 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;i!=requestScope.page.pageNo&#125;&quot;&gt; &lt;a href=&quot;client/bookServlet?action=page&amp;pageNo=$&#123;i&#125;&quot;&gt;$&#123;i&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;%--页码输出的结束--%&gt; &lt;%--如果已经是最后一页，则不显示下一页和末页--%&gt; &lt;c:if test=&quot;$&#123;requestScope.page.pageNo &lt; requestScope.page.pageTotal&#125;&quot;&gt; &lt;a href=&quot;client/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageNo+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;client/bookServlet?action=page&amp;pageNo=$&#123;requestScope.page.pageTotal&#125;&quot;&gt;末页&lt;/a&gt; &lt;/c:if&gt; 共$&#123;requestScope.page.pageTotal&#125;页，$&#123;requestScope.page.pageTotalCount&#125;条记录 到第&lt;input value=&quot;$&#123;param.pageNo&#125;&quot; name=&quot;pn&quot; id=&quot;pn_input&quot;/&gt;页 &lt;input id=&quot;searchPageBtn&quot; type=&quot;button&quot; value=&quot;确定&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function ()&#123; //跳到指定的页码 $(&quot;#searchPageBtn&quot;).click(function ()&#123; var pageNo = $(&quot;#pn_input&quot;).val(); //js语言提供了一个location地址栏对象 //它有一个属性叫href，它可以获取浏览器地址栏中的地址 location.href=&quot;$&#123;pageScope.basePath&#125;client/bookServlet?action=page&amp;pageNo=&quot;+pageNo; &#125;); &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;%--静态包含页脚内容--%&gt;&lt;%@include file=&quot;/pages/common/footer.jsp&quot;%&gt;&lt;/body&gt;&lt;/html&gt; 根据价格区间查询数据并分页： 第六阶段：登录登出1、登录a、显示用户名2、登出a、注销用户1、销毁session中用户登录的信息（或者销毁session） 2、重定向到首页或者登录界面 3、表单重复提交有三种常见情况： 1234567891、提交完表单，服务器使用请求转发来进行页面跳转，这个时候用户按下F5功能键，就会发起最后一次的请求，造成表单重复提交问题。解决方法是使用重定向来进行页面跳转2、用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败，就会着急，然后多点了几次提交操作，也会造成表单重复提交3、用户正常提交服务器，服务器也没有延迟，但是提交完成之后，用户回退浏览器，重新提交，也会造成表单重复提交后两种因没有可直接解决的方法，后引入验证码，使用验证码防止用户恶意提交 a、验证码验证码解决表单重复提交的底层原理 b、谷歌kaptcha图片验证码的使用使用步骤如下： 12345678910111213141516171、导入谷歌验证码的jar包（kaptcha-2.3.2.jar）2、在web.xml中去配置用于生成验证码的Servlet程序&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、在表单中使用img标签去显示验证码图片并使用它验证码：&lt;input type=&quot;text&quot; style=&quot;width: 50px; &quot; name=&quot;code&quot;&gt; &lt;img src=&quot;http://localhost:8080/bookTest/kaptcha.jpg&quot; style=&quot;width:110px;height: 20px; &quot; alt=&quot;&quot;&gt;&lt;br/&gt; 4、在服务器获取谷歌生成的验证码，和客户端发送过来的验证码比较使用 4、购物车模块 1、编写购物车模型 2、加入购物车功能的实现 3、购物车的展示 4、删除购物车商品项的功能 5、清空购物车 6、修改商品数量 7、加入购物车提醒功能 5、订单模块 1、创建数据库表 2、编写对应实体类 3、编写dao和测试dao 4、编写service和测试service 5、配置web.xml 6、编写OrderServlet 7、修改页面 第七阶段：权限检查1、使用过滤器拦截 2、ThreadLocal的使用 12345678它可以解决多线程的数据安全问题ThreadLocal它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数据，集合）特点：1、ThreadLocal可以为当前线程关联一个数据（它可以是像Map一样存储数据，key为当前线程）2、每一个ThreadLocal对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象实例3、每个ThreadLocal对象实例定义的时候一般都是static类型4、ThreadLocal中保存数据，在线程销毁后，会由JVM虚拟自动释放 3、使用Filter和ThreadLocal组合管理事务 1、使用ThreadLocal确保所有操作对象都使用同一个连接对象 2、使用Filter统一给所有Service方法都加上try—catch，来实现事物的管理 3、将所有异常都统一交给Tomcat，让Tomcat展示友好的错误信息页面 1在web.xml配置错误页面跳转 第八阶段：AJAx1、使用Ajax验证用户名是否可用 2、使用ajax修改加入购物车功能 第九阶段：1、库存问题 2、其他模块 12var msg = $(this).attr(&#x27;orderMsg&#x27;);alert(msg);","tags":"项目"},{"title":"JDBC","url":"/2022/10/14/JDBC/","text":"JDBC核心技术讲师：宋红康 微博：尚硅谷-宋红康 第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O&#x2F;R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值 jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称 jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名&#x3D;属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一12345678910111213141516171819202122@Test public void testConnection1() &#123; try &#123; //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;abc123&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 说明：上述代码中显式出现了第三方数据库的API 2.4.2 连接方式二123456789101112131415161718192021222324@Test public void testConnection2() &#123; try &#123; //1.实例化Driver String className = &quot;com.mysql.jdbc.Driver&quot;; Class clazz = Class.forName(className); Driver driver = (Driver) clazz.newInstance(); //2.提供url，指明具体操作的数据 String url = &quot;jdbc:mysql://localhost:3306/test&quot;; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;abc123&quot;); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三12345678910111213141516171819202122@Test public void testConnection3() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;abc123&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四12345678910111213141516171819202122232425262728293031323334353637@Test public void testConnection4() &#123; try &#123; //1.数据库连接的4个基本要素： String url = &quot;jdbc:mysql://localhost:3306/test&quot;; String user = &quot;root&quot;; String password = &quot;abc123&quot;; String driverName = &quot;com.mysql.jdbc.Driver&quot;; //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 2.4.5 连接方式五(最终版)123456789101112131415161718192021@Test public void testConnection5() throws Exception &#123; //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); &#125; 其中，配置文件声明在工程的src目录下：【jdbc.properties】 1234user=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。 第3章：使用PreparedStatement实现CRUD操作3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class StatementTest &#123; // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() &#123; Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;; String sql = &quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot; + userName + &quot;&#x27; AND PASSWORD = &#x27;&quot; + password + &quot;&#x27;&quot;; User user = get(sql, User.class); if (user != null) &#123; System.out.println(&quot;登陆成功!&quot;); &#125; else &#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123; T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 3.3.4 使用PreparedStatement实现增、删、改操作1234567891011121314151617181920212223242526//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.closeResource(conn, ps); &#125;&#125; 3.3.5 使用PreparedStatement实现查询操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); &#125; return null;&#125; 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta &#x3D; rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型12345678910111213141516171819//获取连接Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute(); fis.close();JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段1234567891011121314Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型123456789101112131415161718192021222324252627282930313233String sql = &quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(1, 8);rs = ps.executeQuery();if(rs.next())&#123; Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 Blob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(&quot;c.jpg&quot;); byte [] buffer = new byte[1024]; int len ; while((len = is.read(buffer)) != -1)&#123; os.write(buffer, 0, len); &#125; JDBCUtils.closeResource(conn, ps, rs); if(is != null)&#123; is.close(); &#125; if(os != null)&#123; os.close(); &#125; &#125; 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： 1234CREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)); 5.2.1 实现层次一：使用Statement123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123; String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql);&#125; 5.2.2 实现层次二：使用PreparedStatement12345678910111213141516long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 20000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); ps.executeUpdate();&#125; long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//82340 JDBCUtils.closeResource(conn, ps); 5.2.3 实现层次三12345678910111213141516171819202122232425262728293031323334/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */@Testpublic void testInsert1() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625 //1000000条:14733 JDBCUtils.closeResource(conn, ps);&#125; 5.2.4 实现层次四1234567891011121314151617181920212223242526272829303132333435363738/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/@Testpublic void testInsert2() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps);&#125; 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 1234567891011121314151617181920212223242526272829303132333435363738public void testJDBCTransaction() &#123; Connection conn = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); // 4.若没有异常，则提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 5.若有异常，则回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //7.关闭连接 JDBCUtils.closeResource(conn, null, null); &#125; &#125; 其中，对数据库操作的方法为： 1234567891011121314151617181920//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123; PreparedStatement ps = null; try &#123; // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 3.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.关闭资源 JDBCUtils.closeResource(null, ps); &#125;&#125; 6.3 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by &#x27;abc123&#x27;; 授予权限 123456#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; 第7章：DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Book.java】1234567891011121314151617package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123; private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略&#125; 【Page.java】12345678910111213141516package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】12345678910111213package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 12345678910111213//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn;&#125; 获取连接方式二 123456//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123; Connection conn = cpds.getConnection(); return conn;&#125; 其中，src下的配置文件为：【c3p0-config.xml】 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 1234567891011121314public static Connection getConnection3() throws Exception &#123; BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;&#125; 获取连接方式二： 12345678910111213141516171819202122//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123; try &#123; Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public static Connection getConnection4() throws Exception &#123; Connection conn = source.getConnection(); return conn;&#125; 其中，src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 8.3.3 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 123456789101112131415161718package com.atguigu.druid;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;public class TestDruid &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… 测试 12345678910111213// 测试添加@Testpublic void testInsert() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;); System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null);&#125; 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 12345678910111213141516171819/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 1234567891011121314151617181920/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */@Testpublic void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123; @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(&quot;handle&quot;);// return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819202122232425/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */@Testpublic void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一：// String sql = &quot;select count(*) from customers where id &lt; ?&quot;;// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; JDBC总结12345678910111213141516171819202122232425262728293031323334353637总结@Testpublic void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125;","tags":"jdbc"},{"title":"Html和CSS","url":"/2022/10/14/前端基础-三件套/","text":"前端基础—-三件套[TOC] 一、前言Zeal64位下载https://wwr.lanzoui.com/iQhP5urk3gbHtml5文档下载https://wwr.lanzoui.com/iqAiiurklfiCSS3文档下载https://wwr.lanzoui.com/iA86gurklgj文档下载完解压，将html.docset和css.docset放到Zeal-x64&#x2F;docset文件夹下启动zeal.exe程序就可以直接使用了 1、客户端 2、网页 3、历史蒂姆·伯纳斯李爵士— 万维网的发明人 1991年8月6日，世界上第一个服务器和第一个网站在欧洲核子研究中心上线。 第一个网站：http://info.cern.ch/hypertext/WWW/TheProject.html 4、浏览器和网页 5、浏览器的问题 不同浏览器可能解析出来的页面不一样 6、W3C的建立 7、网页的结构 1、结构、表现、行为 结构 HTML用于描述页面的结构 表现 CSS用于控制页面中元素的样式 行为 JavaScript用于响应用户操作 二、HTMLHTML：超文本标记语言 负责网页三要素之中的结构 使用标签的形式来标识网页中的不同组成部分 所谓超文本指的是超链接，使用超链接可以让我们从一个页面跳转到另外一个页面 纯文本只能存储数据 1、第一个网页用记事本编写第一个网页 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;哈哈哈&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 1、根标签&lt;html&gt;&lt;&#x2F;html&gt; 2、头部标签&lt;head&gt;&lt;&#x2F;head&gt; 3、title标签&lt;title&gt;&lt;&#x2F;title&gt; 4、body标签&lt;body&gt;&lt;&#x2F;body&gt; 2、第二个网页用notepad++编写 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;这个第二个网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello第二个网页&lt;/h1&gt; &lt;!--标签一般成对出现，但是也存在一些自结束标签 注释不会在网页中显示，但是可以在网页的源代码中查看 注意:注释不能嵌套--&gt; &lt;!-- &lt;img/&gt; &lt;input/&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 3、第三个网页1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;标签的属性&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 在标签中（开始标签或自结束标签）可以设置属性 属性是一个名值对结构（x=y） 属性可以用来设置标签中的内容如何显示 属性和标签名或其他属性应该用空格隔开 属性不能瞎写，有些属性有属性值，属性值注意不能漏了引号，有些属性没有属性值 可以自定义属性 --&gt; &lt;h1&gt;这是我的&lt;font color=&quot;red&quot; size=&quot;3&quot;&gt;第三个网页!&lt;/font&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 4、第四个网页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!Doctype HTML&gt;&lt;html&gt; &lt;head&gt; &lt;!--可以通过meta标签来设置网页的字符集，避免乱码问题--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;网页的基本结构&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 迭代 网页的版本 HTML4 XHTML2.0 HTML5 ... 文档声明（doctype） -文档声明用来告诉浏览器当前网页的版本 -html的文档声明 &lt;!doctype html&gt; 进制： 十进制：满10进1 -计数：0 1 2 3 4 5 6 7 8 9 10... -单位数字:10个（0-9） 八进制：满8进1 -计数：0 1 2 3 4 5 6 7 10 11 12... -单位数字：8个（0-7） 二进制：满2进1（底层） -计数：0 1 10 11 100 101 110 111... -单位数字：2个（0-1） -扩展: -所有数据在计算机底层都是以二进制形式保存 -可以将内存想象成为一个有多个小各自组成的容器，每一个小格子可以存储一个1或0 一个格子在内存中称为1位（bit） 8bit = 1byte（字节） 最小操作单位字节 1024byte = 1kb（千字节） 1024kb = 1mb（兆字节） 1024mb = 1gb（吉字节） 1024gb = 1tb（特字节） 1024tb = 1pb 十六进制：满16进1（一般显示一个二进制数字时，都会转换位16进制） -计数：0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12... -单位数字：16个（0-f） 字符编码： 小林 -&gt; 1010100101 1010100101 -&gt; 小林 -所有数据在计算机底层都是以二进制形式保存，文字也不例外 所以一段文字在存储进内存时，都会转换成为二进制编码 当我们查看这段文字时，计算机会将编码转换为字符，给我们阅读 -编码 -将字符转换为二进制码 -解码 -将二进制码转换为字符 -字符集（charset） -编码和解码所采用的规则成为字符集 -乱码问题 -如果编码和解码所采用的字符集不同就会出现乱码 -常见的字符集： ASCII ISO88591 GB2312 GBK UTF-8（万国码）首选 --&gt; &lt;/body&gt;&lt;/html&gt; 5、第五个网页 1234567891011121314151617181920212223242526&lt;!--文档声明,声明当前网页的版本--&gt;&lt;!doctype html&gt;&lt;!--html的根标签（元素），网页中所有的内容都要写根元素的里面--&gt;&lt;html&gt; &lt;!--head是网页的头部，head内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎解析网页--&gt; &lt;head&gt; &lt;!-- meta标签用来设置网页的元数据 这里meta用来设置网页的字符集，避免乱码问题 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--title中的内容会显示在浏览器的标题栏，搜索引擎会主要根据title中的内容来判断网页的主要内容--&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;!--body是html是子元素，显示网页的主体，网页中所有可见的内容都要写在body的里面--&gt; &lt;body&gt; &lt;!--h1设置一级标题--&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 6、文档工具网址：w3school 在线教程 软件：zeal 7、vscode123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、安装vscode 2、安装中文语言包 3、安装ayu主题 4、打开一个文件目录 5、创建一个新网页 6、安装liveServer 7、通过liveserver运行网页/livePreview可以在软件中分屏显示 8、设置自动保存 --&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;hhhhhh&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 8、实体12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;实体&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在网页中编写的多个空格默认情况都会自动被浏览器解析为一个空格 在Html中有些时候，不能直接书写一些特殊符号 比如：多个连续空格，比如字母两侧的大于和小于号 如果我们需要在网页书写这些特殊符号，则需要使用html中的实体（转义字符） 实体的语法： &amp;实体的名字; &amp;nbsp;空格 &amp;gt;大于号 &amp;lt;小于号 &amp;copy;版权符号 --&gt; &lt;!-- &amp;nbsp;表示一个空格 --&gt; &lt;p&gt; 今天&amp;nbsp;&amp;nbsp;天气真不错 &lt;/p&gt; &lt;p&gt; &lt;!-- &amp;lt; &amp;gt;分别表示小于号和大于号 --&gt; a&amp;lt;b&amp;gt;c &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 9、meta标签1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- meta标签主要用于设置网页的一些元数据，元数据不是给用户看的 charset：指定网页的字符集 content：指定数据的内容 name：指定数据的名称 keywords 表示网站的关键字（搜索引擎搜索出的关键字）, 可以同时指定多个关键字，关键字间使用,隔开 &lt;meta name=&quot;keywords&quot; content=&quot;qq,微信,淘宝&quot;&gt; description用于指定网站的描述 &lt;meta name=&quot;description&quot; content=&quot;这是一个非常不错的网站&quot;&gt; 网站的描述会显示在搜索引擎的搜索结果中 title标签的内容会作为搜索结果的超链接上的文字显示 --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS,JavaScript&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;这是一个非常不错的网站&quot;&gt; &lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.mozilla.org&quot;&gt; 将页面重定向到另一个网站！！！ --&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt; &lt;title&gt;meta标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 10、语义化标签1.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;语义化标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在网页中HTML专门用来辅助网页的结构 所以在使用html标签时，应该关注的是标签的语义，而不是它的样式 标题标签： h1-h6 一共有六级标题 从h1-h6重要性递减，h1最重要，h6最不重要 h1在网页中的重要性仅次于title标签，一般情况下一个页面只有一个h1标签 一般情况下标题标签只会使用到h1-h3，h4-h6很少用 标题标签都是块元素 在页面中独占一行的元素成为块元素（block element） --&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;h5&gt;五级标题&lt;/h5&gt; &lt;h6&gt;六级标题&lt;/h6&gt; &lt;!-- hgroup标签用来给标题分组，可以将一组相关的标题同时放入到hgroup --&gt; &lt;hgroup&gt; &lt;h1&gt;哈哈哈哈哈&lt;/h1&gt; &lt;h2&gt;六六六六六&lt;/h2&gt; &lt;/hgroup&gt; &lt;!-- p标签表示页面中的一个段落 p也是一个块元素 --&gt; &lt;p&gt;标签表示页面中的一个段落&lt;/p&gt; &lt;p&gt;标签表示页面中的一个段落&lt;/p&gt; &lt;!-- em标签用于表示语音语调的一个加重 在页面中不会独占一行的元素称为行内元素（inline element） --&gt; &lt;p&gt;今天天气&lt;em&gt;真&lt;/em&gt;不错!&lt;/p&gt; &lt;!-- strong表示强调，重要内容！ --&gt; &lt;p&gt;你今天必须&lt;strong&gt;完成作业！&lt;/strong&gt;&lt;/p&gt; 鲁迅说： &lt;!-- blockquote表示一个长引用 --&gt; &lt;blockquote&gt; 这句话我可是从来没说过！ &lt;/blockquote&gt; &lt;!-- q表示一个短引用 --&gt; 子曰：&lt;q&gt;学而时习之，不亦说乎！&lt;/q&gt; &lt;!-- br标签表示页面中的一个换行 --&gt; &lt;br&gt; &lt;br&gt; 今天天气很不错！&lt;/body&gt;&lt;/html&gt; 11、语义化标签2.01234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;语义化标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 块元素（block element） -在网页中一般通过块元素来对页面进行布局 行内元素(inline element) -行内元素主要用来包裹文字 -一般情况下会在块元素中放行内元素，而不会在行内元素中方块元素 -块元素中基本都可以放任何元素 -p元素不能放任何块元素 浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正 比如： 标签写在了根元素的外部 p元素中嵌套了块元素 根元素中出现了除head和body以外的子元素 ... 开发者工具可以看到代码在内存中的存放情况 --&gt; &lt;p&gt; &lt;h1&gt;哈哈&lt;/h1&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12、语义化标签3.012345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 布局标签（结构化语义标签） --&gt; &lt;!-- header表示网页的头部 main表示网页的主体部分,一个页面只会有一个main footer表示网页的底部 nav表示网页中的导航 aside表示和主体相关的其他内容，侧边栏 article表示一个独立的文章 section表示一个独立的区块，上边的标签都不能表示时使用section div没有语义，但它表示一个区块，目前来讲div还是我们主要的布局元素 span是行内元素，没有语义，一般用于在网页中选中文字 --&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt;&lt;/main&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;aside&gt;&lt;/aside&gt; &lt;article&gt;&lt;/article&gt; &lt;section&gt;&lt;/section&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 13、列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 列表(list) 1、铅笔 2、尺子 3、橡皮 在html也可以创建列表，分为三种 1、无序列表 2、有序列表 3、定义列表 无序列表，使用ul标签来创建 使用li标签标识列表的列表项 有序列表，使用ol标签来创建 使用li标签标识列表的列表项 定义列表，使用dl标签来创建 使用dt标签标识定义的内容 使用dd来对内容进行解释说明 列表之间可以互相嵌套 --&gt; &lt;ul&gt; &lt;li&gt;结构&lt;/li&gt; &lt;li&gt;表现&lt;/li&gt; &lt;li&gt;行为&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;结构&lt;/li&gt; &lt;li&gt;表现&lt;/li&gt; &lt;li&gt;行为&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;结构&lt;/dt&gt; &lt;dd&gt;结构表示网页的结构，用来规定网页中哪里是标题，哪里是段落&lt;/dd&gt; &lt;/dl&gt; &lt;ul&gt; &lt;li&gt; aa &lt;ul&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc &lt;ul&gt; &lt;li&gt;ddd&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 14、超链接123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;超链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 超链接可以让我们从一个页面跳转到其他页面 也可以跳转到我们当前页面的其他位置，或者其他页面指定的位置 使用a标签来定义超链接 属性： href：指定跳转的目标路径 -值可以是外部网站的地址 -也可以写一个内部页面的地址 - 超链接也是行内元素，在a标签中可以嵌套除了它自身之外的任何元素 --&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;超链接1&lt;/a&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=&quot;07.列表.html&quot;&gt;超链接2&lt;/a&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=&quot;https://bilibili.com&quot;&gt;超链接3&lt;/a&gt;&lt;br/&gt;&lt;br/&gt; &lt;a href=&quot;https://douyin.com&quot;&gt;超链接4&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 15、相对路径 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 当我们需要跳转到服务器或项目内部的页面时，一般使用相对路径 相对路径都会使用.或..开头 ./ ../ ./可以省略不写，如果不写./也不写../相当于写了./ ./表示当前文件所在目录 - 当前页面就是09.相对路径.html - ./就相当于09.相对路径.html所在的目录path ../表示当前文件所在目录的上一级目录 --&gt; &lt;a href=&quot;../07.列表.html&quot;&gt;超链接1&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;./inner/target.html&quot;&gt;超链接2&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;../out/target2.html&quot;&gt;超链接3&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 16、超链接2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- target属性：用来指定超链接打开的方式 可选值： _self默认值，在当前页面打开超链接 _blank 在新窗口打开超链接 --&gt; &lt;a href=&quot;07.列表.html&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 给其他标签声明id属性 使用#id属性值给href赋值 跳转到指定id值标签位置 --&gt; &lt;a href=&quot;#bottom&quot;&gt;去底部&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;#p3&quot;&gt;去p3&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 在开发中，可以用#作为超链接的路径的占位符使用 --&gt; &lt;a href=&quot;#&quot;&gt;新的超链接&lt;/a&gt; &lt;!-- 可以使用javascript:;来作为href的属性值，此时点击这个超链接不会有反应 --&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;javascript:;&quot;&gt;新的超链接2&lt;/a&gt; &lt;p&gt;书是朋友，它能带着我们畅游知识的海洋；书是老师，在我有问题不懂的时侯，它能给我解答；书是家，在我们孤独寂寞的时候，它能给我们带来温暖和快乐…… 自记事的那天起，无论是幼儿园时看的连环画、小人书，还是一二年级时读的儿童文学，又或是三四五年级时读的少年文学，直到现在，放眼望去，他们都还整整齐齐的在书柜里边儿仿佛排列着队伍等着我随时的检阅。 记得那是一个周末的早上，天有点冷，我包裹着被子把头伸向窗外，雨淅淅沥沥的下着，不愿起床的我随手拿着一本名为《假如给我三天光明》的书看了起来，可是我要怎么理解这本书呢？ 我见过午后明媚的阳光透过学校后面的小树林，随着徐徐微风轻轻地起舞，就像好多星星一样的眼睛又明亮又可爱的在那里眨巴眨巴。 我见过隔壁阿姨家的小朋友，虽然还那么小，每当她从我手里抢走棒棒糖并塞到嘴里的时候，笑得跟朵花儿似的。 我还见过，见过高年级的大哥哥大姐姐们穿着漂亮的衣服照毕业照。想着他们小学的美好时光，就在照相师傅快门咔嚓一声后就永远的定格在了那，我也会想，想自己毕业的那天穿的是不是妈妈特意买的新衣服，扎的是小学时候的羊角辫还是属于初中时的大马尾，无限憧憬无限期望…… 假如给我三天光明，如果可以，我想把它捐给从来就没看见过爸爸妈妈、看见过这个五彩世界的人。大熊猫的世界里还有黑色、白色；而失明人的世界里就只有一种单调的颜色，那就是“黑”。如果这个世界都是盲人，他们不可怜，因为这样就有好多好多人陪在他们的身边，大家互相帮助，一起生活。可是，世界并不是这样，在正常人的世界里，他们需要人帮助。 如果我能借给他们三天光明，我一定要督促他们多走多看，看擦身而过的每一个笑脸； 如果我能借给他们三天光明，我一定要呼吁更多的人帮助他们，在时间没到之前，谁也不许打扰他们； 多美好的“如果”啊！可是，我知道没有如果。 如果可以，我希望能给他们的不是三天光明，我要做一位医生，我要用最先进的仪器和我最精湛的医术给他们一辈子光明。 书，我们的朋友、我们的老师，我们的家，书让我们插上力量的翅膀，飞向美好的明天，也让我们对未来有了无限期待。 &lt;/p&gt; &lt;p&gt;书是朋友，它能带着我们畅游知识的海洋；书是老师，在我有问题不懂的时侯，它能给我解答；书是家，在我们孤独寂寞的时候，它能给我们带来温暖和快乐…… 自记事的那天起，无论是幼儿园时看的连环画、小人书，还是一二年级时读的儿童文学，又或是三四五年级时读的少年文学，直到现在，放眼望去，他们都还整整齐齐的在书柜里边儿仿佛排列着队伍等着我随时的检阅。 记得那是一个周末的早上，天有点冷，我包裹着被子把头伸向窗外，雨淅淅沥沥的下着，不愿起床的我随手拿着一本名为《假如给我三天光明》的书看了起来，可是我要怎么理解这本书呢？ 我见过午后明媚的阳光透过学校后面的小树林，随着徐徐微风轻轻地起舞，就像好多星星一样的眼睛又明亮又可爱的在那里眨巴眨巴。 我见过隔壁阿姨家的小朋友，虽然还那么小，每当她从我手里抢走棒棒糖并塞到嘴里的时候，笑得跟朵花儿似的。 我还见过，见过高年级的大哥哥大姐姐们穿着漂亮的衣服照毕业照。想着他们小学的美好时光，就在照相师傅快门咔嚓一声后就永远的定格在了那，我也会想，想自己毕业的那天穿的是不是妈妈特意买的新衣服，扎的是小学时候的羊角辫还是属于初中时的大马尾，无限憧憬无限期望…… 假如给我三天光明，如果可以，我想把它捐给从来就没看见过爸爸妈妈、看见过这个五彩世界的人。大熊猫的世界里还有黑色、白色；而失明人的世界里就只有一种单调的颜色，那就是“黑”。如果这个世界都是盲人，他们不可怜，因为这样就有好多好多人陪在他们的身边，大家互相帮助，一起生活。可是，世界并不是这样，在正常人的世界里，他们需要人帮助。 如果我能借给他们三天光明，我一定要督促他们多走多看，看擦身而过的每一个笑脸； 如果我能借给他们三天光明，我一定要呼吁更多的人帮助他们，在时间没到之前，谁也不许打扰他们； 多美好的“如果”啊！可是，我知道没有如果。 如果可以，我希望能给他们的不是三天光明，我要做一位医生，我要用最先进的仪器和我最精湛的医术给他们一辈子光明。 书，我们的朋友、我们的老师，我们的家，书让我们插上力量的翅膀，飞向美好的明天，也让我们对未来有了无限期待。 &lt;/p&gt; &lt;p id=&quot;p3&quot;&gt;书是朋友，它能带着我们畅游知识的海洋；书是老师，在我有问题不懂的时侯，它能给我解答；书是家，在我们孤独寂寞的时候，它能给我们带来温暖和快乐…… 自记事的那天起，无论是幼儿园时看的连环画、小人书，还是一二年级时读的儿童文学，又或是三四五年级时读的少年文学，直到现在，放眼望去，他们都还整整齐齐的在书柜里边儿仿佛排列着队伍等着我随时的检阅。 记得那是一个周末的早上，天有点冷，我包裹着被子把头伸向窗外，雨淅淅沥沥的下着，不愿起床的我随手拿着一本名为《假如给我三天光明》的书看了起来，可是我要怎么理解这本书呢？ 我见过午后明媚的阳光透过学校后面的小树林，随着徐徐微风轻轻地起舞，就像好多星星一样的眼睛又明亮又可爱的在那里眨巴眨巴。 我见过隔壁阿姨家的小朋友，虽然还那么小，每当她从我手里抢走棒棒糖并塞到嘴里的时候，笑得跟朵花儿似的。 我还见过，见过高年级的大哥哥大姐姐们穿着漂亮的衣服照毕业照。想着他们小学的美好时光，就在照相师傅快门咔嚓一声后就永远的定格在了那，我也会想，想自己毕业的那天穿的是不是妈妈特意买的新衣服，扎的是小学时候的羊角辫还是属于初中时的大马尾，无限憧憬无限期望…… 假如给我三天光明，如果可以，我想把它捐给从来就没看见过爸爸妈妈、看见过这个五彩世界的人。大熊猫的世界里还有黑色、白色；而失明人的世界里就只有一种单调的颜色，那就是“黑”。如果这个世界都是盲人，他们不可怜，因为这样就有好多好多人陪在他们的身边，大家互相帮助，一起生活。可是，世界并不是这样，在正常人的世界里，他们需要人帮助。 如果我能借给他们三天光明，我一定要督促他们多走多看，看擦身而过的每一个笑脸； 如果我能借给他们三天光明，我一定要呼吁更多的人帮助他们，在时间没到之前，谁也不许打扰他们； 多美好的“如果”啊！可是，我知道没有如果。 如果可以，我希望能给他们的不是三天光明，我要做一位医生，我要用最先进的仪器和我最精湛的医术给他们一辈子光明。 书，我们的朋友、我们的老师，我们的家，书让我们插上力量的翅膀，飞向美好的明天，也让我们对未来有了无限期待。 &lt;/p&gt; &lt;!-- 可以直接将超链接的href属性设置为#，这样点击超链接以后 页面不会发生跳转，而是转到 当前页面的顶部位置 --&gt; &lt;!-- id属性（唯一不重复） -每一个标签都可以添加一个id属性 -id属性就是元素的唯一标识，同一页面不能出现重复的id属性 --&gt; &lt;a id=&quot;bottom&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 17、图片标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 图片标签用于向当前页面中引入一个外部图片 使用img标签来引入外部图片，img标签是一个自结束标签 img这种元素属于替换元素（基于块元素和行内元素之间,具有两种元素的特点） 属性： src 属性指定的是外部图片的路径，路径规则和超链接是一样的 alt 图片的描述，这个描述默认情况下不会显示，有些浏览器会在图片无法加载时显示 搜索引擎会根据alt的内容来识别图片，如果不写alt属性，则图片不会被搜索引擎所收录 width 图片的宽度（单位的像素） height 图片的高度 -宽度和高度如果只修改了一个，则另一个会等比例缩放（一般情况下只指定一个属性） 注意： 一般情况下在pc端，不建议修改图片的大小，需要多大的图片就裁剪多大 但是在移动端，经常需要对图片进行缩放（大图缩小较多） 图片的格式： jpeg（jpg） -支持的颜色比较丰富，不支持透明效果，不支持动图 -一般用来显示图片 gif -支持的颜色比较少，支持简单透明，支持动图 -颜色单一的图片，动图 png -支持的颜色丰富，支持复杂透明，不支持动图 -颜色丰富，复杂透明（专为网页而生） webp -这种格式是谷歌新推出的专门用来表示网页中的一种样式 -它具有其他图片格式所有优点，而且文件还特别的小 -缺点：兼容性不好 base64 -将图片使用base64进行编码，这样可以将图片转换为字符，通过字符的形式来引入图片 -一般都是一些需要和网页一起加载的图片才会使用base64，可以通过百度在线转换 效果一样，用小的 效果不一样，用效果好的（均衡） --&gt; &lt;img src=&quot;./img/女侠客.jpg&quot; width=&quot;500&quot; alt=&quot;松鼠&quot;&gt; &lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.l8B9TkGhy_umXB5oCD8PawHaJ4?w=186&amp;h=248&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot; alt=&quot;钢铁侠&quot;&gt;&lt;/body&gt;&lt;/html&gt; 18、内联框架123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 内联框架，用来向当前页面引入一个其他页面 src指定要引入的网页路径 frameborder指定内联框架的边框 --&gt; &lt;iframe src=&quot;https://www.bilibili.com&quot; width=&quot;600&quot; height=&quot;600&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;h1&gt;没影响&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 19、音频视频123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- audio标签用来向页面中一引入一个外部的音频文件的 音视频文件引入后，默认情况下不允许用户自己控制播放停止 属性： controls 是否允许用户控制播放，没有属性值 autoplay 音频文件是否自动播放 -如果设置了autoplay，则音乐在打开页面时会自动播放 但是目前来说大多数浏览器不会自动对音乐进行播放 loop 音乐是否循环播放 写了就生效 --&gt; &lt;!-- &lt;audio src=&quot;./source/audio.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt; &lt;!-- &lt;audio src=&quot;./source/audio.mp3&quot; controls loop&gt;&lt;/audio&gt; --&gt; &lt;!-- 除了提供src指定外部文件路径以外，还支持通过source标签来指定文件路径 --&gt; &lt;!-- &lt;audio controls&gt; 对不起，您的浏览器不支持播放音频，请升级浏览器！ &lt;source src=&quot;./source/audio.mp3&quot;&gt; &lt;source src=&quot;./source/audio.ogg&quot;&gt; &lt;/audio&gt; --&gt; &lt;!-- 会自动播放 type指定文件格式 audio/mp3 这个基本支持所有浏览器 --&gt; &lt;!-- &lt;embed src=&quot;./source/audio.mp3&quot; type=&quot;&quot;&gt; --&gt; &lt;audio controls&gt; &lt;source src=&quot;./source/audio.mp3&quot;&gt; &lt;source src=&quot;./source/audio.ogg&quot;&gt; &lt;embed src=&quot;./source/audio.mp3&quot; type=&quot;audio/mp3&quot;&gt; &lt;/audio&gt; &lt;!-- 使用video标签引入视频文件 使用方式根audio基本是一样的 属性跟audio差不多 --&gt; &lt;video controls&gt; &lt;source src=&quot;./source/flower.webm&quot;&gt; &lt;source src=&quot;./source/flower.mp4&quot;&gt; &lt;embed src=&quot;./source/flower.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;&lt;/body&gt;&lt;/html&gt; 三、CSS1、css简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;!-- 第二种方式（内部样式表）： -将样式编写到head中的style标签里 然后通过CSS的选择器选中元素并为其设置各种样式 可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用 -内部样式更加方便对样式进行复用 -问题： 内部样式表只能对一个网页起作用 他里边的样式不能跨页面进行复用 --&gt; &lt;!-- &lt;style&gt; p&#123; color: blue; font-size: 50px; &#125; &lt;/style&gt; --&gt; &lt;!-- 第三种方式(外部样式表)最佳实践 -可以将CSS样式编写到一个外部的CSS文件 然后通过link标签来引入外部的CSS文件 -属性: href:css文件的路径 -外部样式表需要通过link标签进行引入, 意味这只要只要想使用这些样式的网页都可以对他进行引用 使样式可以在不同的页面之间进行复用 -将样式编写到外部的css文件中,可以使用到浏览器的缓存机制 从而加快网页的加载是速度,提高用户的体验 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 网页分成三个部分： 结构（HTML） 表现（CSS） 行为（JavaScript） CSS -层叠样式表 -网页实际上是一个多层结构，通过CSS可以分别为网页的每一个层来设置样式 而最终我们看到的只是最上边的一层 -总而言之，CSS是用来设置网页中的元素的样式 --&gt; &lt;!-- 使用CSS来修改元素的样式 第一种方式(内联样式，行内样式）： -在标签内部通过style属性来设置元素的样式 -问题 使用内联样式，样式只能对一个标签生效，如果希望影响到多个元素必须在每一个元素中复制一遍 并且当样式发生变化时，还要一个一个修改，非常不方便 -注意，开发时绝对不要使用内联样式 --&gt; &lt;!-- &lt;p style=&quot;color:green ; font-size: 50px;&quot;&gt;哈哈哈哈哈哈&lt;/p&gt; --&gt; &lt;!-- &lt;p style=&quot;color:green ; font-size:60px&quot;&gt;今天天气真不错！&lt;/p&gt; --&gt; &lt;p&gt;哈哈哈哈哈&lt;/p&gt; &lt;p&gt;hhhh&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2、CSS语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* css中的注释:注释中的内容自动被浏览器所忽略 css的基本语法 选择器 声明块 选择器,通过选择器可以选中页面中的指定元素 比如p的作用就是选择页面中的所有p元素 声明块,通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值,名和值之间以:连接,以;结尾 */ p&#123; color: red; font-size: 20px; &#125; h1&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;111&lt;/p&gt; &lt;p&gt;222&lt;/p&gt; &lt;h1&gt;333&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3、CSS常用选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style&gt; /* 将所有段落设置为红色（字体） 元素选择器 作用：根据标签名来选中指定的元素 语法：标签名&#123;&#125; 例子：p&#123;&#125; h1&#123;&#125; div&#123;&#125; */ /* p&#123; color: red; &#125; h1&#123; color: blue; &#125; */ /* 将DDDDDDD设置为绿色 id选择器 作用：根据元素的id属性值选中一个元素 语法：#id属性值 例子：#box&#123;&#125; */ /* #D&#123; color: green; &#125; */ /* 将A和C设为黄色 class选择器（类选择器） 作用：根据元素的class属性值选择多个元素 语法：.class属性值 例子：.grenn&#123;&#125; class是一个标签的属性，和id属性类似，但是它可以重复使用，id不行 可以为一个元素指定多个class属性,空格隔开即可 */ /* .pink&#123; color: pink; &#125; .big&#123; font-size: 30px; &#125; */ /* 通配选择器 作用：选中页面中的所有元素 语法：*&#123;&#125; */ *&#123; color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;p class=&quot;pink big&quot;&gt;HAHAHAHAHA&lt;/p&gt; &lt;p&gt;BBBBBBBBBB&lt;/p&gt; &lt;p class=&quot;pink&quot;&gt;CCCCCCCCCC&lt;/p&gt; &lt;p id=&quot;D&quot;&gt;DDDDDDDDDD&lt;/p&gt; &lt;p&gt;EEEEEEEEEE&lt;/p&gt; &lt;p&gt;FFFFFFFFFF&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4、复合选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 将class为red的元素设置为红色（字体） */ .red&#123; color: red; &#125; /* 将class为red的div元素字体大小设置为30px */ /* 交集选择器 作用：选中同时符合多个条件的元素 语法：选择器1选择器2选择器n&#123;&#125; 注意点： 如果选择器中有元素选择器，必须使用元素选择器开头 */ div.red&#123; font-size: 30px; &#125; .a.b.c&#123; font-size: 20px; &#125; /* 选择器分组（并集选择器） 作用：同时选择多个选择器对应的元素 语法：选择器1,选择器2,选择器n&#123;&#125; #b1,.p1,h1,span，div.red&#123;&#125; */ h1,span&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;red&quot;&gt;我是div&lt;/div&gt; &lt;p class=&quot;red&quot;&gt;我是p元素&lt;/p&gt; &lt;div class=&quot;red2 a b c&quot;&gt;我是div2&lt;/div&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;span&gt;hhhh&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 5、关系选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 为div的子元素span设置字体颜色为红色 （为div直接包含的span设置字体颜色） 子元素选择器 作用：选中指定父元素的指定子元素 语法：父元素 &gt; 子元素 */ /* div.box &gt; span&#123; color: orange; &#125; */ /* 后代元素选择器： 作用 ：选中指定元素的指定后代元素 语法：祖先 后代 */ /* div span&#123; color: blue; &#125; */ /* 选择下一个兄弟元素 语法：前一个+后一个 注意：如果紧挨着的下一个元素不是指定的元素，则不生效 */ /* p + span&#123; color: aqua; &#125; */ /* 选择所有兄弟元素 语法：兄~弟 注意是兄后面的，前面的不会记录 */ p ~ span&#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 父元素 -直接包含子元素的元素叫做父元素 子元素 -直接被父元素包含的元素是子元素 祖先元素 -直接或间接包含后代元素的元素叫做祖先元素 -一个元素的父元素也是它的祖先元素 -只能有一个父元素，可以有多个祖先元素 后代元素 -直接或简介被祖先元素包含的元素叫做后代元素 -子元素也是后代元素 -可以有多个子元素和后代元素 兄弟元素 -拥有相同父元素的元素是兄弟元素 --&gt; &lt;div class=&quot;box&quot;&gt; 我是一个div &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;p&gt;我是div中的p元素 &lt;span&gt;我是div中的p中的span元素&lt;/span&gt; &lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;span&gt;我是div中的span元素&lt;/span&gt; &lt;/div&gt; &lt;div&gt; 我是div &lt;span&gt;我也是div的子元素&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、属性选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* [属性名]选择含有指定属性的元素 [属性名=属性值]选择含有指定属性和属性值的元素 [属性名^=值]选择属性值以值为开头的元素 [属性名$=值]选择属性值以值结尾的元素 [属性值*=值]选择属性值中含有某值的元素 */ p[title]&#123; color: orange; &#125; p[title=这是c]&#123; font-size: 20px; &#125; p[title^=aa]&#123; font-size: 30px; &#125; p[title$=dd]&#123; color: aqua; &#125; /* p[title*=这是]&#123; font-size: larger; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p title=&quot;aa这是a&quot;&gt;aaaaa&lt;/p&gt; &lt;p title=&quot;aa这是b&quot;&gt;bbbbb&lt;/p&gt; &lt;p title=&quot;这是c&quot;&gt;ccccc&lt;/p&gt; &lt;p title=&quot;这是dd&quot;&gt;ddddd&lt;/p&gt; &lt;p&gt;eeeee&lt;/p&gt; &lt;p&gt;fffff&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、伪类选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 将ul中的第一个li设置为红色 */ /* 伪类（不存在的类，特殊的类） -伪类用来描述一个元素的特殊状态 比如，第一个子元素，被点击的元素，鼠标移入的元素... -伪类一般情况下都是使用:开头 :first-child 第一个子元素 :last-child最后一个子元素 :nth-child(n)选择第n个元素 特殊值： n 全选，取值范围是0到正无穷 2n 或 even 表示选择偶数位的元素 2n+1 或 odd 表示选择奇数位的元素 -以上这些伪类都是根据所有的子元素进行排序的 :first-of-type :last-of-type :nth-of-type() -这几个伪类的功能和上面的类似，不同点是这三个是在同类型进行排序的 - not()否定伪类 -将符合条件的元素从选择器中去除 */ ul &gt; li:first-child&#123; color: red; &#125; ul &gt; li:last-child&#123; color: orange; &#125; ul &gt; li:nth-child(3)&#123; color: blue; &#125; ul &gt; li:first-of-type&#123; color: aqua; &#125; ul &gt; li:not(:nth-child(3)) &#123; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;span&gt;hhh&lt;/span&gt; &lt;li&gt;000&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 8、超链接的伪类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* :link表示没访问过的链接（正常的链接） */ a:link&#123; color: red; &#125; /* :visited表示访问过的链接 由于隐私的原因，所以visted这个伪类只能修改颜色这个样式 */ a:visited&#123; color: blue; &#125; /* :hover用来表示鼠标移入的状态 */ a:hover&#123; color: aqua; font-size: 20px; &#125; /* :active用来表示鼠标点击的状态 */ a:active&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1、访问过的链接 2、没访问过的链接 --&gt; &lt;a href=&quot;https://www.douyin.com&quot;&gt;抖音&lt;/a&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;https://www.baidu123.com&quot;&gt;baidu123&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 9、伪元素选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; font-size: 20px; &#125; /* 伪元素，表示页面中一些特殊的并不真实存在的元素（特殊的元素） 伪元素使用::开头 ::first-letter表示第一个字母 ::first-line表示第一行 ::selection表示选中的内容 ::before元素的开始位置 ::after元素的最后位置 -beforeheafter必须结合content属性来使用 使用before和after添加的内容不能被复制 */ p::first-letter&#123; font-size: 30px; &#125; p::first-line&#123; background-color: aqua; &#125; P::selection&#123; background-color: gray; &#125; /* div::before&#123; content:&#x27;开始无法选中&#x27; ; color: aqua; &#125; div::after&#123; content: &#x27;最后无法选中&#x27;; color: aqua; &#125; */ div::after&#123; content: &#x27;】&#x27;; &#125; div::before&#123; content: &#x27;【&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;q&gt;我自带引号&lt;/q&gt; &lt;div&gt;我是一个div哈哈哈&lt;/div&gt; &lt;p&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Nobis accusantium sed fugiat voluptas consequuntur nisi labore voluptatem quod? Maiores enim, sint placeat corporis qui dolore debitis quae quasi iusto et. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 10、样式的继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 20px; &#125; /* 样式的继承，我们为一个元素设置的样式也会应用到它的后代元素上 继承是发生在祖先和后代之间的 继承的设计是方便我们的开发，利用继承可以将一些通用的样式设置到共同的祖先元素上， 这样只需设置一次即可让所有的元素都具有该样式 注意：并不是所有样式都会被继承， 比如 背景相关 的，布局相关的这些样式 都不会被继承！！！ */ p&#123; color: red; background-color: yellow; &#125; div&#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 我是一个p元素 &lt;span&gt;我是p元素中的span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;我是一个span元素&lt;/span&gt; &lt;div&gt; 我是一个div &lt;span&gt; 我是div中的span &lt;em&gt;我是span中的em&lt;/em&gt; &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 11、选择器的权重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 样式的冲突 -当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就会发生冲突 发生样式冲突时，应用哪个样式值由选择器的权重（优先级）决定 选择器的权重 内联样式 1,0,0,0 id选择器 0,1,0,0 类和伪类选择器 0,0,1,0 元素选择器 0,0,0,1 通配选择器 0,0,0,0 继承的样式 没有优先级 比较优先级时，需要将所有的选择器的优先级相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的） 选择器的累加不会超过其最大的数量级，类选择器再高也不会超过id选择器 如果优先级计算后相同，此时使用靠下的样式，即后面的会覆盖前面的 可以在某一个样式的后边添加！important，则此时该样式会获取到最高的优先级，甚至超过内联样式 注意：在开发中一定要慎用！ */ #box1&#123; color: orange; &#125; .red&#123; color: red; font-size: 30px; &#125; .d1&#123; color: purple !important; &#125; *&#123; font-size: 50px; &#125; div&#123; font-size: 10px; &#125; /* div#box1&#123; color: yellow; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;color: green ;&quot; id=&quot;box1&quot; class=&quot;red d1&quot;&gt; 我是div &lt;span&gt;我是div中的span&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、单位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 长度单位： 像素 -屏幕(显示器)实际上是由一个一个的小点构成的 -不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰 -所以同样的200px在不同的设备下显示效果不一样 百分比 -也可以将属性值设置为相对于父元素属性的百分比 -设置百分比可以使子元素随父元素的改变而改变 em -em是相对于 自身元素 的字体大小来计算的 -1em= 1font-size -em会根据字体大小的改变而改变 rem -rem是相对于 根元素 的字体大小来计算的 */ .box1&#123; width: 300px; height: 100px; background-color: orange; &#125; .box2&#123; width: 50%; height: 50%; background-color: aqua; &#125; .box3&#123; font-size: 30px; /* width: 10em; height: 10em; */ width: 10rem; height: 10rem; background-color: greenyellow; &#125; html&#123; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 13、颜色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width:100px; height: 100px; /* 颜色单位： 在css中可以直接使用颜色名来设置各种颜色，如blue，red，green 但是在css中直接使用颜色名称是非常的不方便的 RGB值： -RGB通过三种原色的不同浓度来调出不同的配色 -R red，G green，B，Blue -每一种颜色的范围在0-255（0%-100%）之间 -语法：RGB(红色，绿色，蓝色) RGBA: 在RGB的基础上增加了A，A用来设置透明效果 第四个值表示不透明度，1为完全不透明，0完全透明 十六进制的RGB值： -语法：#红色绿色蓝色 -颜色浓度：00-ff -每种颜色用两位数字表示 -如果颜色两位两位重复，则可以进行简写 #aabbcc-&gt;#abc HSL值，HSLA值 H色相（0-360） S饱和度，颜色的浓度(0%-100%) L亮度,颜色的亮度(0%-100%) A透明度 */ background-color: red; background-color: rgb(255,0,0); background-color: rgb(0,255,0); background-color: trgb(0,0,255); background-color: rgb(0,0,0); background-color: rgb(255,255,255); background-color: #0037ff; background-color: hsl(80, 100%, 50%); &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三、layout1、文档流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; background-color: yellow; width: 100px; &#125; .box2&#123; background-color: aqua; width: 100px; &#125; #span1&#123; background-color: black; &#125; #span2&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 文档流（normal flow） -网页时一个多层的结构，一层摞着一层 -通过css可以分别为每一层来设置样式 -作为用户来讲只能看到最顶上的一层 -这些层中，最底下的一层称为 文档流 ，文档流是网页的基础 我们所创建的元素默认都是在文档流中进行排列的 -对我们来说元素主要有两个状态 在文档流中 不在文档流中（脱离文档流） -元素在文档流中有什么特点： -块元素 -块元素在页面中独占一行（自上向下垂直排列） -块元素默认宽度是父元素的全部（会把父元素撑满） -默认高度是被内容撑开（子元素） -注意独占一行不受其他影响 -行内元素 -行内元素不会独占页面一行，只占自身的大小 -行内元素在页面中左向右水平排列，如果一行中不能容纳所有的行内元素 则会换到第二行继续自左向右排列（书写习惯一致） -默认宽度和高度都是被内容撑开 --&gt; &lt;div class=&quot;box1&quot;&gt;我是div1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;我是div2&lt;/div&gt; &lt;span id=&quot;span1&quot;&gt;我是span1&lt;/span&gt; &lt;span id=&quot;span2&quot;&gt;我是span2&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 2、盒模型-简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; /* 内容区（content），元素中的所有子元素和文本内容都在内容区中排列 内容区的大小由width和height两个属性来设置 width设置内容区的宽度 height设置内容区的高度 默认情况下设置的是内容区的大小，可以使用box-sizing=&quot;border-box&quot;;设置为边框盒子 */ background-color: aquamarine; width: 200px; height: 200px; /* 边框（border），边框属性盒子边缘，边缘里边属性盒子内部，出了边框都是盒子外部 边框的大小会影响整个盒子的大小 设置边框，至少要设置三个样式 边框的宽度border-width 边框的颜色border-color 边框的样式border-style solid实线 */ border-width: 10px; border-color: red; border-style: solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 盒模型、盒子模型、框模型（box model） -css将页面中的所有元素都设置为了一个矩形的盒子 -将元素设置为矩形的盒子后，对页面的布局就是将不同的盒子摆放到不同的位置 -每一个盒子都由以下几个部分组成 -内容区（content） -内边距（padding） -边框（border） 外边距(margin) --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、盒子模型-边框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; background-color: #bfa; width: 200px; height: 200px; /* 边框 边框宽度 边框颜色 边框的样式 */ /* border-width: 10px; 默认值：一般是3个像素 可以指定四个方向的边框宽度 值的情况： 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 除了border-width还有border-x-width x可以是top，right，bottom，left 颜色风格也是如此 */ color: green; /* border-top-width: 10px; */ /* border-width: 10px 20px 30px 40px; */ /* border-color用来指定边框的颜色，同样可以分别指定四个边框的颜色 也可以省略不写，省略了自动使用color的颜色值 */ /* border-color: orange; */ /* border-style指定边框的样式 solid实线 dotted点状虚线 dashed虚线 double双线 默认值是none：没有边框 */ /* border-style: solid; */ /* border简写属性：可以同时设置边框所有样式，没有顺序要求 除了border以外还有四个border-xx border-top border-right border-bottom border-left */ border: solid 10px orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、盒子模型-内边距12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; background-color: aquamarine; width: 200px; height: 200px; border: 10px orange solid; /* 内边距（padding） -内容区和边框之间的距离是内边距 -一共有四个方向的内边距 padding-top padding-right padding-bottom padding-left -内边距的设置会影响盒子的大小 -背景颜色会延申到内边距上 -盒子的可见框的大小，由内容区和边框和内边距共同决定 所以在计算盒子大小时，需要将这三个区域加一起计算 */ /* padding-top: 100px; padding-left: 100px; padding-right: 100px; padding-bottom: 100px; */ padding: 10px 20px 30px 40px ; padding: 10px 20px 30px; padding: 10px 20px; padding: 10px; &#125; .inner&#123; background-color: yellow; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、盒子模型-外边距123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: aquamarine ; border: 10px red solid; padding: 30px; /* 外边距（margin） -外边距不会影响盒子可见性的大小 -但是会影响盒子的位置 -一共有四个方向的外边距 margin-top 上外边距，设置一个正值，元素向下移动 margin-right 默认情况下设置margin-right不会产生任何效果 margin-bottom 下外边距，设置一个正值，其下边的元素会向下移动 margin-left 左外边距，设置一个正值，元素会向右移动 -元素在页面中是按照自左向右的顺序排列的 所以默认情况下如果我们设置的左和上外边距就会移动自身元素 而设置下和右外边距会移动其他元素 -margin也可以设置负值，如果是负值则元素会向相反的方向移动 -margin的简写 margin可以同时设置四个方向的外边距，用法都一样 ！！！！margin会影响盒子实际占用页面的大小 */ /* margin-top: 100px; margin-left: 100px; */ /* margin-bottom: 100px; */ /* margin-right: 100px; */ /* margin-bottom: 100px;*/ /* margin-top: -200px; margin-left: -200px; */ /* margin-bottom: -100px; */ margin: 100px; &#125; .box2&#123; background-color: orange; width: 280px; height: 280px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、盒子-水平布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .outer&#123; width: 800px; height: 200px; border: orange 10px solid; &#125; .inner&#123; width:200px; height: 200px; background-color: #bfa; /* 元素的水平方向的布局： 元素在器父元素中水平方向的位置由以下几个属性共同决定： margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式 margin-left+border-left+padding0-left+width+margin-right+border-right+padding-right=其父元素内容区的宽度（必须满足） 0+0+0+200+0+0+0 = 800？ 以上等式必须满足，如果相加结果使等式不满足，则称为过度约束，则等式会自动调整 -调整的情况： -如果这七个值中没有为auto的情况，则浏览器会自动调整margin-right的值以使等式满足 -这7个值钟有三个值可以设置为auto width margin-left margin-right -如果某个值为auto，则会调整auto那个值以使等式满足 -例子：width为auto，其他不设置，则width为被调整为800 width默认为auto -如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0 -如果将三个值都设置为auto，则外边距都是0，宽度设置为最大 -如果将两个外边距设置为auto，width为固定值，则会外边距平分 所以我们经常利用这个特点来使一个元素在其父元素中水平居中 示例： width：xxpx; margin:0 auto; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、盒子-垂直方向布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .outer&#123; background-color: #bfa; height: 600px; /* 默认情况下父元素的高度被内容撑开 */ &#125; .inner&#123; height: 200px; width:100px; background-color: orange; margin-bottom: 100px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; /* 子元素在父元素的内容区中排列的 如果子元素的大小超过了父元素，则子元素会从父元素中溢出 使用overflow属性来设置父元素如何处理溢出的子元素 可选项 visible：默认值，子元素会从父元素溢出，在父元素外的位置显示 hidden：溢出内容会被裁剪不会显示 scroll：生成两个滚动条，通过滚动条来查看完整的内容 auto：根据需要生成滚动条 overflow-x overflow-y */ overflow: auto; &#125; .box2&#123; width: 100px; height: 400px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; --&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8、外边距的折叠123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1,.box2&#123; width: 200px; height: 200px; font-size: 100px; &#125; .box1&#123; background-color: #bfa; /* 设置一个下外边距 */ margin-bottom: 100px; &#125; /* 垂直外边距的重叠（折叠） -相邻的垂直方向外边距会发生重叠现象 -兄弟元素 -兄弟元素间的相邻的垂直外边距会取两者之间的较大值（两者都是正值） -特殊情况： 如果相邻的外边距一正一负，则取两者的和 如果相邻的外边距都是负值，则取绝对值较大的 -兄弟元素之间的外边距的重叠，对于开发时有利的，所以我们不需要处理 -父子元素 -父子元素间相邻的外边距，子元素会传递给父元素（上外边距） -父子外边距的折叠会影响到页面的布局，必须要进行处理 */ .box2&#123; background-color: orange; /* 设置一个上外边距 */ margin-top: 100px; &#125; .box3&#123; width: 200px; height: 200px;/*199px*/ background-color: #bfa; /* padding-top: 100px; */ /* border: top 1px #bfa solid ; */ &#125; .box4&#123; width: 100px; height: 100px;/*99px*/ background-color: orange; /* margin-top: 100px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; --&gt; &lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9、行内元素的盒模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .s1&#123; background-color: yellow; /* 行内元素的盒模型 -行内元素不支持设置宽度和高度 -行内元素可以设置padding。但是垂直方向不会影响页面的布局（会覆盖） -行内元素可以设置border，垂直方向不会影响页面布局 -行内元素可以设置margin，垂直方向不会影响页面布局 */ /* width: 100px; height: 100px; */ /* padding: 100px; */ /* border: 100px solid red; */ &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; &#125; a&#123; width: 100px; height: 100px; /* display用来设置元素的显示类型 可选值： inline将元素设置为行内元素 block将元素设置为块元素 inlin-block 将元素设置为行内块元素 行内块元素，既可以设置宽度和高度又不会独占一行 table 将元素设置为一个表格 none元素不在页面中显示。隐藏且不占据位置 visbility用来设置元素的显示状态 可选择： visible默认值，元素在页面中正常显示 hidden元素在页面中隐藏不显示，但依然会占据页面的位置 */ /* display: block; */ background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:;&quot;&gt;超链接&lt;/a&gt; &lt;span class=&quot;s1&quot;&gt;我是span&lt;/span&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 10、浏览器的默认样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/normalize.css&quot;&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; --&gt; &lt;!-- 重置样式表,专门用来对浏览器的样式进行重置的 reset.css直接去除了浏览器的默认样式 normalize.css对默认样式进行统一 --&gt; &lt;style&gt; /* 默认样式： -通常情况下，浏览器都会为元素设置一些默认样式 -默认样式的存在会影响页面的布局， 通常情况下我们在编写网页时要去除浏览器的默认样式（pc端网页） */ /* body&#123; margin: 0px; &#125; p&#123; margin: 0px; &#125; */ /* ul&#123; margin: 0px; padding: 0px; /* 去除项目符号 * / list-style: none; &#125; */ /* *&#123; margin: 0px; padding: 0px; &#125; */ .box1&#123; width: 100px; height: 100px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 11、盒子的尺寸123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: #bfa; padding: 10px; border: 10px red solid; /* 默认情况下，盒子的可见框的大小由内容区，内边距和边框共同决定 box-sizing，用来设置盒子尺寸的计算方式（设置width和height的作用） 可选值： content-box默认值，宽度和高度用来设置内容区的大小 border-box 宽度和高度用来设置整个盒子的可见框的大小 width和height指的是内容区和内边距和边框的总大小 */ box-sizing: content-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、轮廓阴影和圆角12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: #bfa; /* border: 10px red solid; */ /* outline用来设置元素的轮廓线。用法和border一样 轮廓和边框不同的点，就是轮廓不会影响到可见框的大小 */ /* box-shadow用来设置元素的阴影效果，不会影响页面的布局 第一个值：水平偏移量 设置阴影的水平位置 正值向右移动，负值向左移动 第二个值：垂直偏移量 设置阴影额垂直位置 正值向下移动，负值向上移动 第三个值：阴影的模糊半径 第四个值：阴影的颜色 */ box-shadow: 20px 20px 20px gray; &#125; /* .box1:hover&#123; outline: 10px red solid; &#125; */ .box2&#123; width: 200px; height: 200px; background-color: orange; /* border-radius: ;设置圆角 还有另外四个方向的样式 左上 右上 左下 右下 */ /* 可以指定两个值，第一个x方向的半径，第二个y方向的半径 */ /* border-top-left-radius: 50px 80px; */ /* 可以分别指定四个角的值 四个值：左上 右上 右下 左下（顺时针） 三个值：左上 右上/左下 右下 两个值：左上/右下 右上/左下 一个值：全部角 */ border-radius: 30px; /* 用/隔开指定两个值，变椭圆的两个半径 */ /* border-radius: 30px / 70px;*/ /* 将元素设置为一个圆形 */ /* border-radius: 50%; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;span&gt;hello&lt;/span&gt; --&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、练习1、图片列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;图片列表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; /* 设置body的背景颜色 */ body&#123; background-color: antiquewhite; &#125; /* 设置外部ul的样式 */ .img-list&#123; /* 设置ul宽度 */ width:190px; /* 设置ul高度 */ height: 470px; /* 裁剪溢出的内容 */ overflow: hidden; /* 使ul在页面中居中 */ margin: 50px auto; background-color: rgb(244, 244, 244); &#125; /* 设置li的位置 */ .img-list li:not(last-child)&#123; margin-bottom: 9px; &#125; /* 设置图片大小 */ .img-list img&#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; --&gt; &lt;ul class=&quot;img-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;./img/01/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;./img/01/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;./img/01/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2、京东的左侧导航123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;京东侧边导航&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; /* 设置body背景颜色 */ body&#123; /* 设置网页背景颜色方便查看 */ background-color: #bfa; &#125; /* 设置菜单外部容器 */ .left-nav&#123; /* 设置宽度 */ width: 190px; /* 设置高度 */ height: 450px; /* 设置padding */ padding: 10px 0; /* 设置背景颜色 */ background-color: #fff; margin: 50px auto; &#125; /* 设置菜单内部item */ .left-nav .item&#123; height: 25px; /* 要让一个文字在其父元素中垂直居中，只需要将父元素的line-height设置为一个和父元素height一样的值 */ line-height: 25px; /* margin-left: 18px; */ /* 设置item的左内边距，将文字向右移动18px */ padding-left: 18px; font-size: 12px; &#125; /* 为item设置一个鼠标移入的状态 */ .item:hover&#123; background-color: #d9d9d9; &#125; /* 设置超链接的颜色 */ .item a&#123; /* 设置字体大小 */ font-size: 14px; /* 设置字体颜色 */ color: rgb(9, 5, 5); /* 去除下划线 */ text-decoration: none; &#125; .item a:hover&#123; color: #c81623; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个外部的容器 nav(div) div(div) ul(li) --&gt; &lt;nav class=&quot;left-nav&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;家用电器&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;运营商&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;数码&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;电脑&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;办公&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;家居&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;家具&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;家装&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;厨具&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;男装&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;女装&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;童装&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;内衣&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;美妆&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;个护清洁&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;宠物&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;女鞋/ &lt;a href=&quot;#&quot;&gt;箱包&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;钟表&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;珠宝&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;男鞋&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;运动&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;户外&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;房产&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;汽车&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;汽车用品&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;母婴&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;玩具乐器&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;食品&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;酒类&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;生鲜&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;特产&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;艺术&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;礼品鲜花&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;农资绿植&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;医药保健&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;计生情趣&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;图书&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;文娱&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;电子书&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;机票&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;酒店&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;旅游&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;生活&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;理财&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;众筹&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;白条&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;保险&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;安装&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;维修&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;清洗&lt;/a&gt;/&lt;a href=&quot;#&quot;&gt;二手&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;工业品&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 3、网易新闻导航123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;网易新闻导航&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; body&#123; background-color:aqua ; &#125; /* 设置容器的样式 */ .news-wrapper&#123; /* 设置宽度 */ width: 300px; /* 设置高度 */ height: 357px; /* 设置居中 */ margin:50px auto; /* 设置背景颜色 */ background-color: #fff; /* 设置上边框 */ border-top: 1px solid #ddd; &#125; /* 设置news-title */ .news-title&#123; /* 为了边框和文字宽度一致，需要将h2转换为行内块元素 */ display: inline-block; height: 30px; border-top: 1px solid red; /* 通过margin-top将h2上移，盖住上边框 */ margin-top: -1px; line-height: 30px; &#125; /* 设置title中的超链接 */ .news-title a&#123; /* 去除下划线 */ text-decoration: none; /* 设置颜色 */ color: #40406B; /* 设置文字的加粗效果 */ font-weight: bold; &#125; a&#123; /* 统一去除下划线 */ text-decoration: none; &#125; /* 设置图片容器的高度 */ .news-img&#123; height: 150px; &#125; /* 设置图片文字效果 */ .news-img .img-title&#123; /* font-size: 15px; */ /* 向上移动文字 */ margin-top: -30px; /* 设置字体颜色 */ color: #fff; /* 设置加粗 */ font-weight: bold; padding-left: 30px; &#125; /* 设置新闻列表 */ .news-list&#123; /* 设置上外边距 */ margin-top: 20px; /* 设置左外边距 */ /* padding-left: 14px; */ /* 设置项目符号 */ /* list-style: square; */ &#125; /* 设置li */ .news-list li&#123; /* 设置下外边距 */ margin-bottom: 17px; &#125; /* 设置li中的文字 */ .news-list a&#123; /* 设置字体大小 */ font-size: 14px; /* 设置字体颜色 */ color: #666; &#125; /* 设置a标签鼠标移入效果 */ .news-list a:hover&#123; color: red; &#125; /* 伪元素为每一个li添加项目符号 */ .news-list li::before&#123; content: &#x27;■&#x27;; color: rgb(218, 218, 218); font-size: 10px; margin-right: 4px; margin-left: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建新闻列表外层的容器 --&gt; &lt;div class=&quot;news-wrapper&quot;&gt; &lt;!-- 创建一个标题标签 --&gt; &lt;h2 class=&quot;news-title&quot;&gt; &lt;a href=&quot;#&quot;&gt;体育&lt;/a&gt; &lt;/h2&gt; &lt;!-- 创建图片容器 --&gt; &lt;div class=&quot;news-img&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/03/1.jpeg&quot; alt=&quot;费德勒&quot;&gt; &lt;!-- 创建图片标题 --&gt; &lt;h3 class=&quot;img-title&quot;&gt; 费德勒首负迪米 扶额摇头不满发挥 &lt;/h3&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 新闻列表 --&gt; &lt;ul class=&quot;news-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;乔治:我爱LA 喜欢和LBJ一起打球&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;格林:3年前降薪就在等KD 特别T恤嘲讽LBJ&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;塔克4000双鞋让保罗羡慕嫉妒 乔丹被震惊&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;CBA下季新赛制:常规赛4组循环 增至46轮&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、w3school导航条12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;w3school导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; .nav-wrapper &#123; background-color: gainsboro; height: 40px; width:1100px; /* padding-left: 32px; */ &#125; li&#123; float: left; /* width: 170px; */ /* margin-right: 72px; */ line-height: 40px; &#125; li a&#123; color: rgb(127, 127, 126); text-decoration: none; text-align: center; padding: 0 35px; &#125; li:hover&#123; background-color: #3F3F3F; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav-wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;HTML/CSS&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Browser Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Server Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Programming&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;XML&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Web Building&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Reference&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; .nav&#123; /* 设置宽度高度*/ height: 48px; width: 1200px; /* 设置背景颜色 */ background-color: gainsboro; /* 设置居中 */ margin: 100px auto; &#125; /* 设置nav中的li */ .nav li&#123; /* 设置li向左浮动，已使菜单横向排列 */ float: left; /* 设置li高度和垂直居中 */ line-height: 48px; /* height: 48px; */ &#125; .nav a&#123; /* 将a转换为块元素 */ display: block; /* 去除下划线 */ text-decoration: none; /* 字体颜色和大小 */ color: #777777; font-size: 18px; padding: 0 39px; &#125; /* 设置鼠标移入效果 */ .nav a:hover&#123; background-color: #3F3F3F; color: #E8E7E3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建导航条的结构 --&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;HTML/CSS&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Browser Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Server Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Programming&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Xml&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Web Buliding&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Reference&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5、京东轮播图（仅布局）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;京东轮播图&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; /* 设置图片的容器 */ .img-list&#123; width: 590px; height: 470px; margin: 100px auto; /* 为ul开启相对定位，目的是使ul中的pointer可以相对于ul定位而不是相对于初始包含块定位 */ position: relative; &#125; .img-list li&#123; position: absolute; &#125; /* 通过修改元素的层级来显示指定的图片 */ .img-list li:nth-child(4)&#123; z-index: 1; &#125; /* 设置导航点的样式 */ .pointer&#123; position: absolute; z-index: 9999; bottom: 20px; left: 40px; &#125; .pointer a&#123; /* display: block; */ /* 设置元素向左浮动 */ float: left; width: 10px; height: 10px; margin: 0px 2px; border-radius: 50%; background-color: rgba(255,255,255,0.6); /* 将背景颜色只设置到内容区，边框和内边距不再有背景颜色 */ background-clip: content-box; border: 2px solid transparent; &#125; .pointer a.active, .pointer a:hover&#123; background-color: #fff; border:2px solid rgba(255,255,255,0.6) ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;img-list&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;img src=&quot;./img/05/8.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;div class=&quot;pointer&quot;&gt; &lt;a class=&quot;active&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 6、京东顶栏导航条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;京东顶部导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; &lt;style&gt; body&#123; /* 设置字体 */ font: 12px/1.5 Microsoft YaHei,HeTi SC,tahoma,arial; &#125; .clearfix::before, .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; /* 设置外部容器样式 */ .top-bar-wrapper&#123; height: 30px; /* 设置宽度 */ width: 100%; /* 设置背景颜色 */ background-color: #E3E4E5; /* height: 30px; */ /* 设置边框 */ border-bottom: 1px #dddddd solid; /* 设置行高 */ line-height: 30px; &#125; /* 设置内部容器样式 */ .top-bar&#123; /* 固定宽度 */ width: 1190px; /* 设置水平居中 */ margin: 0 auto; position: relative; &#125; /* 设置字体颜色样式 */ .top-bar a, .top-bar span, .top-bar i&#123; color: #999; text-decoration: none; &#125; /* 设置鼠标移入效果 */ .top-bar a:hover, .top-bar a.highlight&#123; color: #f10215; &#125; /* 设置location */ .location&#123; float: left; &#125; /* 设置location下的小图标 */ .location .fas&#123; /* font-size: 14px; */ color: #f10215; &#125; /* 设置城市列表效果 */ .location .city-list&#123; width: 300px; height: 436px; background-color: white; border: 1px solid rgb(204, 204, 204); display: none; /* 设置绝对定位，使其不占据页面的位置 */ position: absolute; top: 31px; z-index: 999; box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2); &#125; /* 当鼠标移入到location时，让city-list显示 */ .location:hover .city-list&#123; display: block; &#125; .current-city&#123; padding: 0 10px; /* background-color: white; border: 1px solid rgb(204,204,204); border-bottom: none; */ border: 1px solid transparent; border-bottom: none; position: relative; z-index: 9999; &#125; /* 设置current-city的移入效果 */ .location:hover .current-city&#123; background-color: white; border: 1px solid rgb(204,204,204); border-bottom: none; padding-bottom: 1px; &#125; /* 设置shortcut */ .shortcut&#123; float: right; &#125; /* 设置分割线 */ .shortcut .line&#123; width: 1px; height: 10px; background-color: rgb(204, 202, 202); margin: 12px 12px 0; &#125; /* 设置li */ .shortcut li&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建外围容器 --&gt; &lt;div class=&quot;top-bar-wrapper clearfix&quot;&gt; &lt;!-- 创建内层容器 --&gt; &lt;div class=&quot;top-bar&quot;&gt; &lt;!-- 左侧位置菜单 --&gt; &lt;div class=&quot;location&quot;&gt; &lt;div class=&quot;current-city&quot;&gt; &lt;i class=&quot;fas fa-map-marker-alt&quot;&gt;&lt;/i&gt; &lt;a href=&quot;javascript:;&quot;&gt;北京&lt;/a&gt; &lt;/div&gt; &lt;!-- 放置城市列表 --&gt; &lt;div class=&quot;city-list&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 右侧快捷菜单 --&gt; &lt;ul class=&quot;shortcut clearfix&quot;&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;你好,请登录&lt;/a&gt; &lt;a class=&quot;highlight&quot; href=&quot;javascript:;&quot;&gt;免费注册&lt;/a&gt; &lt;/li&gt; &lt;!-- 分割线 --&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;我的订单&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;我的京东&lt;/a&gt; &lt;i class=&quot;fas fa-angle-down&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;京东会员&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;a class=&quot;highlight&quot; href=&quot;javascript:;&quot;&gt;企业采购&lt;/a&gt; &lt;i class=&quot;fas fa-angle-down&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;span&gt;客户服务&lt;/span&gt; &lt;i class=&quot;fas fa-angle-down&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;span&gt;网站导航&lt;/span&gt; &lt;i class=&quot;fas fa-angle-down&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt; &lt;span&gt;手机京东&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、背景练习1—-背景重复12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 990px; height: 32px; margin: 0 auto; /* background-image: url(&quot;./img/07/bg.png&quot;); background-repeat: repeat-x; */ background: url(&quot;./img/07/bg.png&quot;) repeat-x; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8、按钮练习1.012345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a:link&#123; display: block; width: 93px; height: 29px; background-image: url(&quot;./img/08/link.png&quot;); &#125; a:hover&#123; background-image: url(&quot;./img/08/hover.png&quot;); &#125; a:active&#123; background-image: url(&quot;./img/08/active.png&quot;); &#125; /* 图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载 浏览器加载外部资源是按需加载的，用则加载，不用则不需要加载 像我们上边的练习link会首先加载，而hover和active会在指定状态触发时才会加载 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 9、按钮练习2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a:link&#123; display: block; width: 93px; height: 29px; background-image: url(&quot;./img/09/btn.png&quot;); &#125; a:hover&#123; background-position: -93px 0; &#125; a:active&#123; background-position: -186px 0; &#125; /* 解决图片闪烁的问题 可以将多个小图片保存到一个大图片中，然后通过调整background-position来显示图片的部分 这样图片会同时加载到网页中，就可以有效的避免出现闪烁的问题 这个技术在网页中应用很广泛，被称为css-Sprite，这种图被称为雪碧图 雪碧图的使用步骤： 1、先确定要使用的图标 2、测量图标的大小 3、根据测量结果来创建一个元素 4、将雪碧图设置为元素的背景图片 5、设置偏移量以显示正确的图标 雪碧图的特点： 一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户体验 */ .box1&#123; width: 128px; height: 46px; background-image: url(./img/09/amazon-sprite_.png); &#125; .box2&#123; width: 42px; height: 30px; background-image: url(&quot;./img/09/amazon-sprite_.png&quot;); background-position: -58px -338px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 10、电影卡片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; &lt;style&gt; .outer&#123; width: 240px; margin: 100px auto; /* 设置阴影 */ box-shadow: 0 0 10px rgba(0,0,0,.3); &#125; /* 设置图片 */ .img-wrapper img&#123; width: 100%; vertical-align: bottom; &#125; .info&#123; padding: 0 18px; font-size: 14px; color: #acaaaa; &#125; /* 设置标题 */ .info .title&#123; color: #717171; font-size: 18px; margin: 13px 0 15px 0; &#125; /* .info .category&#123; font-size: 14px; color: #acaaaa; &#125; */ .info .category i&#123; margin-right: 7px; margin-left: 4px; &#125; /* 设置简介的样式 */ .info .intro&#123; margin-left: 4px; margin-top: 18px; margin-bottom: 18px; line-height: 20px; &#125; /* 设置评价样式 */ .star-wrapper&#123; line-height: 46px; height: 46px; border-top: 1px solid #e9e9e9; color: #ddd; padding: 0 16px; &#125; /* 设置星星样式 */ .star&#123; float: left; &#125; .star-wrapper .light&#123; color: #b9cb41; &#125; /* 设置微博 */ .star-wrapper .weibo&#123; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个外层容器 --&gt; &lt;div class=&quot;outer&quot;&gt; &lt;!-- 创建图片容器 --&gt; &lt;div class=&quot;img-wrapper&quot;&gt; &lt;img src=&quot;./img/10/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 创建内容区容器 --&gt; &lt;div class=&quot;info&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; 熊出没之拯救公主 &lt;/h2&gt; &lt;h3 class=&quot;category&quot;&gt; &lt;i class=&quot;fas fa-map-marker-alt&quot;&gt;&lt;/i&gt; 动画 &lt;/h3&gt; &lt;p class=&quot;intro&quot;&gt; 熊大和熊二经历九九八十一难成功救下了美丽的公主! &lt;/p&gt; &lt;/div&gt; &lt;!-- 创建评分的容器 --&gt; &lt;div class=&quot;star-wrapper&quot;&gt; &lt;!-- 创建星星 --&gt; &lt;ul class=&quot;star&quot;&gt; &lt;li class=&quot;fas fa-star light&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star light&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star light&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 创建微博图标 --&gt; &lt;ul class=&quot;weibo&quot;&gt; &lt;li class=&quot;fab fa-weibo&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 11、米兔的动画1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; height: 271px; width: 132px; margin: 0 auto; background-image: url(&quot;./img/11/bigtap-mitu-queue-big.png&quot;); background-position: 0 0; transition: all 1s steps(3); &#125; .box1:hover&#123; background-position: -396px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、奔跑的少年123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 256px; height: 256px; margin: 0,auto; background-image: url(&quot;./img/12/bg2.png&quot;); animation: run 1s steps(6) infinite; &#125; /* 创建关键帧 */ @keyframes run&#123; form&#123; background-position: 0 0; &#125; to&#123; background-position: -1536px 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 13、鸭子表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .clock-wrapper&#123; width: 500px; height: 500px; margin: 0 auto; margin-top: 100px; /* background-color: #bfa; */ border-radius: 50%; /* border:10px solid black; */ position: relative; background-image: url(./img/13/bg3.jpg); background-size: cover; &#125; .clock-wrapper&gt;div&#123; top: 0; position: absolute; left: 0; bottom: 0; right: 0; margin: auto; &#125; /* 设置时针 */ .hour-wrapper&#123; width: 70%; height: 70%; /* background-color: #bfa; */ animation: run 86400 linear infinite; &#125; .hour&#123; height: 50%; width: 6px; background-color: #000; margin: 0 auto; &#125; /* 设置分针 */ .min-wrapper&#123; height: 80%; width: 80%; /* background-color: #bfa; */ animation: run 3600s steps(3600) infinite; &#125; .min&#123; height: 50%; width: 4px; background-color: #000; margin: 0 auto; &#125; /* 设置秒针 */ .sec-wrapper&#123; height: 95%; width: 95%; animation: run 60s steps(60) infinite; &#125; .sec&#123; height: 50%; width: 2px; background-color: #f00; margin: 0 auto; &#125; /* .sec-wrapper&#123; width: 500px; height: 500px; background-color: #bfa; border-radius: 50%; animation: run 60s; &#125; */ /* .sec&#123; height: 250px; width: 4px; background-color: red; margin: 0 auto; animation: run 60s; &#125; */ /* 旋转的关键帧 */ @keyframes run &#123; from&#123; transform: rotate(0); &#125; to&#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;sec-wrapper&quot;&gt;&lt;div class=&quot;sec&quot;&gt;&lt;/div&gt;&lt;/div&gt; --&gt; &lt;!-- 创建表的容器 --&gt; &lt;div class=&quot;clock-wrapper&quot;&gt; &lt;!-- 创建时针 --&gt; &lt;div class=&quot;hour-wrapper&quot;&gt; &lt;div class=&quot;hour&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 创建分针 --&gt; &lt;div class=&quot;min-wrapper&quot;&gt; &lt;div class=&quot;min&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 创建秒针 --&gt; &lt;div class=&quot;sec-wrapper&quot;&gt; &lt;div class=&quot;sec&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 14、复仇者联盟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html&#123; perspective: 800px; &#125; .cube &#123; width: 200px; height: 200px; /* background-color: #bfa; */ margin: 100px auto; /* 设置3d变形效果 */ transform-style: preserve-3d; /* transform: rotateX(45deg) rotateZ(45deg); */ animation: rotate 20s infinite linear; /* transform:rotateY(45deg) scaleZ(2); */ &#125; .cube&gt;div &#123; width: 200px; height: 200px; /* 为元素设置透明效果 */ opacity: 0.7; position: absolute; &#125; img &#123; vertical-align: top; &#125; .box1 &#123; transform: rotateY(90deg) translateZ(100px); &#125; .box2 &#123; transform: rotateY(-90deg) translateZ(100px); &#125; .box3 &#123; transform: rotateX(90deg) translateZ(100px); &#125; .box4 &#123; transform: rotateX(-90deg) translateZ(100px); &#125; .box5 &#123; transform:rotateY(180deg) translateZ(100px); &#125; .box6 &#123; transform: rotateY(0deg) translateZ(100px); &#125; @keyframes rotate &#123; form&#123; transform:rotateX(0) rotateZ(0) &#125; to&#123; transform:rotateX(1turn) rotateZ(1turn) &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个外部的容器 --&gt; &lt;div class=&quot;cube&quot;&gt; &lt;!-- 引入图片 --&gt; &lt;div class=&quot;box1&quot;&gt; &lt;img src=&quot;./img/14/1.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;img src=&quot;./img/14/2.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt; &lt;img src=&quot;./img/14/3.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box4&quot;&gt; &lt;img src=&quot;./img/14/4.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box5&quot;&gt; &lt;img src=&quot;./img/14/5.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box6&quot;&gt; &lt;img src=&quot;./img/14/6.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 15、弹性的w3导航条12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; .nav&#123; width: 1210px; height: 48px; line-height: 48px; margin: 50px auto; background-color: #E8E7E3; display: flex; &#125; .nav li&#123; /* 设置增长系数 */ flex-grow: 1; &#125; .nav a &#123; display: block; color: #808080; text-decoration: none; font-size: 16px; text-align: center; &#125; .nav a:hover&#123; background-color: #636363; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML/CSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Browser Side&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Server Side&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Programming&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;XML&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Web Building&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 16、淘宝导航条—-弹性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; /* 设置外层容器 */ .nav&#123; width: 400px; margin: 100px auto; &#125; /* 设置每一行的容器 */ .nav-inner&#123; /* 设置为弹性容器 */ display: flex; /* 设置主轴的空白分布 */ justify-content: space-around; &#125; .item&#123; width: 18%; /* background-color: #bfa; */ /* flex: auto; */ text-align: center; &#125; .item img&#123; /* 设置图片宽度和父元素宽度一样 */ width: 100%; &#125; .item a&#123; text-decoration: none; color: #333; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建一个外层的容器 --&gt; &lt;nav class=&quot;nav&quot;&gt; &lt;div class=&quot;nav-inner&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;天猫&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/2.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;聚划算&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/3.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;天猫国际&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/4.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;外卖&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/5.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;天猫超市&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;nav-inner&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/6.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;充值中心&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/7.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;飞猪旅行&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/8.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;领金币&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/9.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;拍卖&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/16/10.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;分类&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 17、移动端网页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;学习&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建头部容器 --&gt; &lt;div class=&quot;top-bar&quot;&gt; &lt;div class=&quot;menu-btn&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-stream&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;h1 class=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot;&gt; 爱学习 &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;search-btn&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- banner --&gt; &lt;div class=&quot;banner&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/17/banner.png&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;menu&quot;&gt; &lt;a class=&quot;course&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-book&quot;&gt;&lt;/i&gt; 我的课程 &lt;/a&gt; &lt;a class=&quot;star&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-cut&quot;&gt;&lt;/i&gt; 明星讲师 &lt;/a&gt; &lt;a class=&quot;sub&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt; 我的订阅 &lt;/a&gt; &lt;a class=&quot;download&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-globe&quot;&gt;&lt;/i&gt; 我的下载 &lt;/a&gt; &lt;/div&gt; &lt;!-- 课程列表 --&gt; &lt;div class=&quot;course-list&quot;&gt; &lt;!-- 列表标题 --&gt; &lt;div class=&quot;title&quot;&gt; &lt;h2&gt;最新课程&lt;/h2&gt; &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;更多+&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;course-list&quot;&gt; &lt;!-- 列表标题 --&gt; &lt;div class=&quot;title&quot;&gt; &lt;h2&gt;最新课程&lt;/h2&gt; &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;更多+&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;!-- 封面 --&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 小标题 --&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; less 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178*&#123; margin: 0; padding: 0;&#125;@total-width: 750;.w&#123; width: (693/40rem); margin: 0 auto;&#125;//设置根元素html&#123; // 设置rem比值 font-size: (100vw/@total-width) * 40; background-color: #eff0f4;&#125;a&#123; text-decoration: none;&#125;// 设置头部header.top-bar:extend(.w)&#123; // 设置弹性容器 display: flex; // 设置高度 height: (175/40rem); // 设置对齐方式 justify-content: space-between; //设置辅轴对齐方式 align-items: center; line-height: (175/40rem); a&#123; color: #24253d; font-size: (50/40rem) ; i&#123; color: #999; font-size: (40/40rem); &#125; &#125;&#125;// 设置banner.banner:extend(.w)&#123; img&#123; width: 100%; &#125;&#125;// 设置中间菜单.menu:extend(.w)&#123; // 确定元素的高度 height: (329/40rem); // 设置弹性元素 display: flex; // 设置换行 flex-flow: row wrap; // 设置对齐方式 justify-content: space-between; // 设置辅轴方向的对齐方式 align-content: space-evenly ; // 设置框的大小 a&#123; width: (327/40rem); height: (104/40rem); line-height: (104/40rem); color: white; border-radius: (10/40rem); i&#123; margin: 0 (20/40rem) 0 (38/40rem); &#125; &#125; .course&#123; background-color:#f97053; &#125; .star&#123; background-color:#cd6efe; &#125; .sub&#123; background-color:#fe4479; &#125; .download&#123; background-color:#1bc4fb; &#125;&#125;// 设置课程列表.course-list:extend(.w)&#123; height: (394/40rem); display: flex; flex-direction: column; justify-content: space-between; margin-bottom: (46/40rem); .title&#123; display: flex; // 主轴空间 justify-content: space-between; // 辅轴对齐方式 align-items: center; h2&#123; font-size: (33/40rem); color:#24253d; border-left: 2px solid #3a84ff; padding-left: 5px; &#125; a&#123; font-size: (28/40rem); color: #656565; &#125; &#125;&#125;// 设置课程列表.item-list&#123; overflow: auto; display: flex; // flex-flow: wrap;&#125;.item&#123; flex: none; box-sizing: border-box; width: (320/40rem); height: (324/40rem); background-color: #fff; box-shadow: 0 0 (10/40rem) rgba(0,0,0,.3); border-radius: (10/40rem); padding: 0 (22/40rem); display: flex; flex-direction: column; justify-content: space-evenly; margin-right: (45/40rem); // 设置图片宽度 img&#123; width: 100%; vertical-align: top; &#125; // 课程标题 .course-title&#123; font-size: (32/40rem); color: #24253d; &#125; // 设置用户信息容器 .user-info&#123; display: flex; align-items: center; &#125; // 头像 .avatar&#123; width: (42/40rem); height: (42/40rem); &#125; // 昵称 .nickname&#123; font-size:(24/40rem); color:#969393; margin-left: (8/40rem); &#125;&#125; 18、美图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./meitu/style.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 响应式设计的网页 -移动端优先 -渐进增强 --&gt; &lt;div class=&quot;top-bar-wrapper&quot;&gt; &lt;!-- 顶部容器 --&gt; &lt;div class=&quot;top-bar&quot;&gt; &lt;!-- 左侧菜单 --&gt; &lt;div class=&quot;left-menu&quot;&gt; &lt;!-- 创建菜单图标 --&gt; &lt;ul class=&quot;menu-icon&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 创建菜单 --&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;美容仪器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;配件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务支持&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;企业网站&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;span&gt;搜索Meitu.com&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- logo --&gt; &lt;h1 class=&quot;logo&quot;&gt; &lt;a href=&quot;/&quot;&gt;美图手机&lt;/a&gt; &lt;/h1&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-user&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; less 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184a&#123; text-decoration: none; color: #fff; &amp;:hover&#123; color: rgb(197,196,196); &#125;&#125;.top-bar-wrapper&#123; // width: 100%; background-color: #000;&#125;// 导航条的外部容器.top-bar&#123; max-width: 1200px; margin: 0 auto; height: 48px; background-color: #000; padding: 0 14px; display: flex; align-items: center; justify-content: space-between;&#125;// 设置左侧导航图标.left-menu&#123; &amp;:active&#123; // 显示隐藏菜单 .nav&#123; display: block; &#125; &#125; // 设置菜单 .nav&#123; display: none; position: absolute; top: 48px; left: 0; bottom: 0; right: 0; background-color: #000; padding-top: 60px; li&#123; width: 80%; margin: 0 auto; border-bottom: 1px solid #757474; a&#123; display: block; line-height: 44px; font-size: 14px; &#125; &amp;:last-child a&#123; display: inline-block; margin-right: 6px; &#125; span&#123; color: #fff; font-size: 14px; &#125; &#125; &#125; // 图标 .menu-icon&#123; width: 18px; height: 48px; // background-color: #bfa; position: relative; // 导航线 li&#123; width: 18px; height: 1px; background-color: #fff; position: absolute; // 设置旋转原点 transform-origin: left center; transition: 0.5s; &#125; li:nth-child(1)&#123; top: 18px; &#125; li:nth-child(2)&#123; top: 24px; &#125; li:nth-child(3)&#123; top: 30px; &#125; // 鼠标移入效果，正常项目使用js &amp;:active&#123; li:nth-child(1)&#123; // 向下旋转 transform: rotateZ(40deg); &#125; li:nth-child(2)&#123; // 隐藏 // visibility: hidden; opacity: 0; &#125; li:nth-child(3)&#123; // 向上旋转 transform: rotateZ(-40deg); &#125; &#125; &#125;&#125;// 设置logo.logo&#123; a&#123; text-indent: -9999px; display: block; width: 122px; height: 32px; background-image: url(&quot;../img/18/dff63979.sprites-index@2x.png&quot;); background-size: 400px 400px; &#125;&#125;// 设置媒体查询// 设置断点768px@media only screen &#123; // 断点768px @media (min-width:768px)&#123; .left-menu&#123; order: 2; flex: auto; // 显示菜单 .nav&#123; display: flex; position: static; padding: 0; justify-content: space-around; li&#123; margin: 0; width: auto; border-bottom: none; a&#123; line-height: 48px; &#125; span&#123; display: none; &#125; &#125; &#125; // 隐藏菜单图标 .menu-icon&#123; display: none; &#125; &#125; .logo&#123; order: 1;; &#125; .user-info&#123; order: 3; &#125; &#125;&#125; 五、float1、浮动的简介123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 400px; height: 200px; background-color: green; /* 通过浮动可以使一个元素在其父元素的左侧或右侧移动 使用float属性来设置元素的浮动 可选值： none：默认值，元素不浮动 left：元素向左浮动 right：元素向右浮动 注意：元素设置为浮动以后，水平布局的等式不需要强制成立了 元素设置完浮动以后，会完全从文档流中脱离，不在占用文档流的位置 所以元素下边的还在文档流中的元素会向上移动 浮动的特点： 1、浮动元素会完全脱离文档流，不再占用文档流的位置 2、设置浮动后，元素会向父元素的左侧或右侧移动 3、浮动元素默认不会从父元素中溢出 4、浮动元素向左或向右移动时，不会超过前边的其他浮动元素 5、如果浮动元素上边是没有浮动的元素，则浮动元素无法上移 6、浮动元素不会超过上边的浮动的兄弟元素，最多最多只能是和它一样高 简单总结： 浮动目前来讲他的主要作用就是让页面元素可以水平排列 通过浮动可以制作一些水平方向的布局 */ float: left; &#125; .box2&#123; width: 400px; height: 200px; background-color: orange; float: left; &#125; .box3&#123; width: 200px; height: 200px; background-color: yellow; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、浮动其他的特点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: green; /* 浮动元素不会盖住文字，文字会自动环绕元素的周围 所以我们可以利用浮动来设置文字环绕图片的效果 */ float: left; &#125; *&#123; margin: 0; padding: 0; &#125; .box2&#123; background-color: yellowgreen; /* 元素设置浮动后，将会从文档流中脱离，脱离后，元素的一些特点也会发生改变 脱离文档流的特点： 块元素： 1、块元素不再独占页面的一行 2、脱离文档流后，块元素的宽度和高度由内容撑开决定 行内元素： 行内元素脱离文档流后会变成块元素，特点和块元素一样 脱离文档流后，不再区分块和行内元素了 */ float: left; &#125; .box3&#123; background-color: orange; &#125; .s1&#123; width: 200px; height: 200px; float: left; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; --&gt; &lt;!-- &lt;p&gt; 去年冬天，我回到了故乡下柴市。傍晚，我一个人坐在门前的晒谷场上。柔和的光亮盘桓在村庄上空。白昼将去未去、夜晚将来未来，那暝色很好看很清新，散溢着泥土的芬芳，干净得没一点渣子。它把田埂掩盖，把小桥托在空中，把树木藏进风里，把狗叫声拉长，把鸡撵进笼里，把旷野清理得干干净净。往天上瞅，褐色的天空里间杂着白色，云在风里羊群样蠕动。那时候，水稻已经归仓，黄豆收进了院落，树叶都落光了，所有多余的粉饰都拿掉了；原野洗尽了风尘，褪尽了铅华，恢复了它天然无雕饰的纯真素颜与本来模样；万物毫不戒备地显露出最根本的坦荡。大地像生过婴儿的母亲，幸福地舒展在开阔的天空下，躺着。暗黑，从远处漫过来。最先漫过大湖，然后漫过大堤，来到村庄，来到晒谷场上，最后漫过心田。黄昏，终于阖上眼睑。一切都安安静静、舒舒服服地浸在里面。我坐在暮色里，没有开灯。没有灯的时候看黑，黑色很美。它不是黑洞洞的旋涡似的、深井似的吓人，它透着微微的亮光，安宁而纯粹，单纯而透明，像母亲的怀抱。乡村的夜色真是好看，尽是起起伏伏的黑。看着看着，人清澈得什么似的，渐渐地松软下来，像要飞一样。我突然想一个人走走，在村庄内和田野里，像石头一样滚动。暗黑的夜空中，有一些大雁在悠闲地旅行。蝙蝠在我头上忽东忽西毫无规则地飞翔。无言的黑影，让夜变得富有、神秘和亲近。树枝上零星的夜露懒懒地向下滑落，滴在下面的野草上，像是小孩子滑滑梯似的，很是调皮。灌木、竹林、棉花杆，安静温和，没一点芒剌，和我一同站在夜色里。我和它们离得很近，仿佛手拉手的兄弟。白天看它们，它们就凌厉，一副眼珠子朝上拒绝人的样子。唉！万物不设防的状态真好，不设防才能彼此亲近。童年里的北斗星就在这时候出现，母亲讲述的牛郎星织女星也在这时候出现。北斗星、牛郎星织女星也都没有偏离原来的位置，它们好像是在等我回来，好一下子在星群里找到它们。多少年了，我没有寻觅过它们，没有看过这样的满天星星。我现在的居住地广州，也是可以看到星星的，在我家阳台上就能够看到它们，但我已经很久没有在阳台上看星星了。一个个夜晚，我耽搁于手机里的花边新闻，耽搁于对文字的自我围困，也耽搁于对一些不可得的感情的纠缠……我看见了月光，纯粹的月光，没有一点点灯光参进来。朦朦胧胧的，如薄雾，如出水的香芋苗，如刚刚绽放开来的荷花，又如清晨含着露珠的丝瓜花，纯洁得让我不敢呼吸，丰满得让我心生喜爱。天空，从南到北，一眼能望那么远，那么高，那么一大片，从东到西也一样的宽广无边……我几乎屏住了呼吸——我的一次呼吸就像是一次破坏。如果这个时候我说一句话，那几乎是不可思议的事情，也幸亏我身边没有可以说话的人。明月给周围的一切披上银装。大湖银星万点，小溪银波微漾，浸过露水的枯草，也闪着银色的光芒。月光穿过树枝间的缝隙，在小道上，印上一道道纵横交错的影子。这些已经落叶的树，白天一派萧瑟之气，夜间掩在林间的月光，把它们映照得流光溢彩，好像提早回到勃勃的春天了。 我背着手，抬头望着天空那轮明月，几颗星星点缀在两旁，仿佛我们兄弟几个依偎在母亲的身旁听那些古老的民间故事。唉！那时候，母亲说话的声音年轻得一跳一跳的，柔和的脸上总是带着笑容，眼睛特别的亮。可如今，那个给我们讲故事的母亲，那个将我从乡村送进城市的母亲己经作古。而头上这轮照过古人也照过今人的明月，依然奔波于天地之间，依然像那些流逝的过往岁月，正缓缓拂过我的身体。今夜，我走在故乡的土地上，内心饱满得如同盛夏的果实，一切都如我所愿，一切都如我所想。在这满月的清辉之下，从树木的底下往上端详的那一轮月亮，把错综着生长的树木变成一幅木刻版画，那样的黑白分明，那样的似曾相识。在这个没有灯光、没有车龙马水的夜晚。我独行在故乡的田间小道上，可以横着走，竖着走，踏着圈走，倒着走，想怎么走就怎么走。月光像水银般从高天流泻下来，小路上的漫步便成了我的独舞，迷蒙中，我感觉有类似二胡协奏的音律在耳边萦回，有千万只燕子在空中飞翔，渐渐的，我脱去了人造的面具，氤氲出一份不错的心情，喜爱的氛围激荡在我的心胸，内心充满了对乡村、对故乡乃至新生活的想象和渴望。我喜欢故乡的夜！ &lt;/p&gt; --&gt; &lt;!-- &lt;div class=&quot;box2&quot;&gt;hello1&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;hello2&lt;/div&gt; --&gt; &lt;span class=&quot;s1&quot;&gt;我是一个span&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 导航条练习 3、网页的布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; header,main,footer&#123; width: 1000px; margin: 0 auto; &#125; /* 设置头部 */ header&#123; height: 150px; background-color: silver; &#125; /* 设置主体 */ main&#123; height: 500px; background-color: #bfa; margin: 30px auto; &#125; nav,article,aside&#123; float: left; height: 100%; &#125; /* 设置左侧导航 */ main nav&#123; width: 170px; background-color: yellow; &#125; /* 设置中间内容 */ main article&#123; margin: 0 30px; width: 600px; background-color: aqua; &#125; /* 设置右侧边栏 */ main aside&#123; width: 170px; background-color: green; &#125; footer&#123; height: 150px; background-color: tomato; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建头部 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- 创建网页主题 --&gt; &lt;main&gt; &lt;!-- 左侧导航 --&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!-- 中间内容 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 右边的边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!-- 网页的底部 --&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 4、高度塌陷问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .outer&#123; border: 10px red solid; /* height: 100px; */ /* BFC(Block Formatting Context)块级格式化环境 -BFC是一个CSS中隐含的熟悉，可以为一个元素开启BFC 开启BFC该元素会变成一个独立的布局区域 -元素开启BFC后的特点 1、开启BFC的元素不会被浮动元素所覆盖 2、开启BFC的元素子元素和父元素外边距不会重叠 3、开启BFC的元素可以包含浮动的子元素 -可以通过特殊方式开启BFC： 1、设置元素的浮动 2、将元素设置为行内块元素 3、将元素的overflow设置为一个非visible的值 -常用的方式：为元素设置overflow:hidden 开启BFC（以使其可以包含浮动元素） */ /* float: left; */ /* display: inline-block; */ overflow: hidden; &#125; .inner&#123; height: 100px; width: 100px; background-color: #bfa; /* 高度塌陷的问题： 在浮动布局中，父元素的高度默认使被子元素撑开的 当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离 将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须要进行处理！ -写死高度（不满足实际需求） - */ float: left; &#125; .box2&#123; width: 100px; height: 100px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、BFC123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: #bfa; /* float: left; */ overflow: hidden; /* border: 1px red solid; */ &#125; .box2&#123; width: 200px; height: 200px; background-color: orange; overflow: hidden; &#125; .box3&#123; width: 100px; height: 100px; background-color: yellow; margin-top: 100px; /* padding-top: 100px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 6、clear12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; font-size: 50px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; float: left; &#125; .box2&#123; width: 400px; height: 400px; background-color: #ff0; float: right; &#125; .box3&#123; width: 200px; height: 200px; background-color: orange; /* 由于box1的浮动，导致box3的位置上移 也就是box3受到了box1的影响，位置发生了改变 如果我们不希望某个元素因为其他浮动元素的影响而改变位置， 可以通过clear属性来清除浮动元素对当前元素所产生的影响 clear 作用：清除浮动元素对当前元素所产生的影响 可选值： left：清除左侧浮动元素对当前元素的影响 right：清除右侧浮动元素对当前元素的影响 both：清除两侧较大影响的那侧 原理： 设置清除浮动以后，浏览器会自动为元素添加一个外边距， 以使其位置不受其他元素的影响 */ /* clear: left; */ clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、高度塌陷-最终解决方案12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; border: 10px red solid; /* overflow: hidden; */ &#125; .box2&#123; width: 100px; height: 100px; background-color: #bfa; float: left; &#125; .box3&#123; clear: both; &#125; /* 最佳解决方案 */ .box1::after&#123; /* 伪元素默认是行内元素 */ display: block; content: &#x27;&#x27;; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;!-- &lt;div class=&quot;box3&quot;&gt; &lt;/div&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8、clearfix12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: #bfa; &#125; .box2&#123; width: 100px; height: 100px; background-color: orange; margin-top: 100px; &#125; /* .box1::before&#123; content: &#x27;&#x27;; display: table; &#125; */ /* clearfix可以同时解决高度塌陷和外边距重叠的问题，当你遇到这些问题的时候，直接使用clearfix这个类即可 */ .clearfix::before, .clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1 clearfix&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 六、position1、定位的简介-相对定位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 60px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; &#125; .box2&#123; width: 200px; height: 200px; background-color: orange; /* margin-left: 200px; margin-top: -200px; */ /* 定位（position） -定位是一种更加高级的布局手段 -通过定位可以将元素摆放到页面的任意位置 -使用position属性来设置定位 -可选值 -static 默认值，元素是静止的没有开启定位 -relative 开启元素相对定位 -absolute 开启元素绝对定位 -fixed 开启元素的固定定位 -sticky 开启元素的粘滞定位 -相对定位 -当元素的position属性值设置为relative时则开启了元素的相对定位 -相对定位的特点： 1、元素开启相对定位后，如果不设置偏移量元素不会发生任何变化 2、相对定位是参照于元素在文档流中的位置！！！ 3、相对定位会提升元素的层级 4、相对定位不会使元素脱离文档流 5、相对定位不会改变元素的性质，块还是块，行内还是行内 -偏移量（offset） -当元素开启定位后，可以通过偏移量来设置元素的位置 top -定位元素和定位位置上边的距离 bottom -定位元素和定位位置下边的距离 -定位元素垂直方向的位置由top和bottom两个属性来控制 通常情况下我们只会使用其中之一 -top值越大，越向下 -bottom越大，越向上 left -定位元素和定位位置的左侧距离 right -定位元素和定位位置的右侧距离 --定位元素水平方向的位置由left和right两个属性来控制 通常情况下我们只会使用其中之一 -left值越大，越向右 -right越大，越向左 注意：一定要开启定位后才生效 */ position: relative; /* top: 100px; */ bottom: 200px; left: 200px; &#125; .box3&#123; width: 200px; height: 200px; background-color: yellow; /* margin-top: 200px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、绝对定位123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 60px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; &#125; .box2&#123; width: 200px; height: 200px; background-color: orange; /* 绝对定位 -当元素的position属性值设置为absolute时，则开启了元素的绝对定位 -绝对定位的特点： 1、开启绝对定位后，如果不设置偏移量，则元素的位置不会发生变化 2、开启绝对定位后，元素会从文档流中脱离 3、绝对定位会改变元素的性质，行内变成块，块的宽度被内容撑开 4、绝对定位会使元素提升一个层级 5、绝对定位元素是相对于包含块进行定位的 包含块（containing block） -正常情况下 包含块就是离当前元素最近的祖先块元素 &lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/div&gt; -开启绝对定位的包含块： 包含块就是理他最近的开启了定位的祖先元素 如果所有的祖先元素都没有开启定位，则根元素就是它的包含块 -html（根元素、初始包含块） */ position: absolute; bottom: 0; right: 0; &#125; .box3&#123; width: 200px; height: 200px; background-color: yellow; &#125; .box4&#123; width: 400px; height: 400px; background-color: tomato; &#125; .box5&#123; width: 300px; height: 300px; background-color: aliceblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt; 4 &lt;div class=&quot;box5&quot;&gt; 5 &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、固定定位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 60px; height: 2000px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; &#125; .box2&#123; width: 200px; height: 200px; background-color: orange; /* 固定定位： -将元素的position属性值设置为fixed则开启了固定定位 -固定定位也是一种绝对定位，所以固定定位的大部分特点跟绝对定位一样 唯一不同的是，固定定位永远参考于浏览器的视口进行定位 固定定位的元素不会随网页的滚动条滚动 */ position: fixed; left: 0; top: 0; &#125; .box3&#123; width: 200px; height: 200px; background-color: yellow; &#125; .box4&#123; width: 400px; height: 400px; background-color: tomato; &#125; .box5&#123; width: 300px; height: 300px; background-color: aliceblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt; 4 &lt;div class=&quot;box5&quot;&gt; 5 &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 4、粘滞定位12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;导航条&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;style&gt; body&#123; height: 2500px; &#125; .nav&#123; /* 设置宽度高度*/ height: 48px; width: 1200px; /* 设置背景颜色 */ background-color: gainsboro; /* 设置居中 */ margin: 100px auto; /* 粘滞定位 -当元素的position属性值设置为sticky时则开启了元素的粘滞定位 -粘滞定位和相对定位的特点基本一致 不同的是粘滞定位可以在元素到达某个位置时将其固定 */ position: sticky; top: 10px; &#125; /* 设置nav中的li */ .nav li&#123; /* 设置li向左浮动，已使菜单横向排列 */ float: left; /* 设置li高度和垂直居中 */ line-height: 48px; /* height: 48px; */ &#125; .nav a&#123; /* 将a转换为块元素 */ display: block; /* 去除下划线 */ text-decoration: none; /* 字体颜色和大小 */ color: #777777; font-size: 18px; padding: 0 39px; &#125; /* 设置鼠标移入效果 */ .nav a:hover&#123; background-color: #3F3F3F; color: #E8E7E3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建导航条的结构 --&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;HTML/CSS&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Browser Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Server Side&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Programming&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Xml&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Web Buliding&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Reference&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5、绝对定位元素的布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 500px; height: 500px; background-color: #bfa; position: relative; &#125; .box2&#123; width: 100px; height: 100px; background-color: orange; /* 开启绝对定位后，要满足以下等式 水平布局 left + margin-left + border-left + padding-left + width +padding-right + border-right + margin-right + right = 包含块元素的宽度 -当我们开启了绝对定位后： 水平方向的布局等式就需要添加left和right两个值 此时规则和之前只是多了两个值： 当发生过度约束： 如果9个值中没有auto，则自动调整right值以使等式满足 如果要auto，自动调整auto的值以使等式满足 -可设置auto的值 margin width left right 垂直方向布局的等式也必须要满足 top + margin-top/bottom + padding-top/bottom + height +bottom */ position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、元素的层级12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; font-size: 60px; &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; position: absolute; /* 对于开启了定位的元素，可以通过z-index属性来指定元素的层级 z-index需要一个整数作为参数，值越大元素的层级越高 元素的层级越高越优先显示 如果层级一样，则优先显示靠下的元素 祖先元素的层级再高也不会盖住后代元素 */ z-index: 1; &#125; .box2&#123; width: 200px; height: 200px; background-color: rgba(255, 0, 0, 0.3); position: absolute; top:50px; left: 50px; z-index: 2; &#125; .box3&#123; width: 200px; height: 200px; background-color: yellow; position: absolute; top:100px; left: 100px; z-index: 3; &#125; .box4&#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3 &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 七、font&amp;background1、字体-&gt;font-family12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* font-face可以将服务器中的字体直接提供给用户去使用 问题： 1、加载速度慢 2、版权 3、字体格式（兼容问题），可以指定多个url */ @font-face &#123; /* 指定字体的名字 */ font-family:&#x27;myfont&#x27; ; src: url(./font/ZCOOLKuaiLe-Regular.ttf) format(&quot;truetype&quot;), url(./font/ZCOOLXiaoWei-Regular.ttf); &#125; p&#123; /* 字体相关样式 color 前景色，通常用来设置字体颜色 font-size 字体的大小 font-size相关单位 em相当于当前元素的一个font-size rem 相当于根元素的一个font-size font-family 字体族(字体的格式) 可选值： serif 衬线字体 sans-serif 非衬线字体 monospace 等宽字体 -指定字体的类别，浏览器会自动使用该类别下的字体 -font-family可以同时指定多个字体。字体之间用空格隔开 字体生效时优先使用第一个，如果第一个无法使用则使用第二个，以此类推 */ color: green; font-size: 40px; /* font-family: &#x27;Courier New&#x27;, Courier, monospace ; */ font-family: &#x27;myfont&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 今天天气真不错，Hello, Boy！ &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2、图标字体1.01234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 图标字体（iconfont） -在网页中经常需要使用一些图标，可以通过图片来引入图标 但是图片本身大小比较大，并且非常不灵活 -所以在使用图标时，我们可以将图标设置为字体 然后通过font-face的形式来对字体进行引入 -这样我们就可以通过使用字体的样式来使用图标 fontawesome使用步骤： 1、下载链接https://fontawesome.com/ 2、解压 3、将css和webfonts移动到项目中 4、将all.css引入网页中 5、使用图标字体 -直接通过类名来使用图标字体 class=&quot;fas fa-bell&quot; fas或fab固定，空格后使用图标名 class=&quot;fab fa-accessible-icon&quot; --&gt; &lt;i class=&quot;fas fa-bell&quot; style=&quot;font-size: 80px ;color:red;&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-bell-slash&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fab fa-accessible-icon&quot;&gt;&lt;/i&gt;&lt;/body&gt;&lt;/html&gt; 3、图标字体2.01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; &lt;style&gt; li&#123; list-style: none; &#125; li::before&#123; /* 通过伪元素来设置图标字体 1、找到要设置图标的元素通过before或after选中 2、在content中设置编码 3、设置字体的样式 fab: font-family: &#x27;Font Awesome 5 Brands&#x27;; fas: font-family: &#x27;Font Awesome 5 Free&#x27;; font-weight:900; */ content: &#x27;\\f1b0&#x27;; font-family: &#x27;Font Awesome 5 Free&#x27;; font-weight: 900; color: blue; margin-right: 10px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;!-- &lt;i class=&quot;fas fa-cat&quot;&gt;&lt;/i&gt; --&gt; &lt;ul&gt; &lt;li&gt;锄禾日当午&lt;/li&gt; &lt;li&gt;汗滴禾下土&lt;/li&gt; &lt;li&gt;谁知盘中餐&lt;/li&gt; &lt;li&gt;粒粒皆辛苦&lt;/li&gt; &lt;/ul&gt; &lt;!-- 通过实体来使用图标字体： &amp;#x图标的编码; --&gt; &lt;spa class=&quot;fas&quot;&gt;&amp;#xf0f3;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 4、阿里的图标字体库.html12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont/iconfont.css&quot;&gt; &lt;style&gt; i.iconfont&#123; font-size: 100px; &#125; p::before&#123; content: &#x27;\\e6f2&#x27;; font-family: &#x27;iconfont&#x27;; font-size: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe6ef;&lt;/i&gt; &lt;i class=&quot;iconfont icon-auto&quot;&gt;&lt;/i&gt; &lt;p&gt;Hello&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 5、行高123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; /* 可以将行高设置为和高度一样的值，使单行文字在一个元素中垂直居中 */ height: 200px; line-height: 200px; font-size: 50px; /* 行高（line height） -行高指的是文字占用的实际高度 -可以通过直接指定一个大小（px em） 也可以直接为行高设置一个整数 如果是一个整数的话，行高会是字体的指定整数的倍数 默认是1.33 行高经常还用来设置文字的行间距 行间距=行高-字体大小 字体框 -字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度 行高会在字体框的上下平均分配 */ border: 1px solid red; /* line-height: 200px; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;今天天气真不错呀！Boy！今天天气真不错呀！Boy！今天天气真不错呀！Boy！&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、字体的简写属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; border: 1px solid red; /* line-height: 2; */ /* font可以设置字体相关的所有属性 语法： font:字体大小/行高 字体族 行高 可以省略不写 如果不写使用默认值 */ /* font-size: 50px; font-family: &#x27;Time New Roman&#x27;,Times,serif; */ font: bold italic 50px/2 微软雅黑, &#x27;Time New Roman&#x27;,Times,serif; /* font: normal normal 50px/2 微软雅黑, &#x27;Time New Roman&#x27;,Times,serif; */ /* line-height: 2; */ font-size: 50px; /* font-weight 字重 字体的加粗效果 可选值 normal默认值，不加粗 bold加粗 100-900 九个级别（没什么用） 取决于是否都有9个级别的字体 font-style 字体的风格 可选值 normal正常 italic斜体 */ /* font-weight: bold; */ /* font-weight: normal; font-style: italic; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;今天天气真不错！Hello Boy！&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、文本的样式1.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 500px; border: 1px solid red; /* text-align 文本的水平对齐 可选值： left 左对齐 right 右对齐 center 居中对齐 justify 两端对齐 */ /* text-align: center; */ font-size: 50px; &#125; span&#123; font-size: 20px; border: 1px solid blue; /* 设置元素垂直对齐的方式 可选值： baseline 默认值，基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 也可直接指定值 */ vertical-align: baseline ; &#125; p&#123; border: 1px red solid; &#125; img&#123; vertical-align: top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;今天天气 Boy x&lt;span&gt;真不错！Boy&lt;/span&gt;&lt;/div&gt; &lt;!-- &lt;div&gt; Lorem, ipsum dolor sit amet consectetur adipisicing elit. Vitae quod aliquam sint similique deleniti fugit et sit aspernatur, nulla, eum eos facere! Eligendi nemo ut modi, laboriosam magni assumenda neque. &lt;/div&gt; --&gt; &lt;p&gt; &lt;img src=&quot;../Html/img/城堡.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 8、文本的样式2.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; font-size: 50px; /* text-decoration设置文本修饰 可选值： none默认值，什么都没有 underline 下划线 line-through 删除线 overline 上划线 */ /* text-decoration: underline; */ /* text-decoration: underline red dotted; */ &#125; .box2&#123; width: 200px; /* 用来设置网页如何处理空白 可选值： normal正常 nowrap 不换行 pre 保留空白（代码什么样，页面什么样） 以下三个组合使用 */ white-space: nowrap ; overflow: hidden; text-overflow: ellipsis; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; 今天天气很不错！ &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Aperiam vitae veniam dolores temporibus pariatur ipsum reiciendis omnis eius suscipit impedit. Praesentium assumenda quae eaque magnam adipisci minus explicabo repudiandae aliquam. &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9、背景1.01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 1000px; height: 1000px; /* background-color设置背景颜色 */ background-color: #bfa; /* background-image: ;设置背景图片 -可以同时设置背景图片和背景颜色，这样背景颜色会成为图片的背景色 -如果背景图片小于元素，则背景图片会自动在元素中平铺将元素铺满 -如果背景图片大于元素，将会有一部分背景无法完全显示 -如果背景图片和元素一样大，则直接正常显示 */ background-image: url(&quot;./img/default.jpg&quot;); /* background-repeat: ;设置背景的重复方式 可选值： repeat默认值，背景沿着x轴和y轴方向重复 repeat-x沿着x方向重复 repeat-y沿着y方向重复 no-repeat不重复 */ background-repeat: no-repeat; /* background-position 用来设置图片的位置 设置方式： 通过top left right bottom center几个表示方位的词来设置背景图片的位置 使用方位时必须同时指定两个值，如果只有一个值，默认第二个值为center 通过偏移量指定背景图片的位置 水平方向的偏移量 垂直方向的偏移量 */ /* background-position: top center; */ background-position: 100px 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 10、背景2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 500px; height: 500px; overflow: auto; /* background-color设置背景颜色 */ background-color: #bfa; background-image: url(&quot;./img/mm.jpg&quot;); background-repeat: no-repeat; /* background-position: 100px 100px; */ /* 设置背景的范围 background-clip 可选值： border-box默认值，背景出现在边框的下边 padding-box 背景不会出现在边框下，只出现在内边距和内容区下 content-box 背景只会出现在内容区 background-origin背景图片的偏移量计算的原点 padding-box 默认值，background-position从内边距处开始计算 content-box 背景图片的偏移量从内容区开始计算 border-box 背景图片的偏移量从边框开始计算 */ background-origin: border-box ; background-clip: content-box; /* background-size:设置背景图片的尺寸 ; 第一个值表示宽度 第二个值表示高度 -如果只写一个值，则第二个值默认是auto cover图片的比例不变，将元素铺满 contain图片比例不变，将图片在元素中完整显示 */ /* background-size: 100% auto; */ /* background-size: cover; */ background-size: contain; /* border: 10px red double; */ /* background-color background-image background-repeat background-position background-size background-origin background-clip background-attachment -background 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置 并且该样式没有顺序要求，也没有哪个属性是必须要写的 注意： background-size必须写在background-position的后边，并且使用/隔开 background-position/background-size background-origin background-clip两个样式，origin必须在clip前面 */ &#125; .box2&#123; width: 300px; height: 1000px; /* background-color: orange; */ background-image: url(&quot;./img/1.png&quot;); background-repeat: no-repeat; /* background-attachment 背景图片是否跟随元素移动 可选值： scroll 默认值，背景图片会跟随元素移动 fixed 背景图片固定在页面中，不会随元素移动 */ background-attachment: fixed; &#125; .box3&#123; border: 10px red double; padding: 50px; width: 500px; height: 500px; background: #bfa url(./img/2.jpg) center center/contain border-box content-box no-repeat ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Facilis earum incidunt consequatur modi beatae voluptatem debitis ipsum nesciunt at quam impedit voluptas animi repellat nostrum minus, iusto aliquam sequi possimus. &lt;/div&gt; &lt;/div&gt; --&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 11、渐变-线性123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; /* background-color: #bfa; */ /* 通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过度的效果 ！！！渐变是图片，需要通过background-image来设置 线性渐变，颜色沿着一条直线发生变化 linnear-gradient() linear-gradient(red,yellow)红色开头，黄色结尾，中间是过渡区域 可以指定渐变的方向 to left to right to bottom to top 这些属性值可以组合 默认是向下 deg表示度数 0度是向上 turn表示圈数 -渐变可以同时指定多个颜色，多个颜色默认情况平均分配 也可以手动指定渐变的分布情况 repeating-linear-gradient()可以平铺的线性渐变 */ /* background-image: linear-gradient(to right, red,yellow,#bfa,orange); */ /* background-image: linear-gradient(red 50px,yellow 100px,green 150px,orange 200px); */ background-image: repeating-linear-gradient(red ,yellow 50px); background-repeat: no-repeat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12、径向渐变123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 300px; height: 500px; /* radial-gradient()径向渐变（放射性的效果） 默认情况下径向渐变的形状根据元素的形状来计算的 正方形：圆形 长方形：椭圆形 我们也可以手动指定径向渐变的大小 100px 100px circle ellipse 也可以指定渐变的位置 top left right bottom center 0 0 语法： radial-gradient(大小 at 位置,颜色 位置,颜色 位置) 大小： circle 圆形 ellipse 椭圆 closest-side 近边 closest-corner 近角 farthest-side 远边 farthest-corner 远角 位置： top left right bottom center */ /* background-image: radial-gradient(100px 200px,red,yellow); */ background-image: radial-gradient(circle at 0 0,red,greenyellow); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 八、HTML—&gt;补充1、表格–&gt;简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在现实生活中，我们经常需要使用表格来表示一些格式化的数据 课程表、人名单、成绩单。。 同样在网页我们也需要使用表格，我们通过table标签来参加一个表格 --&gt; &lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;!-- 在table中使用tr表示表格中的一行，有几个tr就有几行 --&gt; &lt;tr&gt; &lt;!-- 在tr中使用td表示一个单元格，有几个td就有几个单元格 --&gt; &lt;td&gt;A1&lt;/td&gt; &lt;td&gt;B1&lt;/td&gt; &lt;td&gt;C1&lt;/td&gt; &lt;td&gt;D1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A2&lt;/td&gt; &lt;td&gt;B2&lt;/td&gt; &lt;td&gt;C2&lt;/td&gt; &lt;!-- rowspan纵向的合并单元格 --&gt; &lt;td rowspan=&quot;2&quot;&gt;D2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A3&lt;/td&gt; &lt;td&gt;B3&lt;/td&gt; &lt;td&gt;C3&lt;/td&gt; &lt;!-- &lt;td&gt;D3&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A4&lt;/td&gt; &lt;td&gt;B4&lt;/td&gt; &lt;!-- colspan横向的合并单元格 --&gt; &lt;td colspan=&quot;2&quot;&gt;C4&lt;/td&gt; &lt;!-- &lt;td&gt;D4&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2、长表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot;center&quot;&gt; &lt;!-- 可以将一个表格分为三部分 头部thead 主体tbody 底部tfoot 三个位置顺序不定 th表示头部的单元格 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;日期&lt;/td&gt; &lt;th&gt;收入&lt;/td&gt; &lt;th&gt;支出&lt;/td&gt; &lt;th&gt;合计&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;2000.1.1&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2000.1.1&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2000.1.1&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2000.1.1&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2000.1.1&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;合计&lt;/td&gt; &lt;td&gt;1000&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3、表格的样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table&#123; width: 50%; border: 1px solid black; margin: 0 auto; /* border-spacing:指定边框之间的距离 ; */ /* border-spacing: 0; */ /* border-collapse: collapse; 设置边框的合并*/ border-collapse: collapse; &#125; td&#123; border: 1px solid black; height: 50px; /* 默认情况下元素是垂直居中的，可以通过vertical-align属性设置 */ vertical-align: middle; text-align: center; &#125; /* 如果表格中没有使用tbody而是直接使用tr 那么浏览器会自动创建一个tbody，并且将tr全部放到tbody中 str不是table的子元素 */ tbody &gt; tr:nth-child(odd)&#123; background-color: #bfa; &#125; .box1&#123; width: 300px; height: 300px; background-color: orange; /* 将元素设置为单元格 */ display: table-cell; vertical-align: middle; &#125; .box2&#123; width: 100px; height: 100px; background-color: yellow; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;孙悟空&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;500&lt;/td&gt; &lt;td&gt;花果山&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;唐僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;东土大唐&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;猪八戒&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;高老庄&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;沙僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;流沙河&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4、表单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 表单 -在现实生活中用于提交数据 -网页中使用表单。网页中的表单用于将本地的数据交给远程的服务器 -使用form标签来创建一个表单 --&gt; &lt;!-- form的属性 action 表单要提交的服务器的地址 --&gt; &lt;form action=&quot;target.html&quot; method=&quot;&quot;&gt; &lt;!-- 文本框text 注意：数据要提交给服务器中，必须要为元素指定一个name属性 --&gt; 账号:&lt;input type=&quot;text&quot; name=&quot;userno&quot;&gt; &lt;br&gt;&lt;br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 单选按钮radio,name属性值要一样才是一组的 像这种选择框，必须指定一个value属性，value属性值才会被服务器接收到 checked可以将单选按钮设置为默认选中 --&gt; 性别: 男&lt;input type=&quot;radio&quot; value=&quot;man&quot; name=&quot;sex&quot; checked&gt; 女&lt;input type=&quot;radio&quot; value=&quot;woman&quot; name=&quot;sex&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 多选框checkbox --&gt; 技能: Java&lt;input type=&quot;checkbox&quot; name=&quot;skills&quot; value=&quot;java&quot; checked&gt; C语言&lt;input type=&quot;checkbox&quot; name=&quot;skills&quot; value=&quot;c&quot;&gt; Python&lt;input type=&quot;checkbox&quot; name=&quot;skills&quot; value=&quot;python&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 下拉列表select标签 --&gt; 期望工资: &lt;select name=&quot;monkey&quot;&gt; &lt;option value=&quot;5k&quot;&gt;5000&lt;/option&gt; &lt;option value=&quot;1w&quot; selected&gt;10000&lt;/option&gt; &lt;option value=&quot;1.5w&quot;&gt;15000&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 提交按钮submit --&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 5、表单2.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;target.html&quot;&gt; &lt;!-- placeholder设置文本框提示信息 --&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请填写用户名&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 普通按钮 --&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 双标签里面还可以放其他标签，扩展性高 --&gt; &lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;!-- &lt;input type=&quot;color&quot;&gt; &lt;br&gt;&lt;br&gt; --&gt; &lt;!-- 邮箱&lt;input type=&quot;email&quot;&gt; --&gt; &lt;!-- autocomplete=&quot;off&quot; 关闭自动补全 readonly将表单项设置为只读,数据会提交 disabled将表单项设置为禁用，数据不会提交 autofocus设置表单项自动获取焦点 --&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; autocomplete=&quot;off&quot; value=&quot;xiaolin&quot; readonly&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;b&quot; value=&quot;bbb&quot; disabled&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;c&quot; autofocus&gt;&lt;br&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 九、小米官网项目1、html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;小米商城&lt;/title&gt; &lt;!-- 引入重置样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../layout/css/reset.css&quot;&gt; &lt;!-- 引入图标字体库 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; &lt;!-- 引入当前页面的css样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt; &lt;!-- 引入公共样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/base.css&quot;&gt; &lt;!-- 设置网站图标（标题栏和收藏栏） --&gt; &lt;link rel=&quot;icon&quot; href=&quot;./favicon.ico&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 顶部导航条 --&gt; &lt;!-- 顶部导航条外层容器 --&gt; &lt;div class=&quot;topbar-wrapper&quot; id=&quot;top&quot;&gt; &lt;!-- 内部容器 --&gt; &lt;div class=&quot;topbar w clearfix&quot;&gt; &lt;!-- 左侧导航条 --&gt; &lt;ul class=&quot;service&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;小米商城&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;MIUI&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;loT&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;云服务&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;金融&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;有品&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;小爱开放平台&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;企业团购&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;资质证照&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;协议规则&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li class=&quot;app-wrapper&quot;&gt; &lt;a class=&quot;app&quot; href=&quot;javascript:;&quot;&gt; 下载app &lt;!-- 添加一个弹出层 --&gt; &lt;div class=&quot;qrcode&quot;&gt; &lt;img src=&quot;./img/download.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;小米商城APP&lt;/span&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;Select Location&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 购物车 --&gt; &lt;ul class=&quot;shop-cart&quot;&gt; &lt;li&gt; &lt;a class=&quot;cart&quot; href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fas fa-shopping-cart&quot;&gt;&lt;/i&gt; 购物车(0) &lt;!-- 添加一个弹出层 --&gt; &lt;div class=&quot;cart-msg&quot;&gt; &lt;span&gt;购物车中还没有商品,赶快选购吧！&lt;/span&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 用户信息 --&gt; &lt;ul class=&quot;user-info&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;消息通知&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 创建一个头部的外部容器 --&gt; &lt;div class=&quot;header-wrapper&quot;&gt; &lt;div class=&quot;header w clearfix&quot;&gt; &lt;!-- 创建一个logo --&gt; &lt;h1 class=&quot;logo&quot; title=&quot;小米&quot;&gt; 小米官网 &lt;a class=&quot;home&quot; href=&quot;/&quot;&gt;&lt;/a&gt; &lt;a class=&quot;mi&quot; href=&quot;&quot;&gt;&lt;/a&gt; &lt;/h1&gt; &lt;!-- 创建中间导航条的容器 --&gt; &lt;div class=&quot;nav-wrapper&quot;&gt; &lt;!-- 创建导航条 --&gt; &lt;ul class=&quot;nav clearfix&quot;&gt; &lt;li class=&quot;all-goods-wrapper&quot;&gt; &lt;a class=&quot;all-goods&quot; href=&quot;#&quot;&gt;全部商品分类&lt;/a&gt; &lt;!-- 创建一个左侧导航菜单 --&gt; &lt;ul class=&quot;left-menu&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;手机 电话卡&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;电视盒子&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;笔记本 平板&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;家电 插线板&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;出行 穿戴&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;智能 路由器&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;电源 配件&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;健康 儿童&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;耳机 音箱&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;生活 箱包&lt;i class=&quot;fas fa-angle-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;小米手机&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;Redmi 红米&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;电视&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;笔记本&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;家电&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;路由器&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;show-goods&quot;&gt;&lt;a href=&quot;#&quot;&gt;智能硬件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;社区&lt;/a&gt;&lt;/li&gt; &lt;!-- 创建弹出层 --&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 创建一个搜索款容器 --&gt; &lt;div class=&quot;search-wrapper&quot;&gt; &lt;form class=&quot;search&quot; action=&quot;#&quot;&gt; &lt;input class=&quot;search-inp&quot; type=&quot;text&quot;&gt; &lt;button class=&quot;search-btn&quot;&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 创建banner的容器 --&gt; &lt;div class=&quot;banner-wrapper&quot;&gt; &lt;div class=&quot;banner w&quot;&gt; &lt;ul class=&quot;img-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/banner1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/banner2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/banner3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/banner4.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/banner5.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;pointer&quot;&gt; &lt;a class=&quot;active&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;prev-next&quot;&gt; &lt;a class=&quot;prev&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;next&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 设置固定定位工具条 --&gt; &lt;div class=&quot;back-top&quot;&gt; &lt;a href=&quot;#top&quot;&gt;点击回到顶部&lt;/a&gt; &lt;/div&gt; &lt;!-- 创建广告容器 --&gt; &lt;div class=&quot;ad w&quot;&gt; &lt;ul class=&quot;shortcut&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-clock&quot;&gt;&lt;/i&gt; 小米秒杀 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-building&quot;&gt;&lt;/i&gt; 企业团购 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-frog&quot;&gt;&lt;/i&gt; F码通道 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-keyboard&quot;&gt;&lt;/i&gt; 米粉卡 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-robot&quot;&gt;&lt;/i&gt; 以旧换新 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-sim-card&quot;&gt;&lt;/i&gt; 话费充值 &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;ad-img&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、base.css12345678910111213141516171819202122232425262728/* 公共样式 */.clearfix::before,.clearfix::after&#123; content: &#x27;&#x27;; display: table; clear: both;&#125;/* 去除a的下划线 */a&#123; text-decoration: none; color: #333;&#125;body&#123; font:14px/1.5 Helvetica Neue,Helvetica,Arial,Microsoft Yahei,Hiragino Sans GB,Heiti SC,WenQuanYi Micro Hei,sans-serif; color: #333; /* 防止body太小溢出 */ min-width: 1226px;&#125;/* 设置一个类，用来表示中间容器的宽度 */.w&#123; /* 固定容器的宽度 */ width: 1226px; /* 设置容器居中 */ margin: 0 auto;&#125; 3、index.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549/* 主页index.html的样式表 *//* 顶部导航条的容器 */.topbar-wrapper&#123; /* 设置全屏宽度 */ width: 100%; /* 设置高度和行高 */ height: 40px; line-height: 40px; /* 设置背景颜色 */ background-color: #333;&#125;/* 设置超链接的字体大小和颜色 */.topbar a&#123; font-size: 12px; color: #b0b0b0; display: block;&#125;/* 设置超链接移入效果 */.topbar a:hover&#123; color: white;&#125;/* 设置中间分割线样式 */.topbar .line&#123; font-size: 12px; color: #424242; margin: 0 8px;&#125;/* 设置左侧导航条左浮动 */.service,.topbar li&#123; float: left;&#125;.app&#123; position: relative;&#125;/* 设置app下的小三角 *//* .app-wrapper:hover&gt;.app::after&#123; */ .app::after&#123; content: &#x27;&#x27;; display: none; /* 设置绝对定位 */ position: absolute; bottom:0; left: 0; right: 0; margin: auto; /* display: block; */ width: 0; height: 0; /* 设置四个方向的边框 */ border: 8px solid transparent; /* 去除上边框 */ border-top: none; /* 单独设置下边框的颜色 */ border-bottom-color: #fff;&#125;/* .app-wrapper:hover&gt;.app .qrcode&#123; display: block;&#125; */.app:hover .qrcode,.app:hover::after&#123; display: block; height: 148px;&#125;/* 设置下载app的下拉框 */.app .qrcode&#123; /* display: none; */ position: absolute; /* left: 22px; */ left: -40px; /* margin-left: -62px; */ width: 124px; /* height: 148px; */ height: 0; overflow: hidden; line-height: 1; text-align: center; background-color: #fff; box-shadow: 0 0 10px rgba(0, 0, 0, .3); z-index: 999; /* transition: ;用于为样式设置过渡效果 */ transition: height 0.3s;&#125;/* 设置二维码图片 */.app .qrcode img&#123; width: 90px; margin: 17px; margin-bottom: 10px;&#125;/* 设置二维码文字 */.app .qrcode span&#123; font-size: 14px; color: #000;&#125;/* 设置右侧导航栏右浮动 */.shop-cart,.user-info&#123; float: right;&#125;/* 设置购物车样式 */.shop-cart&#123; margin-left: 26px;&#125;/* 设置购物车的样式 */.shop-cart a&#123; width: 120px; background-color: #424242; text-align: center;&#125;.shop-cart:hover a&#123; background-color: #fff; color: #ff6700;&#125;.shop-cart i&#123; margin-right: 2px;&#125;.cart&#123; position: relative;&#125;.shop-cart:hover .cart-msg&#123; display: block; color:#b0b0b0;&#125;.cart-msg&#123; display: none; position: absolute; left: -180px; width: 300px; height: 100px; line-height: 1; /* text-align: center; */ background-color: #fff; /* box-shadow: 0 0 10px rgba(0, 0, 0, .3); */ border: 1px solid rgba(0, 0, 0, .1); border-top: none; z-index: 9999;&#125;.cart-msg span&#123; display: block; margin-top: 43px; font-size: 14px;&#125;.header-wrapper&#123; position: relative;&#125;/* 设置中间的header */.header&#123; height: 100px; /* background-color: #bfa; */&#125;/* 设置logo的h1 */.header .logo&#123; float: left; margin-top: 22px; width: 55px; height: 55px; position: relative; overflow: hidden; /* 隐藏logo中的字 */ text-indent: -9999px;&#125;/* 统一设置logo的超链接 */.header .logo a&#123; /* display: block; */ position: absolute; left: 0; width: 55px; height: 55px; /* background-image: url(&quot;../img/mi-logo.png&quot;); */ background-image: url(&quot;../img/logo-mi2.png&quot;); background-size: 55px 55px; background-position: center; transition: left 0.3s;&#125;/* 设置home图标 */.header .logo .home&#123; background-color: #ff6700; background-image: url(&quot;../img/mi-home.png&quot;); left: -55px;&#125;/* 设置鼠标移入后改变图标的效果 */.header .logo:hover .mi&#123; left: 55px;&#125;.header .logo:hover .home&#123; left: 0;&#125;/* 设置中间的导航条 */.header .nav-wrapper&#123; float: left; margin-left: 7px; width: 850px;&#125;/* 设置导航条 */.header .nav&#123; /* width: 792px; */ /* background-color: #bfa; */ height: 100px; line-height: 100px; /* margin-left: 58px; */ padding-left: 58px;&#125;/* 设置导航条中的li */.nav &gt; li&#123; float: left;&#125;.all-goods-wrapper&#123; position: relative; /* background-color: red; */&#125;/* 设置左侧导航条样式 */.left-menu&#123; width: 234px; height: 420px; background-color: rgba(0,0,0,.6); position: absolute; z-index: 999; left: -120px; line-height: 1; padding: 20px 0;&#125;ul .left-menu li a&#123; height: 42px; display: block; line-height: 42px; color: white; margin-right: 0; padding: 0 30px; font-size: 14px;&#125;ul .left-menu li a:hover&#123; color: white; background-color: #ff6700;&#125;.left-menu a i&#123; float: right; line-height: 42px;&#125;.nav-wrapper li a&#123; display: block; font-size: 16px; margin-right: 20px;&#125;.nav-wrapper li a:hover&#123; color: #ff6700;&#125;/* 隐藏全部商品 */.all-goods&#123; visibility: hidden;&#125;/* */.nav .goods-info&#123; height: 0px; overflow: hidden; transition: height 0.5s; /* height: 228px; */ width: 100%; background-color: #fff; /* border-top: 1px solid rgb(224, 224, 224); */ position: absolute; top:100px; left: 0px; z-index: 9999; /* box-shadow: 0 5px 3px rgba(0, 0, 0, .2); */&#125;/* *//* .nav li:not(:first-of-type):not(:last-of-type):not(:nth-child(9)):hover ~ .goods-info, */.nav .show-goods:hover ~ .goods-info,.goods-info:hover&#123; height: 228px; border-top: 1px solid rgb(224, 224, 224); box-shadow: 0 5px 3px rgba(0, 0, 0, .2);&#125;/* 设置搜索框容器 */.search-wrapper&#123; width: 296px; height: 50px; float: right; background-color: #bfa; margin-top: 25px;&#125;.search-wrapper .search-inp&#123; float: left; height: 50px; padding: 0; border: none; width: 244px; padding: 0 10px; font-size: 15px; box-sizing: border-box; border: 1px solid rgb(224, 224, 224); outline: none;&#125;/* 设置input获取焦点后的样式 */.search-wrapper .search-inp:focus,.search-wrapper .search-inp:focus + button&#123; /* outline: 1px solid #ff6700; */ border-color: #ff6700;&#125;.search-wrapper .search-btn&#123; height: 50px; width: 52px; float: left; padding: 0; border: none; background-color: #fff; color: #616161; font-size: 16px; border: 1px solid rgb(224, 224, 224); border-left: none;&#125;.search-wrapper .search-btn:hover&#123; background-color: #ff6700; color: white; border: none;&#125;/* 设置banner */.banner&#123; position: relative; height: 460px;&#125;.banner .img-list li&#123; position: absolute;&#125;.banner img&#123; width: 100%; vertical-align: top;&#125;/* 设置五个导航点 */.pointer&#123; position: absolute; bottom: 22px; right: 35px;&#125;.pointer a&#123; float: left; width: 6px; height: 6px; border: 2px rgba(255, 255, 255, .4) solid; border-radius: 50%; background-color: rgba(0, 0, 0, .4); margin-left: 6px;&#125;.pointer a:hover,.pointer a.active&#123; border-color: rgba(0,0,0,.4); background-color: rgba(255, 255, 255, .4);&#125;/* 设置两个箭头 */.prev-next a&#123; width: 41px; height: 69px; /* background-color: red; */ position:absolute; top: 0; bottom: 0; margin: auto 0; background-image: url(&quot;../img/icon-slides.png&quot;);&#125;.prev-next .prev&#123; left: 234px; background-position: -84px 0;&#125;.prev-next .prev:hover&#123; background-position: 0 0;&#125;.prev-next .next&#123; right: 0; background-position: -125px 0;&#125;.prev-next .next:hover&#123; background-position: -42px 0;&#125;/* 设置回到顶部的元素 */.back-top&#123; width: 26px; height: 160px; background-color: orange; /* 开启固定定位 */ position: fixed; bottom: 60px; right: 50%; text-align: center; margin-right: -639px; padding-top: 40px; /* 布局的等式 left + margin-left + width + margin-right + right=视口宽度 auto + 0 + 26 + 0 + 60 = 视口宽度 auto + 0 + 26 +0 + 50% = 视口宽度 */&#125;/* 设置底部广告栏 */body .ad&#123; height: 170px; margin-top: 14px; /* background-color: red; */&#125;.ad .shortcut,.ad .ad-img,.ad li&#123; float: left;&#125;/* 设置左侧快捷方式 */.ad .shortcut&#123; width: 228px; height: 168px; background-color: #5f5750; margin-right: 14px; padding-top: 2px; padding-left: 6px;&#125;.ad .shortcut li&#123; position: relative;&#125;/* 设置上边框 */.ad .shortcut li::before&#123; content: &#x27;&#x27;; position: absolute; width: 64px; height: 1px; background-color: #665e57; left: 0; right: 0; top: 0; margin: 0 auto;&#125;/* 设置左边框 */.ad .shortcut li::before&#123; content: &#x27;&#x27;; position: absolute; width: 1px; height: 70px; background-color: #665e57; left: 0; top: 0; bottom: 0; margin: auto 0;&#125;/* 设置快捷方式中的超链接 */.ad .shortcut a&#123; display: block; color: #cfccca; width: 76px; height: 84px; text-align: center; font-size: 12px; overflow: hidden;&#125;.ad .shortcut a:hover&#123; color: #fff;&#125;/* 设置ad的图标字体 */.ad .shortcut i&#123; display: block; margin-top: 20px; font-size: 20px; margin-bottom: 5px;&#125;/* 设置右侧图片 */.ad .ad-img li&#123; width: 316px; margin-right: 15px;&#125;.ad .ad-img li:last-child&#123; margin: 0;&#125;.ad .ad-img img&#123; width: 100%; vertical-align: top;&#125; 4、reset.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* v2.0 | 20110126 http://meyerweb.com/eric/tools/css/reset/ License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: &#x27;&#x27;; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 十、animation（动画）1、过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box1&#123; width: 800px; height: 800px; background-color: silver; overflow: hidden; &#125; .box1 div&#123; width: 100px; height: 100px; margin-bottom: 100px; &#125; .box2&#123; margin-left: 700px; background-color: #bfa; /* 过渡transition 通过过渡可以指定一个属性发生变化时的切换方式 通过过渡可以创建一些非常好的效果，提升用户的体验 */ /* transition: all 2s; */ /* transition-property: ; 指定要执行过渡的属性 多个属性用逗号,隔开，全部属性用all 大部分属性都支持过渡效果 */ /* transition-property: all; */ /* transition-duration:指定过渡效果要持续的时间 时间单位s和ms 也可以分别指定时间，用逗号隔开 */ /* transition-duration: 5s; */ /* transition-timing-function: ;过渡的时序函数 指定动画过渡执行的方式 可选值： ease默认值，慢速开始，先加速，再减速 linear 匀速运动 ease-in 加速运动 ease-out 减速运动 ease-in-out 先加速后减速 cubic-bezier()来指定时序函数 https://cubic-bezier.com steps()分布执行过渡效果 可以设置第二个值 end默认值，在时间段结束时执行过渡 start在时间段开始时执行过渡 */ /* transition-timing-function: cubic-bezier(.32,1.64,.43,-1.23); */ /* transition-timing-function: steps(5,start); */ /* transition-delay: ;过渡效果的延迟，等待一段时间后执行过渡 */ /* transition-delay: 2s; */ /* tansition可以同时设置过渡相关的所有属性，只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟时间 */ transition: margin-left 2s 2s; &#125; .box1:hover div&#123; /* width: 200px; height: 200px; background-color: blue; */ margin-left: 0; &#125; .box3&#123; margin-left: 700px; background-color: orange; /* transition-property:all ; */ /* transition-duration: 5s; */ /* transition-timing-function: ease; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 练习 2、动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box1&#123; width: 800px; height: 800px; background-color: silver; overflow: hidden; &#125; .box1 div&#123; width: 100px; height: 100px; margin-bottom: 100px; margin-left: 0; &#125; .box2&#123; background-color: #bfa; /* transition: 2s; */ /* 设置box2的动画 */ /* animation-name 要对当前元素生效关键帧的名字 */ animation-name: test; /* animation-duration动画的执行时间 */ animation-duration: 2s; /* 动画延迟 */ animation-delay: 2s; /* 函数 */ animation-timing-function: ease-in-out; /* animation-iteration-count:动画执行的次数 ; 可选值： 整数 infinite 无限执行 */ animation-iteration-count:3 ; /* animation-direction: ; 指定动画运行的方向 可选值 默认值normal 从from到to运行，每次都这样 reverse从to到from运行，每次都是这样 alternate 从from到to运行，重复执行动画时折返 alternate-reverse从to到from运行，重复执行动画时折返 */ animation-direction: normal; /* animation-play-state: 设置动画的执行状态; 可选值： running默认值，动画执行 paused动画暂停 */ animation-play-state: running; /* animation-fill-mode:动画的填充模式 ; 可选值： none默认值 动画执行完回到元素原来的位置 forwards动画执行完停到结束的位置 backwards动画延迟等待时，元素就会处于开始位置 both结合了forwards和backwards */ animation-fill-mode: backwards; /* animation简写属性 */ animation: test 2s 3 1s alternate; &#125; .box1:hover div&#123; animation-play-state: paused; &#125; /* .box1:hover div&#123; margin-left: 700px; &#125; */ /* 动画和过渡类似，都是可以实现一些动态的效果 不同的是过渡需要在某个属性发生变化时才会触发 动画可以自动触发动态效果 设置动画效果，必须先设置一个关键帧，关键帧设置了动画执行的每一个步骤 */ @keyframes test &#123; /* to表示动画开始的位置 也可以使用百分率表示%*/ from&#123; margin-left: 0; background-color: #fff; &#125; /* to表示动画结束的位置 */ to&#123; margin-left: 700px; background-color: orange; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .outer&#123; height: 500px; border-bottom: 10px black solid; margin: 50px auto; overflow: hidden; &#125; .outer div&#123; float: left; width: 100px; height: 100px; border-radius: 50%; background-color: #bfa; animation: ball 0.5s forwards linear infinite alternate; &#125; .outer .box1&#123; background-color: orange; animation-delay: 0.1s; &#125; .outer .box2&#123; background-color: bisque; animation-delay: 0.2s; &#125; .outer .box3&#123; background-color: red; animation-delay: 0.3s; &#125; .outer .box4&#123; background-color: green; animation-delay: 0.4s; &#125; .outer .box5&#123; background-color: blue; animation-delay: 0.5s; &#125; .outer .box6&#123; background-color: purple; animation-delay: 0.6s; &#125; .outer .box7&#123; background-color: pink; animation-delay: 0.7s; &#125; .outer .box8&#123; background-color: yellow; animation-delay: 0.8s; &#125; /* 创建小球下落的动画 */ @keyframes ball &#123; from&#123; margin-top: 0; &#125; to&#123; margin-top: 400px; &#125; /* 20%,60%,to&#123; margin-top: 400px; animation-timing-function: ease-out; &#125; 40%&#123; margin-top: 100px; &#125; 80%&#123; margin-top: 200px; &#125; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box7&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box8&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 4、变形—-X、Y轴123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: rgb(238, 235, 229); &#125; .box1&#123; width: 200px; height: 200px; background-color: #bfa; margin: 0px auto; margin-top: 200px; /* 变形就是通过css来改变元素的形状或位置 变形不会影响页面的布局 transform用来设置元素的变形效果 -平移： translateX()沿着x轴方向平移 translateY()沿着Y轴方向平移 translateZ()沿着Z轴方向平移 平移元素的百分比是相对于自身计算的 */ /* transform: translateY(-100px); */ transform: translateX(100%); &#125; /* .box2&#123; width: 200px; height: 200px; background-color: orange; margin: 0px auto; &#125; */ .box3&#123; /* width: 100px; height: 100px; */ background-color: orange; position: absolute; /* 这种方式只适用于元素的大小确定的 left: 0; right: 0; bottom: 0; top: 0; margin: auto; */ left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%); &#125; .box4,.box5&#123; width: 220px; height: 300px; background-color: white; float: left; margin: 0 10px; transition: all .3s; &#125; .box4:hover&#123; transform: translateY(-4px); box-shadow: 0 0 10px rgba(0,0,0,.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;!-- &lt;div class=&quot;box3&quot;&gt; aaa &lt;/div&gt; --&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、Z轴平移12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; /* 设置当前网页的视距为800px 人眼距离网页的距离 */ perspective: 800px; &#125; .box1&#123; color: red; width: 474px; height: 355px; /* background-color: #bfa; */ background-image: url(./OIP-C.jpg); background-size: 100%; margin: 200px auto; /* z轴平移，调整元素在z轴的位置，正常情况下是调整元素和人眼之间的距离 距离越大，离人越近 z轴平移属性立体效果（近大远小），默认情况下网页是不支持透视的 如果需要看到效果，必须设置网页的视距 */ transition:all 2s ; &#125; .box1:hover&#123; transform: translateZ(780px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;点我一下&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 6、旋转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; /* 设置当前网页的视距为800px 人眼距离网页的距离 */ perspective: 800px; &#125; .box1&#123; color: red; width: 200px; height: 200px; background-color: #bfa; margin: 200px auto; transition:all 2s ; &#125; .box1:hover&#123; /* 通过旋转可以使元素沿着x，y或z旋转指定的角度 rotateX() rotateY() rotateZ() deg turn */ /* transform: rotateZ(360deg); */ /* transform: rotateX(360deg); */ /* transform: rotateY(360deg); */ /* transform: rotateY(180deg) translateZ(400px); */ /* transform:translateZ(400px) rotateY(180deg) ; */ transform: rotateY(180deg); /* 设置是否显示元素的背面 */ backface-visibility: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;img src=&quot;./OIP-C.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 7、缩放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html&#123; perspective: 800px; &#125; .box1&#123; width: 100px; height: 100px; background-color: #bfa; transition: 2s; margin: 100px auto; /* 变形原点 默认值center */ transform-origin: 0 0; &#125; .box1:hover&#123; /* 对元素进行缩放的函数 scaleX()水平方向 scaleY()垂直方向 scale双方向缩放 */ transform: scale(2); &#125; .img-wrapper&#123; width: 200px; height: 200px; border: 1px solid red; overflow: hidden; &#125; img&#123; transition: 2s; &#125; .img-wrapper:hover img&#123; transform: scale(1.2); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img-wrapper&quot;&gt; &lt;img src=&quot;an.jpg&quot; width=&quot;100%&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十一、less1、less的简介123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html&#123; /* css原生也支持变量的设置 */ --color:orange; --lenght:100px; &#125; .box1&#123; /* calc()计算函数 */ width: calc(1000px/10); height: var(--lenght); background-color: var(--color); &#125; .box2&#123; width: var(--lenght); height: var(--lenght); color: var(--color); &#125; .box3&#123; width:var(--lenght); height: var(--lenght); border: 10px solid var(--color); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- less是一门css的预处理语言 -less是一个css的增强版，通过less可以编写更少的代码实现更强大的样式 -在less中添加了许多新特性，像对变量的支持，对mixin的支持..... -less的语法大致和css语法是一致的，但是less中增添了许多css的扩展 所以浏览器无法直接执行less代码，要执行必须要将less转换为css，再由浏览器执行 --&gt; &lt;!-- .box$*3 --&gt; &lt;div class=&quot;box1&quot;&gt;aaaa&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;aaaa&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;aaaa&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、less的语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//less中的单行注释，注释内容不会被解析到css中/* css中的注释，内容会被解析到css文件中*/.box1&#123; background-color: #bfa; .box2&#123; background-color: orange; .box4&#123; background-color: red; &#125; &#125; .box3&#123; background-color: green; &#125;&#125;// 变量，在变量可以存储一个任意的值//并且我们可以在需要时，任意的修改变量中的值//变量的语法，@变量名@a:100px;@b:#bfa;@c:box6;.box5&#123; // 使用变量时，如果是直接使用则以 @变量名 的形式使用 width: @a; color: @b;&#125;// 作为类名时，或者一部分值使用时必须以 @&#123;变量名&#125; 的形式使用.@&#123;c&#125;&#123; width: @a; background-image: url(&quot;@&#123;c&#125;/1.jpg&quot;);&#125;@d:300px;@d:400px;div&#123; // 变量发生重名时，晚赋值的会覆盖前面的 @d:1000px; width: @d; height: @e;&#125;// 可以在变量声明前就使用变量@e:335px;div&#123; width: 300px; height: $width;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192.box1&#123; .box2&#123; color: red; &#125; &gt;.box3&#123; color: red; &amp;:hover&#123; color: blue; &#125; &#125; // 为box1设置一个hover // &amp;表示外层的父元素 &amp;:hover&#123; color: orange; &#125; div &amp;&#123; width: 100px; &#125;&#125;.p1&#123; width: 100px; height: 100px;&#125;// .p2&#123;// width: 100px;// height: 100px;// color: orange;// &#125;// :extend()对当前选择器扩展指定选择器的样式（选择器分组）.p2:extend(.p1)&#123; color: orange;&#125;.p3&#123; //直接对指定的样式进行引用，这里相对于将p1的样式在这里进行了复制 .p1();&#125;//使用类选择器时可以在选择器后边加一个括号，这时，我们实际上就创建了一个mixins// 自己不存在，但是别人可以引用.p4()&#123; width: 100px; height: 100px; background-color: #bfa;&#125;.p5&#123; .p4;&#125;// 混合函数,在混合函数中可以直接设置变量.test(@w:100px,@h:200px,@bg-color:red)&#123; width: @w; height: @h; border: 1px solid @bg-color;&#125;div&#123; //调用混合函数，按顺序传递参数 // .test(200px,300px,#bfa); //也可以直接指定对应值 // .test(@bg-color:red,@w:300px,@h:200px); // 指定了默认值，参数数量可以小于总参数数量 .test(300px);&#125;span&#123; // 取颜色的平均值 color: average(red,yellow);&#125;html&#123; width: 100%; height: 100%;&#125;body&#123; width: 100%; height: 100%; background-color: #bfa;&#125;body:hover&#123; // darken加深颜色 background-color: darken(#bfa,20%);&#125; 3、less的补充1234567891011121314// 可以通过import直接导入其他less文件到此文件@import &quot;syntax2.less&quot;;.box1&#123; //在less中所有的数值可以直接进行运算 // + - * / width: 100px * 10; // 除法需要括号 height: (100px/2); background-color: #bfa;&#125; 在设置的扩展中，修改json文件，添加从插件处复制的一段代码，全部设置为true 方便浏览器查找样式位置 十二、flex1、弹性盒123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; &#125; ul&#123; width: 500px; border:10px solid red; display: flex; /* flex-direction指定容器中弹性元素的排列方式 可选值： row默认值，弹性元素在容器中水平排列（左向右） 主轴：自左向右 row-reverse，弹性元素在容器中水平排列（右向左） 主轴：自右向左 column 弹性元纵向排列（自上向下） column-reverse 弹性元素方向纵向排列（自下向上） 主轴： 弹性元素排列的方向称为主轴 侧轴： 与主轴垂直的方向称为侧轴 */ flex-direction: row; &#125; li&#123; width: 200px; height: 100px; background-color: #bfa; font-size: 50px; text-align: center; /* float: left;会高度塌陷 */ line-height: 100px; /* 弹性元素的属性： flex-grow:指定弹性元的伸展系数 -当父元素有多余的空间时，子元素如何伸展 -父元素的剩余空间，会按照给定的系数换算的比例进行分配 flex-shrink:指定弹性元素的收缩系数 ; -当父元素的空间不足以容纳所有子元素时，如何对子元素进行收缩 -0不收缩 */ /* flex-grow: 0; */ flex-shrink: 0; &#125; li:nth-child(1)&#123; /* flex-grow: 1; */ flex-shrink:1; &#125; li:nth-child(2)&#123; background-color: pink; /* flex-grow: 2; */ flex-shrink: 2; &#125; li:nth-child(3)&#123; background-color: orange; /* flex-grow: 3; */ flex-shrink: 3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- flex弹性盒、伸缩盒 -是css中的又一种布局手段，他主要用来代替浮动来完成页面的布局 兼容选浮动，未来选flex -flex可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变 -弹性容器 -要使用弹性盒，必须将一个元素设置为一个弹性容器 -我们通过display来设置弹性容器 display:flex 设置为块级弹性容器 display:inline-flex 设置为行内的弹性容器 -弹性元素 -弹性容器的直接子元素是弹性元素（弹性项） -注意是直接！！！ -一个元素可以同时是弹性容器和弹性元素 --&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2、弹性容器的样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; &#125; ul&#123; width: 800px; border:10px solid red; /* 设置ul为弹性容器 */ display: flex; /* flex-direction: column; */ /* flex-wrap: ; 设置弹性元素是否在弹性容器中自动换行 可选值： nowrap 默认值，不自动换行 wrap 元素沿着辅轴方向自动换行 wrap-reverse元素沿着辅轴反方向换行 */ /* flex-wrap: nowrap; */ /* flex-flow: wrap 和direction的简写属性 */ /* flex-flow: row wrap; */ /* justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列） 可选值; flex-start:元素沿着主轴的起边排列 flex-end:元素沿着主轴的终边排列 center:元素居中排列 space-around 空白分布到元素两侧 space-evenly 空白分布到元素的单侧 space-between 空白均匀分布到元素间 */ /* justify-content: flex-start; */ &#125; li&#123; width: 200px; height: 100px; background-color: #bfa; font-size: 50px; text-align: center; line-height: 100px; flex-shrink: 0; &#125; li:nth-child(1)&#123; &#125; li:nth-child(2)&#123; background-color: pink; &#125; li:nth-child(3)&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3、弹性容器的样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; &#125; ul&#123; width: 600px; height: 800px; border:10px solid red; /* 设置ul为弹性容器 */ display: flex; /* flex-direction: column; */ /* flex-wrap: ; 设置弹性元素是否在弹性容器中自动换行 可选值： nowrap 默认值，不自动换行 wrap 元素沿着辅轴方向自动换行 wrap-reverse元素沿着辅轴反方向换行 */ /* flex-wrap: nowrap; */ /* flex-flow: wrap 和direction的简写属性 */ flex-flow: row wrap; /* justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列） 可选值; flex-start:元素沿着主轴的起边排列 flex-end:元素沿着主轴的终边排列 center:元素居中排列 space-around 空白分布到元素两侧 space-evenly 空白分布到元素的单侧 space-between 空白均匀分布到元素间 */ /* justify-content: flex-start; */ /* align-items: 元素在辅轴上如何对齐; 元素间的操作 可选值： stretch 默认值。将元素的高度设置为相同的值（行与行） flex-start 元素不会拉伸，沿着辅轴的起边对齐 flex-end 沿着辅轴的终边对齐 center 居中对齐 baseline 基线对齐 */ /* align-items: stretch; */ /* align-content: 辅轴空白空间的分布; 可选值与justify-content一样 */ /* align-content: center; */ &#125; li&#123; width: 200px; /* height: 100px; */ background-color: #bfa; font-size: 50px; text-align: center; line-height: 100px; flex-shrink: 0; &#125; li:nth-child(1)&#123; /* align-self: ;用来覆盖当前弹性元素上的align-items */ &#125; li:nth-child(2)&#123; background-color: pink; &#125; li:nth-child(3)&#123; background-color: orange; &#125; li:nth-child(4)&#123; background-color: green; &#125; li:nth-child(5)&#123; background-color: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2 &lt;div&gt;2&lt;/div&gt; &lt;/li&gt; &lt;li&gt;3 &lt;div&gt;3&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2 &lt;div&gt;2&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 4、弹性元素的样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; &#125; ul&#123; width: 800px; border:10px solid red; /* 设置ul为弹性容器 */ display: flex; &#125; li&#123; width: 200px; height: 100px; background-color: #bfa; font-size: 50px; text-align: center; line-height: 100px; /* flex-grow 弹性的增长系数 */ /* flex-grow: 1; */ /* 弹性系数缩减系数 -缩减系数的计算方式比较复杂 -缩减多少是根据 缩减系数和元素大小来计算的 */ /* flex-shrink: 1; */ /* 元素的基础长度 flex-basic 指定的是元素在主轴上的基础长度 如果主轴是横向的，则该值确定的就是元素的宽度 如果主轴是纵向的，则该值确定的就是元素的高度 -默认值是auto，表示参考元素自身的高度或宽度 -如果传递了一个具体的数值，则以该值为准 */ /* flex-basis: auto; */ /* flex可以设置弹性元素所有的三个样式 flex 增长 缩减 基础（按照顺序） initial: 0 1 auto auto: 1 1 auto none: 0 0 auto 弹性元素没有弹性 */ flex: initial; &#125; li:nth-child(1)&#123; /* order 指定弹性元素的排列顺序 */ order: 2; &#125; li:nth-child(2)&#123; background-color: pink; order: 3; &#125; li:nth-child(3)&#123; background-color: orange; order: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5、像素12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 100px; height: 100px; background-color: #bfa; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 像素： -屏幕是由一个一个发光的小点构成的，这一个个的小点就是像素 -分辨率。1920x1080 说的就是屏幕中的像素数量 -在前端开发中像素要分成两种情况讨论，css像素和物理像素 -物理像素，上述所说的小点就属于物理像素 -css像素，编写网页时，我们所用像素都是css像素 -浏览器在显示网页时，需要将css像素转换为物理像素然后再呈现 -一个css像素最终由几个物理像素显示，由浏览器决定 默认情况下在pc端，一个css像素，一个物理像素 视口（viewport） -视口就是屏幕中用来显示网页的区域 -我们可以通过查看视口的大小，来计算css像素和物理像素的比值 -默认情况下 视口宽度 1920px（css像素） 1920px（物理像素） -此时，css像素和物理像素的比是1:1 放大两倍的情况： 视口宽度960px（css像素0 1920px(物理像素) -此时，cs像素和物理像素的比是1:2 我们可以通过改变视口的大小，来改变css像素和物理像素的比值 --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、移动端12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; --&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 900px; height: 100px; background-color: #bfa; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 在不同的屏幕。单位像素的大小是不同的，像素越小越清晰 24寸 1920x1080 iphone6 4.7寸 750x1334 智能手机的像素点 远远小于计算机的像素点 问题：一个宽度为900px的网页在iPhone6中如何显示 默认情况下，移动端的网页都会将视口设置为980像素(css像素) 以确保pc端的网页可以在移动端正常访问，但是如果网页的宽度超过了980，移动端的浏览器会自动缩放以显示完整的网页 https://material.io/resources/devices/ 所以基本大部分的pc端网站都可以在移动端中正常浏览，但是往往不会有一个好的体验 为了解决这个问题，大部分网站都会单独为移动端设计一个网页 --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7、移动端的页面.html123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; --&gt; &lt;!-- 设置视口大小 device-width表示设置的宽度（完美视口）--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 移动端默认的视口是980px（css像素） 默认情况下，移动端的像素比就是 980/移动端的宽度 如果直接在网页中编写移动端代码，这样在980视口下，像素比是非常不好的 导致网页中的内容非常的小 编写移动端页面时，必须要确保有一个比较合理的像素比 1css像素 对应两个物理像素 1css像素 对应3个物理像素 我们可以通过meta标签来设置视口大小 -每一款移动设备设计时，都会有一个最佳的像素比， 一般我们只需要将像素比设置为该值即可得到一个最佳效果 将像素比设置为最佳像素比的视口大小，我们称其为完美视口 将网页的视口设置为完美视口 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 结论：以后写移动端的页面，就把上边这个玩意先写上 --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8、视口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box1&#123; width: 100vw; height: 100px; background-color: #bfa; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;!-- 不同的设备完美的视口大小是不一样的 iphone 6 --375 iphone6p --414 由于不同设置视口和像素比不同，所以同样375像素在不同的设备下意义是不一样的 比如在iphone6中，375就是全屏，但到了plus中375就会缺一块 所以在移动端开发时，就不能在使用px来进行布局了 vw表示的是视口的宽度（viewport width） 100vw = 一个视口的宽度 -1vw = 百分之一视口宽度 vw这个单位永远相当于视口宽度进行计算 设计图的宽度 750px X 1125px 设计图 750px 使用vm作为单位 100vw 创建一个48px x 35px大小的元素 100vw = 750px（设计图） 6.4vw = 48px 4.667vw =35px --&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 9、vw的适配方案123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; html&#123; /* 网页中字体的大小是12px，不能设置一个比12px像素还小的字体 如果我们设置了设置了一个小于12px的字体，则字体自动设置为12px 0.1333333vw = 1px 5.3333vw = 40px */ font-size: 5.3333vw; &#125; .box1&#123; /* em - 1rem = 1 html的字体大小 1rem = 40px（设计图） */ width: 1.2rem; height: 0.875rem; background-color: #bfa; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 48px x 35px --&gt; &lt;div class=&quot;box1&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 10、响应式布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 使用媒体查询 语法：@media 查询规则&#123;&#125; 媒体类型： all 所有设备 print 打印设备 screen 带屏幕的设备 speech 屏幕阅读器 可以使用,连接多个媒体类型，这样他们之间就是一个或的关系 可以在媒体类型前添加一个only表示只有 only的使用主要是为了兼容一些老版本的浏览器 */ /* @media print,screen &#123; body&#123; background-color: #bfa; &#125; &#125; */ @media only screen &#123; body&#123; background-color: #bfa; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 响应式布局 -网页可以根据不同的设备或窗口大小呈现出不同的效果 -使用响应式布局，可以使一个网页使用于所有设备 -响应布局的关键就是媒体查询 -通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式 --&gt;&lt;/body&gt;&lt;/html&gt; 11、媒体查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 媒体类型： width：视口的宽度 height：视口的高度 要刚刚好=500px才会生效 min-width 视口的最小宽度（大于等于宽度时生效） max-width 视口的最大宽度（小于等于宽度时生效） */ /* @media (min-width: 500px)&#123; body&#123; background-color: #bfa; &#125; &#125; */ /* 样式的切换的分界点，我们称其为断点，也就是页面的样式会在这个点是发生变化 一般常用的断点 小于768 超小屏幕 max-width=768px 大于768 小屏幕 min-width=768px 大于992 中型屏幕 min-width=992px 大于1200 大屏幕 min-width=1200px */ @media only screen and (min-width: 500px ) and (max-width:800px)&#123; body&#123; background-color: #bfa; &#125; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","tags":"html-css"},{"title":"Markdown语法","url":"/2022/10/14/Markdown语法/","text":"Markdown语法 1.标题两种方法： 1）使用快捷键Ctrl+(1-6) 1）使用#+空格+文字(一个#代表一级，两个代表二级……) 例： 一级标题二级标题2.段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 换行不换段：shift+enter 换段：enter 如： 我不换段哈哈哈 我换了 3.区块引用在段落的每行或者只在第一行使用符号”&gt;”，还可使用多个嵌套引用，如： 区块引用 嵌套引用 4.代码区块输入法切换为非中文，输入键盘左上角ESc下的按键，连续输入三次 ，在输入对应的编程语言类型，则会出现代码框，即可输入代码。 代码区块： 12345void main()&#123; printf(&quot;Hello,Markdown.&quot;);&#125; 5.强调（加粗）在强调内容两侧分别加上**或者– 如： 加粗 6.斜体在要使用斜体的内容左右两侧加上*或- 如： 斜体 7.下划线HTML的语法： 12&lt;u&gt;我是下划线&lt;/u&gt;或者快捷键CTRL+u 我是下划线 8.高亮在需要加高亮的内容左右两侧加上&#x3D;&#x3D; 如： &#x3D;&#x3D;这是高亮的内容&#x3D;&#x3D; 9.下标如： 12水 H~2~O在下标的左右两端加上~ 水 H2O 10.上标如： 123面积 m^2^体积 m^3^在上标的左右两端加上^ 面积 m^2^体积 m^3^ 10.表格 快捷键：Ctrl+t 源代码模式下使用|来分隔不同的单元格，使用-来分隔表头和其他行 如: 姓名 年龄 成绩 张三 11 19 索酷 29 299 四去 29 210 11.分割线只需要输入三个-符号 12.删除线左右两边加上~~ 删除了 13.脚注[^文字] 示例： 给这段文字加上脚注[^脚注] 14.有序列表 快捷键：CTRL+shift+[ 直接输入数字+一点+空格 15.无序列表 快捷键：CTRL+shift+] 直接输入-+空格 16.链接1[链接名称](图片地址) 例如： 这个一个链接：百度 17.图片1![当图片无法显示时的占位符](图片地址) 例如： 18.内部跳转-本文件内跳转，必须是标题格式为[link text](#要去哪个标题) 我想跳转到第一个标题 19.自动链接使用&lt;&gt;包括的URL或邮箱地址会被直接自动做转换为超链接： https://www.baidu.com 20.网上图片一样的，把图片路径换为网页路径 如： 21.任务- [x] 吃饭 吃饭 睡觉 22.数学公式公式左右两边用两个美元符号包围$$\\frac{\\partial f}{\\partial x} &#x3D; 2\\sqrt{a}x$$相关数学公式符号可查","tags":"markdown"},{"title":"Maven","url":"/2022/10/14/Maven/","text":"Maven一、小白入门第一章、Maven概述1、为什么要学习Maven？1、Maven作为依赖管理工具 jar包的规模 1随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多，项目中，一个模块里面要用到上百个jar包是非常正常的。 比如下面这个例子，我们只用到SpringBoot、SpringCloud框架中的三个功能： Nacos服务器注册发现 Web框架环境 图模块技术Thyme leaf 最终导入了106个jar包 而如果使用Maven来引用这些jar包只需要配置三个【依赖】。 jar包的来源 jar之间的依赖关系 2、Maven作为构建管理工具 你没有注意过的构建 1你可以不使用Maven，但是构建必须要做，当我们使用idea进行开发时，构建是idea替我们做的。 脱离IDE环境仍需构建 3、结论 管理规模庞大的jar白，需要专门的工具 脱离ide环境执行构建操作，需要专门的工具 2、什么是Maven？Maven是Apache软件基金会组织维护的一款专门为java项目提供构建和依赖管理支持的工具。 1、构建 2、依赖 3、Maven的工作机制 第二章、Maven核心程序解压和配置1、Maven核心程序解压和配置1、Maven官网下载及解压Maven官网：https://maven.apache.org/ windows:下载bin.zip&#x2F;src.zip linux:下载tar.gz 重点关注conf&#x2F;settings.xml bin&#x2F;mvn.cmd 是mvn可执行文件 2、指定本地仓库 3、配置阿里云提供的镜像仓库 1234567891011121314151617181920212223242526272829303132333435&lt;!--阿里云镜像1--&gt;&lt;mirror&gt; &lt;id&gt;aliyunId&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;&lt;/mirror&gt; &lt;!--阿里云镜像2--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; &lt;!--阿里云镜像3--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt; &lt;!--阿里云镜像4--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://central.maven.org/maven2&lt;/url&gt;&lt;/mirror&gt;&lt;!--maven官方镜像--&gt; &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name&lt;/name&gt; &lt;url&gt;https://repol.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 4、配置Maven工程的基础JDK版本1234567891011121314&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 2、配置环境变量1、检查JAVA_HOME配置是否正确 2、配置MAVEN_HOME 3、配置PATH将MAVEN_HOME引用到path 4、验证 第三章、使用Maven：命令行环境1、根据坐标创建Maven工程1、Maven核心概念：坐标 2、实验操作 ⑤解读生成的pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- project 标签：根标签，表示对当前工程进行配置、管理--&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- modelVersion 标签：从maven2 开始就固定是4.0.0。 --&gt; &lt;!-- 代表当前pom.xml所采用的标签结构--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 坐标信息 --&gt; &lt;!-- groupId 标签，坐标向量之一：代表公司或组织开发的某一个项目 --&gt; &lt;groupId&gt;com.lxg.maven&lt;/groupId&gt; &lt;!-- artifactId 标签，坐标向量之一：代表项目下的某一个模块 --&gt; &lt;artifactId&gt;maven-01-java&lt;/artifactId&gt; &lt;!-- version 标签：坐标向量之一：代表当前模块的版本 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- packaging 标签：打包方式 --&gt; &lt;!-- 取值jar：生成jar包，说明这个一个java工程--&gt; &lt;!-- 取值jar：生成war包，说明这个一个web工程--&gt; &lt;!-- 取值pom：说明这个工程是用来管理其他工程的工程 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;maven-01-java&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在Maven中定义属性值 --&gt; &lt;properties&gt; &lt;!-- properties 标签：在构建过程中读取源码时使用的字符集 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- dependencies 标签：配置具体依赖信息，可以包含多个dependency子标签 --&gt; &lt;dependencies&gt; &lt;!-- dependency 标签：配置一个具体的依赖信息 --&gt; &lt;dependency&gt; &lt;!-- 依赖坐标信息 --&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;!-- scope标签：配置当前依赖的范围--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、Maven核心概念：POM 4、Maven核心概念：约定的目录结构 2、在Maven工程中编写代码1、主体程序 123456package com.lxg.maven;public class Calculator &#123; public int sum(int i,int j)&#123; return i + j; &#125;&#125; 2、测试主程序测试类： 123456789101112131415161718192021package com.lxg.maven;import org.junit.Test;import com.lxg.maven.Calculator;// 静态导入的效果是将Assert类中的静态资源导入当前类// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名import static org.junit.Assert.*;public class CalculatorTest&#123; @Test public void testSum()&#123; // 1.创建Calculator对象 Calculator calculator = new Calculator(); // 2.调用Calculator对象的方法，获取到程序运行实际的结果 int actualResult = calculator.sum(5, 3); // 3.声明一个变量，表示程序运行期待的结果 int expectedResult = 8; // 4.使用断言来判断实际结果和期待结果是否一致 // 如果一致：测试通过，不会抛出异常 // 如果不一致：抛出异常，测试失败 assertEquals(expectedResult, actualResult); &#125;&#125; 3、执行Maven的构建命令1、要求 2、清理工作mvn clean 效果：删除target目录 3、编译操作 4、测试操作mvn test 测试的报告存放的目录：target&#x2F;surefile-reports 5、打包操作mvn package 打包的结果—jar包，存放的目录：target 6、安装操作 4、创建Maven版的Web工程1、说明 2、操作 3、生成的pom.xml文件12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lxg.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-02-web&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;maven-02-web Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4、生成的Web工程的目录结构 5、创建Servlet ③在包下创建Servlet类 123456789101112package com.lxg.maven;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.ServletException;import java.io.IOException;public class HelloServlet extends HttpServlet&#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(&quot;hello maven web&quot;); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lxg.maven.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、在index.jsp页面编写超链接123456&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;a href=&quot;helloServlet&quot;&gt;Access Servlet&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 7、编译 8、配置对servlet-api.jar包的依赖 网址：https://mvnrepository.com/ 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 9、将Web工程打包为war包 10、将war包部署到Tomcat上运行将war包的解压包复制到tomcat的webapps目录下，然后启动tomcat服务器即可在浏览器访问 5、让Web工程依赖Java工程1、观念 2、操作在web工程的pom.xml文件中，找到dependencies标签，在标签中做如下配置 12345&lt;dependency&gt; &lt;groupId&gt;com.lxg.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-01-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 3、在web工程中，编写测试代码 4、执行Maven命令 6、测试依赖范围1、依赖范围 部署到服务器是否有效取决于 会不会参与打包。 provided：已提供，说明服务器已经提供了，打包的时候就不要参与进去。 若是服务器已有的你还参与打包了就会发生冲突，常见会抛空指针异常或找不到类异常。 7、测试依赖的传递性1、依赖的传递性 2、使用compile范围依赖spring-core 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 8、测试依赖的排除1、概念 2、配置方式12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.lxg.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-01-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 使用excludes标签配置依赖的排除 --&gt; &lt;exclusions&gt; &lt;!-- 在exclude标签中配置一个具体的排除 --&gt; &lt;exclusion&gt; &lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3、测试 9、继承1、概念 2、作用 3、举例 4、操作 12345&lt;modules&gt; &lt;module&gt;maven-04-module&lt;/module&gt; &lt;module&gt;maven-05-module&lt;/module&gt; &lt;module&gt;maven-06-module&lt;/module&gt;&lt;/modules&gt; 123456789101112131415161718192021222324252627282930&lt;!-- 在父工程中统一管理依赖信息 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; 123456&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;&lt;properties&gt;&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;!-- 自定义标签，维护Spring版本数据 --&gt;&lt;atguigu.spring.version&gt;4.3.6.RELEASE&lt;/atguigu.spring.version&gt;&lt;/properties&gt; 123456&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-core&lt;/artifactId&gt;&lt;version&gt;$&#123;atguigu.spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 5、实际意义 10、聚合1、聚合本身的含义 2、Maven中的聚合 3、好处 4、聚合的配置 5、依赖循环问题 第四章、使用Maven：IDEA环境1、创建父工程1、创建Project 2、配置Maven信息 3、创建Java模块工程 测试： IDEA执行mvn命令的三种方式： 1、 2、 跳过test -D表示后面要附加的参数，字母D和后面的参数是紧挨着的，中间没有任何其他的字符 3、 4、创建Web模块工程 运行： 5、其他操作1、工程导入 2、模块导入 第五章、其他核心概念1、生命周期①作用 ②三个生命周期 ③特点 2、插件和目标 3、仓库 二、掌握Maven环境开发全流程三、Maven技术体系全面覆盖","tags":"maven"},{"title":"站内全文静态搜索","url":"/search/index.html","text":"&#9906; $(document).ready(function() { $('#tipue_search_input').tipuesearch({ 'show': 10, // 每页显示的最大搜索记录数，默认值：10 'showURL': true, // 是否将URL显示在每个搜索结果中，默认值：true 'newWindow': true, // 点击搜索结果时是否在新的浏览器选项卡中打开页面，默认值：false 'footerPages': 10, // 页脚中显示的最大页面选择数，默认值：3 'minimumLength': 1, // 搜索关键字中最小的字符长度，默认值：3 'wholeWords': false, // 是否不使用英语以外的其他语言，默认值：true 'showTitleCount': false // 是否将搜索结果的数量显示在浏览器选项卡的标题中，默认值：true }); });","tags":""},{"title":"","url":"/js/script.js","text":"gsap.set(\"svg\", { visibility: \"visible\" }); gsap.to(\"#headStripe\", { y: 0.5, rotation: 1, yoyo: true, repeat: -1, ease: \"sine.inOut\", duration: 1 }); gsap.to(\"#spaceman\", { y: 0.5, rotation: 1, yoyo: true, repeat: -1, ease: \"sine.inOut\", duration: 1 }); gsap.to(\"#craterSmall\", { x: -3, yoyo: true, repeat: -1, duration: 1, ease: \"sine.inOut\" }); gsap.to(\"#craterBig\", { x: 3, yoyo: true, repeat: -1, duration: 1, ease: \"sine.inOut\" }); gsap.to(\"#planet\", { rotation: -2, yoyo: true, repeat: -1, duration: 1, ease: \"sine.inOut\", transformOrigin: \"50% 50%\" }); gsap.to(\"#starsBig g\", { rotation: \"random(-30,30)\", transformOrigin: \"50% 50%\", yoyo: true, repeat: -1, ease: \"sine.inOut\" }); gsap.fromTo( \"#starsSmall g\", { scale: 0, transformOrigin: \"50% 50%\" }, { scale: 1, transformOrigin: \"50% 50%\", yoyo: true, repeat: -1, stagger: 0.1 }); gsap.to(\"#circlesSmall circle\", { y: -4, yoyo: true, duration: 1, ease: \"sine.inOut\", repeat: -1 }); gsap.to(\"#circlesBig circle\", { y: -2, yoyo: true, duration: 1, ease: \"sine.inOut\", repeat: -1 }); gsap.set(\"#glassShine\", { x: -68 }); gsap.to(\"#glassShine\", { x: 80, duration: 2, rotation: -30, ease: \"expo.inOut\", transformOrigin: \"50% 50%\", repeat: -1, repeatDelay: 8, delay: 2 }); const burger = document.querySelector('.burger'); const nav = document.querySelector('nav'); burger.addEventListener('click', e => { burger.dataset.state === 'closed' ? burger.dataset.state = \"open\" : burger.dataset.state = \"closed\"; nav.dataset.state === \"closed\" ? nav.dataset.state = \"open\" : nav.dataset.state = \"closed\"; });","tags":""},{"title":"","url":"/js/gsap.min.js","text":"/*! * GSAP 3.1.1 * https://greensock.com * * @license Copyright 2020, GreenSock. All rights reserved. * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership. * @author: Jack Doyle, jack@greensock.com */ !function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],e):e((t=t||self).window=t.window||{})}(this,function(e){\"use strict\";function _inheritsLoose(t,e){t.prototype=Object.create(e.prototype),(t.prototype.constructor=t).__proto__=e}function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}function n(t){return\"string\"==typeof t}function o(t){return\"function\"==typeof t}function p(t){return\"number\"==typeof t}function q(t){return void 0===t}function r(t){return\"object\"==typeof t}function s(t){return!1!==t}function t(){return\"undefined\"!=typeof window}function u(t){return o(t)||n(t)}function J(t){return(l=_t(t,at))&&ne}function K(t,e){return console.warn(\"Invalid property\",t,\"set to\",e,\"Missing plugin? gsap.registerPlugin()\")}function L(t,e){return!e&&console.warn(t)}function M(t,e){return t&&(at[t]=e)&&l&&(l[t]=e)||at}function N(){return 0}function X(t){var e,n,i=t[0];if(r(i)||o(i)||(t=[t]),!(e=(i._gsap||{}).harness)){for(n=pt.length;n--&&!pt[n].targetTest(i););e=pt[n]}for(n=t.length;n--;)t[n]&&(t[n]._gsap||(t[n]._gsap=new Et(t[n],e)))||t.splice(n,1);return t}function Y(t){return t._gsap||X(yt(t))[0]._gsap}function Z(t,e){var r=t[e];return o(r)?t[e]():q(r)&&t.getAttribute(e)||r}function $(t,e){return(t=t.split(\",\")).forEach(e)||t}function _(t){return Math.round(1e4*t)/1e4}function aa(t,e){for(var r=e.length,n=0;t.indexOf(e[n])","tags":""},{"title":"","url":"/css/style.css","text":"@import url(\"https://fonts.googleapis.com/css?family=Nunito+Sans\"); :root { --blue: #0e0620; --white: #fff; --green: #2ccf6d; } html, body { height: 100%; } body { display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; -webkit-box-pack: center; justify-content: center; font-family: \"Nunito Sans\"; color: var(--blue); font-size: 1em; } button { font-family: \"Nunito Sans\"; } ul { list-style-type: none; -webkit-padding-start: 35px; padding-inline-start: 35px; } svg { width: 100%; visibility: hidden; } h1 { font-size: 7.5em; margin: 15px 0px; font-weight: bold; } h2 { font-weight: bold; } .hamburger-menu { position: absolute; top: 0; left: 0; padding: 35px; z-index: 2; } .hamburger-menu button { position: relative; width: 30px; height: 22px; border: none; background: none; padding: 0; cursor: pointer; } .hamburger-menu button span { position: absolute; height: 3px; background: #000; width: 100%; left: 0px; top: 0px; -webkit-transition: 0.1s ease-in; transition: 0.1s ease-in; } .hamburger-menu button span:nth-child(2) { top: 9px; } .hamburger-menu button span:nth-child(3) { top: 18px; } .hamburger-menu [data-state=\"open\"] span:first-child { -webkit-transform: rotate(45deg); transform: rotate(45deg); top: 10px; } .hamburger-menu [data-state=\"open\"] span:nth-child(2) { width: 0%; opacity: 0; } .hamburger-menu [data-state=\"open\"] span:nth-child(3) { -webkit-transform: rotate(-45deg); transform: rotate(-45deg); top: 10px; } nav { position: absolute; height: 100%; top: 0; left: 0; background: var(--green); color: var(--blue); width: 300px; z-index: 1; padding-top: 80px; -webkit-transform: translateX(-100%); transform: translateX(-100%); -webkit-transition: 0.24s cubic-bezier(0.52, 0.01, 0.8, 1); transition: 0.24s cubic-bezier(0.52, 0.01, 0.8, 1); } nav li { -webkit-transform: translateX(-5px); transform: translateX(-5px); -webkit-transition: 0.16s cubic-bezier(0.44, 0.09, 0.46, 0.84); transition: 0.16s cubic-bezier(0.44, 0.09, 0.46, 0.84); opacity: 0; } nav a { display: block; font-size: 1.75em; font-weight: bold; text-decoration: none; color: inherit; -webkit-transition: 0.24s ease-in-out; transition: 0.24s ease-in-out; } nav a:hover { text-decoration: none; color: var(--white); } nav[data-state=\"open\"] { -webkit-transform: translateX(0%); transform: translateX(0%); } nav[data-state=\"open\"] ul li:nth-child(1) { -webkit-transition-delay: 0.16s; transition-delay: 0.16s; -webkit-transform: translateX(0px); transform: translateX(0px); opacity: 1; } nav[data-state=\"open\"] ul li:nth-child(2) { -webkit-transition-delay: 0.32s; transition-delay: 0.32s; -webkit-transform: translateX(0px); transform: translateX(0px); opacity: 1; } nav[data-state=\"open\"] ul li:nth-child(3) { -webkit-transition-delay: 0.48s; transition-delay: 0.48s; -webkit-transform: translateX(0px); transform: translateX(0px); opacity: 1; } nav[data-state=\"open\"] ul li:nth-child(4) { -webkit-transition-delay: 0.64s; transition-delay: 0.64s; -webkit-transform: translateX(0px); transform: translateX(0px); opacity: 1; } .btn { z-index: 1; overflow: hidden; background: transparent; position: relative; padding: 8px 50px; border-radius: 30px; cursor: pointer; font-size: 1em; letter-spacing: 2px; -webkit-transition: 0.2s ease; transition: 0.2s ease; font-weight: bold; margin: 5px 0px; } .btn.green { border: 4px solid var(--green); color: var(--blue); } .btn.green:before { content: \"\"; position: absolute; left: 0; top: 0; width: 0%; height: 100%; background: var(--green); z-index: -1; -webkit-transition: 0.2s ease; transition: 0.2s ease; } .btn.green:hover { color: var(--white); background: var(--green); -webkit-transition: 0.2s ease; transition: 0.2s ease; } .btn.green:hover:before { width: 100%; } @media screen and (max-width: 768px) { body { display: block; } .container { margin-top: 70px; margin-bottom: 70px; } }","tags":""},{"title":"","url":"/css/bootstrap.min.css","text":"/*! * Bootstrap v4.1.3 (https://getbootstrap.com/) * Copyright 2011-2018 The Bootstrap Authors * Copyright 2011-2018 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) */:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-family-monospace:SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace}*,::after,::before{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent}@-ms-viewport{width:device-width}article,aside,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}[tabindex=\"-1\"]:focus{outline:0!important}hr{box-sizing:content-box;height:0;overflow:visible}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}abbr[data-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;border-bottom:0}address{margin-bottom:1rem;font-style:normal;line-height:inherit}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}dfn{font-style:italic}b,strong{font-weight:bolder}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#007bff;text-decoration:none;background-color:transparent;-webkit-text-decoration-skip:objects}a:hover{color:#0056b3;text-decoration:underline}a:not([href]):not([tabindex]){color:inherit;text-decoration:none}a:not([href]):not([tabindex]):focus,a:not([href]):not([tabindex]):hover{color:inherit;text-decoration:none}a:not([href]):not([tabindex]):focus{outline:0}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto;-ms-overflow-style:scrollbar}figure{margin:0 0 1rem}img{vertical-align:middle;border-style:none}svg{overflow:hidden;vertical-align:middle}table{border-collapse:collapse}caption{padding-top:.75rem;padding-bottom:.75rem;color:#6c757d;text-align:left;caption-side:bottom}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=date],input[type=datetime-local],input[type=month],input[type=time]{-webkit-appearance:listbox}textarea{overflow:auto;resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:none}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}summary{display:list-item;cursor:pointer}template{display:none}[hidden]{display:none!important}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-family:inherit;font-weight:500;line-height:1.2;color:inherit}.h1,h1{font-size:2.5rem}.h2,h2{font-size:2rem}.h3,h3{font-size:1.75rem}.h4,h4{font-size:1.5rem}.h5,h5{font-size:1.25rem}.h6,h6{font-size:1rem}.lead{font-size:1.25rem;font-weight:300}.display-1{font-size:6rem;font-weight:300;line-height:1.2}.display-2{font-size:5.5rem;font-weight:300;line-height:1.2}.display-3{font-size:4.5rem;font-weight:300;line-height:1.2}.display-4{font-size:3.5rem;font-weight:300;line-height:1.2}hr{margin-top:1rem;margin-bottom:1rem;border:0;border-top:1px solid rgba(0,0,0,.1)}.small,small{font-size:80%;font-weight:400}.mark,mark{padding:.2em;background-color:#fcf8e3}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none}.list-inline-item{display:inline-block}.list-inline-item:not(:last-child){margin-right:.5rem}.initialism{font-size:90%;text-transform:uppercase}.blockquote{margin-bottom:1rem;font-size:1.25rem}.blockquote-footer{display:block;font-size:80%;color:#6c757d}.blockquote-footer::before{content:\"\\2014 \\00A0\"}.img-fluid{max-width:100%;height:auto}.img-thumbnail{padding:.25rem;background-color:#fff;border:1px solid #dee2e6;border-radius:.25rem;max-width:100%;height:auto}.figure{display:inline-block}.figure-img{margin-bottom:.5rem;line-height:1}.figure-caption{font-size:90%;color:#6c757d}code{font-size:87.5%;color:#e83e8c;word-break:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:87.5%;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:100%;font-weight:700}pre{display:block;font-size:87.5%;color:#212529}pre code{font-size:inherit;color:inherit;word-break:normal}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.container{max-width:540px}}@media (min-width:768px){.container{max-width:720px}}@media (min-width:992px){.container{max-width:960px}}@media (min-width:1200px){.container{max-width:1140px}}.container-fluid{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.no-gutters{margin-right:0;margin-left:0}.no-gutters>.col,.no-gutters>[class*=col-]{padding-right:0;padding-left:0}.col,.col-1,.col-10,.col-11,.col-12,.col-2,.col-3,.col-4,.col-5,.col-6,.col-7,.col-8,.col-9,.col-auto,.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-auto,.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-auto,.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-auto,.col-xl,.col-xl-1,.col-xl-10,.col-xl-11,.col-xl-12,.col-xl-2,.col-xl-3,.col-xl-4,.col-xl-5,.col-xl-6,.col-xl-7,.col-xl-8,.col-xl-9,.col-xl-auto{position:relative;width:100%;min-height:1px;padding-right:15px;padding-left:15px}.col{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.col-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:none}.col-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-first{-ms-flex-order:-1;order:-1}.order-last{-ms-flex-order:13;order:13}.order-0{-ms-flex-order:0;order:0}.order-1{-ms-flex-order:1;order:1}.order-2{-ms-flex-order:2;order:2}.order-3{-ms-flex-order:3;order:3}.order-4{-ms-flex-order:4;order:4}.order-5{-ms-flex-order:5;order:5}.order-6{-ms-flex-order:6;order:6}.order-7{-ms-flex-order:7;order:7}.order-8{-ms-flex-order:8;order:8}.order-9{-ms-flex-order:9;order:9}.order-10{-ms-flex-order:10;order:10}.order-11{-ms-flex-order:11;order:11}.order-12{-ms-flex-order:12;order:12}.offset-1{margin-left:8.333333%}.offset-2{margin-left:16.666667%}.offset-3{margin-left:25%}.offset-4{margin-left:33.333333%}.offset-5{margin-left:41.666667%}.offset-6{margin-left:50%}.offset-7{margin-left:58.333333%}.offset-8{margin-left:66.666667%}.offset-9{margin-left:75%}.offset-10{margin-left:83.333333%}.offset-11{margin-left:91.666667%}@media (min-width:576px){.col-sm{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.col-sm-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:none}.col-sm-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-sm-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-sm-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-sm-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-sm-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-sm-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-sm-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-sm-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-sm-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-sm-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-sm-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-sm-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-sm-first{-ms-flex-order:-1;order:-1}.order-sm-last{-ms-flex-order:13;order:13}.order-sm-0{-ms-flex-order:0;order:0}.order-sm-1{-ms-flex-order:1;order:1}.order-sm-2{-ms-flex-order:2;order:2}.order-sm-3{-ms-flex-order:3;order:3}.order-sm-4{-ms-flex-order:4;order:4}.order-sm-5{-ms-flex-order:5;order:5}.order-sm-6{-ms-flex-order:6;order:6}.order-sm-7{-ms-flex-order:7;order:7}.order-sm-8{-ms-flex-order:8;order:8}.order-sm-9{-ms-flex-order:9;order:9}.order-sm-10{-ms-flex-order:10;order:10}.order-sm-11{-ms-flex-order:11;order:11}.order-sm-12{-ms-flex-order:12;order:12}.offset-sm-0{margin-left:0}.offset-sm-1{margin-left:8.333333%}.offset-sm-2{margin-left:16.666667%}.offset-sm-3{margin-left:25%}.offset-sm-4{margin-left:33.333333%}.offset-sm-5{margin-left:41.666667%}.offset-sm-6{margin-left:50%}.offset-sm-7{margin-left:58.333333%}.offset-sm-8{margin-left:66.666667%}.offset-sm-9{margin-left:75%}.offset-sm-10{margin-left:83.333333%}.offset-sm-11{margin-left:91.666667%}}@media (min-width:768px){.col-md{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.col-md-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:none}.col-md-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-md-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-md-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-md-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-md-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-md-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-md-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-md-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-md-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-md-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-md-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-md-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-md-first{-ms-flex-order:-1;order:-1}.order-md-last{-ms-flex-order:13;order:13}.order-md-0{-ms-flex-order:0;order:0}.order-md-1{-ms-flex-order:1;order:1}.order-md-2{-ms-flex-order:2;order:2}.order-md-3{-ms-flex-order:3;order:3}.order-md-4{-ms-flex-order:4;order:4}.order-md-5{-ms-flex-order:5;order:5}.order-md-6{-ms-flex-order:6;order:6}.order-md-7{-ms-flex-order:7;order:7}.order-md-8{-ms-flex-order:8;order:8}.order-md-9{-ms-flex-order:9;order:9}.order-md-10{-ms-flex-order:10;order:10}.order-md-11{-ms-flex-order:11;order:11}.order-md-12{-ms-flex-order:12;order:12}.offset-md-0{margin-left:0}.offset-md-1{margin-left:8.333333%}.offset-md-2{margin-left:16.666667%}.offset-md-3{margin-left:25%}.offset-md-4{margin-left:33.333333%}.offset-md-5{margin-left:41.666667%}.offset-md-6{margin-left:50%}.offset-md-7{margin-left:58.333333%}.offset-md-8{margin-left:66.666667%}.offset-md-9{margin-left:75%}.offset-md-10{margin-left:83.333333%}.offset-md-11{margin-left:91.666667%}}@media (min-width:992px){.col-lg{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.col-lg-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:none}.col-lg-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-lg-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-lg-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-lg-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-lg-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-lg-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-lg-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-lg-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-lg-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-lg-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-lg-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-lg-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-lg-first{-ms-flex-order:-1;order:-1}.order-lg-last{-ms-flex-order:13;order:13}.order-lg-0{-ms-flex-order:0;order:0}.order-lg-1{-ms-flex-order:1;order:1}.order-lg-2{-ms-flex-order:2;order:2}.order-lg-3{-ms-flex-order:3;order:3}.order-lg-4{-ms-flex-order:4;order:4}.order-lg-5{-ms-flex-order:5;order:5}.order-lg-6{-ms-flex-order:6;order:6}.order-lg-7{-ms-flex-order:7;order:7}.order-lg-8{-ms-flex-order:8;order:8}.order-lg-9{-ms-flex-order:9;order:9}.order-lg-10{-ms-flex-order:10;order:10}.order-lg-11{-ms-flex-order:11;order:11}.order-lg-12{-ms-flex-order:12;order:12}.offset-lg-0{margin-left:0}.offset-lg-1{margin-left:8.333333%}.offset-lg-2{margin-left:16.666667%}.offset-lg-3{margin-left:25%}.offset-lg-4{margin-left:33.333333%}.offset-lg-5{margin-left:41.666667%}.offset-lg-6{margin-left:50%}.offset-lg-7{margin-left:58.333333%}.offset-lg-8{margin-left:66.666667%}.offset-lg-9{margin-left:75%}.offset-lg-10{margin-left:83.333333%}.offset-lg-11{margin-left:91.666667%}}@media (min-width:1200px){.col-xl{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.col-xl-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:none}.col-xl-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-xl-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-xl-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-xl-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-xl-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-xl-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-xl-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-xl-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-xl-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-xl-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-xl-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-xl-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-xl-first{-ms-flex-order:-1;order:-1}.order-xl-last{-ms-flex-order:13;order:13}.order-xl-0{-ms-flex-order:0;order:0}.order-xl-1{-ms-flex-order:1;order:1}.order-xl-2{-ms-flex-order:2;order:2}.order-xl-3{-ms-flex-order:3;order:3}.order-xl-4{-ms-flex-order:4;order:4}.order-xl-5{-ms-flex-order:5;order:5}.order-xl-6{-ms-flex-order:6;order:6}.order-xl-7{-ms-flex-order:7;order:7}.order-xl-8{-ms-flex-order:8;order:8}.order-xl-9{-ms-flex-order:9;order:9}.order-xl-10{-ms-flex-order:10;order:10}.order-xl-11{-ms-flex-order:11;order:11}.order-xl-12{-ms-flex-order:12;order:12}.offset-xl-0{margin-left:0}.offset-xl-1{margin-left:8.333333%}.offset-xl-2{margin-left:16.666667%}.offset-xl-3{margin-left:25%}.offset-xl-4{margin-left:33.333333%}.offset-xl-5{margin-left:41.666667%}.offset-xl-6{margin-left:50%}.offset-xl-7{margin-left:58.333333%}.offset-xl-8{margin-left:66.666667%}.offset-xl-9{margin-left:75%}.offset-xl-10{margin-left:83.333333%}.offset-xl-11{margin-left:91.666667%}}.table{width:100%;margin-bottom:1rem;background-color:transparent}.table td,.table th{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6}.table tbody+tbody{border-top:2px solid #dee2e6}.table .table{background-color:#fff}.table-sm td,.table-sm th{padding:.3rem}.table-bordered{border:1px solid #dee2e6}.table-bordered td,.table-bordered th{border:1px solid #dee2e6}.table-bordered thead td,.table-bordered thead th{border-bottom-width:2px}.table-borderless tbody+tbody,.table-borderless td,.table-borderless th,.table-borderless thead th{border:0}.table-striped tbody tr:nth-of-type(odd){background-color:rgba(0,0,0,.05)}.table-hover tbody tr:hover{background-color:rgba(0,0,0,.075)}.table-primary,.table-primary>td,.table-primary>th{background-color:#b8daff}.table-hover .table-primary:hover{background-color:#9fcdff}.table-hover .table-primary:hover>td,.table-hover .table-primary:hover>th{background-color:#9fcdff}.table-secondary,.table-secondary>td,.table-secondary>th{background-color:#d6d8db}.table-hover .table-secondary:hover{background-color:#c8cbcf}.table-hover .table-secondary:hover>td,.table-hover .table-secondary:hover>th{background-color:#c8cbcf}.table-success,.table-success>td,.table-success>th{background-color:#c3e6cb}.table-hover .table-success:hover{background-color:#b1dfbb}.table-hover .table-success:hover>td,.table-hover .table-success:hover>th{background-color:#b1dfbb}.table-info,.table-info>td,.table-info>th{background-color:#bee5eb}.table-hover .table-info:hover{background-color:#abdde5}.table-hover .table-info:hover>td,.table-hover .table-info:hover>th{background-color:#abdde5}.table-warning,.table-warning>td,.table-warning>th{background-color:#ffeeba}.table-hover .table-warning:hover{background-color:#ffe8a1}.table-hover .table-warning:hover>td,.table-hover .table-warning:hover>th{background-color:#ffe8a1}.table-danger,.table-danger>td,.table-danger>th{background-color:#f5c6cb}.table-hover .table-danger:hover{background-color:#f1b0b7}.table-hover .table-danger:hover>td,.table-hover .table-danger:hover>th{background-color:#f1b0b7}.table-light,.table-light>td,.table-light>th{background-color:#fdfdfe}.table-hover .table-light:hover{background-color:#ececf6}.table-hover .table-light:hover>td,.table-hover .table-light:hover>th{background-color:#ececf6}.table-dark,.table-dark>td,.table-dark>th{background-color:#c6c8ca}.table-hover .table-dark:hover{background-color:#b9bbbe}.table-hover .table-dark:hover>td,.table-hover .table-dark:hover>th{background-color:#b9bbbe}.table-active,.table-active>td,.table-active>th{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover>td,.table-hover .table-active:hover>th{background-color:rgba(0,0,0,.075)}.table .thead-dark th{color:#fff;background-color:#212529;border-color:#32383e}.table .thead-light th{color:#495057;background-color:#e9ecef;border-color:#dee2e6}.table-dark{color:#fff;background-color:#212529}.table-dark td,.table-dark th,.table-dark thead th{border-color:#32383e}.table-dark.table-bordered{border:0}.table-dark.table-striped tbody tr:nth-of-type(odd){background-color:rgba(255,255,255,.05)}.table-dark.table-hover tbody tr:hover{background-color:rgba(255,255,255,.075)}@media (max-width:575.98px){.table-responsive-sm{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar}.table-responsive-sm>.table-bordered{border:0}}@media (max-width:767.98px){.table-responsive-md{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar}.table-responsive-md>.table-bordered{border:0}}@media (max-width:991.98px){.table-responsive-lg{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar}.table-responsive-lg>.table-bordered{border:0}}@media (max-width:1199.98px){.table-responsive-xl{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar}.table-responsive-xl>.table-bordered{border:0}}.table-responsive{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch;-ms-overflow-style:-ms-autohiding-scrollbar}.table-responsive>.table-bordered{border:0}.form-control{display:block;width:100%;height:calc(2.25rem + 2px);padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:#495057;background-color:#fff;background-clip:padding-box;border:1px solid #ced4da;border-radius:.25rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media screen and (prefers-reduced-motion:reduce){.form-control{transition:none}}.form-control::-ms-expand{background-color:transparent;border:0}.form-control:focus{color:#495057;background-color:#fff;border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.form-control::-webkit-input-placeholder{color:#6c757d;opacity:1}.form-control::-moz-placeholder{color:#6c757d;opacity:1}.form-control:-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::placeholder{color:#6c757d;opacity:1}.form-control:disabled,.form-control[readonly]{background-color:#e9ecef;opacity:1}select.form-control:focus::-ms-value{color:#495057;background-color:#fff}.form-control-file,.form-control-range{display:block;width:100%}.col-form-label{padding-top:calc(.375rem + 1px);padding-bottom:calc(.375rem + 1px);margin-bottom:0;font-size:inherit;line-height:1.5}.col-form-label-lg{padding-top:calc(.5rem + 1px);padding-bottom:calc(.5rem + 1px);font-size:1.25rem;line-height:1.5}.col-form-label-sm{padding-top:calc(.25rem + 1px);padding-bottom:calc(.25rem + 1px);font-size:.875rem;line-height:1.5}.form-control-plaintext{display:block;width:100%;padding-top:.375rem;padding-bottom:.375rem;margin-bottom:0;line-height:1.5;color:#212529;background-color:transparent;border:solid transparent;border-width:1px 0}.form-control-plaintext.form-control-lg,.form-control-plaintext.form-control-sm{padding-right:0;padding-left:0}.form-control-sm{height:calc(1.8125rem + 2px);padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.form-control-lg{height:calc(2.875rem + 2px);padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}select.form-control[multiple],select.form-control[size]{height:auto}textarea.form-control{height:auto}.form-group{margin-bottom:1rem}.form-text{display:block;margin-top:.25rem}.form-row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-5px;margin-left:-5px}.form-row>.col,.form-row>[class*=col-]{padding-right:5px;padding-left:5px}.form-check{position:relative;display:block;padding-left:1.25rem}.form-check-input{position:absolute;margin-top:.3rem;margin-left:-1.25rem}.form-check-input:disabled~.form-check-label{color:#6c757d}.form-check-label{margin-bottom:0}.form-check-inline{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;padding-left:0;margin-right:.75rem}.form-check-inline .form-check-input{position:static;margin-top:0;margin-right:.3125rem;margin-left:0}.valid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#28a745}.valid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(40,167,69,.9);border-radius:.25rem}.custom-select.is-valid,.form-control.is-valid,.was-validated .custom-select:valid,.was-validated .form-control:valid{border-color:#28a745}.custom-select.is-valid:focus,.form-control.is-valid:focus,.was-validated .custom-select:valid:focus,.was-validated .form-control:valid:focus{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.custom-select.is-valid~.valid-feedback,.custom-select.is-valid~.valid-tooltip,.form-control.is-valid~.valid-feedback,.form-control.is-valid~.valid-tooltip,.was-validated .custom-select:valid~.valid-feedback,.was-validated .custom-select:valid~.valid-tooltip,.was-validated .form-control:valid~.valid-feedback,.was-validated .form-control:valid~.valid-tooltip{display:block}.form-control-file.is-valid~.valid-feedback,.form-control-file.is-valid~.valid-tooltip,.was-validated .form-control-file:valid~.valid-feedback,.was-validated .form-control-file:valid~.valid-tooltip{display:block}.form-check-input.is-valid~.form-check-label,.was-validated .form-check-input:valid~.form-check-label{color:#28a745}.form-check-input.is-valid~.valid-feedback,.form-check-input.is-valid~.valid-tooltip,.was-validated .form-check-input:valid~.valid-feedback,.was-validated .form-check-input:valid~.valid-tooltip{display:block}.custom-control-input.is-valid~.custom-control-label,.was-validated .custom-control-input:valid~.custom-control-label{color:#28a745}.custom-control-input.is-valid~.custom-control-label::before,.was-validated .custom-control-input:valid~.custom-control-label::before{background-color:#71dd8a}.custom-control-input.is-valid~.valid-feedback,.custom-control-input.is-valid~.valid-tooltip,.was-validated .custom-control-input:valid~.valid-feedback,.was-validated .custom-control-input:valid~.valid-tooltip{display:block}.custom-control-input.is-valid:checked~.custom-control-label::before,.was-validated .custom-control-input:valid:checked~.custom-control-label::before{background-color:#34ce57}.custom-control-input.is-valid:focus~.custom-control-label::before,.was-validated .custom-control-input:valid:focus~.custom-control-label::before{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(40,167,69,.25)}.custom-file-input.is-valid~.custom-file-label,.was-validated .custom-file-input:valid~.custom-file-label{border-color:#28a745}.custom-file-input.is-valid~.custom-file-label::after,.was-validated .custom-file-input:valid~.custom-file-label::after{border-color:inherit}.custom-file-input.is-valid~.valid-feedback,.custom-file-input.is-valid~.valid-tooltip,.was-validated .custom-file-input:valid~.valid-feedback,.was-validated .custom-file-input:valid~.valid-tooltip{display:block}.custom-file-input.is-valid:focus~.custom-file-label,.was-validated .custom-file-input:valid:focus~.custom-file-label{box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.invalid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#dc3545}.invalid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(220,53,69,.9);border-radius:.25rem}.custom-select.is-invalid,.form-control.is-invalid,.was-validated .custom-select:invalid,.was-validated .form-control:invalid{border-color:#dc3545}.custom-select.is-invalid:focus,.form-control.is-invalid:focus,.was-validated .custom-select:invalid:focus,.was-validated .form-control:invalid:focus{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.custom-select.is-invalid~.invalid-feedback,.custom-select.is-invalid~.invalid-tooltip,.form-control.is-invalid~.invalid-feedback,.form-control.is-invalid~.invalid-tooltip,.was-validated .custom-select:invalid~.invalid-feedback,.was-validated .custom-select:invalid~.invalid-tooltip,.was-validated .form-control:invalid~.invalid-feedback,.was-validated .form-control:invalid~.invalid-tooltip{display:block}.form-control-file.is-invalid~.invalid-feedback,.form-control-file.is-invalid~.invalid-tooltip,.was-validated .form-control-file:invalid~.invalid-feedback,.was-validated .form-control-file:invalid~.invalid-tooltip{display:block}.form-check-input.is-invalid~.form-check-label,.was-validated .form-check-input:invalid~.form-check-label{color:#dc3545}.form-check-input.is-invalid~.invalid-feedback,.form-check-input.is-invalid~.invalid-tooltip,.was-validated .form-check-input:invalid~.invalid-feedback,.was-validated .form-check-input:invalid~.invalid-tooltip{display:block}.custom-control-input.is-invalid~.custom-control-label,.was-validated .custom-control-input:invalid~.custom-control-label{color:#dc3545}.custom-control-input.is-invalid~.custom-control-label::before,.was-validated .custom-control-input:invalid~.custom-control-label::before{background-color:#efa2a9}.custom-control-input.is-invalid~.invalid-feedback,.custom-control-input.is-invalid~.invalid-tooltip,.was-validated .custom-control-input:invalid~.invalid-feedback,.was-validated .custom-control-input:invalid~.invalid-tooltip{display:block}.custom-control-input.is-invalid:checked~.custom-control-label::before,.was-validated .custom-control-input:invalid:checked~.custom-control-label::before{background-color:#e4606d}.custom-control-input.is-invalid:focus~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus~.custom-control-label::before{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(220,53,69,.25)}.custom-file-input.is-invalid~.custom-file-label,.was-validated .custom-file-input:invalid~.custom-file-label{border-color:#dc3545}.custom-file-input.is-invalid~.custom-file-label::after,.was-validated .custom-file-input:invalid~.custom-file-label::after{border-color:inherit}.custom-file-input.is-invalid~.invalid-feedback,.custom-file-input.is-invalid~.invalid-tooltip,.was-validated .custom-file-input:invalid~.invalid-feedback,.was-validated .custom-file-input:invalid~.invalid-tooltip{display:block}.custom-file-input.is-invalid:focus~.custom-file-label,.was-validated .custom-file-input:invalid:focus~.custom-file-label{box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.form-inline{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center}.form-inline .form-check{width:100%}@media (min-width:576px){.form-inline label{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;margin-bottom:0}.form-inline .form-group{display:-ms-flexbox;display:flex;-ms-flex:0 0 auto;flex:0 0 auto;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center;margin-bottom:0}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-plaintext{display:inline-block}.form-inline .custom-select,.form-inline .input-group{width:auto}.form-inline .form-check{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-left:0}.form-inline .form-check-input{position:relative;margin-top:0;margin-right:.25rem;margin-left:0}.form-inline .custom-control{-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.form-inline .custom-control-label{margin-bottom:0}}.btn{display:inline-block;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:1px solid transparent;padding:.375rem .75rem;font-size:1rem;line-height:1.5;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media screen and (prefers-reduced-motion:reduce){.btn{transition:none}}.btn:focus,.btn:hover{text-decoration:none}.btn.focus,.btn:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.btn.disabled,.btn:disabled{opacity:.65}.btn:not(:disabled):not(.disabled){cursor:pointer}a.btn.disabled,fieldset:disabled a.btn{pointer-events:none}.btn-primary{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:hover{color:#fff;background-color:#0069d9;border-color:#0062cc}.btn-primary.focus,.btn-primary:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-primary.disabled,.btn-primary:disabled{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:not(:disabled):not(.disabled).active,.btn-primary:not(:disabled):not(.disabled):active,.show>.btn-primary.dropdown-toggle{color:#fff;background-color:#0062cc;border-color:#005cbf}.btn-primary:not(:disabled):not(.disabled).active:focus,.btn-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-secondary{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:hover{color:#fff;background-color:#5a6268;border-color:#545b62}.btn-secondary.focus,.btn-secondary:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-secondary.disabled,.btn-secondary:disabled{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:not(:disabled):not(.disabled).active,.btn-secondary:not(:disabled):not(.disabled):active,.show>.btn-secondary.dropdown-toggle{color:#fff;background-color:#545b62;border-color:#4e555b}.btn-secondary:not(:disabled):not(.disabled).active:focus,.btn-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-success{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:hover{color:#fff;background-color:#218838;border-color:#1e7e34}.btn-success.focus,.btn-success:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-success.disabled,.btn-success:disabled{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:not(:disabled):not(.disabled).active,.btn-success:not(:disabled):not(.disabled):active,.show>.btn-success.dropdown-toggle{color:#fff;background-color:#1e7e34;border-color:#1c7430}.btn-success:not(:disabled):not(.disabled).active:focus,.btn-success:not(:disabled):not(.disabled):active:focus,.show>.btn-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-info{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:hover{color:#fff;background-color:#138496;border-color:#117a8b}.btn-info.focus,.btn-info:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-info.disabled,.btn-info:disabled{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:not(:disabled):not(.disabled).active,.btn-info:not(:disabled):not(.disabled):active,.show>.btn-info.dropdown-toggle{color:#fff;background-color:#117a8b;border-color:#10707f}.btn-info:not(:disabled):not(.disabled).active:focus,.btn-info:not(:disabled):not(.disabled):active:focus,.show>.btn-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-warning{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:hover{color:#212529;background-color:#e0a800;border-color:#d39e00}.btn-warning.focus,.btn-warning:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-warning.disabled,.btn-warning:disabled{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:not(:disabled):not(.disabled).active,.btn-warning:not(:disabled):not(.disabled):active,.show>.btn-warning.dropdown-toggle{color:#212529;background-color:#d39e00;border-color:#c69500}.btn-warning:not(:disabled):not(.disabled).active:focus,.btn-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-danger{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:hover{color:#fff;background-color:#c82333;border-color:#bd2130}.btn-danger.focus,.btn-danger:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-danger.disabled,.btn-danger:disabled{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:not(:disabled):not(.disabled).active,.btn-danger:not(:disabled):not(.disabled):active,.show>.btn-danger.dropdown-toggle{color:#fff;background-color:#bd2130;border-color:#b21f2d}.btn-danger:not(:disabled):not(.disabled).active:focus,.btn-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-light{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:hover{color:#212529;background-color:#e2e6ea;border-color:#dae0e5}.btn-light.focus,.btn-light:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-light.disabled,.btn-light:disabled{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:not(:disabled):not(.disabled).active,.btn-light:not(:disabled):not(.disabled):active,.show>.btn-light.dropdown-toggle{color:#212529;background-color:#dae0e5;border-color:#d3d9df}.btn-light:not(:disabled):not(.disabled).active:focus,.btn-light:not(:disabled):not(.disabled):active:focus,.show>.btn-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-dark{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:hover{color:#fff;background-color:#23272b;border-color:#1d2124}.btn-dark.focus,.btn-dark:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-dark.disabled,.btn-dark:disabled{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:not(:disabled):not(.disabled).active,.btn-dark:not(:disabled):not(.disabled):active,.show>.btn-dark.dropdown-toggle{color:#fff;background-color:#1d2124;border-color:#171a1d}.btn-dark:not(:disabled):not(.disabled).active:focus,.btn-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-outline-primary{color:#007bff;background-color:transparent;background-image:none;border-color:#007bff}.btn-outline-primary:hover{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary.focus,.btn-outline-primary:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-primary.disabled,.btn-outline-primary:disabled{color:#007bff;background-color:transparent}.btn-outline-primary:not(:disabled):not(.disabled).active,.btn-outline-primary:not(:disabled):not(.disabled):active,.show>.btn-outline-primary.dropdown-toggle{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary:not(:disabled):not(.disabled).active:focus,.btn-outline-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-secondary{color:#6c757d;background-color:transparent;background-image:none;border-color:#6c757d}.btn-outline-secondary:hover{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary.focus,.btn-outline-secondary:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-secondary.disabled,.btn-outline-secondary:disabled{color:#6c757d;background-color:transparent}.btn-outline-secondary:not(:disabled):not(.disabled).active,.btn-outline-secondary:not(:disabled):not(.disabled):active,.show>.btn-outline-secondary.dropdown-toggle{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary:not(:disabled):not(.disabled).active:focus,.btn-outline-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-success{color:#28a745;background-color:transparent;background-image:none;border-color:#28a745}.btn-outline-success:hover{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success.focus,.btn-outline-success:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-success.disabled,.btn-outline-success:disabled{color:#28a745;background-color:transparent}.btn-outline-success:not(:disabled):not(.disabled).active,.btn-outline-success:not(:disabled):not(.disabled):active,.show>.btn-outline-success.dropdown-toggle{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success:not(:disabled):not(.disabled).active:focus,.btn-outline-success:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-info{color:#17a2b8;background-color:transparent;background-image:none;border-color:#17a2b8}.btn-outline-info:hover{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info.focus,.btn-outline-info:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-info.disabled,.btn-outline-info:disabled{color:#17a2b8;background-color:transparent}.btn-outline-info:not(:disabled):not(.disabled).active,.btn-outline-info:not(:disabled):not(.disabled):active,.show>.btn-outline-info.dropdown-toggle{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info:not(:disabled):not(.disabled).active:focus,.btn-outline-info:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-warning{color:#ffc107;background-color:transparent;background-image:none;border-color:#ffc107}.btn-outline-warning:hover{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning.focus,.btn-outline-warning:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-warning.disabled,.btn-outline-warning:disabled{color:#ffc107;background-color:transparent}.btn-outline-warning:not(:disabled):not(.disabled).active,.btn-outline-warning:not(:disabled):not(.disabled):active,.show>.btn-outline-warning.dropdown-toggle{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning:not(:disabled):not(.disabled).active:focus,.btn-outline-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-danger{color:#dc3545;background-color:transparent;background-image:none;border-color:#dc3545}.btn-outline-danger:hover{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger.focus,.btn-outline-danger:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-danger.disabled,.btn-outline-danger:disabled{color:#dc3545;background-color:transparent}.btn-outline-danger:not(:disabled):not(.disabled).active,.btn-outline-danger:not(:disabled):not(.disabled):active,.show>.btn-outline-danger.dropdown-toggle{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger:not(:disabled):not(.disabled).active:focus,.btn-outline-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-light{color:#f8f9fa;background-color:transparent;background-image:none;border-color:#f8f9fa}.btn-outline-light:hover{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light.focus,.btn-outline-light:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-light.disabled,.btn-outline-light:disabled{color:#f8f9fa;background-color:transparent}.btn-outline-light:not(:disabled):not(.disabled).active,.btn-outline-light:not(:disabled):not(.disabled):active,.show>.btn-outline-light.dropdown-toggle{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light:not(:disabled):not(.disabled).active:focus,.btn-outline-light:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-dark{color:#343a40;background-color:transparent;background-image:none;border-color:#343a40}.btn-outline-dark:hover{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark.focus,.btn-outline-dark:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-outline-dark.disabled,.btn-outline-dark:disabled{color:#343a40;background-color:transparent}.btn-outline-dark:not(:disabled):not(.disabled).active,.btn-outline-dark:not(:disabled):not(.disabled):active,.show>.btn-outline-dark.dropdown-toggle{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark:not(:disabled):not(.disabled).active:focus,.btn-outline-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-link{font-weight:400;color:#007bff;background-color:transparent}.btn-link:hover{color:#0056b3;text-decoration:underline;background-color:transparent;border-color:transparent}.btn-link.focus,.btn-link:focus{text-decoration:underline;border-color:transparent;box-shadow:none}.btn-link.disabled,.btn-link:disabled{color:#6c757d;pointer-events:none}.btn-group-lg>.btn,.btn-lg{padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.btn-group-sm>.btn,.btn-sm{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:.5rem}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{transition:opacity .15s linear}@media screen and (prefers-reduced-motion:reduce){.fade{transition:none}}.fade:not(.show){opacity:0}.collapse:not(.show){display:none}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}@media screen and (prefers-reduced-motion:reduce){.collapsing{transition:none}}.dropdown,.dropleft,.dropright,.dropup{position:relative}.dropdown-toggle::after{display:inline-block;width:0;height:0;margin-left:.255em;vertical-align:.255em;content:\"\";border-top:.3em solid;border-right:.3em solid transparent;border-bottom:0;border-left:.3em solid transparent}.dropdown-toggle:empty::after{margin-left:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:10rem;padding:.5rem 0;margin:.125rem 0 0;font-size:1rem;color:#212529;text-align:left;list-style:none;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);border-radius:.25rem}.dropdown-menu-right{right:0;left:auto}.dropup .dropdown-menu{top:auto;bottom:100%;margin-top:0;margin-bottom:.125rem}.dropup .dropdown-toggle::after{display:inline-block;width:0;height:0;margin-left:.255em;vertical-align:.255em;content:\"\";border-top:0;border-right:.3em solid transparent;border-bottom:.3em solid;border-left:.3em solid transparent}.dropup .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-menu{top:0;right:auto;left:100%;margin-top:0;margin-left:.125rem}.dropright .dropdown-toggle::after{display:inline-block;width:0;height:0;margin-left:.255em;vertical-align:.255em;content:\"\";border-top:.3em solid transparent;border-right:0;border-bottom:.3em solid transparent;border-left:.3em solid}.dropright .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-toggle::after{vertical-align:0}.dropleft .dropdown-menu{top:0;right:100%;left:auto;margin-top:0;margin-right:.125rem}.dropleft .dropdown-toggle::after{display:inline-block;width:0;height:0;margin-left:.255em;vertical-align:.255em;content:\"\"}.dropleft .dropdown-toggle::after{display:none}.dropleft .dropdown-toggle::before{display:inline-block;width:0;height:0;margin-right:.255em;vertical-align:.255em;content:\"\";border-top:.3em solid transparent;border-right:.3em solid;border-bottom:.3em solid transparent}.dropleft .dropdown-toggle:empty::after{margin-left:0}.dropleft .dropdown-toggle::before{vertical-align:0}.dropdown-menu[x-placement^=bottom],.dropdown-menu[x-placement^=left],.dropdown-menu[x-placement^=right],.dropdown-menu[x-placement^=top]{right:auto;bottom:auto}.dropdown-divider{height:0;margin:.5rem 0;overflow:hidden;border-top:1px solid #e9ecef}.dropdown-item{display:block;width:100%;padding:.25rem 1.5rem;clear:both;font-weight:400;color:#212529;text-align:inherit;white-space:nowrap;background-color:transparent;border:0}.dropdown-item:focus,.dropdown-item:hover{color:#16181b;text-decoration:none;background-color:#f8f9fa}.dropdown-item.active,.dropdown-item:active{color:#fff;text-decoration:none;background-color:#007bff}.dropdown-item.disabled,.dropdown-item:disabled{color:#6c757d;background-color:transparent}.dropdown-menu.show{display:block}.dropdown-header{display:block;padding:.5rem 1.5rem;margin-bottom:0;font-size:.875rem;color:#6c757d;white-space:nowrap}.dropdown-item-text{display:block;padding:.25rem 1.5rem;color:#212529}.btn-group,.btn-group-vertical{position:relative;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;-ms-flex:0 1 auto;flex:0 1 auto}.btn-group-vertical>.btn:hover,.btn-group>.btn:hover{z-index:1}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus{z-index:1}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group,.btn-group-vertical .btn+.btn,.btn-group-vertical .btn+.btn-group,.btn-group-vertical .btn-group+.btn,.btn-group-vertical .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-pack:start;justify-content:flex-start}.btn-toolbar .input-group{width:auto}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn-group:not(:last-child)>.btn,.btn-group>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:not(:first-child)>.btn,.btn-group>.btn:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.dropdown-toggle-split{padding-right:.5625rem;padding-left:.5625rem}.dropdown-toggle-split::after,.dropright .dropdown-toggle-split::after,.dropup .dropdown-toggle-split::after{margin-left:0}.dropleft .dropdown-toggle-split::before{margin-right:0}.btn-group-sm>.btn+.dropdown-toggle-split,.btn-sm+.dropdown-toggle-split{padding-right:.375rem;padding-left:.375rem}.btn-group-lg>.btn+.dropdown-toggle-split,.btn-lg+.dropdown-toggle-split{padding-right:.75rem;padding-left:.75rem}.btn-group-vertical{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:center;justify-content:center}.btn-group-vertical .btn,.btn-group-vertical .btn-group{width:100%}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn-group:not(:last-child)>.btn,.btn-group-vertical>.btn:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:not(:first-child)>.btn,.btn-group-vertical>.btn:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.btn-group-toggle>.btn,.btn-group-toggle>.btn-group>.btn{margin-bottom:0}.btn-group-toggle>.btn input[type=checkbox],.btn-group-toggle>.btn input[type=radio],.btn-group-toggle>.btn-group>.btn input[type=checkbox],.btn-group-toggle>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:stretch;align-items:stretch;width:100%}.input-group>.custom-file,.input-group>.custom-select,.input-group>.form-control{position:relative;-ms-flex:1 1 auto;flex:1 1 auto;width:1%;margin-bottom:0}.input-group>.custom-file+.custom-file,.input-group>.custom-file+.custom-select,.input-group>.custom-file+.form-control,.input-group>.custom-select+.custom-file,.input-group>.custom-select+.custom-select,.input-group>.custom-select+.form-control,.input-group>.form-control+.custom-file,.input-group>.form-control+.custom-select,.input-group>.form-control+.form-control{margin-left:-1px}.input-group>.custom-file .custom-file-input:focus~.custom-file-label,.input-group>.custom-select:focus,.input-group>.form-control:focus{z-index:3}.input-group>.custom-file .custom-file-input:focus{z-index:4}.input-group>.custom-select:not(:last-child),.input-group>.form-control:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-select:not(:first-child),.input-group>.form-control:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.input-group>.custom-file{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.input-group>.custom-file:not(:last-child) .custom-file-label,.input-group>.custom-file:not(:last-child) .custom-file-label::after{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-file:not(:first-child) .custom-file-label{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-append,.input-group-prepend{display:-ms-flexbox;display:flex}.input-group-append .btn,.input-group-prepend .btn{position:relative;z-index:2}.input-group-append .btn+.btn,.input-group-append .btn+.input-group-text,.input-group-append .input-group-text+.btn,.input-group-append .input-group-text+.input-group-text,.input-group-prepend .btn+.btn,.input-group-prepend .btn+.input-group-text,.input-group-prepend .input-group-text+.btn,.input-group-prepend .input-group-text+.input-group-text{margin-left:-1px}.input-group-prepend{margin-right:-1px}.input-group-append{margin-left:-1px}.input-group-text{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;padding:.375rem .75rem;margin-bottom:0;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;text-align:center;white-space:nowrap;background-color:#e9ecef;border:1px solid #ced4da;border-radius:.25rem}.input-group-text input[type=checkbox],.input-group-text input[type=radio]{margin-top:0}.input-group-lg>.form-control,.input-group-lg>.input-group-append>.btn,.input-group-lg>.input-group-append>.input-group-text,.input-group-lg>.input-group-prepend>.btn,.input-group-lg>.input-group-prepend>.input-group-text{height:calc(2.875rem + 2px);padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.input-group-sm>.form-control,.input-group-sm>.input-group-append>.btn,.input-group-sm>.input-group-append>.input-group-text,.input-group-sm>.input-group-prepend>.btn,.input-group-sm>.input-group-prepend>.input-group-text{height:calc(1.8125rem + 2px);padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.input-group>.input-group-append:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group>.input-group-append:last-child>.input-group-text:not(:last-child),.input-group>.input-group-append:not(:last-child)>.btn,.input-group>.input-group-append:not(:last-child)>.input-group-text,.input-group>.input-group-prepend>.btn,.input-group>.input-group-prepend>.input-group-text{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.input-group-append>.btn,.input-group>.input-group-append>.input-group-text,.input-group>.input-group-prepend:first-child>.btn:not(:first-child),.input-group>.input-group-prepend:first-child>.input-group-text:not(:first-child),.input-group>.input-group-prepend:not(:first-child)>.btn,.input-group>.input-group-prepend:not(:first-child)>.input-group-text{border-top-left-radius:0;border-bottom-left-radius:0}.custom-control{position:relative;display:block;min-height:1.5rem;padding-left:1.5rem}.custom-control-inline{display:-ms-inline-flexbox;display:inline-flex;margin-right:1rem}.custom-control-input{position:absolute;z-index:-1;opacity:0}.custom-control-input:checked~.custom-control-label::before{color:#fff;background-color:#007bff}.custom-control-input:focus~.custom-control-label::before{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-control-input:active~.custom-control-label::before{color:#fff;background-color:#b3d7ff}.custom-control-input:disabled~.custom-control-label{color:#6c757d}.custom-control-input:disabled~.custom-control-label::before{background-color:#e9ecef}.custom-control-label{position:relative;margin-bottom:0}.custom-control-label::before{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;pointer-events:none;content:\"\";-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#dee2e6}.custom-control-label::after{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;content:\"\";background-repeat:no-repeat;background-position:center center;background-size:50% 50%}.custom-checkbox .custom-control-label::before{border-radius:.25rem}.custom-checkbox .custom-control-input:checked~.custom-control-label::before{background-color:#007bff}.custom-checkbox .custom-control-input:checked~.custom-control-label::after{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3E%3C/svg%3E\")}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::before{background-color:#007bff}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::after{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 4'%3E%3Cpath stroke='%23fff' d='M0 2h4'/%3E%3C/svg%3E\")}.custom-checkbox .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-checkbox .custom-control-input:disabled:indeterminate~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-radio .custom-control-label::before{border-radius:50%}.custom-radio .custom-control-input:checked~.custom-control-label::before{background-color:#007bff}.custom-radio .custom-control-input:checked~.custom-control-label::after{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3E%3Ccircle r='3' fill='%23fff'/%3E%3C/svg%3E\")}.custom-radio .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-select{display:inline-block;width:100%;height:calc(2.25rem + 2px);padding:.375rem 1.75rem .375rem .75rem;line-height:1.5;color:#495057;vertical-align:middle;background:#fff url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E\") no-repeat right .75rem center;background-size:8px 10px;border:1px solid #ced4da;border-radius:.25rem;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-select:focus{border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(128,189,255,.5)}.custom-select:focus::-ms-value{color:#495057;background-color:#fff}.custom-select[multiple],.custom-select[size]:not([size=\"1\"]){height:auto;padding-right:.75rem;background-image:none}.custom-select:disabled{color:#6c757d;background-color:#e9ecef}.custom-select::-ms-expand{opacity:0}.custom-select-sm{height:calc(1.8125rem + 2px);padding-top:.375rem;padding-bottom:.375rem;font-size:75%}.custom-select-lg{height:calc(2.875rem + 2px);padding-top:.375rem;padding-bottom:.375rem;font-size:125%}.custom-file{position:relative;display:inline-block;width:100%;height:calc(2.25rem + 2px);margin-bottom:0}.custom-file-input{position:relative;z-index:2;width:100%;height:calc(2.25rem + 2px);margin:0;opacity:0}.custom-file-input:focus~.custom-file-label{border-color:#80bdff;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-file-input:focus~.custom-file-label::after{border-color:#80bdff}.custom-file-input:disabled~.custom-file-label{background-color:#e9ecef}.custom-file-input:lang(en)~.custom-file-label::after{content:\"Browse\"}.custom-file-label{position:absolute;top:0;right:0;left:0;z-index:1;height:calc(2.25rem + 2px);padding:.375rem .75rem;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #ced4da;border-radius:.25rem}.custom-file-label::after{position:absolute;top:0;right:0;bottom:0;z-index:3;display:block;height:2.25rem;padding:.375rem .75rem;line-height:1.5;color:#495057;content:\"Browse\";background-color:#e9ecef;border-left:1px solid #ced4da;border-radius:0 .25rem .25rem 0}.custom-range{width:100%;padding-left:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-range:focus{outline:0}.custom-range:focus::-webkit-slider-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-moz-range-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-ms-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range::-moz-focus-outer{border:0}.custom-range::-webkit-slider-thumb{width:1rem;height:1rem;margin-top:-.25rem;background-color:#007bff;border:0;border-radius:1rem;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-webkit-appearance:none;appearance:none}@media screen and (prefers-reduced-motion:reduce){.custom-range::-webkit-slider-thumb{transition:none}}.custom-range::-webkit-slider-thumb:active{background-color:#b3d7ff}.custom-range::-webkit-slider-runnable-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-moz-range-thumb{width:1rem;height:1rem;background-color:#007bff;border:0;border-radius:1rem;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-moz-appearance:none;appearance:none}@media screen and (prefers-reduced-motion:reduce){.custom-range::-moz-range-thumb{transition:none}}.custom-range::-moz-range-thumb:active{background-color:#b3d7ff}.custom-range::-moz-range-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-ms-thumb{width:1rem;height:1rem;margin-top:0;margin-right:.2rem;margin-left:.2rem;background-color:#007bff;border:0;border-radius:1rem;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;appearance:none}@media screen and (prefers-reduced-motion:reduce){.custom-range::-ms-thumb{transition:none}}.custom-range::-ms-thumb:active{background-color:#b3d7ff}.custom-range::-ms-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:transparent;border-color:transparent;border-width:.5rem}.custom-range::-ms-fill-lower{background-color:#dee2e6;border-radius:1rem}.custom-range::-ms-fill-upper{margin-right:15px;background-color:#dee2e6;border-radius:1rem}.custom-control-label::before,.custom-file-label,.custom-select{transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media screen and (prefers-reduced-motion:reduce){.custom-control-label::before,.custom-file-label,.custom-select{transition:none}}.nav{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none}.nav-link{display:block;padding:.5rem 1rem}.nav-link:focus,.nav-link:hover{text-decoration:none}.nav-link.disabled{color:#6c757d}.nav-tabs{border-bottom:1px solid #dee2e6}.nav-tabs .nav-item{margin-bottom:-1px}.nav-tabs .nav-link{border:1px solid transparent;border-top-left-radius:.25rem;border-top-right-radius:.25rem}.nav-tabs .nav-link:focus,.nav-tabs .nav-link:hover{border-color:#e9ecef #e9ecef #dee2e6}.nav-tabs .nav-link.disabled{color:#6c757d;background-color:transparent;border-color:transparent}.nav-tabs .nav-item.show .nav-link,.nav-tabs .nav-link.active{color:#495057;background-color:#fff;border-color:#dee2e6 #dee2e6 #fff}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.nav-pills .nav-link{border-radius:.25rem}.nav-pills .nav-link.active,.nav-pills .show>.nav-link{color:#fff;background-color:#007bff}.nav-fill .nav-item{-ms-flex:1 1 auto;flex:1 1 auto;text-align:center}.nav-justified .nav-item{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;text-align:center}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.navbar{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;padding:.5rem 1rem}.navbar>.container,.navbar>.container-fluid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}.navbar-brand{display:inline-block;padding-top:.3125rem;padding-bottom:.3125rem;margin-right:1rem;font-size:1.25rem;line-height:inherit;white-space:nowrap}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-nav{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0;list-style:none}.navbar-nav .nav-link{padding-right:0;padding-left:0}.navbar-nav .dropdown-menu{position:static;float:none}.navbar-text{display:inline-block;padding-top:.5rem;padding-bottom:.5rem}.navbar-collapse{-ms-flex-preferred-size:100%;flex-basis:100%;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center}.navbar-toggler{padding:.25rem .75rem;font-size:1.25rem;line-height:1;background-color:transparent;border:1px solid transparent;border-radius:.25rem}.navbar-toggler:focus,.navbar-toggler:hover{text-decoration:none}.navbar-toggler:not(:disabled):not(.disabled){cursor:pointer}.navbar-toggler-icon{display:inline-block;width:1.5em;height:1.5em;vertical-align:middle;content:\"\";background:no-repeat center center;background-size:100% 100%}@media (max-width:575.98px){.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid{padding-right:0;padding-left:0}}@media (min-width:576px){.navbar-expand-sm{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-sm .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-sm .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-sm .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-sm .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-sm .navbar-toggler{display:none}}@media (max-width:767.98px){.navbar-expand-md>.container,.navbar-expand-md>.container-fluid{padding-right:0;padding-left:0}}@media (min-width:768px){.navbar-expand-md{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-md .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-md .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-md .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-md>.container,.navbar-expand-md>.container-fluid{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-md .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-md .navbar-toggler{display:none}}@media (max-width:991.98px){.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid{padding-right:0;padding-left:0}}@media (min-width:992px){.navbar-expand-lg{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-lg .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-lg .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-lg .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-lg .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-lg .navbar-toggler{display:none}}@media (max-width:1199.98px){.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid{padding-right:0;padding-left:0}}@media (min-width:1200px){.navbar-expand-xl{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-xl .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-xl .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-xl .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-xl .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-xl .navbar-toggler{display:none}}.navbar-expand{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand>.container,.navbar-expand>.container-fluid{padding-right:0;padding-left:0}.navbar-expand .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand .navbar-nav .dropdown-menu{position:absolute}.navbar-expand .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand>.container,.navbar-expand>.container-fluid{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand .navbar-toggler{display:none}.navbar-light .navbar-brand{color:rgba(0,0,0,.9)}.navbar-light .navbar-brand:focus,.navbar-light .navbar-brand:hover{color:rgba(0,0,0,.9)}.navbar-light .navbar-nav .nav-link{color:rgba(0,0,0,.5)}.navbar-light .navbar-nav .nav-link:focus,.navbar-light .navbar-nav .nav-link:hover{color:rgba(0,0,0,.7)}.navbar-light .navbar-nav .nav-link.disabled{color:rgba(0,0,0,.3)}.navbar-light .navbar-nav .active>.nav-link,.navbar-light .navbar-nav .nav-link.active,.navbar-light .navbar-nav .nav-link.show,.navbar-light .navbar-nav .show>.nav-link{color:rgba(0,0,0,.9)}.navbar-light .navbar-toggler{color:rgba(0,0,0,.5);border-color:rgba(0,0,0,.1)}.navbar-light .navbar-toggler-icon{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 0, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E\")}.navbar-light .navbar-text{color:rgba(0,0,0,.5)}.navbar-light .navbar-text a{color:rgba(0,0,0,.9)}.navbar-light .navbar-text a:focus,.navbar-light .navbar-text a:hover{color:rgba(0,0,0,.9)}.navbar-dark .navbar-brand{color:#fff}.navbar-dark .navbar-brand:focus,.navbar-dark .navbar-brand:hover{color:#fff}.navbar-dark .navbar-nav .nav-link{color:rgba(255,255,255,.5)}.navbar-dark .navbar-nav .nav-link:focus,.navbar-dark .navbar-nav .nav-link:hover{color:rgba(255,255,255,.75)}.navbar-dark .navbar-nav .nav-link.disabled{color:rgba(255,255,255,.25)}.navbar-dark .navbar-nav .active>.nav-link,.navbar-dark .navbar-nav .nav-link.active,.navbar-dark .navbar-nav .nav-link.show,.navbar-dark .navbar-nav .show>.nav-link{color:#fff}.navbar-dark .navbar-toggler{color:rgba(255,255,255,.5);border-color:rgba(255,255,255,.1)}.navbar-dark .navbar-toggler-icon{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.5)' stroke-width='2' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E\")}.navbar-dark .navbar-text{color:rgba(255,255,255,.5)}.navbar-dark .navbar-text a{color:#fff}.navbar-dark .navbar-text a:focus,.navbar-dark .navbar-text a:hover{color:#fff}.card{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-width:0;word-wrap:break-word;background-color:#fff;background-clip:border-box;border:1px solid rgba(0,0,0,.125);border-radius:.25rem}.card>hr{margin-right:0;margin-left:0}.card>.list-group:first-child .list-group-item:first-child{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.card>.list-group:last-child .list-group-item:last-child{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.card-body{-ms-flex:1 1 auto;flex:1 1 auto;padding:1.25rem}.card-title{margin-bottom:.75rem}.card-subtitle{margin-top:-.375rem;margin-bottom:0}.card-text:last-child{margin-bottom:0}.card-link:hover{text-decoration:none}.card-link+.card-link{margin-left:1.25rem}.card-header{padding:.75rem 1.25rem;margin-bottom:0;background-color:rgba(0,0,0,.03);border-bottom:1px solid rgba(0,0,0,.125)}.card-header:first-child{border-radius:calc(.25rem - 1px) calc(.25rem - 1px) 0 0}.card-header+.list-group .list-group-item:first-child{border-top:0}.card-footer{padding:.75rem 1.25rem;background-color:rgba(0,0,0,.03);border-top:1px solid rgba(0,0,0,.125)}.card-footer:last-child{border-radius:0 0 calc(.25rem - 1px) calc(.25rem - 1px)}.card-header-tabs{margin-right:-.625rem;margin-bottom:-.75rem;margin-left:-.625rem;border-bottom:0}.card-header-pills{margin-right:-.625rem;margin-left:-.625rem}.card-img-overlay{position:absolute;top:0;right:0;bottom:0;left:0;padding:1.25rem}.card-img{width:100%;border-radius:calc(.25rem - 1px)}.card-img-top{width:100%;border-top-left-radius:calc(.25rem - 1px);border-top-right-radius:calc(.25rem - 1px)}.card-img-bottom{width:100%;border-bottom-right-radius:calc(.25rem - 1px);border-bottom-left-radius:calc(.25rem - 1px)}.card-deck{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column}.card-deck .card{margin-bottom:15px}@media (min-width:576px){.card-deck{-ms-flex-flow:row wrap;flex-flow:row wrap;margin-right:-15px;margin-left:-15px}.card-deck .card{display:-ms-flexbox;display:flex;-ms-flex:1 0 0%;flex:1 0 0%;-ms-flex-direction:column;flex-direction:column;margin-right:15px;margin-bottom:0;margin-left:15px}}.card-group{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column}.card-group>.card{margin-bottom:15px}@media (min-width:576px){.card-group{-ms-flex-flow:row wrap;flex-flow:row wrap}.card-group>.card{-ms-flex:1 0 0%;flex:1 0 0%;margin-bottom:0}.card-group>.card+.card{margin-left:0;border-left:0}.card-group>.card:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.card-group>.card:first-child .card-header,.card-group>.card:first-child .card-img-top{border-top-right-radius:0}.card-group>.card:first-child .card-footer,.card-group>.card:first-child .card-img-bottom{border-bottom-right-radius:0}.card-group>.card:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.card-group>.card:last-child .card-header,.card-group>.card:last-child .card-img-top{border-top-left-radius:0}.card-group>.card:last-child .card-footer,.card-group>.card:last-child .card-img-bottom{border-bottom-left-radius:0}.card-group>.card:only-child{border-radius:.25rem}.card-group>.card:only-child .card-header,.card-group>.card:only-child .card-img-top{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.card-group>.card:only-child .card-footer,.card-group>.card:only-child .card-img-bottom{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.card-group>.card:not(:first-child):not(:last-child):not(:only-child){border-radius:0}.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-footer,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-header,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-img-bottom,.card-group>.card:not(:first-child):not(:last-child):not(:only-child) .card-img-top{border-radius:0}}.card-columns .card{margin-bottom:.75rem}@media (min-width:576px){.card-columns{-webkit-column-count:3;-moz-column-count:3;column-count:3;-webkit-column-gap:1.25rem;-moz-column-gap:1.25rem;column-gap:1.25rem;orphans:1;widows:1}.card-columns .card{display:inline-block;width:100%}}.accordion .card:not(:first-of-type):not(:last-of-type){border-bottom:0;border-radius:0}.accordion .card:not(:first-of-type) .card-header:first-child{border-radius:0}.accordion .card:first-of-type{border-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.accordion .card:last-of-type{border-top-left-radius:0;border-top-right-radius:0}.breadcrumb{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding:.75rem 1rem;margin-bottom:1rem;list-style:none;background-color:#e9ecef;border-radius:.25rem}.breadcrumb-item+.breadcrumb-item{padding-left:.5rem}.breadcrumb-item+.breadcrumb-item::before{display:inline-block;padding-right:.5rem;color:#6c757d;content:\"/\"}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:underline}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:none}.breadcrumb-item.active{color:#6c757d}.pagination{display:-ms-flexbox;display:flex;padding-left:0;list-style:none;border-radius:.25rem}.page-link{position:relative;display:block;padding:.5rem .75rem;margin-left:-1px;line-height:1.25;color:#007bff;background-color:#fff;border:1px solid #dee2e6}.page-link:hover{z-index:2;color:#0056b3;text-decoration:none;background-color:#e9ecef;border-color:#dee2e6}.page-link:focus{z-index:2;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.page-link:not(:disabled):not(.disabled){cursor:pointer}.page-item:first-child .page-link{margin-left:0;border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.page-item:last-child .page-link{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.page-item.active .page-link{z-index:1;color:#fff;background-color:#007bff;border-color:#007bff}.page-item.disabled .page-link{color:#6c757d;pointer-events:none;cursor:auto;background-color:#fff;border-color:#dee2e6}.pagination-lg .page-link{padding:.75rem 1.5rem;font-size:1.25rem;line-height:1.5}.pagination-lg .page-item:first-child .page-link{border-top-left-radius:.3rem;border-bottom-left-radius:.3rem}.pagination-lg .page-item:last-child .page-link{border-top-right-radius:.3rem;border-bottom-right-radius:.3rem}.pagination-sm .page-link{padding:.25rem .5rem;font-size:.875rem;line-height:1.5}.pagination-sm .page-item:first-child .page-link{border-top-left-radius:.2rem;border-bottom-left-radius:.2rem}.pagination-sm .page-item:last-child .page-link{border-top-right-radius:.2rem;border-bottom-right-radius:.2rem}.badge{display:inline-block;padding:.25em .4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25rem}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:.6em;padding-left:.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}.badge-primary[href]:focus,.badge-primary[href]:hover{color:#fff;text-decoration:none;background-color:#0062cc}.badge-secondary{color:#fff;background-color:#6c757d}.badge-secondary[href]:focus,.badge-secondary[href]:hover{color:#fff;text-decoration:none;background-color:#545b62}.badge-success{color:#fff;background-color:#28a745}.badge-success[href]:focus,.badge-success[href]:hover{color:#fff;text-decoration:none;background-color:#1e7e34}.badge-info{color:#fff;background-color:#17a2b8}.badge-info[href]:focus,.badge-info[href]:hover{color:#fff;text-decoration:none;background-color:#117a8b}.badge-warning{color:#212529;background-color:#ffc107}.badge-warning[href]:focus,.badge-warning[href]:hover{color:#212529;text-decoration:none;background-color:#d39e00}.badge-danger{color:#fff;background-color:#dc3545}.badge-danger[href]:focus,.badge-danger[href]:hover{color:#fff;text-decoration:none;background-color:#bd2130}.badge-light{color:#212529;background-color:#f8f9fa}.badge-light[href]:focus,.badge-light[href]:hover{color:#212529;text-decoration:none;background-color:#dae0e5}.badge-dark{color:#fff;background-color:#343a40}.badge-dark[href]:focus,.badge-dark[href]:hover{color:#fff;text-decoration:none;background-color:#1d2124}.jumbotron{padding:2rem 1rem;margin-bottom:2rem;background-color:#e9ecef;border-radius:.3rem}@media (min-width:576px){.jumbotron{padding:4rem 2rem}}.jumbotron-fluid{padding-right:0;padding-left:0;border-radius:0}.alert{position:relative;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid transparent;border-radius:.25rem}.alert-heading{color:inherit}.alert-link{font-weight:700}.alert-dismissible{padding-right:4rem}.alert-dismissible .close{position:absolute;top:0;right:0;padding:.75rem 1.25rem;color:inherit}.alert-primary{color:#004085;background-color:#cce5ff;border-color:#b8daff}.alert-primary hr{border-top-color:#9fcdff}.alert-primary .alert-link{color:#002752}.alert-secondary{color:#383d41;background-color:#e2e3e5;border-color:#d6d8db}.alert-secondary hr{border-top-color:#c8cbcf}.alert-secondary .alert-link{color:#202326}.alert-success{color:#155724;background-color:#d4edda;border-color:#c3e6cb}.alert-success hr{border-top-color:#b1dfbb}.alert-success .alert-link{color:#0b2e13}.alert-info{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb}.alert-info hr{border-top-color:#abdde5}.alert-info .alert-link{color:#062c33}.alert-warning{color:#856404;background-color:#fff3cd;border-color:#ffeeba}.alert-warning hr{border-top-color:#ffe8a1}.alert-warning .alert-link{color:#533f03}.alert-danger{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb}.alert-danger hr{border-top-color:#f1b0b7}.alert-danger .alert-link{color:#491217}.alert-light{color:#818182;background-color:#fefefe;border-color:#fdfdfe}.alert-light hr{border-top-color:#ececf6}.alert-light .alert-link{color:#686868}.alert-dark{color:#1b1e21;background-color:#d6d8d9;border-color:#c6c8ca}.alert-dark hr{border-top-color:#b9bbbe}.alert-dark .alert-link{color:#040505}@-webkit-keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}.progress{display:-ms-flexbox;display:flex;height:1rem;overflow:hidden;font-size:.75rem;background-color:#e9ecef;border-radius:.25rem}.progress-bar{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;color:#fff;text-align:center;white-space:nowrap;background-color:#007bff;transition:width .6s ease}@media screen and (prefers-reduced-motion:reduce){.progress-bar{transition:none}}.progress-bar-striped{background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-size:1rem 1rem}.progress-bar-animated{-webkit-animation:progress-bar-stripes 1s linear infinite;animation:progress-bar-stripes 1s linear infinite}.media{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start}.media-body{-ms-flex:1;flex:1}.list-group{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0}.list-group-item-action{width:100%;color:#495057;text-align:inherit}.list-group-item-action:focus,.list-group-item-action:hover{color:#495057;text-decoration:none;background-color:#f8f9fa}.list-group-item-action:active{color:#212529;background-color:#e9ecef}.list-group-item{position:relative;display:block;padding:.75rem 1.25rem;margin-bottom:-1px;background-color:#fff;border:1px solid rgba(0,0,0,.125)}.list-group-item:first-child{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.list-group-item:focus,.list-group-item:hover{z-index:1;text-decoration:none}.list-group-item.disabled,.list-group-item:disabled{color:#6c757d;background-color:#fff}.list-group-item.active{z-index:2;color:#fff;background-color:#007bff;border-color:#007bff}.list-group-flush .list-group-item{border-right:0;border-left:0;border-radius:0}.list-group-flush:first-child .list-group-item:first-child{border-top:0}.list-group-flush:last-child .list-group-item:last-child{border-bottom:0}.list-group-item-primary{color:#004085;background-color:#b8daff}.list-group-item-primary.list-group-item-action:focus,.list-group-item-primary.list-group-item-action:hover{color:#004085;background-color:#9fcdff}.list-group-item-primary.list-group-item-action.active{color:#fff;background-color:#004085;border-color:#004085}.list-group-item-secondary{color:#383d41;background-color:#d6d8db}.list-group-item-secondary.list-group-item-action:focus,.list-group-item-secondary.list-group-item-action:hover{color:#383d41;background-color:#c8cbcf}.list-group-item-secondary.list-group-item-action.active{color:#fff;background-color:#383d41;border-color:#383d41}.list-group-item-success{color:#155724;background-color:#c3e6cb}.list-group-item-success.list-group-item-action:focus,.list-group-item-success.list-group-item-action:hover{color:#155724;background-color:#b1dfbb}.list-group-item-success.list-group-item-action.active{color:#fff;background-color:#155724;border-color:#155724}.list-group-item-info{color:#0c5460;background-color:#bee5eb}.list-group-item-info.list-group-item-action:focus,.list-group-item-info.list-group-item-action:hover{color:#0c5460;background-color:#abdde5}.list-group-item-info.list-group-item-action.active{color:#fff;background-color:#0c5460;border-color:#0c5460}.list-group-item-warning{color:#856404;background-color:#ffeeba}.list-group-item-warning.list-group-item-action:focus,.list-group-item-warning.list-group-item-action:hover{color:#856404;background-color:#ffe8a1}.list-group-item-warning.list-group-item-action.active{color:#fff;background-color:#856404;border-color:#856404}.list-group-item-danger{color:#721c24;background-color:#f5c6cb}.list-group-item-danger.list-group-item-action:focus,.list-group-item-danger.list-group-item-action:hover{color:#721c24;background-color:#f1b0b7}.list-group-item-danger.list-group-item-action.active{color:#fff;background-color:#721c24;border-color:#721c24}.list-group-item-light{color:#818182;background-color:#fdfdfe}.list-group-item-light.list-group-item-action:focus,.list-group-item-light.list-group-item-action:hover{color:#818182;background-color:#ececf6}.list-group-item-light.list-group-item-action.active{color:#fff;background-color:#818182;border-color:#818182}.list-group-item-dark{color:#1b1e21;background-color:#c6c8ca}.list-group-item-dark.list-group-item-action:focus,.list-group-item-dark.list-group-item-action:hover{color:#1b1e21;background-color:#b9bbbe}.list-group-item-dark.list-group-item-action.active{color:#fff;background-color:#1b1e21;border-color:#1b1e21}.close{float:right;font-size:1.5rem;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.5}.close:not(:disabled):not(.disabled){cursor:pointer}.close:not(:disabled):not(.disabled):focus,.close:not(:disabled):not(.disabled):hover{color:#000;text-decoration:none;opacity:.75}button.close{padding:0;background-color:transparent;border:0;-webkit-appearance:none}.modal-open{overflow:hidden}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;outline:0}.modal-dialog{position:relative;width:auto;margin:.5rem;pointer-events:none}.modal.fade .modal-dialog{transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out;-webkit-transform:translate(0,-25%);transform:translate(0,-25%)}@media screen and (prefers-reduced-motion:reduce){.modal.fade .modal-dialog{transition:none}}.modal.show .modal-dialog{-webkit-transform:translate(0,0);transform:translate(0,0)}.modal-dialog-centered{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;min-height:calc(100% - (.5rem * 2))}.modal-dialog-centered::before{display:block;height:calc(100vh - (.5rem * 2));content:\"\"}.modal-content{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;pointer-events:auto;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop.show{opacity:.5}.modal-header{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:justify;justify-content:space-between;padding:1rem;border-bottom:1px solid #e9ecef;border-top-left-radius:.3rem;border-top-right-radius:.3rem}.modal-header .close{padding:1rem;margin:-1rem -1rem -1rem auto}.modal-title{margin-bottom:0;line-height:1.5}.modal-body{position:relative;-ms-flex:1 1 auto;flex:1 1 auto;padding:1rem}.modal-footer{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:end;justify-content:flex-end;padding:1rem;border-top:1px solid #e9ecef}.modal-footer>:not(:first-child){margin-left:.25rem}.modal-footer>:not(:last-child){margin-right:.25rem}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:576px){.modal-dialog{max-width:500px;margin:1.75rem auto}.modal-dialog-centered{min-height:calc(100% - (1.75rem * 2))}.modal-dialog-centered::before{height:calc(100vh - (1.75rem * 2))}.modal-sm{max-width:300px}}@media (min-width:992px){.modal-lg{max-width:800px}}.tooltip{position:absolute;z-index:1070;display:block;margin:0;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;opacity:0}.tooltip.show{opacity:.9}.tooltip .arrow{position:absolute;display:block;width:.8rem;height:.4rem}.tooltip .arrow::before{position:absolute;content:\"\";border-color:transparent;border-style:solid}.bs-tooltip-auto[x-placement^=top],.bs-tooltip-top{padding:.4rem 0}.bs-tooltip-auto[x-placement^=top] .arrow,.bs-tooltip-top .arrow{bottom:0}.bs-tooltip-auto[x-placement^=top] .arrow::before,.bs-tooltip-top .arrow::before{top:0;border-width:.4rem .4rem 0;border-top-color:#000}.bs-tooltip-auto[x-placement^=right],.bs-tooltip-right{padding:0 .4rem}.bs-tooltip-auto[x-placement^=right] .arrow,.bs-tooltip-right .arrow{left:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=right] .arrow::before,.bs-tooltip-right .arrow::before{right:0;border-width:.4rem .4rem .4rem 0;border-right-color:#000}.bs-tooltip-auto[x-placement^=bottom],.bs-tooltip-bottom{padding:.4rem 0}.bs-tooltip-auto[x-placement^=bottom] .arrow,.bs-tooltip-bottom .arrow{top:0}.bs-tooltip-auto[x-placement^=bottom] .arrow::before,.bs-tooltip-bottom .arrow::before{bottom:0;border-width:0 .4rem .4rem;border-bottom-color:#000}.bs-tooltip-auto[x-placement^=left],.bs-tooltip-left{padding:0 .4rem}.bs-tooltip-auto[x-placement^=left] .arrow,.bs-tooltip-left .arrow{right:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=left] .arrow::before,.bs-tooltip-left .arrow::before{left:0;border-width:.4rem 0 .4rem .4rem;border-left-color:#000}.tooltip-inner{max-width:200px;padding:.25rem .5rem;color:#fff;text-align:center;background-color:#000;border-radius:.25rem}.popover{position:absolute;top:0;left:0;z-index:1060;display:block;max-width:276px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem}.popover .arrow{position:absolute;display:block;width:1rem;height:.5rem;margin:0 .3rem}.popover .arrow::after,.popover .arrow::before{position:absolute;display:block;content:\"\";border-color:transparent;border-style:solid}.bs-popover-auto[x-placement^=top],.bs-popover-top{margin-bottom:.5rem}.bs-popover-auto[x-placement^=top] .arrow,.bs-popover-top .arrow{bottom:calc((.5rem + 1px) * -1)}.bs-popover-auto[x-placement^=top] .arrow::after,.bs-popover-auto[x-placement^=top] .arrow::before,.bs-popover-top .arrow::after,.bs-popover-top .arrow::before{border-width:.5rem .5rem 0}.bs-popover-auto[x-placement^=top] .arrow::before,.bs-popover-top .arrow::before{bottom:0;border-top-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=top] .arrow::after,.bs-popover-top .arrow::after{bottom:1px;border-top-color:#fff}.bs-popover-auto[x-placement^=right],.bs-popover-right{margin-left:.5rem}.bs-popover-auto[x-placement^=right] .arrow,.bs-popover-right .arrow{left:calc((.5rem + 1px) * -1);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=right] .arrow::after,.bs-popover-auto[x-placement^=right] .arrow::before,.bs-popover-right .arrow::after,.bs-popover-right .arrow::before{border-width:.5rem .5rem .5rem 0}.bs-popover-auto[x-placement^=right] .arrow::before,.bs-popover-right .arrow::before{left:0;border-right-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=right] .arrow::after,.bs-popover-right .arrow::after{left:1px;border-right-color:#fff}.bs-popover-auto[x-placement^=bottom],.bs-popover-bottom{margin-top:.5rem}.bs-popover-auto[x-placement^=bottom] .arrow,.bs-popover-bottom .arrow{top:calc((.5rem + 1px) * -1)}.bs-popover-auto[x-placement^=bottom] .arrow::after,.bs-popover-auto[x-placement^=bottom] .arrow::before,.bs-popover-bottom .arrow::after,.bs-popover-bottom .arrow::before{border-width:0 .5rem .5rem .5rem}.bs-popover-auto[x-placement^=bottom] .arrow::before,.bs-popover-bottom .arrow::before{top:0;border-bottom-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=bottom] .arrow::after,.bs-popover-bottom .arrow::after{top:1px;border-bottom-color:#fff}.bs-popover-auto[x-placement^=bottom] .popover-header::before,.bs-popover-bottom .popover-header::before{position:absolute;top:0;left:50%;display:block;width:1rem;margin-left:-.5rem;content:\"\";border-bottom:1px solid #f7f7f7}.bs-popover-auto[x-placement^=left],.bs-popover-left{margin-right:.5rem}.bs-popover-auto[x-placement^=left] .arrow,.bs-popover-left .arrow{right:calc((.5rem + 1px) * -1);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=left] .arrow::after,.bs-popover-auto[x-placement^=left] .arrow::before,.bs-popover-left .arrow::after,.bs-popover-left .arrow::before{border-width:.5rem 0 .5rem .5rem}.bs-popover-auto[x-placement^=left] .arrow::before,.bs-popover-left .arrow::before{right:0;border-left-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=left] .arrow::after,.bs-popover-left .arrow::after{right:1px;border-left-color:#fff}.popover-header{padding:.5rem .75rem;margin-bottom:0;font-size:1rem;color:inherit;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.popover-header:empty{display:none}.popover-body{padding:.5rem .75rem;color:#212529}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-item{position:relative;display:none;-ms-flex-align:center;align-items:center;width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-item-next,.carousel-item-prev,.carousel-item.active{display:block;transition:-webkit-transform .6s ease;transition:transform .6s ease;transition:transform .6s ease,-webkit-transform .6s ease}@media screen and (prefers-reduced-motion:reduce){.carousel-item-next,.carousel-item-prev,.carousel-item.active{transition:none}}.carousel-item-next,.carousel-item-prev{position:absolute;top:0}.carousel-item-next.carousel-item-left,.carousel-item-prev.carousel-item-right{-webkit-transform:translateX(0);transform:translateX(0)}@supports ((-webkit-transform-style:preserve-3d) or (transform-style:preserve-3d)){.carousel-item-next.carousel-item-left,.carousel-item-prev.carousel-item-right{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.active.carousel-item-right,.carousel-item-next{-webkit-transform:translateX(100%);transform:translateX(100%)}@supports ((-webkit-transform-style:preserve-3d) or (transform-style:preserve-3d)){.active.carousel-item-right,.carousel-item-next{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}}.active.carousel-item-left,.carousel-item-prev{-webkit-transform:translateX(-100%);transform:translateX(-100%)}@supports ((-webkit-transform-style:preserve-3d) or (transform-style:preserve-3d)){.active.carousel-item-left,.carousel-item-prev{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}}.carousel-fade .carousel-item{opacity:0;transition-duration:.6s;transition-property:opacity}.carousel-fade .carousel-item-next.carousel-item-left,.carousel-fade .carousel-item-prev.carousel-item-right,.carousel-fade .carousel-item.active{opacity:1}.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-right{opacity:0}.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-prev,.carousel-fade .carousel-item-next,.carousel-fade .carousel-item-prev,.carousel-fade .carousel-item.active{-webkit-transform:translateX(0);transform:translateX(0)}@supports ((-webkit-transform-style:preserve-3d) or (transform-style:preserve-3d)){.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-prev,.carousel-fade .carousel-item-next,.carousel-fade .carousel-item-prev,.carousel-fade .carousel-item.active{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-control-next,.carousel-control-prev{position:absolute;top:0;bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:15%;color:#fff;text-align:center;opacity:.5}.carousel-control-next:focus,.carousel-control-next:hover,.carousel-control-prev:focus,.carousel-control-prev:hover{color:#fff;text-decoration:none;outline:0;opacity:.9}.carousel-control-prev{left:0}.carousel-control-next{right:0}.carousel-control-next-icon,.carousel-control-prev-icon{display:inline-block;width:20px;height:20px;background:transparent no-repeat center center;background-size:100% 100%}.carousel-control-prev-icon{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M5.25 0l-4 4 4 4 1.5-1.5-2.5-2.5 2.5-2.5-1.5-1.5z'/%3E%3C/svg%3E\")}.carousel-control-next-icon{background-image:url(\"data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 8 8'%3E%3Cpath d='M2.75 0l-1.5 1.5 2.5 2.5-2.5 2.5 1.5 1.5 4-4-4-4z'/%3E%3C/svg%3E\")}.carousel-indicators{position:absolute;right:0;bottom:10px;left:0;z-index:15;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;padding-left:0;margin-right:15%;margin-left:15%;list-style:none}.carousel-indicators li{position:relative;-ms-flex:0 1 auto;flex:0 1 auto;width:30px;height:3px;margin-right:3px;margin-left:3px;text-indent:-999px;cursor:pointer;background-color:rgba(255,255,255,.5)}.carousel-indicators li::before{position:absolute;top:-10px;left:0;display:inline-block;width:100%;height:10px;content:\"\"}.carousel-indicators li::after{position:absolute;bottom:-10px;left:0;display:inline-block;width:100%;height:10px;content:\"\"}.carousel-indicators .active{background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center}.align-baseline{vertical-align:baseline!important}.align-top{vertical-align:top!important}.align-middle{vertical-align:middle!important}.align-bottom{vertical-align:bottom!important}.align-text-bottom{vertical-align:text-bottom!important}.align-text-top{vertical-align:text-top!important}.bg-primary{background-color:#007bff!important}a.bg-primary:focus,a.bg-primary:hover,button.bg-primary:focus,button.bg-primary:hover{background-color:#0062cc!important}.bg-secondary{background-color:#6c757d!important}a.bg-secondary:focus,a.bg-secondary:hover,button.bg-secondary:focus,button.bg-secondary:hover{background-color:#545b62!important}.bg-success{background-color:#28a745!important}a.bg-success:focus,a.bg-success:hover,button.bg-success:focus,button.bg-success:hover{background-color:#1e7e34!important}.bg-info{background-color:#17a2b8!important}a.bg-info:focus,a.bg-info:hover,button.bg-info:focus,button.bg-info:hover{background-color:#117a8b!important}.bg-warning{background-color:#ffc107!important}a.bg-warning:focus,a.bg-warning:hover,button.bg-warning:focus,button.bg-warning:hover{background-color:#d39e00!important}.bg-danger{background-color:#dc3545!important}a.bg-danger:focus,a.bg-danger:hover,button.bg-danger:focus,button.bg-danger:hover{background-color:#bd2130!important}.bg-light{background-color:#f8f9fa!important}a.bg-light:focus,a.bg-light:hover,button.bg-light:focus,button.bg-light:hover{background-color:#dae0e5!important}.bg-dark{background-color:#343a40!important}a.bg-dark:focus,a.bg-dark:hover,button.bg-dark:focus,button.bg-dark:hover{background-color:#1d2124!important}.bg-white{background-color:#fff!important}.bg-transparent{background-color:transparent!important}.border{border:1px solid #dee2e6!important}.border-top{border-top:1px solid #dee2e6!important}.border-right{border-right:1px solid #dee2e6!important}.border-bottom{border-bottom:1px solid #dee2e6!important}.border-left{border-left:1px solid #dee2e6!important}.border-0{border:0!important}.border-top-0{border-top:0!important}.border-right-0{border-right:0!important}.border-bottom-0{border-bottom:0!important}.border-left-0{border-left:0!important}.border-primary{border-color:#007bff!important}.border-secondary{border-color:#6c757d!important}.border-success{border-color:#28a745!important}.border-info{border-color:#17a2b8!important}.border-warning{border-color:#ffc107!important}.border-danger{border-color:#dc3545!important}.border-light{border-color:#f8f9fa!important}.border-dark{border-color:#343a40!important}.border-white{border-color:#fff!important}.rounded{border-radius:.25rem!important}.rounded-top{border-top-left-radius:.25rem!important;border-top-right-radius:.25rem!important}.rounded-right{border-top-right-radius:.25rem!important;border-bottom-right-radius:.25rem!important}.rounded-bottom{border-bottom-right-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-left{border-top-left-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-circle{border-radius:50%!important}.rounded-0{border-radius:0!important}.clearfix::after{display:block;clear:both;content:\"\"}.d-none{display:none!important}.d-inline{display:inline!important}.d-inline-block{display:inline-block!important}.d-block{display:block!important}.d-table{display:table!important}.d-table-row{display:table-row!important}.d-table-cell{display:table-cell!important}.d-flex{display:-ms-flexbox!important;display:flex!important}.d-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}@media (min-width:576px){.d-sm-none{display:none!important}.d-sm-inline{display:inline!important}.d-sm-inline-block{display:inline-block!important}.d-sm-block{display:block!important}.d-sm-table{display:table!important}.d-sm-table-row{display:table-row!important}.d-sm-table-cell{display:table-cell!important}.d-sm-flex{display:-ms-flexbox!important;display:flex!important}.d-sm-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:768px){.d-md-none{display:none!important}.d-md-inline{display:inline!important}.d-md-inline-block{display:inline-block!important}.d-md-block{display:block!important}.d-md-table{display:table!important}.d-md-table-row{display:table-row!important}.d-md-table-cell{display:table-cell!important}.d-md-flex{display:-ms-flexbox!important;display:flex!important}.d-md-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:992px){.d-lg-none{display:none!important}.d-lg-inline{display:inline!important}.d-lg-inline-block{display:inline-block!important}.d-lg-block{display:block!important}.d-lg-table{display:table!important}.d-lg-table-row{display:table-row!important}.d-lg-table-cell{display:table-cell!important}.d-lg-flex{display:-ms-flexbox!important;display:flex!important}.d-lg-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:1200px){.d-xl-none{display:none!important}.d-xl-inline{display:inline!important}.d-xl-inline-block{display:inline-block!important}.d-xl-block{display:block!important}.d-xl-table{display:table!important}.d-xl-table-row{display:table-row!important}.d-xl-table-cell{display:table-cell!important}.d-xl-flex{display:-ms-flexbox!important;display:flex!important}.d-xl-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media print{.d-print-none{display:none!important}.d-print-inline{display:inline!important}.d-print-inline-block{display:inline-block!important}.d-print-block{display:block!important}.d-print-table{display:table!important}.d-print-table-row{display:table-row!important}.d-print-table-cell{display:table-cell!important}.d-print-flex{display:-ms-flexbox!important;display:flex!important}.d-print-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}.embed-responsive{position:relative;display:block;width:100%;padding:0;overflow:hidden}.embed-responsive::before{display:block;content:\"\"}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-21by9::before{padding-top:42.857143%}.embed-responsive-16by9::before{padding-top:56.25%}.embed-responsive-4by3::before{padding-top:75%}.embed-responsive-1by1::before{padding-top:100%}.flex-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-center{-ms-flex-align:center!important;align-items:center!important}.align-items-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}@media (min-width:576px){.flex-sm-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-sm-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-sm-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-sm-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-sm-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-sm-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-sm-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-sm-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-sm-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-sm-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-sm-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-sm-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-sm-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-sm-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-sm-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-sm-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-sm-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-sm-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-sm-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-sm-center{-ms-flex-align:center!important;align-items:center!important}.align-items-sm-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-sm-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-sm-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-sm-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-sm-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-sm-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-sm-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-sm-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-sm-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-sm-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-sm-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-sm-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-sm-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-sm-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:768px){.flex-md-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-md-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-md-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-md-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-md-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-md-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-md-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-md-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-md-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-md-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-md-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-md-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-md-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-md-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-md-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-md-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-md-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-md-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-md-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-md-center{-ms-flex-align:center!important;align-items:center!important}.align-items-md-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-md-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-md-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-md-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-md-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-md-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-md-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-md-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-md-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-md-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-md-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-md-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-md-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-md-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:992px){.flex-lg-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-lg-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-lg-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-lg-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-lg-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-lg-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-lg-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-lg-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-lg-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-lg-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-lg-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-lg-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-lg-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-lg-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-lg-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-lg-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-lg-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-lg-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-lg-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-lg-center{-ms-flex-align:center!important;align-items:center!important}.align-items-lg-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-lg-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-lg-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-lg-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-lg-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-lg-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-lg-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-lg-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-lg-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-lg-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-lg-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-lg-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-lg-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-lg-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:1200px){.flex-xl-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-xl-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-xl-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-xl-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-xl-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-xl-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-xl-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-xl-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-xl-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-xl-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-xl-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-xl-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-xl-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-xl-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-xl-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-xl-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-xl-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-xl-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-xl-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-xl-center{-ms-flex-align:center!important;align-items:center!important}.align-items-xl-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-xl-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-xl-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-xl-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-xl-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-xl-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-xl-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-xl-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-xl-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-xl-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-xl-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-xl-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-xl-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-xl-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}.float-left{float:left!important}.float-right{float:right!important}.float-none{float:none!important}@media (min-width:576px){.float-sm-left{float:left!important}.float-sm-right{float:right!important}.float-sm-none{float:none!important}}@media (min-width:768px){.float-md-left{float:left!important}.float-md-right{float:right!important}.float-md-none{float:none!important}}@media (min-width:992px){.float-lg-left{float:left!important}.float-lg-right{float:right!important}.float-lg-none{float:none!important}}@media (min-width:1200px){.float-xl-left{float:left!important}.float-xl-right{float:right!important}.float-xl-none{float:none!important}}.position-static{position:static!important}.position-relative{position:relative!important}.position-absolute{position:absolute!important}.position-fixed{position:fixed!important}.position-sticky{position:-webkit-sticky!important;position:sticky!important}.fixed-top{position:fixed;top:0;right:0;left:0;z-index:1030}.fixed-bottom{position:fixed;right:0;bottom:0;left:0;z-index:1030}@supports ((position:-webkit-sticky) or (position:sticky)){.sticky-top{position:-webkit-sticky;position:sticky;top:0;z-index:1020}}.sr-only{position:absolute;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto;white-space:normal}.shadow-sm{box-shadow:0 .125rem .25rem rgba(0,0,0,.075)!important}.shadow{box-shadow:0 .5rem 1rem rgba(0,0,0,.15)!important}.shadow-lg{box-shadow:0 1rem 3rem rgba(0,0,0,.175)!important}.shadow-none{box-shadow:none!important}.w-25{width:25%!important}.w-50{width:50%!important}.w-75{width:75%!important}.w-100{width:100%!important}.w-auto{width:auto!important}.h-25{height:25%!important}.h-50{height:50%!important}.h-75{height:75%!important}.h-100{height:100%!important}.h-auto{height:auto!important}.mw-100{max-width:100%!important}.mh-100{max-height:100%!important}.m-0{margin:0!important}.mt-0,.my-0{margin-top:0!important}.mr-0,.mx-0{margin-right:0!important}.mb-0,.my-0{margin-bottom:0!important}.ml-0,.mx-0{margin-left:0!important}.m-1{margin:.25rem!important}.mt-1,.my-1{margin-top:.25rem!important}.mr-1,.mx-1{margin-right:.25rem!important}.mb-1,.my-1{margin-bottom:.25rem!important}.ml-1,.mx-1{margin-left:.25rem!important}.m-2{margin:.5rem!important}.mt-2,.my-2{margin-top:.5rem!important}.mr-2,.mx-2{margin-right:.5rem!important}.mb-2,.my-2{margin-bottom:.5rem!important}.ml-2,.mx-2{margin-left:.5rem!important}.m-3{margin:1rem!important}.mt-3,.my-3{margin-top:1rem!important}.mr-3,.mx-3{margin-right:1rem!important}.mb-3,.my-3{margin-bottom:1rem!important}.ml-3,.mx-3{margin-left:1rem!important}.m-4{margin:1.5rem!important}.mt-4,.my-4{margin-top:1.5rem!important}.mr-4,.mx-4{margin-right:1.5rem!important}.mb-4,.my-4{margin-bottom:1.5rem!important}.ml-4,.mx-4{margin-left:1.5rem!important}.m-5{margin:3rem!important}.mt-5,.my-5{margin-top:3rem!important}.mr-5,.mx-5{margin-right:3rem!important}.mb-5,.my-5{margin-bottom:3rem!important}.ml-5,.mx-5{margin-left:3rem!important}.p-0{padding:0!important}.pt-0,.py-0{padding-top:0!important}.pr-0,.px-0{padding-right:0!important}.pb-0,.py-0{padding-bottom:0!important}.pl-0,.px-0{padding-left:0!important}.p-1{padding:.25rem!important}.pt-1,.py-1{padding-top:.25rem!important}.pr-1,.px-1{padding-right:.25rem!important}.pb-1,.py-1{padding-bottom:.25rem!important}.pl-1,.px-1{padding-left:.25rem!important}.p-2{padding:.5rem!important}.pt-2,.py-2{padding-top:.5rem!important}.pr-2,.px-2{padding-right:.5rem!important}.pb-2,.py-2{padding-bottom:.5rem!important}.pl-2,.px-2{padding-left:.5rem!important}.p-3{padding:1rem!important}.pt-3,.py-3{padding-top:1rem!important}.pr-3,.px-3{padding-right:1rem!important}.pb-3,.py-3{padding-bottom:1rem!important}.pl-3,.px-3{padding-left:1rem!important}.p-4{padding:1.5rem!important}.pt-4,.py-4{padding-top:1.5rem!important}.pr-4,.px-4{padding-right:1.5rem!important}.pb-4,.py-4{padding-bottom:1.5rem!important}.pl-4,.px-4{padding-left:1.5rem!important}.p-5{padding:3rem!important}.pt-5,.py-5{padding-top:3rem!important}.pr-5,.px-5{padding-right:3rem!important}.pb-5,.py-5{padding-bottom:3rem!important}.pl-5,.px-5{padding-left:3rem!important}.m-auto{margin:auto!important}.mt-auto,.my-auto{margin-top:auto!important}.mr-auto,.mx-auto{margin-right:auto!important}.mb-auto,.my-auto{margin-bottom:auto!important}.ml-auto,.mx-auto{margin-left:auto!important}@media (min-width:576px){.m-sm-0{margin:0!important}.mt-sm-0,.my-sm-0{margin-top:0!important}.mr-sm-0,.mx-sm-0{margin-right:0!important}.mb-sm-0,.my-sm-0{margin-bottom:0!important}.ml-sm-0,.mx-sm-0{margin-left:0!important}.m-sm-1{margin:.25rem!important}.mt-sm-1,.my-sm-1{margin-top:.25rem!important}.mr-sm-1,.mx-sm-1{margin-right:.25rem!important}.mb-sm-1,.my-sm-1{margin-bottom:.25rem!important}.ml-sm-1,.mx-sm-1{margin-left:.25rem!important}.m-sm-2{margin:.5rem!important}.mt-sm-2,.my-sm-2{margin-top:.5rem!important}.mr-sm-2,.mx-sm-2{margin-right:.5rem!important}.mb-sm-2,.my-sm-2{margin-bottom:.5rem!important}.ml-sm-2,.mx-sm-2{margin-left:.5rem!important}.m-sm-3{margin:1rem!important}.mt-sm-3,.my-sm-3{margin-top:1rem!important}.mr-sm-3,.mx-sm-3{margin-right:1rem!important}.mb-sm-3,.my-sm-3{margin-bottom:1rem!important}.ml-sm-3,.mx-sm-3{margin-left:1rem!important}.m-sm-4{margin:1.5rem!important}.mt-sm-4,.my-sm-4{margin-top:1.5rem!important}.mr-sm-4,.mx-sm-4{margin-right:1.5rem!important}.mb-sm-4,.my-sm-4{margin-bottom:1.5rem!important}.ml-sm-4,.mx-sm-4{margin-left:1.5rem!important}.m-sm-5{margin:3rem!important}.mt-sm-5,.my-sm-5{margin-top:3rem!important}.mr-sm-5,.mx-sm-5{margin-right:3rem!important}.mb-sm-5,.my-sm-5{margin-bottom:3rem!important}.ml-sm-5,.mx-sm-5{margin-left:3rem!important}.p-sm-0{padding:0!important}.pt-sm-0,.py-sm-0{padding-top:0!important}.pr-sm-0,.px-sm-0{padding-right:0!important}.pb-sm-0,.py-sm-0{padding-bottom:0!important}.pl-sm-0,.px-sm-0{padding-left:0!important}.p-sm-1{padding:.25rem!important}.pt-sm-1,.py-sm-1{padding-top:.25rem!important}.pr-sm-1,.px-sm-1{padding-right:.25rem!important}.pb-sm-1,.py-sm-1{padding-bottom:.25rem!important}.pl-sm-1,.px-sm-1{padding-left:.25rem!important}.p-sm-2{padding:.5rem!important}.pt-sm-2,.py-sm-2{padding-top:.5rem!important}.pr-sm-2,.px-sm-2{padding-right:.5rem!important}.pb-sm-2,.py-sm-2{padding-bottom:.5rem!important}.pl-sm-2,.px-sm-2{padding-left:.5rem!important}.p-sm-3{padding:1rem!important}.pt-sm-3,.py-sm-3{padding-top:1rem!important}.pr-sm-3,.px-sm-3{padding-right:1rem!important}.pb-sm-3,.py-sm-3{padding-bottom:1rem!important}.pl-sm-3,.px-sm-3{padding-left:1rem!important}.p-sm-4{padding:1.5rem!important}.pt-sm-4,.py-sm-4{padding-top:1.5rem!important}.pr-sm-4,.px-sm-4{padding-right:1.5rem!important}.pb-sm-4,.py-sm-4{padding-bottom:1.5rem!important}.pl-sm-4,.px-sm-4{padding-left:1.5rem!important}.p-sm-5{padding:3rem!important}.pt-sm-5,.py-sm-5{padding-top:3rem!important}.pr-sm-5,.px-sm-5{padding-right:3rem!important}.pb-sm-5,.py-sm-5{padding-bottom:3rem!important}.pl-sm-5,.px-sm-5{padding-left:3rem!important}.m-sm-auto{margin:auto!important}.mt-sm-auto,.my-sm-auto{margin-top:auto!important}.mr-sm-auto,.mx-sm-auto{margin-right:auto!important}.mb-sm-auto,.my-sm-auto{margin-bottom:auto!important}.ml-sm-auto,.mx-sm-auto{margin-left:auto!important}}@media (min-width:768px){.m-md-0{margin:0!important}.mt-md-0,.my-md-0{margin-top:0!important}.mr-md-0,.mx-md-0{margin-right:0!important}.mb-md-0,.my-md-0{margin-bottom:0!important}.ml-md-0,.mx-md-0{margin-left:0!important}.m-md-1{margin:.25rem!important}.mt-md-1,.my-md-1{margin-top:.25rem!important}.mr-md-1,.mx-md-1{margin-right:.25rem!important}.mb-md-1,.my-md-1{margin-bottom:.25rem!important}.ml-md-1,.mx-md-1{margin-left:.25rem!important}.m-md-2{margin:.5rem!important}.mt-md-2,.my-md-2{margin-top:.5rem!important}.mr-md-2,.mx-md-2{margin-right:.5rem!important}.mb-md-2,.my-md-2{margin-bottom:.5rem!important}.ml-md-2,.mx-md-2{margin-left:.5rem!important}.m-md-3{margin:1rem!important}.mt-md-3,.my-md-3{margin-top:1rem!important}.mr-md-3,.mx-md-3{margin-right:1rem!important}.mb-md-3,.my-md-3{margin-bottom:1rem!important}.ml-md-3,.mx-md-3{margin-left:1rem!important}.m-md-4{margin:1.5rem!important}.mt-md-4,.my-md-4{margin-top:1.5rem!important}.mr-md-4,.mx-md-4{margin-right:1.5rem!important}.mb-md-4,.my-md-4{margin-bottom:1.5rem!important}.ml-md-4,.mx-md-4{margin-left:1.5rem!important}.m-md-5{margin:3rem!important}.mt-md-5,.my-md-5{margin-top:3rem!important}.mr-md-5,.mx-md-5{margin-right:3rem!important}.mb-md-5,.my-md-5{margin-bottom:3rem!important}.ml-md-5,.mx-md-5{margin-left:3rem!important}.p-md-0{padding:0!important}.pt-md-0,.py-md-0{padding-top:0!important}.pr-md-0,.px-md-0{padding-right:0!important}.pb-md-0,.py-md-0{padding-bottom:0!important}.pl-md-0,.px-md-0{padding-left:0!important}.p-md-1{padding:.25rem!important}.pt-md-1,.py-md-1{padding-top:.25rem!important}.pr-md-1,.px-md-1{padding-right:.25rem!important}.pb-md-1,.py-md-1{padding-bottom:.25rem!important}.pl-md-1,.px-md-1{padding-left:.25rem!important}.p-md-2{padding:.5rem!important}.pt-md-2,.py-md-2{padding-top:.5rem!important}.pr-md-2,.px-md-2{padding-right:.5rem!important}.pb-md-2,.py-md-2{padding-bottom:.5rem!important}.pl-md-2,.px-md-2{padding-left:.5rem!important}.p-md-3{padding:1rem!important}.pt-md-3,.py-md-3{padding-top:1rem!important}.pr-md-3,.px-md-3{padding-right:1rem!important}.pb-md-3,.py-md-3{padding-bottom:1rem!important}.pl-md-3,.px-md-3{padding-left:1rem!important}.p-md-4{padding:1.5rem!important}.pt-md-4,.py-md-4{padding-top:1.5rem!important}.pr-md-4,.px-md-4{padding-right:1.5rem!important}.pb-md-4,.py-md-4{padding-bottom:1.5rem!important}.pl-md-4,.px-md-4{padding-left:1.5rem!important}.p-md-5{padding:3rem!important}.pt-md-5,.py-md-5{padding-top:3rem!important}.pr-md-5,.px-md-5{padding-right:3rem!important}.pb-md-5,.py-md-5{padding-bottom:3rem!important}.pl-md-5,.px-md-5{padding-left:3rem!important}.m-md-auto{margin:auto!important}.mt-md-auto,.my-md-auto{margin-top:auto!important}.mr-md-auto,.mx-md-auto{margin-right:auto!important}.mb-md-auto,.my-md-auto{margin-bottom:auto!important}.ml-md-auto,.mx-md-auto{margin-left:auto!important}}@media (min-width:992px){.m-lg-0{margin:0!important}.mt-lg-0,.my-lg-0{margin-top:0!important}.mr-lg-0,.mx-lg-0{margin-right:0!important}.mb-lg-0,.my-lg-0{margin-bottom:0!important}.ml-lg-0,.mx-lg-0{margin-left:0!important}.m-lg-1{margin:.25rem!important}.mt-lg-1,.my-lg-1{margin-top:.25rem!important}.mr-lg-1,.mx-lg-1{margin-right:.25rem!important}.mb-lg-1,.my-lg-1{margin-bottom:.25rem!important}.ml-lg-1,.mx-lg-1{margin-left:.25rem!important}.m-lg-2{margin:.5rem!important}.mt-lg-2,.my-lg-2{margin-top:.5rem!important}.mr-lg-2,.mx-lg-2{margin-right:.5rem!important}.mb-lg-2,.my-lg-2{margin-bottom:.5rem!important}.ml-lg-2,.mx-lg-2{margin-left:.5rem!important}.m-lg-3{margin:1rem!important}.mt-lg-3,.my-lg-3{margin-top:1rem!important}.mr-lg-3,.mx-lg-3{margin-right:1rem!important}.mb-lg-3,.my-lg-3{margin-bottom:1rem!important}.ml-lg-3,.mx-lg-3{margin-left:1rem!important}.m-lg-4{margin:1.5rem!important}.mt-lg-4,.my-lg-4{margin-top:1.5rem!important}.mr-lg-4,.mx-lg-4{margin-right:1.5rem!important}.mb-lg-4,.my-lg-4{margin-bottom:1.5rem!important}.ml-lg-4,.mx-lg-4{margin-left:1.5rem!important}.m-lg-5{margin:3rem!important}.mt-lg-5,.my-lg-5{margin-top:3rem!important}.mr-lg-5,.mx-lg-5{margin-right:3rem!important}.mb-lg-5,.my-lg-5{margin-bottom:3rem!important}.ml-lg-5,.mx-lg-5{margin-left:3rem!important}.p-lg-0{padding:0!important}.pt-lg-0,.py-lg-0{padding-top:0!important}.pr-lg-0,.px-lg-0{padding-right:0!important}.pb-lg-0,.py-lg-0{padding-bottom:0!important}.pl-lg-0,.px-lg-0{padding-left:0!important}.p-lg-1{padding:.25rem!important}.pt-lg-1,.py-lg-1{padding-top:.25rem!important}.pr-lg-1,.px-lg-1{padding-right:.25rem!important}.pb-lg-1,.py-lg-1{padding-bottom:.25rem!important}.pl-lg-1,.px-lg-1{padding-left:.25rem!important}.p-lg-2{padding:.5rem!important}.pt-lg-2,.py-lg-2{padding-top:.5rem!important}.pr-lg-2,.px-lg-2{padding-right:.5rem!important}.pb-lg-2,.py-lg-2{padding-bottom:.5rem!important}.pl-lg-2,.px-lg-2{padding-left:.5rem!important}.p-lg-3{padding:1rem!important}.pt-lg-3,.py-lg-3{padding-top:1rem!important}.pr-lg-3,.px-lg-3{padding-right:1rem!important}.pb-lg-3,.py-lg-3{padding-bottom:1rem!important}.pl-lg-3,.px-lg-3{padding-left:1rem!important}.p-lg-4{padding:1.5rem!important}.pt-lg-4,.py-lg-4{padding-top:1.5rem!important}.pr-lg-4,.px-lg-4{padding-right:1.5rem!important}.pb-lg-4,.py-lg-4{padding-bottom:1.5rem!important}.pl-lg-4,.px-lg-4{padding-left:1.5rem!important}.p-lg-5{padding:3rem!important}.pt-lg-5,.py-lg-5{padding-top:3rem!important}.pr-lg-5,.px-lg-5{padding-right:3rem!important}.pb-lg-5,.py-lg-5{padding-bottom:3rem!important}.pl-lg-5,.px-lg-5{padding-left:3rem!important}.m-lg-auto{margin:auto!important}.mt-lg-auto,.my-lg-auto{margin-top:auto!important}.mr-lg-auto,.mx-lg-auto{margin-right:auto!important}.mb-lg-auto,.my-lg-auto{margin-bottom:auto!important}.ml-lg-auto,.mx-lg-auto{margin-left:auto!important}}@media (min-width:1200px){.m-xl-0{margin:0!important}.mt-xl-0,.my-xl-0{margin-top:0!important}.mr-xl-0,.mx-xl-0{margin-right:0!important}.mb-xl-0,.my-xl-0{margin-bottom:0!important}.ml-xl-0,.mx-xl-0{margin-left:0!important}.m-xl-1{margin:.25rem!important}.mt-xl-1,.my-xl-1{margin-top:.25rem!important}.mr-xl-1,.mx-xl-1{margin-right:.25rem!important}.mb-xl-1,.my-xl-1{margin-bottom:.25rem!important}.ml-xl-1,.mx-xl-1{margin-left:.25rem!important}.m-xl-2{margin:.5rem!important}.mt-xl-2,.my-xl-2{margin-top:.5rem!important}.mr-xl-2,.mx-xl-2{margin-right:.5rem!important}.mb-xl-2,.my-xl-2{margin-bottom:.5rem!important}.ml-xl-2,.mx-xl-2{margin-left:.5rem!important}.m-xl-3{margin:1rem!important}.mt-xl-3,.my-xl-3{margin-top:1rem!important}.mr-xl-3,.mx-xl-3{margin-right:1rem!important}.mb-xl-3,.my-xl-3{margin-bottom:1rem!important}.ml-xl-3,.mx-xl-3{margin-left:1rem!important}.m-xl-4{margin:1.5rem!important}.mt-xl-4,.my-xl-4{margin-top:1.5rem!important}.mr-xl-4,.mx-xl-4{margin-right:1.5rem!important}.mb-xl-4,.my-xl-4{margin-bottom:1.5rem!important}.ml-xl-4,.mx-xl-4{margin-left:1.5rem!important}.m-xl-5{margin:3rem!important}.mt-xl-5,.my-xl-5{margin-top:3rem!important}.mr-xl-5,.mx-xl-5{margin-right:3rem!important}.mb-xl-5,.my-xl-5{margin-bottom:3rem!important}.ml-xl-5,.mx-xl-5{margin-left:3rem!important}.p-xl-0{padding:0!important}.pt-xl-0,.py-xl-0{padding-top:0!important}.pr-xl-0,.px-xl-0{padding-right:0!important}.pb-xl-0,.py-xl-0{padding-bottom:0!important}.pl-xl-0,.px-xl-0{padding-left:0!important}.p-xl-1{padding:.25rem!important}.pt-xl-1,.py-xl-1{padding-top:.25rem!important}.pr-xl-1,.px-xl-1{padding-right:.25rem!important}.pb-xl-1,.py-xl-1{padding-bottom:.25rem!important}.pl-xl-1,.px-xl-1{padding-left:.25rem!important}.p-xl-2{padding:.5rem!important}.pt-xl-2,.py-xl-2{padding-top:.5rem!important}.pr-xl-2,.px-xl-2{padding-right:.5rem!important}.pb-xl-2,.py-xl-2{padding-bottom:.5rem!important}.pl-xl-2,.px-xl-2{padding-left:.5rem!important}.p-xl-3{padding:1rem!important}.pt-xl-3,.py-xl-3{padding-top:1rem!important}.pr-xl-3,.px-xl-3{padding-right:1rem!important}.pb-xl-3,.py-xl-3{padding-bottom:1rem!important}.pl-xl-3,.px-xl-3{padding-left:1rem!important}.p-xl-4{padding:1.5rem!important}.pt-xl-4,.py-xl-4{padding-top:1.5rem!important}.pr-xl-4,.px-xl-4{padding-right:1.5rem!important}.pb-xl-4,.py-xl-4{padding-bottom:1.5rem!important}.pl-xl-4,.px-xl-4{padding-left:1.5rem!important}.p-xl-5{padding:3rem!important}.pt-xl-5,.py-xl-5{padding-top:3rem!important}.pr-xl-5,.px-xl-5{padding-right:3rem!important}.pb-xl-5,.py-xl-5{padding-bottom:3rem!important}.pl-xl-5,.px-xl-5{padding-left:3rem!important}.m-xl-auto{margin:auto!important}.mt-xl-auto,.my-xl-auto{margin-top:auto!important}.mr-xl-auto,.mx-xl-auto{margin-right:auto!important}.mb-xl-auto,.my-xl-auto{margin-bottom:auto!important}.ml-xl-auto,.mx-xl-auto{margin-left:auto!important}}.text-monospace{font-family:SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace}.text-justify{text-align:justify!important}.text-nowrap{white-space:nowrap!important}.text-truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}@media (min-width:576px){.text-sm-left{text-align:left!important}.text-sm-right{text-align:right!important}.text-sm-center{text-align:center!important}}@media (min-width:768px){.text-md-left{text-align:left!important}.text-md-right{text-align:right!important}.text-md-center{text-align:center!important}}@media (min-width:992px){.text-lg-left{text-align:left!important}.text-lg-right{text-align:right!important}.text-lg-center{text-align:center!important}}@media (min-width:1200px){.text-xl-left{text-align:left!important}.text-xl-right{text-align:right!important}.text-xl-center{text-align:center!important}}.text-lowercase{text-transform:lowercase!important}.text-uppercase{text-transform:uppercase!important}.text-capitalize{text-transform:capitalize!important}.font-weight-light{font-weight:300!important}.font-weight-normal{font-weight:400!important}.font-weight-bold{font-weight:700!important}.font-italic{font-style:italic!important}.text-white{color:#fff!important}.text-primary{color:#007bff!important}a.text-primary:focus,a.text-primary:hover{color:#0062cc!important}.text-secondary{color:#6c757d!important}a.text-secondary:focus,a.text-secondary:hover{color:#545b62!important}.text-success{color:#28a745!important}a.text-success:focus,a.text-success:hover{color:#1e7e34!important}.text-info{color:#17a2b8!important}a.text-info:focus,a.text-info:hover{color:#117a8b!important}.text-warning{color:#ffc107!important}a.text-warning:focus,a.text-warning:hover{color:#d39e00!important}.text-danger{color:#dc3545!important}a.text-danger:focus,a.text-danger:hover{color:#bd2130!important}.text-light{color:#f8f9fa!important}a.text-light:focus,a.text-light:hover{color:#dae0e5!important}.text-dark{color:#343a40!important}a.text-dark:focus,a.text-dark:hover{color:#1d2124!important}.text-body{color:#212529!important}.text-muted{color:#6c757d!important}.text-black-50{color:rgba(0,0,0,.5)!important}.text-white-50{color:rgba(255,255,255,.5)!important}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.visible{visibility:visible!important}.invisible{visibility:hidden!important}@media print{*,::after,::before{text-shadow:none!important;box-shadow:none!important}a:not(.btn){text-decoration:underline}abbr[title]::after{content:\" (\" attr(title) \")\"}pre{white-space:pre-wrap!important}blockquote,pre{border:1px solid #adb5bd;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}@page{size:a3}body{min-width:992px!important}.container{min-width:992px!important}.navbar{display:none}.badge{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #dee2e6!important}.table-dark{color:inherit}.table-dark tbody+tbody,.table-dark td,.table-dark th,.table-dark thead th{border-color:#dee2e6}.table .thead-dark th{color:inherit;border-color:#dee2e6}} /*# sourceMappingURL=bootstrap.min.css.map */","tags":""},{"title":"tags","url":"/tags/index.html","text":"","tags":""},{"title":"文章分类","url":"/categories/index.html","text":"","tags":""}]}